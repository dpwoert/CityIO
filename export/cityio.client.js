(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
window.IO = require('./client');

console.log(window.IO);

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client.export.js","/")
},{"./client":17,"IrXUsu":44,"buffer":41}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

//shaders
var vertexShader = ['varying float z;',
'void main(void) {',
    'gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
    'z = position.z;',
'}'].join("\n");

var fragmentShader = ['uniform vec3 colorDay;',
'uniform vec3 colorNight;',
'uniform vec3 fogNight;',
'uniform vec3 fogDay;',
'uniform float currentTime;',

'varying float z;',

'#ifdef USE_FOG',

	'uniform vec3 fogColor;',
	'uniform float fogDensity;',

'#endif',

'void main() {',

	'vec4 c1 = vec4(colorDay,1.0);',
	'vec4 c2 = vec4(colorNight,1.0);',
	'gl_FragColor = mix(c1,c2, smoothstep(0.0, 1.0, currentTime));',

	'vec3 fogColorMix = mix(fogDay,fogNight, smoothstep(0.0, 1.0, currentTime));',

	'float depth = gl_FragCoord.z / gl_FragCoord.w;',
	'const float LOG2 = 1.442695;' +
	'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
	'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	'gl_FragColor = mix( gl_FragColor, vec4( fogColorMix, gl_FragColor.w ), fogFactor );',

'}'].join("\n");

module.exports = function(world){

    var self = this;

    //fixed height
    this.options.height = function(properties, group){
        return (1 * group.nr);
    };

    //color material
    this.options.createMaterial = function(color, i){

        //get night color
        var colorNight = self.options.night[i];

        //uniforms
    	var uniforms = {
    		"currentTime" : { type: "f", value: 0.0 },
    		"colorDay" : { type: "c", value: new THREE.Color(color) },
    		"colorNight" : { type: "c", value: new THREE.Color(colorNight) },

    		"fogColor" : { type: "c", value: world.scene.fog.color },
    		"fogNight" : { type: "c", value: world.scene.fog.night },
    		"fogDay" : { type: "c", value: world.scene.fog.day },
    		"fogDensity" : { type: "f", value: world.scene.fog.density },
    	};

    	//material
    	return new THREE.ShaderMaterial({
    		uniforms: uniforms,
    	    vertexShader: vertexShader,
    	    fragmentShader: fragmentShader,
    	    fog: true
    	});

    };

    //defer to buildings
    return IO.build.buildings.call(this, world);

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/build/areas.js","/client/build")
},{"IrXUsu":44,"buffer":41,"three":115}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

module.exports = function(world){

	var mesh;

	//set variables
	var options = this.options;
	var data = this.data;
	var z = this.z;
	var colors = options.colors || [0xffffff];
	var groups = [];

	//group detection
	var baseGroupDetect = function(groups, input){
		return groups[0];
	};

	//base or custom?
	var groupDetect = options.groups || baseGroupDetect;

	//base
	var base = options.material || new THREE.MeshLambertMaterial({
    	color: 0xffffff,
    	shading: THREE.FlatShading
	});

	//groups
	for( var i = 0 ; i < colors.length ; i++ ){

		var material;

		if(!options.createMaterial){

			//create material for group
			material = base.clone();
			material.color = new THREE.Color(colors[i]);

		} else {
			material = options.createMaterial(colors[i], i);
		}

		//create geometry for group
		var geometry = new THREE.Geometry();

		groups.push({
			'nr': i,
			'material': material,
			'geometry': geometry
		});

	}

	//finalise
	var finalise = function(){

		groups.forEach(function(group){

			var buffer = new THREE.BufferGeometry();
			// buffer.fromGeometry(group.geometry);
			// geometry.dispose();

			//create mesh
			// group.mesh = new THREE.Mesh( buffer, group.material );
			group.mesh = new THREE.Mesh( group.geometry, group.material );
			world.group.add( group.mesh );

		});

	};

	//create building
	var createBuilding = function(pos, properties){

		try{

			var group = groupDetect(groups, properties);
			var height = options.height(properties, group);
			// height = IO.tools.parseHeight(height);

			//prevent
			if(isNaN(height)) height = 1;

			//create shape
			var shape = new THREE.Shape(pos);
			var extrusionSettings = {
				amount: height,
				//bevelSize: 15,
				bevelEnabled: false,
				//steps: 0,
				bevelThickness: 0,
				steps: 1
			};

			//extrude & make mesh
			var geometry = new THREE.ExtrudeGeometry( shape, extrusionSettings );
			group.geometry.merge( geometry );
			geometry.dispose();

		} catch(e){
			console.warn(e);
		}

	};

	//add all buildings from list
	var buildings = data.get();
	for( var i = 0 ; i < buildings.length ; i++ ){

		this.render.push(function(){

			createBuilding( this.object.get3D(world.projection), this.object.properties );

			//end?
			if(this.current >= buildings.length - 1){
				finalise();
			}

		}.bind({ object: buildings[i], current: i }));
	}

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/build/buildings.js","/client/build")
},{"IrXUsu":44,"buffer":41,"three":115}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

module.exports = function(world){

	var mesh;

	//set variables
	var options = this.options;
	var data = this.data;
	var z = this.z;

	//defaults
	options.color = options.color || '#FFFFFF';
	options.color = new THREE.Color(options.color);
	options.width = options.width || 1.5;
	options.maxSegments = options.maxSegments || 50;
	//options.segments = options.segments || 5;
	options.radiusSegments = options.radiusSegments || 3;
	options.quality = options.quality || 1;
	options.opacity = options.opacity || 1;

	//create geometry
	var geometry = new THREE.Geometry();
	
	//add to scene when done
	var finalise = function(){

		//create material settings
		var materialSettings = {};
		materialSettings.color = options.color;

		//transparency?
		if(options.opacity < 1){
			materialSettings.opacity = options.opacity;
			materialSettings.transparent = true;
		}

		var buffer = new THREE.BufferGeometry();
		buffer.fromGeometry(geometry);
		geometry.dispose();

		//create mesh
		var material = new THREE.MeshLambertMaterial(materialSettings);
		mesh = new THREE.Mesh( buffer, material );
		// mesh.position.z = IO.tools.parseHeight(z);

		//add to scene
		world.group.add(mesh);

	}.bind(this);

	//add paths to 3d object
	var createTube = function(data){

		//create tubes
		var path3D = new THREE.SplineCurve3(data);
		var segments = data.length < options.maxSegments ? data.length : options.maxSegments;
		segments = Math.ceil(options.quality * segments);
		var tube = new THREE.TubeGeometry(path3D, segments, options.width, options.radiusSegments, false);

		geometry.merge(tube);
		tube.dispose();
		path3D = null;

	};

	//add all roads
	var roads = data.get();
	for( var i = 0 ; i < roads.length ; i++ ){

		this.render.push(function(){

			createTube( this.object.get3D(world.projection) );

			//end?
			if(this.current >= roads.length - 1){
				finalise();
			}

		}.bind({ object: roads[i], current: i }));
	}

	//actions - todo
	// return {};

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/build/roads.js","/client/build")
},{"IrXUsu":44,"buffer":41,"three":115}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

module.exports = function(world){

	var stop = false;
	var _process;
	var list = [];

	var lerp = function(from, to, progress){
		var delta = to - from;
		return from + (delta*progress);
	};

	var animate = function(property, progress, options){

		//animate vectors
		if(property instanceof THREE.Vector3){
			property.copy(IO.tools.lerp3(options.from, options.to, progress));
		}

		//animate material
		if(property instanceof THREE.Material){

			if(options.type === 'opacity'){

				property.transparent = true;
				// var delta = options.to - options.from;
				// property.opacity = options.from + (delta*progress);
				property.opacity = lerp(options.from, options.to, progress);

			}

			if(options.type === 'color'){

				property.color = options.from.lerp(options.to, progress);

			}

		}

		//animate meshes (scale)
		if(property instanceof THREE.Mesh){
			property.scale.copy(IO.tools.lerp3(options.from, options.to, progress));
		}

		//custom
		if(options.tick instanceof Function){
			options.tick(property, progress, options, lerp);
		}

	};

	var detectFrom = function(property, options){

		//animate vectors
		if(property instanceof THREE.Vector3){
			return property.clone();
		}

		//animate material
		if(property instanceof THREE.Material){

			if(options.type === 'opacity'){
				return property.opacity;
			}

			if(options.type === 'color'){
				return property.color.clone();
			}

		}

		//animate meshes (scale)
		if(property instanceof THREE.Mesh){

			return property.scale.clone();

		}

	};

	var update = function(){

		//stop when needed
		if(stop){
			world.render.remove(_process);
		}

		for( var i = 0 ; i < list.length ; i++ ){

			var anim = list[i];
			var finished = false;

			//On first iteration set this as start point in time
			if(!anim.start){
				anim.start = +Date.now();
			}

			//when paused, recalculate starting point
			if(pauseTime){
				anim.start += +Date.now() - pauseTime;
			}

			//calculate progress
			var now = +Date.now() - anim.start;
			var progress = now/anim.duration;

			//check if finished
			if(progress > 1){
				progress = 1;
				finished = true;
			}

			//interpolate
			animate(anim.property, progress, anim);

			//finished so remove from list
			if(finished){
				list.splice(i, 1);
			}

		}

		//reset pause
		if(pauseTime){
			pauseTime = undefined;
		}

		//rerun next time (when needed)
		if(list.length > 0){
			world.render.remove(_process);
		}

	}.bind(this);

	var pauseTime;
	var pause = function(){
		pauseTime = +Date.now();
	};

	this.add = function(property, options){

		var from = options.from || detectFrom(property, options);

		list.push({

			from: from,
			to: options.to,
			duration: options.duration || 1000,
			ease: 'easeInOutCubic',
			property: property,
			type: options.type,
			tick: options.tick

		});

	};

	this.start = function(){
		stop = false;
		_process = world.render.add(update, pause);
	};

	this.stop = function(){
		stop = true;
		world.render.remove(_process);
	};

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/animation.js","/client/classes")
},{"IrXUsu":44,"buffer":41,"three":115}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(min, max, projection){

    this.getGeo = function(){

    };

    this.get2D = function(){

    };

    this.get3D = function(){

    };

    this.inBox = function(lat, lon){

    };


}

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/boundingbox.js","/client/classes")
},{"IrXUsu":44,"buffer":41}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

module.exports = function(world){

	var self = this;
	var update;

	this.getDirection = function(){

		var q = world.camera.quaternion;
		var pVec = new THREE.Vector3( 1, 0, 0 ).applyQuaternion( q );

		var heading = Math.atan2( pVec.z, pVec.x );
		heading += Math.PI/2;
		heading *= 180 / Math.PI;
		heading = heading > 0 ? heading : heading + 360;
		heading = Math.floor(heading % 360);

		return heading;

	};

	this.updateElement = function(element){

		update = window.setInterval(function(){

			var rotation = self.getDirection();

			//transform
			element.style.webkitTransform = 'rotate('+rotation+'deg)';
			element.style.mozTransform = 'rotate('+rotation+'deg)';
			element.style.transform = 'rotate('+rotation+'deg)';

		}, 250);

	};

	this.destroy = function(){

		window.clearInterval(update);

	};

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/compass.js","/client/classes")
},{"IrXUsu":44,"buffer":41,"three":115}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');
var EffectComposer = require('../lib/effect-composer.js');
var RenderPass = require('../lib/render-pass.js');

module.exports = function(renderer, scene, camera, world){

	// this.dpr = window.devicePixelRatio || 1;
	this.dpr = 2;

	//Create Shader Passes
	this.composer = new EffectComposer(renderer);
	this.composer.setSize(renderer.domElement.offsetWidth * this.dpr, renderer.domElement.offsetHeight * this.dpr);
	this.renderPass = new RenderPass(scene, camera, null, new THREE.Color(0xFFFFFF));
	this.composer.addPass(this.renderPass);

	//get max size
	var gl = renderer.context;
	var max = gl.getParameter(gl.MAX_TEXTURE_SIZE);

	//abbility to add FX
	this.add = function(name){
		IO.FXlib[name].call(this, scene, camera, renderer, world);
		return this; //chainable
	};

	//always add FXAA
	// this.add('FXAA');

	this.render = function(delta){
		this.composer.render(delta);
	}.bind(this);

	this.setBackground = function(color){
		this.renderPass.clearColor = color;
		return this;
	};

	this.resize = function(){

		var width = renderer.domElement.offsetWidth * this.dpr;
		var height = renderer.domElement.offsetHeight * this.dpr;
		var ratio;

		if(width < 1024){
			width = 1024;
		}

		//check for max. texture size for dimensions
		if(width > height && width > max){

			ratio = height/width;
			width = max;
			height *= ratio;

		}
		else if( height > width && height > max ){

			ratio = width/height;
			height = max;
			max *= ratio;

		}

		//on resize
		this.composer.setSize(width, height);
		if(this.effectFXAA){
			this.effectFXAA.uniforms.resolution.value.set(1 / width, 1 / height);
		}

	};

	this.destroy = function(){

		this.composer.reset();
		this.composer.renderTarget1.dispose();
		this.composer.renderTarget2.dispose();

		this.composer.renderTarget1 = undefined;
		this.composer.renderTarget2 = undefined;

	};

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/fx.js","/client/classes")
},{"../lib/effect-composer.js":19,"../lib/render-pass.js":24,"IrXUsu":44,"buffer":41,"three":115}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

module.exports = function(fov, aspect, near, far, group){

	var projection, current, currentLook;
	var animation = {};
	var prevAnimation = {};
	var status = 'fixed';

	//create camera
	var camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
	camera.needsUpdate = false;

	//change z and y axis
	camera.up = new THREE.Vector3( 0, 0, 1 );

	var convert = function(pos){

		return pos;

		// group.updateMatrixWorld();
		var converted = group.localToWorld(pos);
		converted.y *= -1;
		return converted;

	};

	camera.setProjection = function(_projection){

		//save
		projection = _projection;

		//chainable
		return camera;
	};

	camera.gotoGeo = function(lat, lon, height){

		//get position from projection
		var newPos = projection.translate3D(lat, lon);
		var newPos3 = convert( new THREE.Vector3(newPos.x, newPos.y, height) );

		//save
		camera.position.copy(newPos3);

		//save
		current = newPos3.clone();

		//chainable
		return camera;
	};

	camera.lookAtGeo = function(lat, lon, height){

		//get position from projection
		var newPos = projection.translate3D(lat, lon);
		var lookAt = convert( new THREE.Vector3(newPos.x, newPos.y, height) );

		camera.lookAt( lookAt );

		//save
		currentLook = lookAt.clone();

		//chainable
		return camera;

	};

	camera.interpolateTo = function(center, dest, distance, extrapolate){

		var _center;
		_center = projection.translate3D(center.lat, center.lon);
		_center = new THREE.Vector3(_center.x, _center.y, center.height);

		var _dest;
		_dest = projection.translate3D(dest.lat, dest.lon);
		_dest = new THREE.Vector3(_dest.x, _dest.y, center.height);


		var line = new THREE.Line3(_center, _dest);
		var totalDistance = line.distance();
		var relDistance = distance / totalDistance;

		if(relDistance > 0.8){
			relDistance = 0.8;
		}

		var newPoint;
		if(extrapolate){
			relDistance += 1;
			newPoint = line.at(relDistance);
		} else {
			newPoint = line.at(1-relDistance);
		}

		camera.animateTo(convert(newPoint), dest);

	};

	camera.animateTo = function(to, lookTo, time, callback){

		var _to, _lookTo;
		time = time || 2000;

		if(to instanceof THREE.Vector3 === false){

			//generate to
			_to = projection.translate3D(to.lat, to.lon);
			_to = convert( new THREE.Vector3(_to.x, _to.y, to.height) );

		} else {

			//to already given
			_to = to;

		}

		if(lookTo instanceof THREE.Vector3 === false){

			//generate look to
			_lookTo = projection.translate3D(lookTo.lat, lookTo.lon);
			_lookTo = convert( new THREE.Vector3(_lookTo.x, _lookTo.y, lookTo.height) );

		} else {

			// look to already given
			_lookTo = lookTo.clone();

		}

		//save animation object for rendering
		animation = {

			'type': 'fly',

			'from': current.clone(),
			'lookFrom': currentLook.clone(),

			'to': _to,
			'lookTo': _lookTo,

			'timeFrom': +Date.now(),
			'timeTo': +Date.now() + time

		};

		//callback?
		if(callback){
			animation.callback = callback;
		}

		//trigger rendering
		camera.needsUpdate = true;

		//chainable
		return camera;
	};

	var generateHoverPlace = function(center, radius, height, speed, elapsedTime){
		return new THREE.Vector3(
			center.x + radius * Math.cos( speed * elapsedTime ),
			center.y + radius * Math.sin( speed * elapsedTime ),
			height
		);
	};

	camera.flyAround = function(center, radius, height, speed, fromCallback){

		//settings
		radius = radius || 500;
		height = height || 250;
		speed = speed || 0.10;

		var _center, _look;
		if(center instanceof THREE.Vector3){

			_center = convert( center.clone() );
			// center = convert(center.clone());
			_look = _center.clone();

		} else {

			//get center point
			center.height = center.height || -50;
			var point = projection.translate3D(center.lat, center.lon);
			_center = convert( new THREE.Vector3(point.x, point.y, center.height) );
			_look = _center.clone();

		}

		//generate start point
		var startPoint = generateHoverPlace(_center, radius, height, speed, 0);

		//move to place?
		if(!fromCallback){

			camera.animateTo(startPoint, _look, 1000, function(){

				//when on correct position start animating
				camera.flyAround(center, radius, height, speed, true);

			});


		} else {

			//change animation object
			animation = {
				'type': 'hover',
				'start': +Date.now(),
				'count': 0,
				'speed': speed,
				'radius': radius,
				'center': _center,
				'height': height
			};

			currentLook = animation.center.clone();

		}

		//save for animation
		camera.needsUpdate = true;

	};

	var paused = false;
	camera.pause = function(){
		paused = true;
	};

	camera.render = function(){

		//check if needs to render
		if(!camera.needsUpdate){
			return false;
		}

		status = 'moving';

		if(animation.type === 'hover'){

			// animation.count += delta;
			animation.count += 0.02;
			// var elapsedTime = +Date.now() - animation.start;

			var newPos = generateHoverPlace(animation.center, animation.radius, animation.height, animation.speed, animation.count);
			camera.position.copy(newPos);
			camera.lookAt( animation.center );

			current = camera.position.clone();

		}

		else if(animation.type === 'fly'){

			//calculate progress
			var duration = animation.timeTo - animation.timeFrom;
			var now = +Date.now() - animation.timeFrom;
			var progress = now/duration;

			//when paused make sure last frame is triggered
			if(paused && progress > 1){
				progress = 1;
			}

			//not paused now
			paused = false;

			//check if done
			if(progress <= 1){

				//prevent overdoing
				if(progress > 1){
					progress = 1;
				}

				//lerp and ease
				var pos = IO.tools.lerp3(animation.from, animation.to, progress);
				var look = IO.tools.lerp3(animation.lookFrom, animation.lookTo, progress);

				//do updating
				camera.position.x = pos.x;
				camera.position.y = pos.y;
				camera.position.z = pos.z;
				camera.lookAt(look);

				//save current pos
				current = pos.clone();
				currentLook = look.clone();

			} else {

				//prevent rendering next time
				camera.needsUpdate = false;
				prevAnimation = animation;
				status = 'fixed';

				//save callback
				var callback = animation.callback || undefined;

				//reset
				animation = {};

				//execute callback when set
				if(callback !== undefined){
					callback();
				}

			}

		}

	};

	//return camera
	return camera;

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/geo-camera.js","/client/classes")
},{"IrXUsu":44,"buffer":41,"three":115}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var q = require('q');

module.exports = function(world){

	//defer object for use within promises
	var self = this;

	var map, data, z, bbox;
	var options = {};
	var actions = [];
	var render = [];
	var loaded = q.defer();
	this.needsRendering = false;

	this.data = function(mapData, _z){

		//save data
		map = mapData;
		z = _z;

		//chainable
		return this;

	};

	//set options
	this.options = function(_options){

		//save
		options = _options;

		//chainable
		return this;
	};

	//load data
	this.fetch = function(){

		var _load = map.load();

		//promise for layer
		_load.then(function(){
			loaded.resolve();
		});

		//promise for loader
		return _load;

	};

	//build mesh with correct buildscript
	this.build = function(build, customZ){

		loaded.promise.done(function(){

			var _z = customZ || z;

			//convert data to 3D when not already converted
			if(!data){

				console.log('converting');

				// //when an array load multiple maps
				// if(map instanceof Array){
				//
				// 	data = [];
				//
				// 	//merge multiple road maps into one
				// 	for( var i = 0 ; i < mapData.length ; i++ ){
				//
				// 		data = _data.concat( map[i].getData() );
				//
				// 	}
				//
				// 	//get bounding box of first map
				// 	//bbox = mapData[0].getBoundingBox();
				//
				// } else {
				//
				// 	//single map
				// 	data = map.convert3D(world.projection, _z);
				// 	// bbox = mapData.getBoundingBox();
				//
				// }

				data = map.getData();

			}

			var meta = {
				'data': data,
				'render': render,
				'boundingbox': bbox,
				'options': options,
				'z': _z
			};

			//start build script
			var action = build.call(meta, world);

			//add actions
			actions = IO.tools.actionExtend(actions, action);

			//needs rendering?
			if(render.length > 0){
				self.needsRendering = render.length;
			} else {
				self.needsRendering = false;
			}

		})

		//chainable
		return this;

	};

	//add abbility to render data in multiple cycles to prevent CPU overloading
	this.render = function(start, end){

		for(var i = start ; i < end ; i++){
			render[i]();
		}

	};

	this.action = function(name, properties){

		var response;

		if(actions[name] instanceof Array){

			response = [];

			for( var i = 0 ; i < actions[name].length ; i++ ){
				response.push( actions[name][i].call(world, properties) );
			}

		} else {
			response = actions[name].call(world, properties);
		}

		//make it possible to call back
		return response;

	};

	this.destroy = function(){
		data = undefined;
		options = undefined;
		z = undefined;
		bbox = undefined;
		actions = undefined;
	};

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/layer3d.js","/client/classes")
},{"IrXUsu":44,"buffer":41,"q":114}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(){

    //defer object needed in promises
    var self = this;

    var list = [];
    var q = require('q');
    var objects = 0;
    var rendered = 0;

    //amount of objects to render at once
    this.throttle = 15;

    this.add = function(_list){

        if(_list instanceof Array){
            list = list.concat(_list);
        } else {
            list.push(_list);
        }

        //chainable
        return this;

    };

    this.start = function(){

        //collection of promised
        var loadList = [];

        for( var i = 0 ; i < list.length ; i++ ){
            loadList.push( list[i].fetch() );
        }

        //show we're now downloading
        this.state('downloading');

        //create grouped promise
        var loadPromise = q.all(loadList);
        var renderPromise = q.defer();

        //on finished start rendering
        loadPromise.then(function(){
            self.render(renderPromise);
        });

        return renderPromise.promise;

    };

    this.render = function(defer){

        var self = this;

        //we're now rendering
        this.state('rendering');

        //determine how many objects to render
        for( var i = 0 ; i < list.length ; i++ ){

            if(list[i].needsRendering){
                objects += list[i].needsRendering;
            }

        }

        //render all objects
        for( var i = 0 ; i < list.length ; i++ ){

            for( var j = 0 ; j < list[i].needsRendering ; j+=this.throttle ){

                //throttle to prevent CPU overload
                setTimeout(function(){

                    //determine end
                    var end = this.start + self.throttle;
                    if(end > list[this.current].needsRendering){
                        end = list[this.current].needsRendering;
                    }

                    //do rendering
                    list[this.current].render(this.start, end);

                    //determine progress
                    rendered += end - this.start;
                    var progress = rendered / objects;

                    //update hook
                    self.update(progress);

                    //finished?
                    if(rendered === objects){
                        self.state('loaded');
                        defer.resolve();
                    }

                }.bind({ 'start': j, 'current': i }), 0);

            }

        }

        //create as promise
        return defer.promise;

    };

    this.update = function(progress){

        console.log('loaded: ' + Math.round(progress * 100) + '%');

    };

    //hook for changes of state [idle, downloading, rendering, done]
    this.state = function(state){
        console.log('state', state );
    };

    //set initial state to idle
    this.state('idle');

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/loader.js","/client/classes")
},{"IrXUsu":44,"buffer":41,"q":114}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');
var q = require('q-xhr')(window.XMLHttpRequest, require('q'))
var topojson = require('topojson');

module.exports = function(url, params){

    var rawData, type;
    var isLoaded = false;

    var convertTopo = function(data, key){
        if (data.type && data.type === 'Topology') {
            return topojson.feature(data, data.objects[key]);
        }
    };

    this.load = function(){

        //create promise
        var self = this;
        var defer = q.defer();

        //get file extention
        var splitted = url.split('.');
        var ext = splitted[splitted.length-1];

        //get file name
        splitted = splitted[splitted.length-2].split('/');
        var filename = splitted[splitted.length-1];

        //serve from cache
        if(isLoaded){
            defer.resolve(self);
        }

        else if(ext === 'png' || ext === 'jpg'){

            //get texture
            rawData = THREE.ImageUtils.loadTexture(url);
            type = 'image';

            //resolve (chainable)
            defer.resolve(self);

        }

        //request data from server
        else {

            q.xhr
                .get(url)
                .then(function(data){

                    //convert to JSON
                    data = JSON.parse(data.data);

                    console.log('ext', ext);

                    //get type and possibly convert
                    switch(ext.toLowerCase()){

                        case 'topojson':

                            var key = params || filename;
                            data = convertTopo(data, key);
                            console.log('converted to topo');

                        case 'geojson':
                            type = 'geoJSON';
                        break;

                        default:
                            type = 'json';
                        break;

                    }

                    console.log(type);

                    //save in object
                    rawData = data;

                    //resolve (chainable)
                    defer.resolve(self);

                    //load change
                    isLoaded = true;

                },function(){
                    console.error('error retrieving map data');
                });

            return defer.promise;

        }

        return defer.promise;

    };

    this.data = function(){
        return rawData;
    };

    var getHeight = function(z, feature){

        if(z instanceof Function){
            return z(feature);
        } else {
            return IO.tools.parseHeight(z);
        }

    };

    var loadFeature = function(projection, coordinates, z, polygon){

        var path = [];

        //polygon fix
        if(polygon){
            coordinates = coordinates[0];
        }

        //loop through coordinates
        coordinates.forEach(function(coordinate){

            //check for junk
            if(coordinate[0] !== 0 && coordinate[1] !== 0){

                var v2 = projection.translate3D(coordinate[0], coordinate[1]);

                // Push positions
                path.push(new THREE.Vector3( v2.x, v2.y, getHeight(z) ));

            }

        });

        return path;

    };

    this.getData = function(){

        //determine what to return
        switch(type){

            case 'geoJSON':

                var collection = new IO.classes.Collection();
                collection.parse(rawData);
                return collection;

            break;

            case 'geoGrid':
            case 'image':

                return data;

        }

    };

}

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/map2.js","/client/classes")
},{"IrXUsu":44,"buffer":41,"q":114,"q-xhr":113,"three":115,"topojson":116}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(world){

	//init
	// var projector = new THREE.Projector();
	var clickable = [];
	var element = world.renderer.domElement;

	//listen to click event
	var clickEvt = function(evt){

		//translate mouse Y value
		var top = element.getBoundingClientRect().top + document.body.scrollTop;
		var y = evt.clientY - top + document.body.scrollTop;

		//translate mouse to Vector
		var vector = new THREE.Vector3(
			( evt.clientX / window.innerWidth ) * 2 - 1,
			- ( y / window.innerHeight ) * 2 + 1,
			0.5
		);

		//get objects in ray
		vector.unproject( world.camera );
		var ray = new THREE.Raycaster( world.camera.position, vector.sub( world.camera.position ).normalize() );
		var intersects = ray.intersectObjects( clickable );

		if ( intersects.length > 0 ) {

			var intersection = intersects[0];
			var object = intersection.object;

			//get geo coordinate
			var clicked = intersection.point;
			intersection.geo = world.projection.reverse(clicked);

			// alert('clicked at ' + geo[0] + ', ' + geo[1]);

			//click event
			if(object.onClick){
				object.onClick(intersection);
			}

		}

	};

	element.addEventListener('click', clickEvt);

	this.addSpot = function(element, callback){

		//click
		if(callback){
			element.onClick = callback;
		}

		clickable.push(element);
	};

	this.destroy = function(){
		clickable = undefined;
		window.removeEventListener('resize', clickEvt, false);
	};

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/mouse.js","/client/classes")
},{"IrXUsu":44,"buffer":41}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');
var d3 = require('d3');

module.exports = function(center, zoom){

    //todo switch between projections [globe - map]

	zoom = zoom || 20;

	//create d3 projection
	var projection = d3.geo.mercator()
			.scale(Math.pow(2,zoom))
			.center(center);

	this.translate = function(lat, lon){
		return projection([lat, lon]);
	};

	this.translate3D = function(lat, lon){
		var coords = projection([lat, lon]);
		return new THREE.Vector2(coords[0], coords[1]);
	};

	this.reverse = function(vec3){

		//reverse through projection
		return projection.invert([vec3.x,vec3.y]);

	};

	//make public, maybe needed
	this.d3 = projection;

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/projection.js","/client/classes")
},{"IrXUsu":44,"buffer":41,"d3":40,"three":115}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

module.exports = function(){

	var list = [];
	var end = false;
	var clock = new THREE.Clock();

	this.add = function(fn){

		var id = THREE.Math.generateUUID();

		list.push({
			'task': fn,
			'id': id
		});

		return id;
	};

	this.remove = function(id){

        for( var i = 0 ; i < list.length ; i++ ){

            if( list[i].id === id){
                list.splice(i, 1);
            }

        }

    };

    this.clear = function(){
        list = [];
		clock.stop();
    };

	var render = function(){

		//stop when needed
        if(end) {
            end = false;
            return false;
        }

        //shedule next frame [TODO add shim]
        requestAnimationFrame( render );

        //delta
        var delta = clock.getDelta();

        for( var i = 0 ; i < list.length ; i++ ){

            list[i].task(delta);

        }

	};

	this.start = function(){
		end = false;
        render();
    };

    this.stop = function(clear){
        end = true;

		if(clear){
			this.clear();
		}
    };

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/render-manager.js","/client/classes")
},{"IrXUsu":44,"buffer":41,"three":115}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(canvas, projection, FXlist){

	var pause = true;
	var world = this;

	//create projection
	this.projection = projection;

	//Setup renderer and cameras
	IO.tools.createThree.call(this, canvas);

	//get mouse positions
	this.mouse = new IO.classes.Mouse(this);

	//setup geo
	this.camera.setProjection(this.projection);

	//add FX
	this.FX = new IO.classes.FX(this.renderer, this.scene, this.camera, this);

	//add FX from list
	FXlist = FXlist || [];
	for( var i = 0 ; i < FXlist.length ; i++ ){
		this.FX.add(FXlist[i]);
	}

	//trigger applying FX
	this.FX
		.add('FXAA')
		.add('copyShader')
		.resize();

	//prevent showing before playing
	canvas.style.visibility = 'hidden';

	//add list
	this.render = new IO.classes.RenderManager();

	//add to the list of renderable function
	this.render.add(this.camera.render, this.camera.pause);
	this.render.add(this.FX.render);
	// this.render.add(this.renderer.render);

	//add preloader
	this.preloader = new IO.classes.Loader();

	//shortcut to preloader
	this.load = function(list){

		return this.preloader
			.add(list)
			.start();

	}

	//playback controls
	this.start = function(){

		console.log('start', this.scene);

		var startRender = pause;
		canvas.style.visibility = 'visible';
		pause = false;

		if(startRender){
			world.render.start();
		}

	};

	this.stop = function(){
		pause = true;
		world.render.stop();
	};

	//resize
	var resize = function(){

		var w = this.renderer.domElement.offsetWidth;
		var h = this.renderer.domElement.offsetHeight;

		this.renderer.setSize( w, h );
		this.camera.aspect = w / h;
		this.camera.updateProjectionMatrix();
		this.FX.resize(w, h);

	}.bind(this);

	//destroy webGL buffers and memory
	var destroyWebGL = function(){

		//destroy WebGL thingies
		IO.tools.destroyGroup(this.group, this.scene);
		this.renderer.clear();
		this.FX.destroy();
		this.mouse.destroy();
		this.FX = undefined;
		this.camera = undefined;
		this.scene = undefined;
		this.group = undefined;
		this.mouse = undefined;
		this.render = undefined;

		//remove DOM element
		var elem = this.renderer.domElement;
		elem.parentNode.removeChild(elem);

		world = undefined;

	}.bind(this);

	//events
	window.addEventListener('resize', resize, false );

	//make sure event listeners are destroyed
	this.destroy = function(){
		world.render.stop(true);
		window.removeEventListener('resize', resize, false);
		destroyWebGL();
	};

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/classes/world.js","/client/classes")
},{"IrXUsu":44,"buffer":41}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//read all folders
module.exports = {

    'classes': {

        //isomorphic (shared)
        'Geo': require('../isomorphic/classes/geo.js'),
        'Feature': require('../isomorphic/classes/geo.js'),
        'Collection': require('../isomorphic/classes/collection.js'),

        //client only
        'World': require('./classes/world.js'),
        'RenderManager': require('./classes/render-manager.js'),
        'Projection': require('./classes/projection.js'),
        'BoundingBox': require('./classes/boundingbox.js'),
        'Map': require('./classes/map2.js'),
        'Loader': require('./classes/loader.js'),
        'Layer3D': require('./classes/layer3d.js'),
        'FX': require('./classes/fx.js'),
        'GeoCamera': require('./classes/geo-camera.js'),
        'Animation': require('./classes/animation.js'),
        'Mouse': require('./classes/mouse.js'),
        'Compass': require('./classes/compass.js')

    },

    'tools': {

        'actionExtend': require('./tools/action-extend.js'),
        'createThree': require('./tools/create-three.js'),
        'destroyGroup': require('./tools/destroy-group.js'),
        'lerp3': require('./tools/lerp-3d.js'),
        'mergeMaps': require('./tools/merge-maps.js'),
        'parseHeight': require('./tools/parse-height.js'),

    },

    'build': {

        'roads': require('./build/roads.js'),
        'buildings': require('./build/buildings.js'),
        'areas': require('./build/areas.js')

    },

    'FXlib': {

        'copyShader': require('./tools/fx/copy-shader.js'),
        'filmGrain': require('./tools/fx/film-grain.js'),
        'FXAA': require('./tools/fx/fxaa.js'),
        'tiltShift': require('./tools/fx/tilt-shift.js')

    }

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/index.js","/client")
},{"../isomorphic/classes/collection.js":37,"../isomorphic/classes/geo.js":39,"./build/areas.js":2,"./build/buildings.js":3,"./build/roads.js":4,"./classes/animation.js":5,"./classes/boundingbox.js":6,"./classes/compass.js":7,"./classes/fx.js":8,"./classes/geo-camera.js":9,"./classes/layer3d.js":10,"./classes/loader.js":11,"./classes/map2.js":12,"./classes/mouse.js":13,"./classes/projection.js":14,"./classes/render-manager.js":15,"./classes/world.js":16,"./tools/action-extend.js":27,"./tools/create-three.js":28,"./tools/destroy-group.js":29,"./tools/fx/copy-shader.js":30,"./tools/fx/film-grain.js":31,"./tools/fx/fxaa.js":32,"./tools/fx/tilt-shift.js":33,"./tools/lerp-3d.js":34,"./tools/merge-maps.js":35,"./tools/parse-height.js":36,"IrXUsu":44,"buffer":41}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join("\n")

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/lib/copy-shader.js","/client/lib")
},{"IrXUsu":44,"buffer":41,"three":115}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * @author alteredq / http://alteredqualia.com/
 */

var THREE = require('three');
var ShaderPass = require('./shader-pass.js');
var CopyShader = require('./copy-shader.js');

var EffectComposer = function ( renderer, renderTarget ) {

	this.renderer = renderer;

	if ( renderTarget === undefined ) {

		var width = window.innerWidth || 1;
		var height = window.innerHeight || 1;
		var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

		renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );

	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	if ( CopyShader === undefined )
		console.error( "THREE.EffectComposer relies on THREE.CopyShader" );

	this.copyPass = new ShaderPass( CopyShader );

};

EffectComposer.prototype = {

	swapBuffers: function() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	},

	addPass: function ( pass ) {

		this.passes.push( pass );

	},

	insertPass: function ( pass, index ) {

		this.passes.splice( index, 0, pass );

	},

	render: function ( delta ) {

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		var maskActive = false;

		var pass, i, il = this.passes.length;

		for ( i = 0; i < il; i ++ ) {

			pass = this.passes[ i ];

			if ( !pass.enabled ) continue;

			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					var context = this.renderer.context;

					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			//CUSTOM [bug fix, to prevent errors]
			// if ( pass instanceof THREE.MaskPass ) {
			//
			// 	maskActive = true;
			//
			// } else if ( pass instanceof THREE.ClearMaskPass ) {
			//
			// 	maskActive = false;
			//
			// }

		}

	},

	reset: function ( renderTarget ) {

		if ( renderTarget === undefined ) {

			renderTarget = this.renderTarget1.clone();

			renderTarget.width = window.innerWidth;
			renderTarget.height = window.innerHeight;

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	},

	setSize: function ( width, height ) {

		var renderTarget = this.renderTarget1.clone();

		renderTarget.width = width;
		renderTarget.height = height;

		this.reset( renderTarget );

	}

};

module.exports = EffectComposer;

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/lib/effect-composer.js","/client/lib")
},{"./copy-shader.js":18,"./shader-pass.js":25,"IrXUsu":44,"buffer":41,"three":115}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * @author alteredq / http://alteredqualia.com/
 */

var THREE = require('three');
var FilmShader = require('./film-shader.js');

var FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {

	if ( FilmShader === undefined )
		console.error( "THREE.FilmPass relies on THREE.FilmShader" );

	var shader = FilmShader;

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	} );

	if ( grayscale !== undefined )	this.uniforms.grayscale.value = grayscale;
	if ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;
	if ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;
	if ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;

	this.enabled = true;
	this.renderToScreen = false;
	this.needsSwap = true;


	this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

FilmPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		this.uniforms[ "tDiffuse" ].value = readBuffer;
		this.uniforms[ "time" ].value += delta;

		this.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, false );

		}

	}

};

module.exports = FilmPass;

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/lib/film-pass.js","/client/lib")
},{"./film-shader.js":21,"IrXUsu":44,"buffer":41,"three":115}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"time":       { type: "f", value: 0.0 },
		"nIntensity": { type: "f", value: 0.5 },
		"sIntensity": { type: "f", value: 0.05 },
		"sCount":     { type: "f", value: 4096 },
		"grayscale":  { type: "i", value: 1 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		// control parameter
		"uniform float time;",

		"uniform bool grayscale;",

		// noise effect intensity value (0 = no effect, 1 = full effect)
		"uniform float nIntensity;",

		// scanlines effect intensity value (0 = no effect, 1 = full effect)
		"uniform float sIntensity;",

		// scanlines effect count value (0 = no effect, 4096 = full effect)
		"uniform float sCount;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			// sample the source
			"vec4 cTextureScreen = texture2D( tDiffuse, vUv );",

			// make some noise
			"float x = vUv.x * vUv.y * time *  1000.0;",
			"x = mod( x, 13.0 ) * mod( x, 123.0 );",
			"float dx = mod( x, 0.01 );",

			// add noise
			"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );",

			// get us a sine and cosine
			"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",

			// add scanlines
			"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",

			// interpolate between source and result by intensity
			"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",

			// convert to grayscale if desired
			"if( grayscale ) {",

				"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",

			"}",

			"gl_FragColor =  vec4( cResult, cTextureScreen.a );",

		"}"

	].join("\n")

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/lib/film-shader.js","/client/lib")
},{"IrXUsu":44,"buffer":41}],22:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

module.exports = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"resolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }

	},

	vertexShader: [

		//"varying vec2 vUv;",

		"void main() {",

			// "vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec2 resolution;",

		//"varying vec2 vUv;",

		"#define FXAA_REDUCE_MIN   (1.0/128.0)",
		"#define FXAA_REDUCE_MUL   (1.0/8.0)",
		"#define FXAA_SPAN_MAX     8.0",

		"void main() {",

			"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
			"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
			"vec3 rgbM  = rgbaM.xyz;",
			"float opacity  = rgbaM.w;",

			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			"float lumaNW = dot( rgbNW, luma );",
			"float lumaNE = dot( rgbNE, luma );",
			"float lumaSW = dot( rgbSW, luma );",
			"float lumaSE = dot( rgbSE, luma );",
			"float lumaM  = dot( rgbM,  luma );",
			"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
			"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",

			"vec2 dir;",
			"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
			"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",

			"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",

			"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
			"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
				  "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
						"dir * rcpDirMin)) * resolution;",

			"vec3 rgbA = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz;",
			"rgbA += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz;",
			"rgbA *= 0.5;",

			"vec3 rgbB = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz;",
			"rgbB += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz;",
			"rgbB *= 0.25;",
			"rgbB += rgbA * 0.5;",

			"float lumaB = dot( rgbB, luma );",

			"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",

				"gl_FragColor = vec4( rgbA, opacity );",

			"} else {",

				"gl_FragColor = vec4( rgbB, opacity );",

			"}",

		"}"

	].join("\n")

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/lib/fxaa.js","/client/lib")
},{"IrXUsu":44,"buffer":41,"three":115}],23:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 * - "r" parameter control where "focused" horizontal line lies
 */

//edited for cityio

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"h":        { type: "f", value: 1.0 / 512.0 },
		"r":        { type: "f", value: 0.35 },
		"spread":   { type: "f", value: 1.2 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float h;",
		"uniform float r;",
		"uniform float spread;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"float hh = h * pow( abs( r - vUv.y) , spread);",

			"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join("\n")

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/lib/horizontal-tilt-shift-shader.js","/client/lib")
},{"IrXUsu":44,"buffer":41}],24:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

var RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

};

RenderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		this.scene.overrideMaterial = this.overrideMaterial;

		if ( this.clearColor ) {

			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		renderer.render( this.scene, this.camera, readBuffer, this.clear );

		if ( this.clearColor ) {

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

		}

		this.scene.overrideMaterial = null;

	}

};

module.exports = RenderPass;

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/lib/render-pass.js","/client/lib")
},{"IrXUsu":44,"buffer":41,"three":115}],25:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * @author alteredq / http://alteredqualia.com/
 */

var THREE = require('three');

ShaderPass = function ( shader, textureID ) {

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	} );

	this.renderToScreen = false;

	this.enabled = true;
	this.needsSwap = true;
	this.clear = false;


	this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

ShaderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer;

		}

		this.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	}

};

module.exports = ShaderPass;

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/lib/shader-pass.js","/client/lib")
},{"IrXUsu":44,"buffer":41,"three":115}],26:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 * - "r" parameter control where "focused" horizontal line lies
 */

//edited for cityio

module.exports = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"v":        { type: "f", value: 1.0 / 512.0 },
		"r":        { type: "f", value: 0.35 },
		"spread":   { type: "f", value: 1.2 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float v;",
		"uniform float r;",
		"uniform float spread;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"float vv = v * pow( abs( r - vUv.y ) ,spread);",

			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join("\n")

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/lib/vertical-tilt-shift-shader.js","/client/lib")
},{"IrXUsu":44,"buffer":41}],27:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(source, props) {

	var res = source;

	//create original object
	// for (var prop in source) {
	// 	res[prop] = source[prop];
	// }

	//overwrite
	for (var prop in props) {

		//new
		if(!res[prop]){
			res[prop] = props[prop];
		}

		//overwrite
		else {

			//first time
			if(res[prop] instanceof Function){
				res[prop] = [ res[prop], props[prop] ];
			}

			//add to existing list
			else {
				res[prop].push( props[prop] );
			}

		}
	}

	return res;

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/tools/action-extend.js","/client/tools")
},{"IrXUsu":44,"buffer":41}],28:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

module.exports = function(canvas, minHeight){

	var width = window.innerWidth;
	var height = window.innerHeight;

	if(width < 1024){
		width = 1024;
	}

	if(minHeight){
		height = minHeight;
	}

	this.renderer = new THREE.WebGLRenderer( { antialias: true } );
	this.renderer.setClearColor( 0xFFFFFF, 1 );
	this.renderer.setSize(width, height);

	//rotate world
	this.group = new THREE.Object3D();

	//Setup camera
	this.camera = new IO.classes.GeoCamera(60, width/height , 1, 5000, this.group);
	this.camera.position.z = 1500;

	//Setup scene
	this.scene = new THREE.Scene();
	this.scene.fog = new THREE.FogExp2( 0xFFFFFF, 0.00050 );
	this.scene.fog.night = new THREE.Color(0x222222);
    this.scene.fog.day = new THREE.Color(0xFFFFFF);

	//Add rotated world to scene
	this.scene.add(this.group);
	// this.group.rotateX(Math.PI/2);
	// this.group.rotateZ(-Math.PI/2);
	// this.group.updateMatrixWorld();

	//create light
	var hemisphere = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
	this.scene.add(hemisphere);

	// Append to canvas
	canvas.appendChild( this.renderer.domElement );

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/tools/create-three.js","/client/tools")
},{"IrXUsu":44,"buffer":41,"three":115}],29:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(group, scene){

	//no children in group
	if(!group.children){
		return false;
	}

	for( var i = 0 ; i < group.children.length ; i++ ){

		var object = group.children[i];

		scene.remove(object);
		group.remove(object);

		if (object.geometry) {
			object.geometry.dispose();
			object.geometry = undefined;
		}
		if (object.material) {


			if (object.material.materials){

                for (i = 0; i < object.material.materials.length; i++){
                    object.material.materials[i].dispose();
                }

            }
            else {
                object.material.dispose();
            }

            object.material = undefined;
		}
		if (object.texture) {
			object.texture.dispose();
			object.texture = undefined;
		}

		if (object.dispose) {
			object.dispose();
		}

		object = undefined;

	}

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/tools/destroy-group.js","/client/tools")
},{"IrXUsu":44,"buffer":41}],30:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var CopyShader = require('../../lib/copy-shader.js');
var ShaderPass = require('../../lib/shader-pass.js');

module.exports = function(){

	//check
	if(!this.composer){
		console.warn('composer not found');
		return false;
	}

	//copy pass?
	var copyPass = new ShaderPass(CopyShader);
	copyPass.renderToScreen = true;
	this.composer.addPass(copyPass);

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/tools/fx/copy-shader.js","/client/tools/fx")
},{"../../lib/copy-shader.js":18,"../../lib/shader-pass.js":25,"IrXUsu":44,"buffer":41}],31:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var FilmPass = require('../../lib/film-pass.js')

module.exports = function(){

    //check
    if(!this.composer){
        console.warn('composer not found');
        return false;
    }

    //film grain
    var effectFilm = new FilmPass(0.1, 0, 100, false);
    this.composer.addPass(effectFilm);

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/tools/fx/film-grain.js","/client/tools/fx")
},{"../../lib/film-pass.js":20,"IrXUsu":44,"buffer":41}],32:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var ShaderPass = require('../../lib/shader-pass.js');
var FXAAShader = require('../../lib/fxaa.js');

module.exports = function(){

	//check
	if(!this.composer){
		console.warn('composer not found');
		return false;
	}

	//FXAA - AntiAliasing
	this.effectFXAA = new ShaderPass(FXAAShader);
	// var width = window.innerWidth || 2;
	// var height = window.innerHeight || 2;
	// this.effectFXAA.uniforms.resolution.value.set(1 / (width * this.dpr ), 1 / (height * this.dpr ));
	this.composer.addPass(this.effectFXAA);

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/tools/fx/fxaa.js","/client/tools/fx")
},{"../../lib/fxaa.js":22,"../../lib/shader-pass.js":25,"IrXUsu":44,"buffer":41}],33:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var ShaderPass = require('../../lib/shader-pass.js');
var HorizontalTiltShiftShader = require('../../lib/horizontal-tilt-shift-shader.js');
var VerticalTiltShiftShader = require('../../lib/vertical-tilt-shift-shader.js');

module.exports = function(scene, camera, renderer, world){

    //check
    if(!this.composer){
        console.warn('composer not found');
        return false;
    }

    var current;

    //abbility to set
    this.setBlur = function(blur, point, spread, animate){

        spread = spread || 1;

        //only set
        if(!animate){

            this.hblur.uniforms.h.value = blur / window.innerWidth;
            this.vblur.uniforms.v.value = blur / window.innerHeight;
            this.hblur.uniforms.r.value = point;
            this.vblur.uniforms.r.value = point;
            this.hblur.uniforms.spread.value = spread;
            this.vblur.uniforms.spread.value = spread;

            //save
            current = [blur, point, spread];

        }

        //animate
        else {

            var anim = new IO.classes.Animation(world);
            var duration = animate === true ? 1000 : animate;

            //custom setter function for animation
            var fn = function(property, progress, options, lerp){

                var blur = lerp(options.from[0], options.to[0], progress);
                var point = lerp(options.from[1], options.to[1], progress);
                var spread = lerp(options.from[2], options.to[2], progress);
                property.setBlur(blur, point, spread);

            };

            //add property
            anim.add(this, {
                'from': current,
                'to': [blur, point, spread],
                'duration': duration,
                'tick': fn
            });

            //start
            anim.start();

        }

    };

    //init
    this.hblur = new ShaderPass(HorizontalTiltShiftShader);
    this.vblur = new ShaderPass(VerticalTiltShiftShader);
    this.setBlur(20, 0.55, 1.65);

    this.composer.addPass(this.hblur);
    this.composer.addPass(this.vblur);

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/tools/fx/tilt-shift.js","/client/tools/fx")
},{"../../lib/horizontal-tilt-shift-shader.js":23,"../../lib/shader-pass.js":25,"../../lib/vertical-tilt-shift-shader.js":26,"IrXUsu":44,"buffer":41}],34:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THREE = require('three');

//add easing - from http://gizma.com/easing/#cub3
Math.easeInOutQuad = function (t, b, c, d) {
	t /= d/2;
	if (t < 1) {
		return c/2*t*t + b;
	}
	t--;
	return -c/2 * (t*(t-2) - 1) + b;
};

Math.easeInOutCubic = function (t, b, c, d) {
	t /= d/2;
	if (t < 1){
		return c/2*t*t*t + b;
	}
	t -= 2;
	return c/2*(t*t*t + 2) + b;
};

module.exports = function(from, to, completed){

	return new THREE.Vector3(
		Math.easeInOutCubic(completed, from.x, to.x-from.x, 1),
		Math.easeInOutCubic(completed, from.y, to.y-from.y, 1),
		Math.easeInOutCubic(completed, from.z, to.z-from.z, 1)
	);

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/tools/lerp-3d.js","/client/tools")
},{"IrXUsu":44,"buffer":41,"three":115}],35:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(main, mapList){

	for( var i = 0 ; i < mapList.length ; i++ ){

		main = main.concat( mapList[i] );

	}

};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/tools/merge-maps.js","/client/tools")
},{"IrXUsu":44,"buffer":41}],36:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(height){
	return -height;
};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/client/tools/parse-height.js","/client/tools")
},{"IrXUsu":44,"buffer":41}],37:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Feature = require('./feature.js');

module.exports = function(){

    var list = [];

    this.parse = function(collection){

        for( var i = 0 ; i < collection.features.length ; i++ ){
            this.add(collection.features[i]);
        }

        return this;

    }

    this.add = function(feature){
        var feature = new Feature().parse(feature);
        list.push(feature);

        return this;
    };

    this.get = function(){
        return list;
    };

}

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/isomorphic/classes/collection.js","/isomorphic/classes")
},{"./feature.js":38,"IrXUsu":44,"buffer":41}],38:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Geo = require('./geo.js');

var Feature = function(data){

    var list = [];

    //properties of feature
    this.properties = {};
    this.type = '';

    //data in constructor? (when cloning for example)
    if(data){
        list = data;
    }

    //parse from JSON
    this.parse = function(json){

        if(!json.geometry){
            console.warn('no geometry');
        }

        //save properties
        this.properties = json.properties;
        this.type = json.geometry.type;

        //add al points to list
        json.geometry.coordinates.forEach(function(pos){

            var multi = pos[0] instanceof Array;

            if(!multi){
                var pos = new Geo().fromArray(pos);
                list.push( pos );
            } else {

                var _list = [];

                pos.forEach(function(pos){

                    var pos = new Geo().fromArray(pos);
                    _list.push( pos );

                });

                list.push(_list);
            }

        });

        //chainable
        return this;

    };

    this.each = function(callback){

        if(callback instanceof Function === false){
            console.log('each loop must use a function as parameter');
        }

        for( var i = 0 ; i < list.length ; i++ ){

            var pos = list[i];
            var multi = pos instanceof Array;

            if(!multi){
                callback(pos, i);
            } else {

                for( var j = 0 ; j < pos.length ; j++ ){
                    callback(list[i][j], j);
                }

            }

        }

        //chainable
        return this;

    };

    this.getFlatArray = function(){

        //create list
        var _list = [];

        //add all to new list
        this.each(function(pos){
            debugger
            _list.push(pos);
        });

        //and return
        return _list;
    };

    this.getArray = function(){
        return list;
    };

    this.exportArray = function(){
        var _list = [];

        //get original geometry array back
        list.forEach(function(pos){

            var multi = pos[0] instanceof Array;

            if(!multi){
                _list.push( pos.toArray() );
            } else {

                var sublist = [];

                pos.forEach(function(pos){
                    sublist.push( pos.toArray() );
                });

                _list.push(sublist);
            }

        });

        return _list;

    };

    this.getCenter = function(){

        var _list = this.getFlatArray();
        var x = _list.map(function(a){ return a.lat });
        var y = _list.map(function(a){ return a.lon });
        var minX = Math.min.apply(null, x);
        var maxX = Math.max.apply(null, x);
        var minY = Math.min.apply(null, y);
        var maxY = Math.max.apply(null, y);
        // return [(minX + maxX)/2, (minY + maxY)/2];
        return new Geo((minX + maxX)/2, (minY + maxY)/2);

    };

    this.getClosest = function(compareList){

        var _list = this.getFlatArray();
        var min = -1;
        var closest;

        for( var i = 0 ; i < _list.length ; i++ ){

            //check agains list provided
            for( var j = 0 ; j < compareList.length ; j++ ){

                //get distance
                var distance = _list[i].distanceTo(compareList[j]);

                //is closer?
                if(min < 0 || distance < min){
                    min = distance;
                    closest = compareList[j];
                }

            }

        }

        return closest;

    };

    this.splitPath = function(interval){

        //standard length
        interval = interval || 20;
        var newList = [];

        var split = function(points){

            //prevent loading single points
            if(!points || points.length < 2){
                console.warn('trying to split path of single point');
            }

            var _list = [];
            for (var i = 0; i < points.length-1 ; i++){

                //make line
                start = points[i];
                end = points[i+1];

                //calculate nr of points
                var distance = start.distanceTo(end);
                var parts = Math.ceil(distance/interval);

                //add interpolated points
                var point;
                for(var j=0 ; j < parts ; j++){
                    point = (1 / parts) * j;
                    _list.push(start.lerp(end, point));
                }

                //final point
                _list.push(start.lerp(end, 1));

            }

            return _list;

        };

        //get original geometry array back
        list = split( this.getFlatArray() );

        //chainable
        return this;
    };

    this.get3D = function(projection){

        var points = [];
        var _list = this.getFlatArray();

        //convert to 3d
        debugger
        for( var i = 0 ; i < _list.length ; i++ ){
            points.push( _list[i].to3D(projection) );
        }

        //return new points
        return points;
    };

    this.clone = function(){
        var clone = new Feature(list);
        clone.properties = this.properties;
        return clone;
    };

    this.export = function(){
        var json = {};
        json.properties = this.properties;
        json.geometry = {};
        json.geometry.type = this.type;
        json.geometry.coordinates = this.exportArray();
    };

};

module.exports = Feature;

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/isomorphic/classes/feature.js","/isomorphic/classes")
},{"./geo.js":39,"IrXUsu":44,"buffer":41}],39:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var proj4 = require('proj4');
var THREE = require('three');

var Geo = function(lat, lon, srs){

    this.lat = lat;
    this.lon = lon;
    this.srs = srs || 'EPSG:4326';

    this.distanceTo = function(geo){

        //prevent
        if(!(geo.lat instanceof Number && geo.lon instanceof Number)){
            console.error('destination object not valid');
        }

        //http://stackoverflow.com/questions/639695/how-to-convert-latitude-or-longitude-to-meters
        var R = 6378.137; // Radius of earth in KM
        var dLat = (geo.lat - this.lat) * Math.PI / 180;
        var dLon = (geo.lon - this.lon) * Math.PI / 180;
        var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(this.lon * Math.PI / 180) * Math.cos(geo.lat * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        var d = R * c;
        return d * 1000; // meters

    };

    //linear interpolate to position (alpha between 0,1)
    this.lerp = function(destination, alpha){
        var lat = this.lat * (1 - alpha) + destination.lat * alpha;
		var lon = this.lon * (1 - alpha) + destination.lon * alpha;
		return new Geo(lat, lon);
    };

    this.convert = function(srs){

        //convert to another SRS when needed
        if(srs != this.srs){
            var coord = proj4(this.srs, srs, [this.lat, this.lon]);
            this.lat = coord[0];
            this.lon = coord[1];
            this.srs = srs;
        }

        return this;
    };

    this.clone = function(){
        return new Geo(this.lat, this.lon);
    };

    this.copy = function(geo){
        this.lat = geo.lat;
        this.lon = geo.lon;
    };

    this.fromArray = function(pos){
        this.lat = pos[0];
        this.lon = pos[1];

        return this;
    };

    this.toArray = function(){
        return [this.lat, this.lon];
    };

    this.to3D = function(projection, z){
        z = z || 0;
        var coords = projection.translate3D(this.lat, this.lon);
        return new THREE.Vector3(coords.x, coords.y, z);
    };

};

module.exports = Geo;

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/isomorphic/classes/geo.js","/isomorphic/classes")
},{"IrXUsu":44,"buffer":41,"proj4":80,"three":115}],40:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
!function() {
  var d3 = {
    version: "3.5.2"
  };
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = document, d3_documentElement = d3_document.documentElement, d3_window = window;
  try {
    d3_array(d3_documentElement.childNodes)[0].nodeType;
  } catch (e) {
    d3_array = function(list) {
      var i = list.length, array = new Array(i);
      while (i--) array[i] = list[i];
      return array;
    };
  }
  try {
    d3_document.createElement("div").style.setProperty("opacity", 0, "");
  } catch (error) {
    var d3_element_prototype = d3_window.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
    d3_element_prototype.setAttribute = function(name, value) {
      d3_element_setAttribute.call(this, name, value + "");
    };
    d3_element_prototype.setAttributeNS = function(space, local, value) {
      d3_element_setAttributeNS.call(this, space, local, value + "");
    };
    d3_style_prototype.setProperty = function(name, value, priority) {
      d3_style_setProperty.call(this, name, value + "", priority);
    };
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatcher = d3_documentElement.matches || d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")], d3_selectMatches = function(n, s) {
    return d3_selectMatcher.call(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3_selectionRoot;
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.slice(0, i);
        name = name.slice(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? function() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    } : function() {
      return this.ownerDocument.createElementNS(this.namespaceURI, name);
    };
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues[i] = keyValue;
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group = [ typeof node === "string" ? d3_select(node, d3_document) : node ];
    group.parentNode = d3_documentElement;
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group = d3_array(typeof nodes === "string" ? d3_selectAll(nodes, d3_document) : nodes);
    group.parentNode = d3_documentElement;
    return d3_selection([ group ]);
  };
  var d3_selectionRoot = d3.select(d3_documentElement);
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  d3_selection_onFilters.forEach(function(k) {
    if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
  });
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect = "onselectstart" in d3_document ? null : d3_vendorSymbol(d3_documentElement.style, "userSelect"), d3_event_dragId = 0;
  function d3_event_dragSuppress() {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect) {
      var style = d3_documentElement.style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
        svg = d3.select("body").append("svg").style({
          position: "absolute",
          top: 0,
          left: 0,
          margin: 0,
          padding: 0,
          border: "none"
        }, "important");
        var ctm = svg[0][0].getScreenCTM();
        d3_mouse_bug44083 = !(ctm.f || ctm.e);
        svg.remove();
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_behavior_dragMouseSubject, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_behavior_dragTouchSubject, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject()).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged && d3.event.target === target);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  function d3_behavior_dragTouchSubject() {
    return d3.event.target;
  }
  function d3_behavior_dragMouseSubject() {
    return d3_window;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var  = 1e-6, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ?  : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? half : x < -1 ? -half : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var  = Math.SQRT2, 2 = 2, 4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4 * d2) / (2 * w0 * 2 * d1), b1 = (w1 * w1 - w0 * w0 - 4 * d2) / (2 * w1 * 2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ;
    function interpolate(t) {
      var s = t * S;
      if (dr) {
        var coshr0 = d3_cosh(r0), u = w0 / (2 * d1) * (coshr0 * d3_tanh( * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh( * s + r0) ];
      }
      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp( * s) ];
    }
    interpolate.duration = S * 1e3;
    return interpolate;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: +_
      };
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      });
      center0 = null;
    }
    function mousedowned() {
      var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress();
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged && d3.event.target === target);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress();
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else translate0 = location(center0 = center || d3.mouse(this)), 
      d3_selection_interrupt.call(this), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ];
  var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
  }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
    return d3.event.wheelDelta;
  }, "mousewheel") : (d3_behavior_zoomDelta = function() {
    return -d3.event.detail;
  }, "MozMousePixelScroll");
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) return rgb(color.r, color.g, color.b);
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  function d3_identity(d) {
    return d;
  }
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (d3_window.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      f: false,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now();
    d3_timer_active = d3_timer_queueHead;
    while (d3_timer_active) {
      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
      d3_timer_active = d3_timer_active.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.f) {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      } else {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * ;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 *  + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var 00, 00, 0, cos0, sin0;
    d3_geo_area.point = function(, ) {
      d3_geo_area.point = nextPoint;
      0 = (00 = ) * d3_radians, cos0 = Math.cos( = (00 = ) * d3_radians / 2 +  / 4), 
      sin0 = Math.sin();
    };
    function nextPoint(, ) {
       *= d3_radians;
       =  * d3_radians / 2 +  / 4;
      var d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(), sin = Math.sin(), k = sin0 * sin, u = cos0 * cos + k * Math.cos(ad), v = k * sd * Math.sin(ad);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      0 = , cos0 = cos, sin0 = sin;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(00, 00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var  = spherical[0],  = spherical[1], cos = Math.cos();
    return [ cos * Math.cos(), cos * Math.sin(), Math.sin() ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) <  && abs(a[1] - b[1]) < ;
  }
  d3.geo.bounds = function() {
    var 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) 0 = -(1 = 180), 0 = -(1 = 90); else if (dSum > ) 1 = 90; else if (dSum < -) 0 = -90;
        range[0] = 0, range[1] = 1;
      }
    };
    function point(, ) {
      ranges.push(range = [ 0 = , 1 =  ]);
      if ( < 0) 0 = ;
      if ( > 1) 1 = ;
    }
    function linePoint(, ) {
      var p = d3_geo_cartesian([  * d3_radians,  * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs(d) > 180;
        if (antimeridian ^ (s * _ < i && i < s * )) {
          var i = inflection[1] * d3_degrees;
          if (i > 1) 1 = i;
        } else if (i = (i + 360) % 360 - 180, antimeridian ^ (s * _ < i && i < s * )) {
          var i = -inflection[1] * d3_degrees;
          if (i < 0) 0 = i;
        } else {
          if ( < 0) 0 = ;
          if ( > 1) 1 = ;
        }
        if (antimeridian) {
          if ( < _) {
            if (angle(0, ) > angle(0, 1)) 1 = ;
          } else {
            if (angle(, 1) > angle(0, 1)) 0 = ;
          }
        } else {
          if (1 >= 0) {
            if ( < 0) 0 = ;
            if ( > 1) 1 = ;
          } else {
            if ( > _) {
              if (angle(0, ) > angle(0, 1)) 1 = ;
            } else {
              if (angle(, 1) > angle(0, 1)) 0 = ;
            }
          }
        }
      } else {
        point(, );
      }
      p0 = p, _ = ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = 0, range[1] = 1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(, ) {
      if (p0) {
        var d =  - _;
        dSum += abs(d) > 180 ? d + (d > 0 ? 360 : -360) : d;
      } else __ = , __ = ;
      d3_geo_area.point(, );
      linePoint(, );
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(__, __);
      d3_geo_area.lineEnd();
      if (abs(dSum) > ) 0 = -(1 = 180);
      range[0] = 0, range[1] = 1;
      p0 = null;
    }
    function angle(0, 1) {
      return (1 -= 0) < 0 ? 1 + 360 : 1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      1 = 1 = -(0 = 0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, d;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((d = angle(a[1], b[0])) > best) best = d, 0 = b[0], 1 = a[1];
        }
      }
      ranges = range = null;
      return 0 === Infinity || 0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ 0, 0 ], [ 1, 1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < 2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < 2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(, ) {
     *= d3_radians;
    var cos = Math.cos( *= d3_radians);
    d3_geo_centroidPointXYZ(cos * Math.cos(), cos * Math.sin(), Math.sin());
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians);
      x0 = cos * Math.cos();
      y0 = cos * Math.sin();
      z0 = Math.sin();
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var 00, 00, x0, y0, z0;
    d3_geo_centroid.point = function(, ) {
      00 = , 00 = ;
      d3_geo_centroid.point = nextPoint;
       *= d3_radians;
      var cos = Math.cos( *= d3_radians);
      x0 = cos * Math.cos();
      y0 = cos * Math.sin();
      z0 = Math.sin();
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(00, 00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(, ) {
       *= d3_radians;
      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(, ) {
        var point = rotate(, );
        if (pointVisible( = point[0],  = point[1])) listener.point(, );
      }
      function pointLine(, ) {
        var point = rotate(, );
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(, ) {
        ring.push([ ,  ]);
        var point = rotate(, );
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(, ) {
        line.push([ ,  ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - half -  : half - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half -  : half - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -, - / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var 0 = NaN, 0 = NaN, s0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(1, 1) {
        var s1 = 1 > 0 ?  : -, d = abs(1 - 0);
        if (abs(d - ) < ) {
          listener.point(0, 0 = (0 + 1) / 2 > 0 ? half : -half);
          listener.point(s0, 0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(s1, 0);
          listener.point(1, 0);
          clean = 0;
        } else if (s0 !== s1 && d >= ) {
          if (abs(0 - s0) < ) 0 -= s0 * ;
          if (abs(1 - s1) < ) 1 -= s1 * ;
          0 = d3_geo_clipAntimeridianIntersect(0, 0, 1, 1);
          listener.point(s0, 0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(s1, 0);
          clean = 0;
        }
        listener.point(0 = 1, 0 = 1);
        s0 = s1;
      },
      lineEnd: function() {
        listener.lineEnd();
        0 = 0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(0, 0, 1, 1) {
    var cos0, cos1, sin0_1 = Math.sin(0 - 1);
    return abs(sin0_1) >  ? Math.atan((Math.sin(0) * (cos1 = Math.cos(1)) * Math.sin(1) - Math.sin(1) * (cos0 = Math.cos(0)) * Math.sin(0)) / (cos0 * cos1 * sin0_1)) : (0 + 1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var ;
    if (from == null) {
       = direction * half;
      listener.point(-, );
      listener.point(0, );
      listener.point(, );
      listener.point(, 0);
      listener.point(, -);
      listener.point(0, -);
      listener.point(-, -);
      listener.point(-, 0);
      listener.point(-, );
    } else if (abs(from[0] - to[0]) > ) {
      var s = from[0] < to[0] ?  : -;
       = direction * s / 2;
      listener.point(-s, );
      listener.point(0, );
      listener.point(s, );
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin(0), cos0 = Math.cos(0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(), cos = Math.cos(), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;
        d3_geo_areaRingSum.add(Math.atan2(k * sd * Math.sin(ad), cos0 * cos + k * Math.cos(ad)));
        polarAngle += antimeridian ? d + sd *  : d;
        if (antimeridian ^ 0 >= meridian ^  >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var arc = (antimeridian ^ d >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > arc || parallel === arc && (arc[0] || arc[1])) {
            winding += antimeridian ^ d >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        0 = , sin0 = sin, cos0 = cos, point0 = point;
      }
    }
    return (polarAngle < - || polarAngle <  && d3_geo_areaRingSum < 0) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -, radius -  ]);
    function visible(, ) {
      return Math.cos() * Math.cos() > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(, ) {
          var point1 = [ ,  ], point2, v = visible(, ), c = smallRadius ? v ? 0 : code(, ) : v ? code( + ( < 0 ?  : -), ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ;
              point1[1] += ;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;
      if (1 < 0) z = 0, 0 = 1, 1 = z;
      var  = 1 - 0, polar = abs( - ) < , meridian = polar ||  < ;
      if (!polar && 1 < 0) z = 0, 0 = 1, 1 = z;
      if (meridian ? polar ? 0 + 1 > 0 ^ q[1] < (abs(q[0] - 0) <  ? 0 : 1) : 0 <= q[1] && q[1] <= 1 :  >  ^ (0 <= q[0] && q[0] <= 1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(, ) {
      var r = smallRadius ? radius :  - radius, code = 0;
      if ( < -r) code |= 1; else if ( > r) code |= 2;
      if ( < -r) code |= 4; else if ( > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) <  ? direction > 0 ? 0 : 3 : abs(p[0] - x1) <  ? direction > 0 ? 2 : 1 : abs(p[1] - y0) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator(projectAt), p = m(0, 1);
    p.parallels = function(_) {
      if (!arguments.length) return [ 0 /  * 180, 1 /  * 180 ];
      return m(0 = _[0] *  / 180, 1 = _[1] *  / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(0, 1) {
    var sin0 = Math.sin(0), n = (sin0 + Math.sin(1)) / 2, C = 1 + sin0 * (2 * n - sin0), 0 = Math.sqrt(C) / n;
    function forward(, ) {
      var  = Math.sqrt(C - 2 * n * Math.sin()) / n;
      return [  * Math.sin( *= n), 0 -  * Math.cos() ];
    }
    forward.invert = function(x, y) {
      var 0_y = 0 - y;
      return [ Math.atan2(x, 0_y) / n, d3_asin((C - (x * x + 0_y * 0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + , y + .12 * k +  ], [ x - .214 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + , y + .166 * k +  ], [ x - .115 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, );
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var 2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(, ) {
        var c = d3_geo_cartesian([ ,  ]), p = project(, );
        resampleLineTo(x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(, ) {
        linePoint(00 = , 00 = ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * 2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), 2 = Math.asin(c /= m), 2 = abs(abs(c) - 1) <  || abs(0 - 1) <  ? (0 + 1) / 2 : Math.atan2(b, a), p = project(2, 2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > 2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(2);
      maxDepth = (2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + x, y - x[1] * k ];
    }), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + x, y - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - x) / k, (y - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [  * d3_degrees,  * d3_degrees ];
       = _[0] % 360 * d3_radians;
       = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [  * d3_degrees,  * d3_degrees,  * d3_degrees ];
       = _[0] % 360 * d3_radians;
       = _[1] % 360 * d3_radians;
       = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(, , ), project);
      var center = project(, );
      x = x - center[0] * k;
      y = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(, ) {
    return [ ,  ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(, ) {
    return [  >  ?  -  :  < - ?  +  : ,  ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(, , ) {
    return  ?  ||  ? d3_geo_compose(d3_geo_rotation(), d3_geo_rotation(, )) : d3_geo_rotation() :  ||  ? d3_geo_rotation(, ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotation() {
    return function(, ) {
      return  += , [  >  ?  -  :  < - ?  +  : ,  ];
    };
  }
  function d3_geo_rotation() {
    var rotation = d3_geo_forwardRotation();
    rotation.invert = d3_geo_forwardRotation(-);
    return rotation;
  }
  function d3_geo_rotation(, ) {
    var cos = Math.cos(), sin = Math.sin(), cos = Math.cos(), sin = Math.sin();
    function rotation(, ) {
      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos + x * sin;
      return [ Math.atan2(y * cos - k * sin, x * cos - z * sin), d3_asin(k * cos + y * sin) ];
    }
    rotation.invert = function(, ) {
      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos - y * sin;
      return [ Math.atan2(y * cos + z * sin, x * cos + k * sin), d3_asin(k * cos - x * sin) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * ;
      } else {
        from = radius + direction * ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var  = (b[0] - a[0]) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(), cos = Math.cos(), sin0 = Math.sin(0), cos0 = Math.cos(0), sin1 = Math.sin(1), cos1 = Math.cos(1), t;
    return Math.atan2(Math.sqrt((t = cos1 * sin) * t + (t = cos0 * sin1 - sin0 * cos1 * cos) * t), sin0 * sin1 + cos0 * cos1 * cos);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 +  ], [ 180, 90 -  ] ]).minorExtent([ [ -180, -80 -  ], [ 180, 80 +  ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - , dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - , dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var 0, sin0, cos0;
    d3_geo_length.point = function(, ) {
      0 =  * d3_radians, sin0 = Math.sin( *= d3_radians), cos0 = Math.cos();
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(, ) {
      var sin = Math.sin( *= d3_radians), cos = Math.cos(), t = abs(( *= d3_radians) - 0), cos = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos * Math.sin(t)) * t + (t = cos0 * sin - sin0 * cos * cos) * t), sin0 * sin + cos0 * cos * cos);
      0 = , sin0 = sin, cos0 = cos;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(, ) {
      var cos = Math.cos(), cos = Math.cos(), k = scale(cos * cos);
      return [ k * cos * Math.sin(), k * Math.sin() ];
    }
    azimuthal.invert = function(x, y) {
      var  = Math.sqrt(x * x + y * y), c = angle(), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc,  * cosc), Math.asin( && y * sinc / ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(coscos) {
    return Math.sqrt(2 / (1 + coscos));
  }, function() {
    return 2 * Math.asin( / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(coscos) {
    var c = Math.acos(coscos);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(0, 1) {
    var cos0 = Math.cos(0), t = function() {
      return Math.tan( / 4 +  / 2);
    }, n = 0 === 1 ? Math.sin(0) : Math.log(cos0 / Math.cos(1)) / Math.log(t(1) / t(0)), F = cos0 * Math.pow(t(0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(, ) {
      if (F > 0) {
        if ( < -half + )  = -half + ;
      } else {
        if ( > half - )  = half - ;
      }
      var  = F / Math.pow(t(), n);
      return [  * Math.sin(n * ), F -  * Math.cos(n * ) ];
    }
    forward.invert = function(x, y) {
      var 0_y = F - y,  = d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y);
      return [ Math.atan2(x, 0_y) / n, 2 * Math.atan(Math.pow(F / , 1 / n)) - half ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(0, 1) {
    var cos0 = Math.cos(0), n = 0 === 1 ? Math.sin(0) : (cos0 - Math.cos(1)) / (1 - 0), G = cos0 / n + 0;
    if (abs(n) < ) return d3_geo_equirectangular;
    function forward(, ) {
      var  = G - ;
      return [  * Math.sin(n * ), G -  * Math.cos(n * ) ];
    }
    forward.invert = function(x, y) {
      var 0_y = G - y;
      return [ Math.atan2(x, 0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(coscos) {
    return 1 / coscos;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(, ) {
    return [ , Math.log(Math.tan( / 4 +  / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - half ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k =  * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(coscos) {
    return 1 / (1 + coscos);
  }, function() {
    return 2 * Math.atan();
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(, ) {
    return [ Math.log(Math.tan( / 4 +  / 2)), - ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - half ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) <  && abs(y - lArc.circle.cy) < ) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) <  && abs(y - rArc.circle.cy) < ) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) >  || abs(y3 - y2) > ) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) <  && y1 - y3 >  ? {
            x: x0,
            y: abs(x2 - x0) <  ? y2 : y1
          } : abs(y3 - y1) <  && x1 - x3 >  ? {
            x: abs(y2 - y1) <  ? x2 : x1,
            y: y1
          } : abs(x3 - x1) <  && y3 - y0 >  ? {
            x: x1,
            y: abs(x2 - x1) <  ? y2 : y0
          } : abs(y3 - y0) <  && x3 - x0 >  ? {
            x: abs(y2 - y0) <  ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) <  && abs(e.a.y - e.b.y) < ) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ) * ,
          y: Math.round(fy(d, i) / ) * ,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - point[0], dy = y - point[1], distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * half);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p /  * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransform(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = ( - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, m = candidates.length, x;
        while (++j < m) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(, ) {
      var n = arguments.length;
      if (n < 2)  = 1;
      if (n < 1)  = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return  +  * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
      Math.floor), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= ) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
        if (x1 != null) {
          var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - half;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half, a1 = endAngle.call(self, subgroup, i) - half;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > ) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - half;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / );
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, active;
      if ((lock = this[ns]) && (active = lock[lock.active])) {
        if (--lock.count) {
          delete lock[lock.active];
          lock.active += .5;
        } else {
          delete this[ns];
        }
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3_selectionRoot.transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
      d3.timer(function(elapsed) {
        var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
        timer.t = delay + time;
        if (delay <= elapsed) return start(elapsed - delay);
        timer.c = start;
        function start(elapsed) {
          if (lock.active > id) return stop();
          var active = lock[lock.active];
          if (active) {
            --lock.count;
            delete lock[lock.active];
            active.event && active.event.interrupt.call(node, node.__data__, active.index);
          }
          lock.active = id;
          transition.event && transition.event.start.call(node, node.__data__, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, node.__data__, i)) {
              tweened.push(value);
            }
          });
          ease = transition.ease;
          duration = transition.duration;
          d3.timer(function() {
            timer.c = tick(elapsed || 1) ? d3_true : tick;
            return 1;
          }, 0, time);
        }
        function tick(elapsed) {
          if (lock.active !== id) return 1;
          var t = elapsed / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            transition.event && transition.event.end.call(node, node.__data__, i);
            return stop();
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node[ns];
          return 1;
        }
      }, 0, time);
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ), tickExit = d3.transition(tick.exit()).style("opacity", ).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (typeof define === "function" && define.amd) define(d3); else if (typeof module === "object" && module.exports) module.exports = d3;
  this.d3 = d3;
}();
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/d3/d3.js","/node_modules/d3")
},{"IrXUsu":44,"buffer":41}],41:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/index.js","/node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer")
},{"IrXUsu":44,"base64-js":42,"buffer":41,"ieee754":43}],42:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","/node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib")
},{"IrXUsu":44,"buffer":41}],43:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","/node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754")
},{"IrXUsu":44,"buffer":41}],44:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/browserify/node_modules/process/browser.js","/node_modules/gulp-browserify/node_modules/browserify/node_modules/process")
},{"IrXUsu":44,"buffer":41}],45:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var mgrs = require('mgrs');

function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  }else if(typeof x === 'object'){
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  }
  else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }
  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point.fromMGRS = function(mgrsStr) {
  return new Point(mgrs.toPoint(mgrsStr));
};
Point.prototype.toMGRS = function(accuracy) {
  return mgrs.forward([this.x, this.y], accuracy);
};
module.exports = Point;
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/Point.js","/node_modules/proj4/lib")
},{"IrXUsu":44,"buffer":41,"mgrs":111}],46:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var parseCode = require("./parseCode");
var extend = require('./extend');
var projections = require('./projections');
var deriveConstants = require('./deriveConstants');

function Projection(srsCode,callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error){
    if(error){
      throw error;
    }
  };
  var json = parseCode(srsCode);
  if(typeof json !== 'object'){
    callback(srsCode);
    return;
  }
  var modifiedJSON = deriveConstants(json);
  var ourProj = Projection.projections.get(modifiedJSON.projName);
  if(ourProj){
    extend(this, modifiedJSON);
    extend(this, ourProj);
    this.init();
    callback(null, this);
  }else{
    callback(srsCode);
  }
}
Projection.projections = projections;
Projection.projections.start();
module.exports = Projection;

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/Proj.js","/node_modules/proj4/lib")
},{"./deriveConstants":76,"./extend":77,"./parseCode":81,"./projections":83,"IrXUsu":44,"buffer":41}],47:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(crs, denorm, point) {
  var xin = point.x,
    yin = point.y,
    zin = point.z || 0.0;
  var v, t, i;
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }
    if (i === 0) {
      v = xin;
      t = 'x';
    }
    else if (i === 1) {
      v = yin;
      t = 'y';
    }
    else {
      v = zin;
      t = 'z';
    }
    switch (crs.axis[i]) {
    case 'e':
      point[t] = v;
      break;
    case 'w':
      point[t] = -v;
      break;
    case 'n':
      point[t] = v;
      break;
    case 's':
      point[t] = -v;
      break;
    case 'u':
      if (point[t] !== undefined) {
        point.z = v;
      }
      break;
    case 'd':
      if (point[t] !== undefined) {
        point.z = -v;
      }
      break;
    default:
      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
      return null;
    }
  }
  return point;
};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/adjust_axis.js","/node_modules/proj4/lib")
},{"IrXUsu":44,"buffer":41}],48:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var HALF_PI = Math.PI/2;
var sign = require('./sign');

module.exports = function(x) {
  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/adjust_lat.js","/node_modules/proj4/lib/common")
},{"./sign":65,"IrXUsu":44,"buffer":41}],49:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;
var sign = require('./sign');

module.exports = function(x) {
  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/adjust_lon.js","/node_modules/proj4/lib/common")
},{"./sign":65,"IrXUsu":44,"buffer":41}],50:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(x) {
  if (Math.abs(x) > 1) {
    x = (x > 1) ? 1 : -1;
  }
  return Math.asin(x);
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/asinz.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],51:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(x) {
  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/e0fn.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],52:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(x) {
  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/e1fn.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],53:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(x) {
  return (0.05859375 * x * x * (1 + 0.75 * x));
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/e2fn.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],54:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(x) {
  return (x * x * x * (35 / 3072));
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/e3fn.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],55:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/gN.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],56:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;

  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
  return NaN;
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/imlfn.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],57:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var HALF_PI = Math.PI/2;

module.exports = function(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return (-1 * HALF_PI);
    }
    else {
      return HALF_PI;
    }
  }
  //var phi = 0.5* q/(1-eccent*eccent);
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
  return NaN;
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/iqsfnz.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],58:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(e0, e1, e2, e3, phi) {
  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/mlfn.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],59:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / (Math.sqrt(1 - con * con));
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/msfnz.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],60:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var HALF_PI = Math.PI/2;
module.exports = function(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }
  //console.log("phi2z has NoConvergence");
  return -9999;
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/phi2z.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],61:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;

module.exports = function(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/pj_enfn.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],62:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var pj_mlfn = require("./pj_mlfn");
var EPSLN = 1.0e-10;
var MAX_ITER = 20;
module.exports = function(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;
    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  //..reportError("cass:pj_inv_mlfn: Convergence error");
  return phi;
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/pj_inv_mlfn.js","/node_modules/proj4/lib/common")
},{"./pj_mlfn":63,"IrXUsu":44,"buffer":41}],63:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/pj_mlfn.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],64:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(eccent, sinphi) {
  var con;
  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
  }
  else {
    return (2 * sinphi);
  }
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/qsfnz.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],65:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(x) {
  return x<0 ? -1 : 1;
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/sign.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],66:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(esinp, exp) {
  return (Math.pow((1 - esinp) / (1 + esinp), exp));
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/srat.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],67:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function (array){
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length>2) {
    out.z = array[2];
  }
  if (array.length>3) {
    out.m = array[3];
  }
  return out;
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/toPoint.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],68:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var HALF_PI = Math.PI/2;

module.exports = function(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow(((1 - con) / (1 + con)), com);
  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/common/tsfnz.js","/node_modules/proj4/lib/common")
},{"IrXUsu":44,"buffer":41}],69:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
exports.potsdam = {
  towgs84: "606.0,23.0,413.0",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
exports.hermannskogel = {
  towgs84: "653.0,-212.0,449.0",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};
exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};
exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};
exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/constants/Datum.js","/node_modules/proj4/lib/constants")
},{"IrXUsu":44,"buffer":41}],70:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};
exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};
exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};
exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};
exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};
exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};
exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};
exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};
exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};
exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};
exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};
exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/constants/Ellipsoid.js","/node_modules/proj4/lib/constants")
},{"IrXUsu":44,"buffer":41}],71:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.greenwich = 0.0; //"0dE",
exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
exports.paris = 2.337229166667; //"2d20'14.025\"E",
exports.bogota = -74.080916666667; //"74d04'51.3\"W",
exports.madrid = -3.687938888889; //"3d41'16.58\"W",
exports.rome = 12.452333333333; //"12d27'8.4\"E",
exports.bern = 7.439583333333; //"7d26'22.5\"E",
exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
exports.ferro = -17.666666666667; //"17d40'W",
exports.brussels = 4.367975; //"4d22'4.71\"E",
exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
exports.athens = 23.7163375; //"23d42'58.815\"E",
exports.oslo = 10.722916666667; //"10d43'22.5\"E"
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/constants/PrimeMeridian.js","/node_modules/proj4/lib/constants")
},{"IrXUsu":44,"buffer":41}],72:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var proj = require('./Proj');
var transform = require('./transform');
var wgs84 = proj('WGS84');

function transformer(from, to, coords) {
  var transformedArray;
  if (Array.isArray(coords)) {
    transformedArray = transform(from, to, coords);
    if (coords.length === 3) {
      return [transformedArray.x, transformedArray.y, transformedArray.z];
    }
    else {
      return [transformedArray.x, transformedArray.y];
    }
  }
  else {
    return transform(from, to, coords);
  }
}

function checkProj(item) {
  if (item instanceof proj) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return proj(item);
}
function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  }
  else {
    obj = {
      forward: function(coords) {
        return transformer(fromProj, toProj, coords);
      },
      inverse: function(coords) {
        return transformer(toProj, fromProj, coords);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
module.exports = proj4;
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/core.js","/node_modules/proj4/lib")
},{"./Proj":46,"./transform":109,"IrXUsu":44,"buffer":41}],73:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var HALF_PI = Math.PI/2;
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4; // WGS84 or equivalent
var PJD_NODATUM = 5; // WGS84 or equivalent
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var AD_C = 1.0026000;
var COS_67P5 = 0.38268343236508977;
var datum = function(proj) {
  if (!(this instanceof datum)) {
    return new datum(proj);
  }
  this.datum_type = PJD_WGS84; //default setting
  if (!proj) {
    return;
  }
  if (proj.datumCode && proj.datumCode === 'none') {
    this.datum_type = PJD_NODATUM;
  }
  if (proj.datum_params) {
    for (var i = 0; i < proj.datum_params.length; i++) {
      proj.datum_params[i] = parseFloat(proj.datum_params[i]);
    }
    if (proj.datum_params[0] !== 0 || proj.datum_params[1] !== 0 || proj.datum_params[2] !== 0) {
      this.datum_type = PJD_3PARAM;
    }
    if (proj.datum_params.length > 3) {
      if (proj.datum_params[3] !== 0 || proj.datum_params[4] !== 0 || proj.datum_params[5] !== 0 || proj.datum_params[6] !== 0) {
        this.datum_type = PJD_7PARAM;
        proj.datum_params[3] *= SEC_TO_RAD;
        proj.datum_params[4] *= SEC_TO_RAD;
        proj.datum_params[5] *= SEC_TO_RAD;
        proj.datum_params[6] = (proj.datum_params[6] / 1000000.0) + 1.0;
      }
    }
  }
  // DGR 2011-03-21 : nadgrids support
  this.datum_type = proj.grids ? PJD_GRIDSHIFT : this.datum_type;

  this.a = proj.a; //datum object also uses these values
  this.b = proj.b;
  this.es = proj.es;
  this.ep2 = proj.ep2;
  this.datum_params = proj.datum_params;
  if (this.datum_type === PJD_GRIDSHIFT) {
    this.grids = proj.grids;
  }
};
datum.prototype = {


  /****************************************************************/
  // cs_compare_datums()
  //   Returns TRUE if the two datums match, otherwise FALSE.
  compare_datums: function(dest) {
    if (this.datum_type !== dest.datum_type) {
      return false; // false, datums are not equal
    }
    else if (this.a !== dest.a || Math.abs(this.es - dest.es) > 0.000000000050) {
      // the tolerence for es is to ensure that GRS80 and WGS84
      // are considered identical
      return false;
    }
    else if (this.datum_type === PJD_3PARAM) {
      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2]);
    }
    else if (this.datum_type === PJD_7PARAM) {
      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2] && this.datum_params[3] === dest.datum_params[3] && this.datum_params[4] === dest.datum_params[4] && this.datum_params[5] === dest.datum_params[5] && this.datum_params[6] === dest.datum_params[6]);
    }
    else if (this.datum_type === PJD_GRIDSHIFT || dest.datum_type === PJD_GRIDSHIFT) {
      //alert("ERROR: Grid shift transformations are not implemented.");
      //return false
      //DGR 2012-07-29 lazy ...
      return this.nadgrids === dest.nadgrids;
    }
    else {
      return true; // datums are equal
    }
  }, // cs_compare_datums()

  /*
   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
   * according to the current ellipsoid parameters.
   *
   *    Latitude  : Geodetic latitude in radians                     (input)
   *    Longitude : Geodetic longitude in radians                    (input)
   *    Height    : Geodetic height, in meters                       (input)
   *    X         : Calculated Geocentric X coordinate, in meters    (output)
   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
   *
   */
  geodetic_to_geocentric: function(p) {
    var Longitude = p.x;
    var Latitude = p.y;
    var Height = p.z ? p.z : 0; //Z value not always supplied
    var X; // output
    var Y;
    var Z;

    var Error_Code = 0; //  GEOCENT_NO_ERROR;
    var Rn; /*  Earth radius at location  */
    var Sin_Lat; /*  Math.sin(Latitude)  */
    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
    var Cos_Lat; /*  Math.cos(Latitude)  */

    /*
     ** Don't blow up if Latitude is just a little out of the value
     ** range as it may just be a rounding issue.  Also removed longitude
     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
     */
    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
      Latitude = -HALF_PI;
    }
    else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
      Latitude = HALF_PI;
    }
    else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {
      /* Latitude out of range */
      //..reportError('geocent:lat out of range:' + Latitude);
      return null;
    }

    if (Longitude > Math.PI) {
      Longitude -= (2 * Math.PI);
    }
    Sin_Lat = Math.sin(Latitude);
    Cos_Lat = Math.cos(Latitude);
    Sin2_Lat = Sin_Lat * Sin_Lat;
    Rn = this.a / (Math.sqrt(1.0e0 - this.es * Sin2_Lat));
    X = (Rn + Height) * Cos_Lat * Math.cos(Longitude);
    Y = (Rn + Height) * Cos_Lat * Math.sin(Longitude);
    Z = ((Rn * (1 - this.es)) + Height) * Sin_Lat;

    p.x = X;
    p.y = Y;
    p.z = Z;
    return Error_Code;
  }, // cs_geodetic_to_geocentric()


  geocentric_to_geodetic: function(p) {
    /* local defintions and variables */
    /* end-criterium of loop, accuracy of sin(Latitude) */
    var genau = 1e-12;
    var genau2 = (genau * genau);
    var maxiter = 30;

    var P; /* distance between semi-minor axis and location */
    var RR; /* distance between center and location */
    var CT; /* sin of geocentric latitude */
    var ST; /* cos of geocentric latitude */
    var RX;
    var RK;
    var RN; /* Earth radius at location */
    var CPHI0; /* cos of start or old geodetic latitude in iterations */
    var SPHI0; /* sin of start or old geodetic latitude in iterations */
    var CPHI; /* cos of searched geodetic latitude */
    var SPHI; /* sin of searched geodetic latitude */
    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
    var At_Pole; /* indicates location is in polar region */
    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0.0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;

    At_Pole = false;
    P = Math.sqrt(X * X + Y * Y);
    RR = Math.sqrt(X * X + Y * Y + Z * Z);

    /*      special cases for latitude and longitude */
    if (P / this.a < genau) {

      /*  special case, if P=0. (X=0., Y=0.) */
      At_Pole = true;
      Longitude = 0.0;

      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
      if (RR / this.a < genau) {
        Latitude = HALF_PI;
        Height = -this.b;
        return;
      }
    }
    else {
      /*  ellipsoidal (geodetic) longitude
       *  interval: -PI < Longitude <= +PI */
      Longitude = Math.atan2(Y, X);
    }

    /* --------------------------------------------------------------
     * Following iterative algorithm was developped by
     * "Institut for Erdmessung", University of Hannover, July 1988.
     * Internet: www.ife.uni-hannover.de
     * Iterative computation of CPHI,SPHI and Height.
     * Iteration of CPHI and SPHI to 10**-12 radian resp.
     * 2*10**-7 arcsec.
     * --------------------------------------------------------------
     */
    CT = Z / RR;
    ST = P / RR;
    RX = 1.0 / Math.sqrt(1.0 - this.es * (2.0 - this.es) * ST * ST);
    CPHI0 = ST * (1.0 - this.es) * RX;
    SPHI0 = CT * RX;
    iter = 0;

    /* loop to find sin(Latitude) resp. Latitude
     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
    do {
      iter++;
      RN = this.a / Math.sqrt(1.0 - this.es * SPHI0 * SPHI0);

      /*  ellipsoidal (geodetic) height */
      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - this.es * SPHI0 * SPHI0);

      RK = this.es * RN / (RN + Height);
      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
      CPHI = ST * (1.0 - RK) * RX;
      SPHI = CT * RX;
      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
      CPHI0 = CPHI;
      SPHI0 = SPHI;
    }
    while (SDPHI * SDPHI > genau2 && iter < maxiter);

    /*      ellipsoidal (geodetic) latitude */
    Latitude = Math.atan(SPHI / Math.abs(CPHI));

    p.x = Longitude;
    p.y = Latitude;
    p.z = Height;
    return p;
  }, // cs_geocentric_to_geodetic()

  /** Convert_Geocentric_To_Geodetic
   * The method used here is derived from 'An Improved Algorithm for
   * Geocentric to Geodetic Coordinate Conversion', by Ralph Toms, Feb 1996
   */
  geocentric_to_geodetic_noniter: function(p) {
    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;

    var W; /* distance from Z axis */
    var W2; /* square of distance from Z axis */
    var T0; /* initial estimate of vertical component */
    var T1; /* corrected estimate of vertical component */
    var S0; /* initial estimate of horizontal component */
    var S1; /* corrected estimate of horizontal component */
    var Sin_B0; /* Math.sin(B0), B0 is estimate of Bowring aux variable */
    var Sin3_B0; /* cube of Math.sin(B0) */
    var Cos_B0; /* Math.cos(B0) */
    var Sin_p1; /* Math.sin(phi1), phi1 is estimated latitude */
    var Cos_p1; /* Math.cos(phi1) */
    var Rn; /* Earth radius at location */
    var Sum; /* numerator of Math.cos(phi1) */
    var At_Pole; /* indicates location is in polar region */

    X = parseFloat(X); // cast from string to float
    Y = parseFloat(Y);
    Z = parseFloat(Z);

    At_Pole = false;
    if (X !== 0.0) {
      Longitude = Math.atan2(Y, X);
    }
    else {
      if (Y > 0) {
        Longitude = HALF_PI;
      }
      else if (Y < 0) {
        Longitude = -HALF_PI;
      }
      else {
        At_Pole = true;
        Longitude = 0.0;
        if (Z > 0.0) { /* north pole */
          Latitude = HALF_PI;
        }
        else if (Z < 0.0) { /* south pole */
          Latitude = -HALF_PI;
        }
        else { /* center of earth */
          Latitude = HALF_PI;
          Height = -this.b;
          return;
        }
      }
    }
    W2 = X * X + Y * Y;
    W = Math.sqrt(W2);
    T0 = Z * AD_C;
    S0 = Math.sqrt(T0 * T0 + W2);
    Sin_B0 = T0 / S0;
    Cos_B0 = W / S0;
    Sin3_B0 = Sin_B0 * Sin_B0 * Sin_B0;
    T1 = Z + this.b * this.ep2 * Sin3_B0;
    Sum = W - this.a * this.es * Cos_B0 * Cos_B0 * Cos_B0;
    S1 = Math.sqrt(T1 * T1 + Sum * Sum);
    Sin_p1 = T1 / S1;
    Cos_p1 = Sum / S1;
    Rn = this.a / Math.sqrt(1.0 - this.es * Sin_p1 * Sin_p1);
    if (Cos_p1 >= COS_67P5) {
      Height = W / Cos_p1 - Rn;
    }
    else if (Cos_p1 <= -COS_67P5) {
      Height = W / -Cos_p1 - Rn;
    }
    else {
      Height = Z / Sin_p1 + Rn * (this.es - 1.0);
    }
    if (At_Pole === false) {
      Latitude = Math.atan(Sin_p1 / Cos_p1);
    }

    p.x = Longitude;
    p.y = Latitude;
    p.z = Height;
    return p;
  }, // geocentric_to_geodetic_noniter()

  /****************************************************************/
  // pj_geocentic_to_wgs84( p )
  //  p = point to transform in geocentric coordinates (x,y,z)
  geocentric_to_wgs84: function(p) {

    if (this.datum_type === PJD_3PARAM) {
      // if( x[io] === HUGE_VAL )
      //    continue;
      p.x += this.datum_params[0];
      p.y += this.datum_params[1];
      p.z += this.datum_params[2];

    }
    else if (this.datum_type === PJD_7PARAM) {
      var Dx_BF = this.datum_params[0];
      var Dy_BF = this.datum_params[1];
      var Dz_BF = this.datum_params[2];
      var Rx_BF = this.datum_params[3];
      var Ry_BF = this.datum_params[4];
      var Rz_BF = this.datum_params[5];
      var M_BF = this.datum_params[6];
      // if( x[io] === HUGE_VAL )
      //    continue;
      var x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF;
      var y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF;
      var z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;
      p.x = x_out;
      p.y = y_out;
      p.z = z_out;
    }
  }, // cs_geocentric_to_wgs84

  /****************************************************************/
  // pj_geocentic_from_wgs84()
  //  coordinate system definition,
  //  point to transform in geocentric coordinates (x,y,z)
  geocentric_from_wgs84: function(p) {

    if (this.datum_type === PJD_3PARAM) {
      //if( x[io] === HUGE_VAL )
      //    continue;
      p.x -= this.datum_params[0];
      p.y -= this.datum_params[1];
      p.z -= this.datum_params[2];

    }
    else if (this.datum_type === PJD_7PARAM) {
      var Dx_BF = this.datum_params[0];
      var Dy_BF = this.datum_params[1];
      var Dz_BF = this.datum_params[2];
      var Rx_BF = this.datum_params[3];
      var Ry_BF = this.datum_params[4];
      var Rz_BF = this.datum_params[5];
      var M_BF = this.datum_params[6];
      var x_tmp = (p.x - Dx_BF) / M_BF;
      var y_tmp = (p.y - Dy_BF) / M_BF;
      var z_tmp = (p.z - Dz_BF) / M_BF;
      //if( x[io] === HUGE_VAL )
      //    continue;

      p.x = x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp;
      p.y = -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp;
      p.z = Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp;
    } //cs_geocentric_from_wgs84()
  }
};

/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
module.exports = datum;

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/datum.js","/node_modules/proj4/lib")
},{"IrXUsu":44,"buffer":41}],74:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_NODATUM = 5; // WGS84 or equivalent
var SRS_WGS84_SEMIMAJOR = 6378137; // only used in grid shift transforms
var SRS_WGS84_ESQUARED = 0.006694379990141316; //DGR: 2012-07-29
module.exports = function(source, dest, point) {
  var wp, i, l;

  function checkParams(fallback) {
    return (fallback === PJD_3PARAM || fallback === PJD_7PARAM);
  }
  // Short cut if the datums are identical.
  if (source.compare_datums(dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  }

  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }

  //DGR: 2012-07-29 : add nadgrids support (begin)
  var src_a = source.a;
  var src_es = source.es;

  var dst_a = dest.a;
  var dst_es = dest.es;

  var fallback = source.datum_type;
  // If this datum requires grid shifts, then apply it to geodetic coordinates.
  if (fallback === PJD_GRIDSHIFT) {
    if (this.apply_gridshift(source, 0, point) === 0) {
      source.a = SRS_WGS84_SEMIMAJOR;
      source.es = SRS_WGS84_ESQUARED;
    }
    else {
      // try 3 or 7 params transformation or nothing ?
      if (!source.datum_params) {
        source.a = src_a;
        source.es = source.es;
        return point;
      }
      wp = 1;
      for (i = 0, l = source.datum_params.length; i < l; i++) {
        wp *= source.datum_params[i];
      }
      if (wp === 0) {
        source.a = src_a;
        source.es = source.es;
        return point;
      }
      if (source.datum_params.length > 3) {
        fallback = PJD_7PARAM;
      }
      else {
        fallback = PJD_3PARAM;
      }
    }
  }
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest.a = SRS_WGS84_SEMIMAJOR;
    dest.es = SRS_WGS84_ESQUARED;
  }
  // Do we need to go through geocentric coordinates?
  if (source.es !== dest.es || source.a !== dest.a || checkParams(fallback) || checkParams(dest.datum_type)) {
    //DGR: 2012-07-29 : add nadgrids support (end)
    // Convert to geocentric coordinates.
    source.geodetic_to_geocentric(point);
    // CHECK_RETURN;
    // Convert between datums
    if (checkParams(source.datum_type)) {
      source.geocentric_to_wgs84(point);
      // CHECK_RETURN;
    }
    if (checkParams(dest.datum_type)) {
      dest.geocentric_from_wgs84(point);
      // CHECK_RETURN;
    }
    // Convert back to geodetic coordinates
    dest.geocentric_to_geodetic(point);
    // CHECK_RETURN;
  }
  // Apply grid shift to destination if required
  if (dest.datum_type === PJD_GRIDSHIFT) {
    this.apply_gridshift(dest, 1, point);
    // CHECK_RETURN;
  }

  source.a = src_a;
  source.es = src_es;
  dest.a = dst_a;
  dest.es = dst_es;

  return point;
};


}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/datum_transform.js","/node_modules/proj4/lib")
},{"IrXUsu":44,"buffer":41}],75:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var globals = require('./global');
var parseProj = require('./projString');
var wkt = require('./wkt');

function defs(name) {
  /*global console*/
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = parseProj(arguments[1]);
      }
      else {
        defs[name] = wkt(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  }
  else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        }
        else {
          defs(v);
        }
      });
    }
    else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    }
    else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    }
    else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    }
    else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    }
    else {
      console.log(name);
    }
    return;
  }


}
globals(defs);
module.exports = defs;

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/defs.js","/node_modules/proj4/lib")
},{"./global":78,"./projString":82,"./wkt":110,"IrXUsu":44,"buffer":41}],76:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Datum = require('./constants/Datum');
var Ellipsoid = require('./constants/Ellipsoid');
var extend = require('./extend');
var datum = require('./datum');
var EPSLN = 1.0e-10;
// ellipoid pj_set_ell.c
var SIXTH = 0.1666666666666666667;
/* 1/6 */
var RA4 = 0.04722222222222222222;
/* 17/360 */
var RA6 = 0.02215608465608465608;
module.exports = function(json) {
  // DGR 2011-03-20 : nagrids -> nadgrids
  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = Datum[json.datumCode];
    if (datumDef) {
      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  if (!json.a) { // do we have an ellipsoid?
    var ellipse = Ellipsoid[json.ellps] ? Ellipsoid[json.ellps] : Ellipsoid.WGS84;
    extend(json, ellipse);
  }
  if (json.rf && !json.b) {
    json.b = (1.0 - 1.0 / json.rf) * json.a;
  }
  if (json.rf === 0 || Math.abs(json.a - json.b) < EPSLN) {
    json.sphere = true;
    json.b = json.a;
  }
  json.a2 = json.a * json.a; // used in geocentric
  json.b2 = json.b * json.b; // used in geocentric
  json.es = (json.a2 - json.b2) / json.a2; // e ^ 2
  json.e = Math.sqrt(json.es); // eccentricity
  if (json.R_A) {
    json.a *= 1 - json.es * (SIXTH + json.es * (RA4 + json.es * RA6));
    json.a2 = json.a * json.a;
    json.b2 = json.b * json.b;
    json.es = 0;
  }
  json.ep2 = (json.a2 - json.b2) / json.b2; // used in geocentric
  if (!json.k0) {
    json.k0 = 1.0; //default value
  }
  //DGR 2010-11-12: axis
  if (!json.axis) {
    json.axis = "enu";
  }

  if (!json.datum) {
    json.datum = datum(json);
  }
  return json;
};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/deriveConstants.js","/node_modules/proj4/lib")
},{"./constants/Datum":69,"./constants/Ellipsoid":70,"./datum":73,"./extend":77,"IrXUsu":44,"buffer":41}],77:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== undefined) {
      destination[property] = value;
    }
  }
  return destination;
};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/extend.js","/node_modules/proj4/lib")
},{"IrXUsu":44,"buffer":41}],78:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function(defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/global.js","/node_modules/proj4/lib")
},{"IrXUsu":44,"buffer":41}],79:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var projs = [
  require('./projections/tmerc'),
  require('./projections/utm'),
  require('./projections/sterea'),
  require('./projections/stere'),
  require('./projections/somerc'),
  require('./projections/omerc'),
  require('./projections/lcc'),
  require('./projections/krovak'),
  require('./projections/cass'),
  require('./projections/laea'),
  require('./projections/aea'),
  require('./projections/gnom'),
  require('./projections/cea'),
  require('./projections/eqc'),
  require('./projections/poly'),
  require('./projections/nzmg'),
  require('./projections/mill'),
  require('./projections/sinu'),
  require('./projections/moll'),
  require('./projections/eqdc'),
  require('./projections/vandg'),
  require('./projections/aeqd')
];
module.exports = function(proj4){
  projs.forEach(function(proj){
    proj4.Proj.projections.add(proj);
  });
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/includedProjections.js","/node_modules/proj4/lib")
},{"./projections/aea":84,"./projections/aeqd":85,"./projections/cass":86,"./projections/cea":87,"./projections/eqc":88,"./projections/eqdc":89,"./projections/gnom":91,"./projections/krovak":92,"./projections/laea":93,"./projections/lcc":94,"./projections/mill":97,"./projections/moll":98,"./projections/nzmg":99,"./projections/omerc":100,"./projections/poly":101,"./projections/sinu":102,"./projections/somerc":103,"./projections/stere":104,"./projections/sterea":105,"./projections/tmerc":106,"./projections/utm":107,"./projections/vandg":108,"IrXUsu":44,"buffer":41}],80:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var proj4 = require('./core');
proj4.defaultDatum = 'WGS84'; //default datum
proj4.Proj = require('./Proj');
proj4.WGS84 = new proj4.Proj('WGS84');
proj4.Point = require('./Point');
proj4.toPoint = require("./common/toPoint");
proj4.defs = require('./defs');
proj4.transform = require('./transform');
proj4.mgrs = require('mgrs');
proj4.version = require('../package.json').version;
require('./includedProjections')(proj4);
module.exports = proj4;
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/index.js","/node_modules/proj4/lib")
},{"../package.json":112,"./Point":45,"./Proj":46,"./common/toPoint":67,"./core":72,"./defs":75,"./includedProjections":79,"./transform":109,"IrXUsu":44,"buffer":41,"mgrs":111}],81:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var defs = require('./defs');
var wkt = require('./wkt');
var projStr = require('./projString');
function testObj(code){
  return typeof code === 'string';
}
function testDef(code){
  return code in defs;
}
function testWKT(code){
  var codeWords = ['GEOGCS','GEOCCS','PROJCS','LOCAL_CS'];
  return codeWords.reduce(function(a,b){
    return a+1+code.indexOf(b);
  },0);
}
function testProj(code){
  return code[0] === '+';
}
function parse(code){
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return defs[code];
    }
    else if (testWKT(code)) {
      return wkt(code);
    }
    else if (testProj(code)) {
      return projStr(code);
    }
  }else{
    return code;
  }
}

module.exports = parse;
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/parseCode.js","/node_modules/proj4/lib")
},{"./defs":75,"./projString":82,"./wkt":110,"IrXUsu":44,"buffer":41}],82:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var D2R = 0.01745329251994329577;
var PrimeMeridian = require('./constants/PrimeMeridian');

module.exports = function(defData) {
  var self = {};
  var paramObj = {};
  defData.split("+").map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).forEach(function(a) {
    var split = a.split("=");
    split.push(true);
    paramObj[split[0].toLowerCase()] = split[1];
  });
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self.lat0 = v * D2R;
    },
    lat_1: function(v) {
      self.lat1 = v * D2R;
    },
    lat_2: function(v) {
      self.lat2 = v * D2R;
    },
    lat_ts: function(v) {
      self.lat_ts = v * D2R;
    },
    lon_0: function(v) {
      self.long0 = v * D2R;
    },
    lon_1: function(v) {
      self.long1 = v * D2R;
    },
    lon_2: function(v) {
      self.long2 = v * D2R;
    },
    alpha: function(v) {
      self.alpha = parseFloat(v) * D2R;
    },
    lonc: function(v) {
      self.longc = v * D2R;
    },
    x_0: function(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self.k0 = parseFloat(v);
    },
    k: function(v) {
      self.k0 = parseFloat(v);
    },
    a: function(v) {
      self.a = parseFloat(v);
    },
    b: function(v) {
      self.b = parseFloat(v);
    },
    r_a: function() {
      self.R_A = true;
    },
    zone: function(v) {
      self.zone = parseInt(v, 10);
    },
    south: function() {
      self.utmSouth = true;
    },
    towgs84: function(v) {
      self.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self.to_meter = parseFloat(v);
    },
    from_greenwich: function(v) {
      self.from_greenwich = v * D2R;
    },
    pm: function(v) {
      self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;
    },
    nadgrids: function(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      }
      else {
        self.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      }
      else {
        self[paramOutname] = paramVal;
      }
    }
    else {
      self[paramName] = paramVal;
    }
  }
  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
    self.datumCode = self.datumCode.toLowerCase();
  }
  return self;
};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projString.js","/node_modules/proj4/lib")
},{"./constants/PrimeMeridian":71,"IrXUsu":44,"buffer":41}],83:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var projs = [
  require('./projections/merc'),
  require('./projections/longlat')
];
var names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names[n.toLowerCase()] = len;
  });
  return this;
}

exports.add = add;

exports.get = function(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
    return projStore[names[n]];
  }
};
exports.start = function() {
  projs.forEach(add);
};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections.js","/node_modules/proj4/lib")
},{"./projections/longlat":95,"./projections/merc":96,"IrXUsu":44,"buffer":41}],84:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var EPSLN = 1.0e-10;
var msfnz = require('../common/msfnz');
var qsfnz = require('../common/qsfnz');
var adjust_lon = require('../common/adjust_lon');
var asinz = require('../common/asinz');
exports.init = function() {

  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);

  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  }
  else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
};

/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/
exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);

  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
};


exports.inverse = function(p) {
  var rh1, qs, con, theta, lon, lat;

  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  }
  else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = adjust_lon(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
};

/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/
exports.phi1z = function(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }

  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
};
exports.names = ["Albers_Conic_Equal_Area", "Albers", "aea"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/aea.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/asinz":50,"../common/msfnz":59,"../common/qsfnz":64,"IrXUsu":44,"buffer":41}],85:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var adjust_lon = require('../common/adjust_lon');
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var mlfn = require('../common/mlfn');
var e0fn = require('../common/e0fn');
var e1fn = require('../common/e1fn');
var e2fn = require('../common/e2fn');
var e3fn = require('../common/e3fn');
var gN = require('../common/gN');
var asinz = require('../common/asinz');
var imlfn = require('../common/imlfn');
exports.init = function() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
};

exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    }
    else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c / Math.sin(c);
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    }
    else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }


};

exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > (2 * HALF_PI * this.a)) {
      return;
    }
    z = rh / this.a;

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    }
    else {
      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
      }
      else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;

      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }

};
exports.names = ["Azimuthal_Equidistant", "aeqd"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/aeqd.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/asinz":50,"../common/e0fn":51,"../common/e1fn":52,"../common/e2fn":53,"../common/e3fn":54,"../common/gN":55,"../common/imlfn":56,"../common/mlfn":58,"IrXUsu":44,"buffer":41}],86:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var mlfn = require('../common/mlfn');
var e0fn = require('../common/e0fn');
var e1fn = require('../common/e1fn');
var e2fn = require('../common/e2fn');
var e3fn = require('../common/e3fn');
var gN = require('../common/gN');
var adjust_lon = require('../common/adjust_lon');
var adjust_lat = require('../common/adjust_lat');
var imlfn = require('../common/imlfn');
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
exports.init = function() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
};



/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
exports.forward = function(p) {

  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  }
  else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
};

/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  }
  else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = gN(this.a, this.e, Math.sin(phi1));

    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

  }

  p.x = adjust_lon(lam + this.long0);
  p.y = adjust_lat(phi);
  return p;

};
exports.names = ["Cassini", "Cassini_Soldner", "cass"];
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/cass.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lat":48,"../common/adjust_lon":49,"../common/e0fn":51,"../common/e1fn":52,"../common/e2fn":53,"../common/e3fn":54,"../common/gN":55,"../common/imlfn":56,"../common/mlfn":58,"IrXUsu":44,"buffer":41}],87:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var adjust_lon = require('../common/adjust_lon');
var qsfnz = require('../common/qsfnz');
var msfnz = require('../common/msfnz');
var iqsfnz = require('../common/iqsfnz');
/*
  reference:  
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/
exports.init = function() {
  //no-op
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
};


/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  }
  else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
};

/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
  }
  else {
    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["cea"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/cea.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/iqsfnz":57,"../common/msfnz":59,"../common/qsfnz":64,"IrXUsu":44,"buffer":41}],88:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var adjust_lon = require('../common/adjust_lon');
var adjust_lat = require('../common/adjust_lat');
exports.init = function() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

  this.rc = Math.cos(this.lat_ts);
};


// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p.x = this.x0 + (this.a * dlon * this.rc);
  p.y = this.y0 + (this.a * dlat);
  return p;
};

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
exports.inverse = function(p) {

  var x = p.x;
  var y = p.y;

  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
  return p;
};
exports.names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/eqc.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lat":48,"../common/adjust_lon":49,"IrXUsu":44,"buffer":41}],89:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var e0fn = require('../common/e0fn');
var e1fn = require('../common/e1fn');
var e2fn = require('../common/e2fn');
var e3fn = require('../common/e3fn');
var msfnz = require('../common/msfnz');
var mlfn = require('../common/mlfn');
var adjust_lon = require('../common/adjust_lon');
var adjust_lat = require('../common/adjust_lat');
var imlfn = require('../common/imlfn');
var EPSLN = 1.0e-10;
exports.init = function() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);

  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);

  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  }
  else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
};


/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;

  /* Forward equations
      -----------------*/
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  }
  else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
};

/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }

};
exports.names = ["Equidistant_Conic", "eqdc"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/eqdc.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lat":48,"../common/adjust_lon":49,"../common/e0fn":51,"../common/e1fn":52,"../common/e2fn":53,"../common/e3fn":54,"../common/imlfn":56,"../common/mlfn":58,"../common/msfnz":59,"IrXUsu":44,"buffer":41}],90:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var FORTPI = Math.PI/4;
var srat = require('../common/srat');
var HALF_PI = Math.PI/2;
var MAX_ITER = 20;
exports.init = function() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
};

exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;

  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
};

exports.inverse = function(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  /* convergence failed */
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["gauss"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/gauss.js","/node_modules/proj4/lib/projections")
},{"../common/srat":66,"IrXUsu":44,"buffer":41}],91:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var adjust_lon = require('../common/adjust_lon');
var EPSLN = 1.0e-10;
var asinz = require('../common/asinz');

/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */
exports.init = function() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  // Approximation for projecting points to the horizon (infinity)
  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
};


/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
exports.forward = function(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = adjust_lon(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  }
  else {

    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project 
    // to infinity, on a bearing 
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that 
    // straddle the horizon.

    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

  }
  p.x = x;
  p.y = y;
  return p;
};


exports.inverse = function(p) {
  var rh; /* Rho */
  var sinc, cosc;
  var c;
  var lon, lat;

  /* Inverse equations
      -----------------*/
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;

  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);

    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["gnom"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/gnom.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/asinz":50,"IrXUsu":44,"buffer":41}],92:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var adjust_lon = require('../common/adjust_lon');
exports.init = function() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448; /* 45 */
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
};

/* ellipsoid */
/* calculate xy from lat/lon */
/* Constants, identical to inverse transform function */
exports.forward = function(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  /* Transformation */
  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return (p);
};

/* calculate lat/lon from xy */
exports.inverse = function(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;

  /* Transformation */
  /* revert y, x*/
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }

  return (p);
};
exports.names = ["Krovak", "krovak"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/krovak.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"IrXUsu":44,"buffer":41}],93:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var HALF_PI = Math.PI/2;
var FORTPI = Math.PI/4;
var EPSLN = 1.0e-10;
var qsfnz = require('../common/qsfnz');
var adjust_lon = require('../common/adjust_lon');
/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

exports.S_POLE = 1;
exports.N_POLE = 2;
exports.EQUIT = 3;
exports.OBLIQ = 4;


/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/
exports.init = function() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  }
  else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  }
  else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;

    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = this.authset(this.es);
    switch (this.mode) {
    case this.N_POLE:
      this.dd = 1;
      break;
    case this.S_POLE:
      this.dd = 1;
      break;
    case this.EQUIT:
      this.rq = Math.sqrt(0.5 * this.qp);
      this.dd = 1 / this.rq;
      this.xmf = 1;
      this.ymf = 0.5 * this.qp;
      break;
    case this.OBLIQ:
      this.rq = Math.sqrt(0.5 * this.qp);
      sinphi = Math.sin(this.lat0);
      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
      this.ymf = (this.xmf = this.rq) / this.dd;
      this.xmf *= this.dd;
      break;
    }
  }
  else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
};

/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
exports.forward = function(p) {

  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;

  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= EPSLN) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.phi0) < EPSLN) {
        return null;
      }
      y = FORTPI - phi * 0.5;
      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  }
  else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
    case this.OBLIQ:
      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
      break;
    case this.EQUIT:
      b = 1 + cosb * coslam;
      break;
    case this.N_POLE:
      b = HALF_PI + phi;
      q = this.qp - q;
      break;
    case this.S_POLE:
      b = phi - HALF_PI;
      q = this.qp + q;
      break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
    case this.OBLIQ:
    case this.EQUIT:
      b = Math.sqrt(2 / b);
      if (this.mode === this.OBLIQ) {
        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
      }
      else {
        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
      }
      x = this.xmf * b * cosb * sinlam;
      break;
    case this.N_POLE:
    case this.S_POLE:
      if (q >= 0) {
        x = (b = Math.sqrt(q)) * sinlam;
        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
      }
      else {
        x = y = 0;
      }
      break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
};

/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;

  if (this.sphere) {
    var cosz = 0,
      rh, sinz = 0;

    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
    case this.EQUIT:
      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
      x *= sinz;
      y = cosz * rh;
      break;
    case this.OBLIQ:
      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
      x *= sinz * this.cosph0;
      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
      break;
    case this.N_POLE:
      y = -y;
      phi = HALF_PI - phi;
      break;
    case this.S_POLE:
      phi -= HALF_PI;
      break;
    }
    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
  }
  else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < EPSLN) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= (sCe = Math.sin(sCe));
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      }
      else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = (x * x + y * y);
      if (!q) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = this.authlat(Math.asin(ab), this.apa);
  }


  p.x = adjust_lon(this.long0 + lam);
  p.y = phi;
  return p;
};

/* determine latitude from authalic latitude */
exports.P00 = 0.33333333333333333333;
exports.P01 = 0.17222222222222222222;
exports.P02 = 0.10257936507936507936;
exports.P10 = 0.06388888888888888888;
exports.P11 = 0.06640211640211640211;
exports.P20 = 0.01641501294219154443;

exports.authset = function(es) {
  var t;
  var APA = [];
  APA[0] = es * this.P00;
  t = es * es;
  APA[0] += t * this.P01;
  APA[1] = t * this.P10;
  t *= es;
  APA[0] += t * this.P02;
  APA[1] += t * this.P11;
  APA[2] = t * this.P20;
  return APA;
};

exports.authlat = function(beta, APA) {
  var t = beta + beta;
  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
};
exports.names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/laea.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/qsfnz":64,"IrXUsu":44,"buffer":41}],94:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var EPSLN = 1.0e-10;
var msfnz = require('../common/msfnz');
var tsfnz = require('../common/tsfnz');
var HALF_PI = Math.PI/2;
var sign = require('../common/sign');
var adjust_lon = require('../common/adjust_lon');
var phi2z = require('../common/phi2z');
exports.init = function() {

  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
  //double c_lat;                   /* center latitude                      */
  //double c_lon;                   /* center longitude                     */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */

  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);

  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);

  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);

  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  }
  else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
};


// Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  // singular cases :
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
  }

  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  }
  else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

  return p;
};

// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
exports.inverse = function(p) {

  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = (this.rh - (p.y - this.y0) / this.k0);
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2((con * x), (con * y));
  }
  if ((rh1 !== 0) || (this.ns > 0)) {
    con = 1 / this.ns;
    ts = Math.pow((rh1 / (this.a * this.f0)), con);
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  else {
    lat = -HALF_PI;
  }
  lon = adjust_lon(theta / this.ns + this.long0);

  p.x = lon;
  p.y = lat;
  return p;
};

exports.names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/lcc.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/msfnz":59,"../common/phi2z":60,"../common/sign":65,"../common/tsfnz":68,"IrXUsu":44,"buffer":41}],95:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.init = function() {
  //no-op for longlat
};

function identity(pt) {
  return pt;
}
exports.forward = identity;
exports.inverse = identity;
exports.names = ["longlat", "identity"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/longlat.js","/node_modules/proj4/lib/projections")
},{"IrXUsu":44,"buffer":41}],96:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var msfnz = require('../common/msfnz');
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var R2D = 57.29577951308232088;
var adjust_lon = require('../common/adjust_lon');
var FORTPI = Math.PI/4;
var tsfnz = require('../common/tsfnz');
var phi2z = require('../common/phi2z');
exports.init = function() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if(!('x0' in this)){
    this.x0 = 0;
  }
  if(!('y0' in this)){
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    }
    else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }
  else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      }
      else {
        this.k0 = 1;
      }
    }
  }
};

/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  // convert to radians
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }

  var x, y;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  }
  else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    }
    else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
};


/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
exports.inverse = function(p) {

  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  }
  else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

  p.x = lon;
  p.y = lat;
  return p;
};

exports.names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/merc.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/msfnz":59,"../common/phi2z":60,"../common/tsfnz":68,"IrXUsu":44,"buffer":41}],97:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var adjust_lon = require('../common/adjust_lon');
/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */


/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/
exports.init = function() {
  //no-op
};


/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

  p.x = x;
  p.y = y;
  return p;
};

/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;

  var lon = adjust_lon(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Miller_Cylindrical", "mill"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/mill.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"IrXUsu":44,"buffer":41}],98:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var adjust_lon = require('../common/adjust_lon');
var EPSLN = 1.0e-10;
exports.init = function() {};

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/
exports.forward = function(p) {

  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);

  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/
  for (var i = 0; true; i++) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;

  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
};

exports.inverse = function(p) {
  var theta;
  var arg;

  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);

  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
  if (lon < (-Math.PI)) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Mollweide", "moll"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/moll.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"IrXUsu":44,"buffer":41}],99:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */
exports.iterations = 1;

exports.init = function() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;

  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;

  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;

  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
};

/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */
exports.forward = function(p) {
  var n;
  var lon = p.x;
  var lat = p.y;

  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;

  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }

  // 2. Calculate theta
  var th_re = d_psi;
  var th_im = d_lambda;

  // 3. Calculate z
  var th_n_re = 1;
  var th_n_im = 0; // theta^0
  var th_n_re1;
  var th_n_im1;

  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }

  // 4. Calculate easting and northing
  p.x = (z_im * this.a) + this.x0;
  p.y = (z_re * this.a) + this.y0;

  return p;
};


/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */
exports.inverse = function(p) {
  var n;
  var x = p.x;
  var y = p.y;

  var delta_x = x - this.x0;
  var delta_y = y - this.y0;

  // 1. Calculate z
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;

  // 2a. Calculate theta - first approximation gives km accuracy
  var z_n_re = 1;
  var z_n_im = 0; // z^0
  var z_n_re1;
  var z_n_im1;

  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }

  // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;

    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    // Complex division
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }

  // 3. Calculate d_phi              ...                                    // and d_lambda
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }

  // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
  var lon = this.long0 + d_lambda;

  p.x = lon;
  p.y = lat;

  return p;
};
exports.names = ["New_Zealand_Map_Grid", "nzmg"];
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/nzmg.js","/node_modules/proj4/lib/projections")
},{"IrXUsu":44,"buffer":41}],100:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var tsfnz = require('../common/tsfnz');
var adjust_lon = require('../common/adjust_lon');
var phi2z = require('../common/phi2z');
var HALF_PI = Math.PI/2;
var FORTPI = Math.PI/4;
var EPSLN = 1.0e-10;

/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/
exports.init = function() {
  this.no_off = this.no_off || false;
  this.no_rot = this.no_rot || false;

  if (isNaN(this.k0)) {
    this.k0 = 1;
  }
  var sinlat = Math.sin(this.lat0);
  var coslat = Math.cos(this.lat0);
  var con = this.e * sinlat;

  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
  var t0 = tsfnz(this.e, this.lat0, sinlat);
  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
  if (dl * dl < 1) {
    dl = 1;
  }
  var fl;
  var gl;
  if (!isNaN(this.longc)) {
    //Central point and azimuth method

    if (this.lat0 >= 0) {
      fl = dl + Math.sqrt(dl * dl - 1);
    }
    else {
      fl = dl - Math.sqrt(dl * dl - 1);
    }
    this.el = fl * Math.pow(t0, this.bl);
    gl = 0.5 * (fl - 1 / fl);
    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

  }
  else {
    //2 points method
    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
    if (this.lat0 >= 0) {
      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    else {
      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    var hl = Math.pow(t1, this.bl);
    var ll = Math.pow(t2, this.bl);
    fl = this.el / hl;
    gl = 0.5 * (fl - 1 / fl);
    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
    var pl = (ll - hl) / (ll + hl);
    var dlon12 = adjust_lon(this.long1 - this.long2);
    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
    this.long0 = adjust_lon(this.long0);
    var dlon10 = adjust_lon(this.long1 - this.long0);
    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
  }

  if (this.no_off) {
    this.uc = 0;
  }
  else {
    if (this.lat0 >= 0) {
      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
    else {
      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
  }

};


/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon(lon - this.long0);
  var us, vs;
  var con;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    if (lat > 0) {
      con = -1;
    }
    else {
      con = 1;
    }
    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
    us = -1 * con * HALF_PI * this.al / this.bl;
  }
  else {
    var t = tsfnz(this.e, lat, Math.sin(lat));
    var ql = this.el / Math.pow(t, this.bl);
    var sl = 0.5 * (ql - 1 / ql);
    var tl = 0.5 * (ql + 1 / ql);
    var vl = Math.sin(this.bl * (dlon));
    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
      vs = Number.POSITIVE_INFINITY;
    }
    else {
      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
    }
    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
      us = this.al * this.bl * (dlon);
    }
    else {
      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
    }
  }

  if (this.no_rot) {
    p.x = this.x0 + us;
    p.y = this.y0 + vs;
  }
  else {

    us -= this.uc;
    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
  }
  return p;
};

exports.inverse = function(p) {
  var us, vs;
  if (this.no_rot) {
    vs = p.y - this.y0;
    us = p.x - this.x0;
  }
  else {
    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
    us += this.uc;
  }
  var qp = Math.exp(-1 * this.bl * vs / this.al);
  var sp = 0.5 * (qp - 1 / qp);
  var tp = 0.5 * (qp + 1 / qp);
  var vp = Math.sin(this.bl * us / this.al);
  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
  if (Math.abs(up - 1) < EPSLN) {
    p.x = this.long0;
    p.y = HALF_PI;
  }
  else if (Math.abs(up + 1) < EPSLN) {
    p.x = this.long0;
    p.y = -1 * HALF_PI;
  }
  else {
    p.y = phi2z(this.e, ts);
    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
  }
  return p;
};

exports.names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/omerc.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/phi2z":60,"../common/tsfnz":68,"IrXUsu":44,"buffer":41}],101:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var e0fn = require('../common/e0fn');
var e1fn = require('../common/e1fn');
var e2fn = require('../common/e2fn');
var e3fn = require('../common/e3fn');
var adjust_lon = require('../common/adjust_lon');
var adjust_lat = require('../common/adjust_lat');
var mlfn = require('../common/mlfn');
var EPSLN = 1.0e-10;
var gN = require('../common/gN');
var MAX_ITER = 20;
exports.init = function() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
};


/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    }
    else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  }
  else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    }
    else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }

  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
};


/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x / this.a + this.long0);
      lat = 0;
    }
    else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
    }
  }
  else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x / this.a);
    }
    else {

      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }

      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Polyconic", "poly"];
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/poly.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lat":48,"../common/adjust_lon":49,"../common/e0fn":51,"../common/e1fn":52,"../common/e2fn":53,"../common/e3fn":54,"../common/gN":55,"../common/mlfn":58,"IrXUsu":44,"buffer":41}],102:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var adjust_lon = require('../common/adjust_lon');
var adjust_lat = require('../common/adjust_lat');
var pj_enfn = require('../common/pj_enfn');
var MAX_ITER = 20;
var pj_mlfn = require('../common/pj_mlfn');
var pj_inv_mlfn = require('../common/pj_inv_mlfn');
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var asinz = require('../common/asinz');
exports.init = function() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/


  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  }
  else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }

};

/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/
exports.forward = function(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/
  lon = adjust_lon(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    }
    else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;
        if (Math.abs(V) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;

  }
  else {

    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
};

exports.inverse = function(p) {
  var lat, temp, lon, s;

  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    }
    else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }
    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  }
  else {
    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
      lon = adjust_lon(temp);
    }
    else if ((s - EPSLN) < HALF_PI) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Sinusoidal", "sinu"];
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/sinu.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lat":48,"../common/adjust_lon":49,"../common/asinz":50,"../common/pj_enfn":61,"../common/pj_inv_mlfn":62,"../common/pj_mlfn":63,"IrXUsu":44,"buffer":41}],103:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme  axe oblique et pour la transformation entre
    des systmes de rfrence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */
exports.init = function() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
};


exports.forward = function(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;

  // spheric latitude
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

  // spheric longitude
  var I = this.alpha * (p.x - this.lambda0);

  // psoeudo equatorial rotation
  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
};

exports.inverse = function(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;

  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

  var lambda = this.lambda0 + I / this.alpha;

  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    }
    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
};

exports.names = ["somerc"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/somerc.js","/node_modules/proj4/lib/projections")
},{"IrXUsu":44,"buffer":41}],104:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var sign = require('../common/sign');
var msfnz = require('../common/msfnz');
var tsfnz = require('../common/tsfnz');
var phi2z = require('../common/phi2z');
var adjust_lon = require('../common/adjust_lon');
exports.ssfn_ = function(phit, sinphi, eccen) {
  sinphi *= eccen;
  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
};

exports.init = function() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
    }
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      }
      else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
};

// Stereographic forward equations--mapping lat,long to x,y
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  }
  else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      //trace(p.toString());
      return p;
    }
    else if (Math.abs(this.sinlat0) < EPSLN) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    }
    else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A * cosX * Math.sin(dlon) + this.x0;
  }
  //trace(p.toString());
  return p;
};


//* Stereographic inverse equations--mapping x,y to lat/long
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      }
    }
    else {
      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        //trace(p.toString());
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
    }
    else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      }
      else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;

  //trace(p.toString());
  return p;

};
exports.names = ["stere"];
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/stere.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/msfnz":59,"../common/phi2z":60,"../common/sign":65,"../common/tsfnz":68,"IrXUsu":44,"buffer":41}],105:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var gauss = require('./gauss');
var adjust_lon = require('../common/adjust_lon');
exports.init = function() {
  gauss.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
};

exports.forward = function(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon(p.x - this.long0);
  gauss.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
};

exports.inverse = function(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;
  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  gauss.inverse.apply(this, [p]);
  p.x = adjust_lon(p.x + this.long0);
  return p;
};

exports.names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/sterea.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"./gauss":90,"IrXUsu":44,"buffer":41}],106:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var e0fn = require('../common/e0fn');
var e1fn = require('../common/e1fn');
var e2fn = require('../common/e2fn');
var e3fn = require('../common/e3fn');
var mlfn = require('../common/mlfn');
var adjust_lon = require('../common/adjust_lon');
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var sign = require('../common/sign');
var asinz = require('../common/asinz');

exports.init = function() {
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
};

/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (this.sphere) {
    var b = cos_phi * Math.sin(delta_lon);
    if ((Math.abs(Math.abs(b) - 1)) < 0.0000000001) {
      return (93);
    }
    else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b));
      con = Math.acos(cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - b * b));
      if (lat < 0) {
        con = -con;
      }
      y = this.a * this.k0 * (con - this.lat0);
    }
  }
  else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var tq = Math.tan(lat);
    var t = Math.pow(tq, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    var n = this.a / Math.sqrt(con);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat);

    x = this.k0 * n * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + Math.pow(t, 2) + 72 * c - 58 * this.ep2))) + this.x0;
    y = this.k0 * (ml - this.ml0 + n * tq * (als * (0.5 + als / 24 * (5 - t + 9 * c + 4 * Math.pow(c, 2) + als / 30 * (61 - 58 * t + Math.pow(t, 2) + 600 * c - 330 * this.ep2))))) + this.y0;

  }
  p.x = x;
  p.y = y;
  return p;
};

/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */
exports.inverse = function(p) {
  var con, phi;
  var delta_phi;
  var i;
  var max_iter = 6;
  var lat, lon;

  if (this.sphere) {
    var f = Math.exp(p.x / (this.a * this.k0));
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + p.y / (this.a * this.k0);
    var h = Math.cos(temp);
    con = Math.sqrt((1 - h * h) / (1 + g * g));
    lat = asinz(con);
    if (temp < 0) {
      lat = -lat;
    }
    if ((g === 0) && (h === 0)) {
      lon = this.long0;
    }
    else {
      lon = adjust_lon(Math.atan2(g, h) + this.long0);
    }
  }
  else { // ellipsoidal form
    var x = p.x - this.x0;
    var y = p.y - this.y0;

    con = (this.ml0 + y / this.k0) / this.a;
    phi = con;
    for (i = 0; true; i++) {
      delta_phi = ((con + this.e1 * Math.sin(2 * phi) - this.e2 * Math.sin(4 * phi) + this.e3 * Math.sin(6 * phi)) / this.e0) - phi;
      phi += delta_phi;
      if (Math.abs(delta_phi) <= EPSLN) {
        break;
      }
      if (i >= max_iter) {
        return (95);
      }
    } // for()
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.tan(phi);
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var n = this.a / Math.sqrt(con);
      var r = n * (1 - this.es) / con;
      var d = x / (n * this.k0);
      var ds = Math.pow(d, 2);
      lat = phi - (n * tan_phi * ds / r) * (0.5 - ds / 24 * (5 + 3 * t + 10 * c - 4 * cs - 9 * this.ep2 - ds / 30 * (61 + 90 * t + 298 * c + 45 * ts - 252 * this.ep2 - 3 * cs)));
      lon = adjust_lon(this.long0 + (d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 - 2 * c + 28 * t - 3 * cs + 8 * this.ep2 + 24 * ts))) / cos_phi));
    }
    else {
      lat = HALF_PI * sign(y);
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/tmerc.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/asinz":50,"../common/e0fn":51,"../common/e1fn":52,"../common/e2fn":53,"../common/e3fn":54,"../common/mlfn":58,"../common/sign":65,"IrXUsu":44,"buffer":41}],107:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var D2R = 0.01745329251994329577;
var tmerc = require('./tmerc');
exports.dependsOn = 'tmerc';
exports.init = function() {
  if (!this.zone) {
    return;
  }
  this.lat0 = 0;
  this.long0 = ((6 * Math.abs(this.zone)) - 183) * D2R;
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;

  tmerc.init.apply(this);
  this.forward = tmerc.forward;
  this.inverse = tmerc.inverse;
};
exports.names = ["Universal Transverse Mercator System", "utm"];

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/utm.js","/node_modules/proj4/lib/projections")
},{"./tmerc":106,"IrXUsu":44,"buffer":41}],108:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var adjust_lon = require('../common/adjust_lon');
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var asinz = require('../common/asinz');
/* Initialize the Van Der Grinten projection
  ----------------------------------------*/
exports.init = function() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
};

exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  /* Forward equations
    -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = asinz(2 * Math.abs(lat / Math.PI));
  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    }
    else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
    //  return(OK);
  }
  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);

  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  //con = Math.abs(con / (Math.PI * this.R));
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  }
  else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
};

/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/
exports.inverse = function(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;

  /* inverse equations
    -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = ((3 * d) / a1) / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    }
    else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  }
  else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/projections/vandg.js","/node_modules/proj4/lib/projections")
},{"../common/adjust_lon":49,"../common/asinz":50,"IrXUsu":44,"buffer":41}],109:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var datum_transform = require('./datum_transform');
var adjust_axis = require('./adjust_axis');
var proj = require('./Proj');
var toPoint = require('./common/toPoint');
module.exports = function transform(source, dest, point) {
  var wgs84;
  if (Array.isArray(point)) {
    point = toPoint(point);
  }
  function checkNotWGS(source, dest) {
    return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84");
  }

  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
  if (source.datum && dest.datum && (checkNotWGS(source, dest) || checkNotWGS(dest, source))) {
    wgs84 = new proj('WGS84');
    transform(source, wgs84, point);
    source = wgs84;
  }
  // DGR, 2010/11/12
  if (source.axis !== "enu") {
    adjust_axis(source, false, point);
  }
  // Transform source points to long/lat, if they aren't already.
  if (source.projName === "longlat") {
    point.x *= D2R; // convert degrees to radians
    point.y *= D2R;
  }
  else {
    if (source.to_meter) {
      point.x *= source.to_meter;
      point.y *= source.to_meter;
    }
    source.inverse(point); // Convert Cartesian to longlat
  }
  // Adjust for the prime meridian if necessary
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }

  // Convert datums if needed, and if possible.
  point = datum_transform(source.datum, dest.datum, point);

  // Adjust for the prime meridian if necessary
  if (dest.from_greenwich) {
    point.x -= dest.from_greenwich;
  }

  if (dest.projName === "longlat") {
    // convert radians to decimal degrees
    point.x *= R2D;
    point.y *= R2D;
  }
  else { // else project
    dest.forward(point);
    if (dest.to_meter) {
      point.x /= dest.to_meter;
      point.y /= dest.to_meter;
    }
  }

  // DGR, 2010/11/12
  if (dest.axis !== "enu") {
    adjust_axis(dest, true, point);
  }

  return point;
};
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/transform.js","/node_modules/proj4/lib")
},{"./Proj":46,"./adjust_axis":47,"./common/toPoint":67,"./datum_transform":74,"IrXUsu":44,"buffer":41}],110:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var D2R = 0.01745329251994329577;
var extend = require('./extend');

function mapit(obj, key, v) {
  obj[key] = v.map(function(aa) {
    var o = {};
    sExpr(aa, o);
    return o;
  }).reduce(function(a, b) {
    return extend(a, b);
  }, {});
}

function sExpr(v, obj) {
  var key;
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  else {
    key = v.shift();
    if (key === 'PARAMETER') {
      key = v.shift();
    }
    if (v.length === 1) {
      if (Array.isArray(v[0])) {
        obj[key] = {};
        sExpr(v[0], obj[key]);
      }
      else {
        obj[key] = v[0];
      }
    }
    else if (!v.length) {
      obj[key] = true;
    }
    else if (key === 'TOWGS84') {
      obj[key] = v;
    }
    else {
      obj[key] = {};
      if (['UNIT', 'PRIMEM', 'VERT_DATUM'].indexOf(key) > -1) {
        obj[key] = {
          name: v[0].toLowerCase(),
          convert: v[1]
        };
        if (v.length === 3) {
          obj[key].auth = v[2];
        }
      }
      else if (key === 'SPHEROID') {
        obj[key] = {
          name: v[0],
          a: v[1],
          rf: v[2]
        };
        if (v.length === 4) {
          obj[key].auth = v[3];
        }
      }
      else if (['GEOGCS', 'GEOCCS', 'DATUM', 'VERT_CS', 'COMPD_CS', 'LOCAL_CS', 'FITTED_CS', 'LOCAL_DATUM'].indexOf(key) > -1) {
        v[0] = ['name', v[0]];
        mapit(obj, key, v);
      }
      else if (v.every(function(aa) {
        return Array.isArray(aa);
      })) {
        mapit(obj, key, v);
      }
      else {
        sExpr(v, obj[key]);
      }
    }
  }
}

function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && (inName in obj)) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  }
  else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  }
  else {
    if (typeof wkt.PROJECTION === "object") {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    }
    else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }
    if (wkt.UNIT.convert) {
      wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);
    }
  }

  if (wkt.GEOGCS) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (wkt.GEOGCS.DATUM) {
      wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();
    }
    else {
      wkt.datumCode = wkt.GEOGCS.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }
    if (wkt.datumCode === "wgs_1984") {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }
      wkt.datumCode = 'wgs84';
    }
    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, - 6);
    }
    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, - 8);
    }
    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = "rnb72";
    }
    if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {
      wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt.ellps = 'intl';
      }

      wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);
    }
    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = "osgb36";
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return parseFloat(input, 10) * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ['standard_parallel_1', 'Standard_Parallel_1'],
    ['standard_parallel_2', 'Standard_Parallel_2'],
    ['false_easting', 'False_Easting'],
    ['false_northing', 'False_Northing'],
    ['central_meridian', 'Central_Meridian'],
    ['latitude_of_origin', 'Latitude_Of_Origin'],
    ['latitude_of_origin', 'Central_Parallel'],
    ['scale_factor', 'Scale_Factor'],
    ['k0', 'scale_factor'],
    ['latitude_of_center', 'Latitude_of_center'],
    ['lat0', 'latitude_of_center', d2r],
    ['longitude_of_center', 'Longitude_Of_Center'],
    ['longc', 'longitude_of_center', d2r],
    ['x0', 'false_easting', toMeter],
    ['y0', 'false_northing', toMeter],
    ['long0', 'central_meridian', d2r],
    ['lat0', 'latitude_of_origin', d2r],
    ['lat0', 'standard_parallel_1', d2r],
    ['lat1', 'standard_parallel_1', d2r],
    ['lat2', 'standard_parallel_2', d2r],
    ['alpha', 'azimuth', d2r],
    ['srsCode', 'name']
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.PROJECTION === 'Albers_Conic_Equal_Area' || wkt.PROJECTION === "Lambert_Azimuthal_Equal_Area")) {
    wkt.long0 = wkt.longc;
  }
}
module.exports = function(wkt, self) {
  var lisp = JSON.parse(("," + wkt).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/,''));
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  lisp.unshift('output');
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj.output);
  return extend(self, obj.output);
};

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/lib/wkt.js","/node_modules/proj4/lib")
},{"./extend":77,"IrXUsu":44,"buffer":41}],111:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){



/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;

/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

var A = 65; // A
var I = 73; // I
var O = 79; // O
var V = 86; // V
var Z = 90; // Z

/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 4 for 1000 m or 5 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */
exports.forward = function(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
};

/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */
exports.inverse = function(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
};

exports.toPoint = function(mgrsStr) {
  var llbbox = exports.inverse(mgrsStr);
  return [(llbbox[2] + llbbox[0]) / 2, (llbbox[3] + llbbox[1]) / 2];
};
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */
function degToRad(deg) {
  return (deg * (Math.PI / 180.0));
}

/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */
function radToDeg(rad) {
  return (180.0 * (rad / Math.PI));
}

/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  // (int)
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

  //Make sure the longitude 180.00 is in Zone 60
  if (Long === 180) {
    ZoneNumber = 60;
  }

  // Special zone for Norway
  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  }

  // Special zones for Svalbard
  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    }
    else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    }
    else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    }
    else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone
  LongOriginRad = degToRad(LongOrigin);

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}

/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */
function UTMtoLL(utm) {

  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  // check the ZoneNummber is valid
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;

  // remove 500,000 meter offset for longitude
  var x = UTMEasting - 500000.0;
  var y = UTMNorthing;

  // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly
  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  }

  // There are 60 zones with zone 1 being at West -180 to -174
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
  // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);

  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);

  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);

  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  }
  else {
    result = {
      lat: lat,
      lon: lon
    };
  }
  return result;
}

/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */
function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if ((84 >= lat) && (lat >= 72)) {
    LetterDesignator = 'X';
  }
  else if ((72 > lat) && (lat >= 64)) {
    LetterDesignator = 'W';
  }
  else if ((64 > lat) && (lat >= 56)) {
    LetterDesignator = 'V';
  }
  else if ((56 > lat) && (lat >= 48)) {
    LetterDesignator = 'U';
  }
  else if ((48 > lat) && (lat >= 40)) {
    LetterDesignator = 'T';
  }
  else if ((40 > lat) && (lat >= 32)) {
    LetterDesignator = 'S';
  }
  else if ((32 > lat) && (lat >= 24)) {
    LetterDesignator = 'R';
  }
  else if ((24 > lat) && (lat >= 16)) {
    LetterDesignator = 'Q';
  }
  else if ((16 > lat) && (lat >= 8)) {
    LetterDesignator = 'P';
  }
  else if ((8 > lat) && (lat >= 0)) {
    LetterDesignator = 'N';
  }
  else if ((0 > lat) && (lat >= -8)) {
    LetterDesignator = 'M';
  }
  else if ((-8 > lat) && (lat >= -16)) {
    LetterDesignator = 'L';
  }
  else if ((-16 > lat) && (lat >= -24)) {
    LetterDesignator = 'K';
  }
  else if ((-24 > lat) && (lat >= -32)) {
    LetterDesignator = 'J';
  }
  else if ((-32 > lat) && (lat >= -40)) {
    LetterDesignator = 'H';
  }
  else if ((-40 > lat) && (lat >= -48)) {
    LetterDesignator = 'G';
  }
  else if ((-48 > lat) && (lat >= -56)) {
    LetterDesignator = 'F';
  }
  else if ((-56 > lat) && (lat >= -64)) {
    LetterDesignator = 'E';
  }
  else if ((-64 > lat) && (lat >= -72)) {
    LetterDesignator = 'D';
  }
  else if ((-72 > lat) && (lat >= -80)) {
    LetterDesignator = 'C';
  }
  return LetterDesignator;
}

/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */
function encode(utm, accuracy) {
  var seasting = "" + utm.easting,
    snorthing = "" + utm.northing;

  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}

/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}

/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}

/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */
function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

  // colInt and rowInt are the letters to build to return
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }

  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
    colInt++;
  }

  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  }
  else {
    rollover = false;
  }

  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
    rowInt++;
  }

  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}

/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */
function decode(mgrsString) {

  if (mgrsString && mgrsString.length === 0) {
    throw ("MGRSPoint coverting from nothing");
  }

  var length = mgrsString.length;

  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;

  // get Zone number
  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }
    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw ("MGRSPoint bad conversion from: " + mgrsString);
  }

  var zoneLetter = mgrsString.charAt(i++);

  // Should we check the zone letter here? Why not.
  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
  }

  hunK = mgrsString.substring(i, i += 2);

  var set = get100kSetForZone(zoneNumber);

  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);

  // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  }

  // calculate the char index for easting/northing separator
  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
  }

  var sep = remainder / 2;

  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;

  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}

/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */
function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw ("Bad character: " + e);
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 100000.0;
  }

  return eastingValue;
}

/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */
function getNorthingFromChar(n, set) {

  if (n > 'V') {
    throw ("MGRSPoint given invalid Northing " + n);
  }

  // rowOrigin is the letter at the origin of the set for the
  // column
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character
    if (curRow > V) {
      if (rewindMarker) { // making sure that this loop ends
        throw ("Bad character: " + n);
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 100000.0;
  }

  return northingValue;
}

/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
  case 'C':
    northing = 1100000.0;
    break;
  case 'D':
    northing = 2000000.0;
    break;
  case 'E':
    northing = 2800000.0;
    break;
  case 'F':
    northing = 3700000.0;
    break;
  case 'G':
    northing = 4600000.0;
    break;
  case 'H':
    northing = 5500000.0;
    break;
  case 'J':
    northing = 6400000.0;
    break;
  case 'K':
    northing = 7300000.0;
    break;
  case 'L':
    northing = 8200000.0;
    break;
  case 'M':
    northing = 9100000.0;
    break;
  case 'N':
    northing = 0.0;
    break;
  case 'P':
    northing = 800000.0;
    break;
  case 'Q':
    northing = 1700000.0;
    break;
  case 'R':
    northing = 2600000.0;
    break;
  case 'S':
    northing = 3500000.0;
    break;
  case 'T':
    northing = 4400000.0;
    break;
  case 'U':
    northing = 5300000.0;
    break;
  case 'V':
    northing = 6200000.0;
    break;
  case 'W':
    northing = 7000000.0;
    break;
  case 'X':
    northing = 7900000.0;
    break;
  default:
    northing = -1.0;
  }
  if (northing >= 0.0) {
    return northing;
  }
  else {
    throw ("Invalid zone letter: " + zoneLetter);
  }

}

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/proj4/node_modules/mgrs/mgrs.js","/node_modules/proj4/node_modules/mgrs")
},{"IrXUsu":44,"buffer":41}],112:[function(require,module,exports){
module.exports={
  "name": "proj4",
  "version": "2.3.3",
  "description": "Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.",
  "main": "lib/index.js",
  "directories": {
    "test": "test",
    "doc": "docs"
  },
  "scripts": {
    "test": "./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/proj4js/proj4js.git"
  },
  "author": "",
  "license": "MIT",
  "jam": {
    "main": "dist/proj4.js",
    "include": [
      "dist/proj4.js",
      "README.md",
      "AUTHORS",
      "LICENSE.md"
    ]
  },
  "devDependencies": {
    "grunt-cli": "~0.1.13",
    "grunt": "~0.4.2",
    "grunt-contrib-connect": "~0.6.0",
    "grunt-contrib-jshint": "~0.8.0",
    "chai": "~1.8.1",
    "mocha": "~1.17.1",
    "grunt-mocha-phantomjs": "~0.4.0",
    "browserify": "~3.24.5",
    "grunt-browserify": "~1.3.0",
    "grunt-contrib-uglify": "~0.3.2",
    "curl": "git://github.com/cujojs/curl.git",
    "istanbul": "~0.2.4",
    "tin": "~0.4.0"
  },
  "dependencies": {
    "mgrs": "0.0.0"
  },
  "contributors": [
    {
      "name": "Mike Adair",
      "email": "madair@dmsolutions.ca"
    },
    {
      "name": "Richard Greenwood",
      "email": "rich@greenwoodmap.com"
    },
    {
      "name": "Calvin Metcalf",
      "email": "calvin.metcalf@gmail.com"
    },
    {
      "name": "Richard Marsden",
      "url": "http://www.winwaed.com"
    },
    {
      "name": "T. Mittan"
    },
    {
      "name": "D. Steinwand"
    },
    {
      "name": "S. Nelson"
    }
  ],
  "readme": "#PROJ4JS [![Build Status](https://travis-ci.org/proj4js/proj4js.svg)](https://travis-ci.org/proj4js/proj4js)\n\nProj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.\nOriginally a port of [PROJ.4](http://trac.osgeo.org/proj/) and [GCTCP C](http://edcftp.cr.usgs.gov/pub//software/gctpc) it is\na part of the [MetaCRS](http://wiki.osgeo.org/wiki/MetaCRS) group of projects.\n\n##Installing\n\nDepending on your preferences\n\n```bash\nnpm install proj4\nbower install proj4\njam install proj4\ncomponent install proj4js/proj4js\n```\n\nor just manually grab the file `proj4.js` from the [latest release](https://github.com/proj4js/proj4js/releases).\n\nif you do not want to download anything, Proj4js is also hosted on [cdnjs](http://www.cdnjs.com/libraries/proj4js) for direct use in your browser applications.\n\n##Using\n\nthe basic signature is:\n\n```javascript\nproj4(fromProjection[, toProjection2, coordinates])\n```\n\nProjections can be proj or wkt strings.\n\nCoordinates may an object of the form `{x:x,y:y}` or an array of the form `[x,y]`.\n\nWhen all 3 arguments  are given, the result is that the coordinates are transformed from projection1 to projection 2. And returned in the same format that they were given in.\n\n```javascript\nvar firstProjection = 'PROJCS[\"NAD83 / Massachusetts Mainland\",GEOGCS[\"NAD83\",DATUM[\"North_American_Datum_1983\",SPHEROID[\"GRS 1980\",6378137,298.257222101,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6269\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.01745329251994328,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4269\"]],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],PROJECTION[\"Lambert_Conformal_Conic_2SP\"],PARAMETER[\"standard_parallel_1\",42.68333333333333],PARAMETER[\"standard_parallel_2\",41.71666666666667],PARAMETER[\"latitude_of_origin\",41],PARAMETER[\"central_meridian\",-71.5],PARAMETER[\"false_easting\",200000],PARAMETER[\"false_northing\",750000],AUTHORITY[\"EPSG\",\"26986\"],AXIS[\"X\",EAST],AXIS[\"Y\",NORTH]]';\nvar secondProjection = \"+proj=gnom +lat_0=90 +lon_0=0 +x_0=6300000 +y_0=6300000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs\";\n//I'm not going to redefine those two in latter examples.\nproj4(firstProjection,secondProjection,[2,5]);\n// [-2690666.2977344505, 3662659.885459918]\n```\n\nIf only 1 projection is given then it is assumed that it is being projected *from* WGS84 (fromProjection is WGS84).\n\n```javascript\nproj4(firstProjection,[-71,41]);\n// [242075.00535055372, 750123.32090043]\n```\n\nIf no coordinates are given an object with two methods is returned, its methods are `forward` which projects from the first projection to the second and `inverse` which projects from the second to the first.\n\n```javascript\nproj4(firstProjection,secondProjection).forward([2,5]);\n// [-2690666.2977344505, 3662659.885459918]\nproj4(secondProjection,firstProjection).inverse([2,5]);\n// [-2690666.2977344505, 3662659.885459918]\n```\n\nand as above if only one projection is given, it's assumed to be coming from wgs84\n\n```javascript\nproj4(firstProjection).forward([-71,41]);\n// [242075.00535055372, 750123.32090043]\nproj4(firstProjection).inverse([242075.00535055372, 750123.32090043]);\n//[-71, 40.99999999999986]\n//the floating points to answer your question\n```\n\n## Named Projections\n\nIf you prefer to define a projection as a string and reference it that way, you may use the proj4.defs method which can be called 2 ways, with a name and projection:\n\n```js\nproj4.defs('WGS84', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n```\n\nor with an array\n\n```js\nproj4.defs([\n  [\n    'EPSG:4326',\n    '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees'],\n  [\n    'EPSG:4269',\n    '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees'\n  ]\n]);\n```\n\nyou can then do \n\n```js\nproj4('EPSG:4326');\n```\n\ninstead of writing out the whole proj definition, by default proj4 has the following projections predefined:\n\n- 'EPSG:4326', which has the following alias\n    - 'WGS84'\n- 'EPSG:4269'\n- 'EPSG:3857', which has the following aliases\n    - 'EPSG:3785'\n    - 'GOOGLE'\n    - 'EPSG:900913'\n    - 'EPSG:102113'\n\ndefined projections can also be accessed through the proj4.defs function (`proj4.defs('EPSG:4326')`).\n\nproj4.defs can also be used to define a named alias:\n\n```javascript\nproj4.defs('urn:x-ogc:def:crs:EPSG:4326', proj4.defs('EPSG:4326'));\n``` \n\n##Developing\nto set up build tools make sure you have node and grunt-cli installed and then run `npm install`\n\nto do the complete build and browser tests run\n\n```bash\ngrunt\n```\n\nto run node tests run\n\n```bash\nnpm test\n```\n\nto run node tests with coverage run\n\n```bash\nnode test --coverage\n```\n\nto create a build with only default projections (latlon and Mercator) run \n\n```bash\ngrunt build\n```\n\nto create a build with only custom projections include a comma separated list of projections codes (the file name in 'lib/projections' without the '.js') after a colon, e.g.\n\n```bash\ngrunt build:tmerc\n#includes transverse Mercator\ngrunt build:lcc\n#includes lambert conformal conic\ngrunt build:omerc,moll\n#includes oblique Mercator and Mollweide\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/proj4js/proj4js/issues"
  },
  "homepage": "https://github.com/proj4js/proj4js",
  "_id": "proj4@2.3.3",
  "dist": {
    "shasum": "1060bbf53235d610a3fbf9c3c22eb006fad3f5b8"
  },
  "_from": "proj4@2.3.3",
  "_resolved": "https://registry.npmjs.org/proj4/-/proj4-2.3.3.tgz"
}

},{}],113:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Currently requires polyfills for
// Array#forEach
// Object.keys
// String#trim

(function(factory) {
  if (typeof define === 'function' && define.amd) {
    define(['Q'], function(Q) {
      return factory(XMLHttpRequest, Q)
    })
  } else if (typeof exports === 'object' && typeof module === 'object') {
    // CommonJS, mainly for testing
    module.exports = factory
  } else {
    if (typeof Q !== 'undefined') {
      factory(XMLHttpRequest, Q)
    }
  }
})(function(XHR, Q) {
  // shallow extend with varargs
  function extend(dst) {
    Array.prototype.forEach.call(arguments, function(obj) {
      if (obj && obj !== dst) {
        Object.keys(obj).forEach(function(key) {
          dst[key] = obj[key]
        })
      }
    })

    return dst
  }

  function lowercase(str) {
    return (str || '').toLowerCase()
  }

  function parseHeaders(headers) {
    var parsed = {}, key, val, i

    if (!headers) return parsed

    headers.split('\n').forEach(function(line) {
      i = line.indexOf(':')
      key = lowercase(line.substr(0, i).trim())
      val = line.substr(i + 1).trim()

      if (key) {
        if (parsed[key]) {
          parsed[key] += ', ' + val
        } else {
          parsed[key] = val
        }
      }
    })

    return parsed
  }

  function headersGetter(headers) {
    var headersObj = typeof headers === 'object' ? headers : undefined;

    return function(name) {
      if (!headersObj) headersObj = parseHeaders(headers)

      if (name) {
        return headersObj[lowercase(name)]
      }

      return headersObj
    }
  }

  function transformData(data, headers, fns) {
    if (typeof fns === 'function') {
      return fns(data, headers)
    }

    fns.forEach(function(fn) {
      data = fn(data, headers)
    })

    return data
  }

  function isSuccess(status) {
    return 200 <= status && status < 300
  }

  function forEach(obj, iterator, context) {
    var keys = Object.keys(obj)
    keys.forEach(function(key) {
      iterator.call(context, obj[key], key)
    })
    return keys
  }

  function forEachSorted(obj, iterator, context) {
    var keys = Object.keys(obj).sort()
    keys.forEach(function(key) {
      iterator.call(context, obj[key], key)
    })
    return keys
  }

  function buildUrl(url, params) {
    if (!params) return url
    var parts = []
    forEachSorted(params, function(value, key) {
      if (value == null) return
      if (!Array.isArray(value)) value = [value]

      value.forEach(function(v) {
        if (typeof v === 'object') {
          v = JSON.stringify(v)
        }
        parts.push(encodeURIComponent(key) + '=' +
                   encodeURIComponent(v))
      })
    })
    return url + ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&')
  }

  Q.xhr = function (requestConfig) {
    var defaults = Q.xhr.defaults,
    config = {
      transformRequest: defaults.transformRequest,
      transformResponse: defaults.transformResponse
    },
    mergeHeaders = function(config) {
      var defHeaders = defaults.headers,
          reqHeaders = extend({}, config.headers),
          defHeaderName, lowercaseDefHeaderName, reqHeaderName,

      execHeaders = function(headers) {
        forEach(headers, function(headerFn, header) {
          if (typeof headerFn === 'function') {
            var headerContent = headerFn()
            if (headerContent != null) {
              headers[header] = headerContent
            } else {
              delete headers[header]
            }
          }
        })
      }

      defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);

      // execute if header value is function
      execHeaders(defHeaders);
      execHeaders(reqHeaders);

      // using for-in instead of forEach to avoid unecessary iteration after header has been found
      defaultHeadersIteration:
      for (defHeaderName in defHeaders) {
        lowercaseDefHeaderName = lowercase(defHeaderName);

        for (reqHeaderName in reqHeaders) {
          if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
            continue defaultHeadersIteration;
          }
        }

        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
      }

      return reqHeaders;
    },
    headers = mergeHeaders(requestConfig)

    extend(config, requestConfig)
    config.headers = headers
    config.method = (config.method || 'GET').toUpperCase()

    var serverRequest = function(config) {
      headers = config.headers
      var reqData = transformData(config.data, headersGetter(headers), config.transformRequest)

      // strip content-type if data is undefined TODO does it really matter?
      if (config.data == null) {
        forEach(headers, function(value, header) {
          if (lowercase(header) === 'content-type') {
              delete headers[header]
          }
        })
      }

      if (config.withCredentials == null && defaults.withCredentials != null) {
        config.withCredentials = defaults.withCredentials
      }

      // send request
      return sendReq(config, reqData, headers).then(transformResponse, transformResponse)
    },

    transformResponse = function(response) {
      response.data = transformData(response.data, response.headers, config.transformResponse)
      return isSuccess(response.status) ? response : Q.reject(response)
    },

    promise = Q.when(config)

    // build a promise chain with request interceptors first, then the request, and response interceptors
    Q.xhr.interceptors.filter(function(interceptor) {
        return !!interceptor.request || !!interceptor.requestError
      }).map(function(interceptor) {
        return { success: interceptor.request, failure: interceptor.requestError }
      })
    .concat({ success: serverRequest })
    .concat(Q.xhr.interceptors.filter(function(interceptor) {
        return !!interceptor.response || !!interceptor.responseError
      }).map(function(interceptor) {
        return { success: interceptor.response, failure: interceptor.responseError }
      })
    ).forEach(function(then) {
      promise = promise.then(then.success, then.failure)
    })

    return promise
  }


  var contentTypeJson = { 'Content-Type': 'application/json;charset=utf-8' }

  Q.xhr.defaults = {
    transformResponse: [function(data, headers) {
      if (typeof data === 'string' && (headers('content-type') || '').indexOf('json') >= 0) {
        data = JSON.parse(data)
      }
      return data
    }],

    transformRequest: [function(data) {
      return !!data && typeof data === 'object' && data.toString() !== '[object File]' ?
        JSON.stringify(data) : data
    }],

    headers: {
      common: {
        'Accept': 'application/json, text/plain, */*'
      },
      post:   contentTypeJson,
      put:    contentTypeJson,
      patch:  contentTypeJson
    },
  }

  Q.xhr.interceptors = []
  Q.xhr.pendingRequests = []

  function sendReq(config, reqData, reqHeaders) {
    var deferred = Q.defer(),
        promise = deferred.promise,
        url = buildUrl(config.url, config.params),
        xhr = new XHR(),
        aborted = -1,
        status,
        timeoutId

    Q.xhr.pendingRequests.push(config)

    xhr.open(config.method, url, true)
    forEach(config.headers, function(value, key) {
      if (value) {
        xhr.setRequestHeader(key, value)
      }
    })

    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4) {
        var response, responseHeaders
        if (status !== aborted) {
          responseHeaders = xhr.getAllResponseHeaders()
          // responseText is the old-school way of retrieving response (supported by IE8 & 9)
          // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
          response = xhr.responseType ? xhr.response : xhr.responseText
        }

        // cancel timeout and subsequent timeout promise resolution
        timeoutId && clearTimeout(timeoutId)
        status = status || xhr.status
        xhr = null

        // normalize status, including accounting for IE bug (http://bugs.jquery.com/ticket/1450)
        status = Math.max(status == 1223 ? 204 : status, 0)

        var idx = Q.xhr.pendingRequests.indexOf(config)
        if (idx !== -1) Q.xhr.pendingRequests.splice(idx, 1)

        ;(isSuccess(status) ? deferred.resolve : deferred.reject)({
          data: response,
          status: status,
          headers: headersGetter(responseHeaders),
          config: config
        })
      }
    }

    xhr.onprogress = function (progress) {
      deferred.notify(progress)
    }

    if (config.withCredentials) {
      xhr.withCredentials = true
    }

    if (config.responseType) {
      xhr.responseType = config.responseType;
    }

    xhr.send(reqData || null)

    if (config.timeout > 0) {
      timeoutId = setTimeout(function() {
        status = aborted;
        xhr && xhr.abort()
      }, config.timeout)
    }

    return promise
  }

  ['get', 'delete', 'head'].forEach(function(name) {
    Q.xhr[name] = function(url, config) {
      return Q.xhr(extend(config || {}, {
        method: name,
        url: url
      }))
    }
  });

  ['post', 'put', 'patch'].forEach(function(name) {
    Q.xhr[name] = function(url, data, config) {
      return Q.xhr(extend(config || {}, {
        method: name,
        url: url,
        data: data
      }))
    }
  })

  return Q
})
}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/q-xhr/q-xhr.js","/node_modules/q-xhr")
},{"IrXUsu":44,"buffer":41}],114:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof self !== "undefined") {
        self.Q = definition();

    } else {
        throw new Error("This environment was not anticiapted by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/q/q.js","/node_modules/q")
},{"IrXUsu":44,"buffer":41}],115:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var self = self || {};// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '69' };

// browserify support

if ( typeof module === 'object' ) {

	module.exports = THREE;

}

// polyfills

if ( Math.sign === undefined ) {

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : 0;

	};

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = function () {};

THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};

THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

	if ( arguments.length === 3 ) {

		return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

	}

	return this.set( color )

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var hue2rgb = function ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			};

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		// rgb(255,0,0)

		if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

			var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

			this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
			this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
			this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

			return this;

		}

		// rgb(100%,0%,0%)

		if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

			var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

			this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
			this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
			this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

			return this;

		}

		// #ff0000

		if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

			var color = /^\#([0-9a-f]{6})$/i.exec( style );

			this.setHex( parseInt( color[ 1 ], 16 ) );

			return this;

		}

		// #f00

		if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

			var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

			this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

			return this;

		}

		// red

		if ( /^(\w+)$/i.test( style ) ) {

			this.setHex( THREE.ColorKeywords[ style ] );

			return this;

		}


	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color ) {

		this.r = color.r * color.r;
		this.g = color.g * color.g;
		this.b = color.b * color.b;

		return this;

	},

	copyLinearToGamma: function ( color ) {

		this.r = Math.sqrt( color.r );
		this.g = Math.sqrt( color.g );
		this.b = Math.sqrt( color.b );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array ) {

		this.r = array[ 0 ];
		this.g = array[ 1 ];
		this.b = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.r, this.g, this.b ];

	},

	clone: function () {

		return new THREE.Color().setRGB( this.r, this.g, this.b );

	}

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	_x: 0,_y: 0, _z: 0, _w: 0,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		if ( euler.order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function ( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			this.normalize();

			return this;

		}

	}(),

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {},

	clone: function () {

		return new THREE.Quaternion( this._x, this._y, this._z, this._w );

	}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

}

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		return this;
	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	}

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function ( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function ( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function ( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength  ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function ( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function ( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function ( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},

	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

		return this.setFromMatrixScale( m );
	},

	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;
	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	}

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;
			this.w *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		}

		return this;

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		   && ( Math.abs( m13 - m31 ) < epsilon )
		   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			   && ( Math.abs( m13 + m31 ) < epsilon2 )
			   && ( Math.abs( m23 + m32 ) < epsilon2 )
			   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) { // m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else { // m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						  + ( m13 - m31 ) * ( m13 - m31 )
						  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		if ( this.w > v.w ) {

			this.w = v.w;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		if ( this.w < v.w ) {

			this.w = v.w;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		if ( this.w < min.w ) {

			this.w = min.w;

		} else if ( this.w > max.w ) {

			this.w = max.w;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector4();
				max = new THREE.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );

		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	clone: function () {

		return new THREE.Vector4( this.x, this.y, this.z, this.w );

	}

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order ) {

		var clamp = THREE.Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function ( q, order, update ) {

		var clamp = THREE.Math.clamp;

		// q is assumed to be normalized

		// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m

		var sqx = q.x * q.x;
		var sqy = q.y * q.y;
		var sqz = q.z * q.z;
		var sqw = q.w * q.w;

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ), - 1, 1 ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order ===  'YXZ' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ), - 1, 1 ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ), - 1, 1 ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZYX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ), - 1, 1 ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order === 'YZX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ), - 1, 1 ) );

		} else if ( order === 'XZY' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ), - 1, 1 ) );

		} else {

			console.warn( 'THREE.Euler: .setFromQuaternion() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};


	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._order ];

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {},

	clone: function () {

		return new THREE.Euler( this._x, this._y, this._z, this._order );

	}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	},

	clone: function () {

		return new THREE.Line3().copy( this );

	}

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;
	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;
	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;
	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box2().copy( this );

	}

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and childrens', world transforms

		var v1 = new THREE.Vector3();

		return function ( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry instanceof THREE.Geometry ) {

						var vertices = geometry.vertices;

						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

							v1.copy( vertices[ i ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

						var positions = geometry.attributes[ 'position' ].array;

						for ( var i = 0, il = positions.length; i < il; i += 3 ) {

							v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					}

				}

			} );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box3().copy( this );

	}

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function () {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
		te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
		te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1 = new THREE.Vector3();

		return function ( array, offset, length ) {

			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

				v1.x = array[ j ];
				v1.y = array[ j + 1 ];
				v1.z = array[ j + 2 ];

				v1.applyMatrix3( this );

				array[ j ]     = v1.x;
				array[ j + 1 ] = v1.y;
				array[ j + 2 ] = v1.z;

			}

			return array;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
		te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
		te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
		te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
		te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
		te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
		te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
		te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
		te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset     ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ],
			te[ 3 ], te[ 4 ], te[ 5 ],
			te[ 6 ], te[ 7 ], te[ 8 ]
		];

	},

	clone: function () {

		return new THREE.Matrix3().fromArray( this.elements );

	}

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractRotation: function () {

		var v1 = new THREE.Vector3();

		return function ( m ) {

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
			var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
			var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x = new THREE.Vector3();
		var y = new THREE.Vector3();
		var z = new THREE.Vector3();

		return function ( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.length() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.length() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1 = new THREE.Vector3();

		return function ( array, offset, length ) {

			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

				v1.x = array[ j ];
				v1.y = array[ j + 1 ];
				v1.z = array[ j + 2 ];

				v1.applyMatrix4( this );

				array[ j ]     = v1.x;
				array[ j + 1 ] = v1.y;
				array[ j + 2 ] = v1.z;

			}

			return array;

		};

	}(),

	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset     ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	},

	getPosition: function () {

		var v1 = new THREE.Vector3();

		return function () {

			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det == 0 ) {

			var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;
		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		console.warn( 'THREE.Matrix4: .translate() has been removed.' );

	},

	rotateX: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateX() has been removed.' );

	},

	rotateY: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateY() has been removed.' );

	},

	rotateZ: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},

	rotateByAxis: function ( axis, angle ) {

		console.warn( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector = new THREE.Vector3();
		var matrix = new THREE.Matrix4();

		return function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {
				sx = - sx;
			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	},

	clone: function () {

		return new THREE.Matrix4().fromArray( this.elements );

	}

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceTo( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceTo( point );

		};

	}(),

	distanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
		var segDir = v1.clone().sub( v0 ).normalize();
		var segExtent = v0.distanceTo( v1 ) * 0.5;
		var diff = this.origin.clone().sub( segCenter );
		var a01 = - this.direction.dot( segDir );
		var b0 = diff.dot( this.direction );
		var b1 = - diff.dot( segDir );
		var c = diff.lengthSq();
		var det = Math.abs( 1 - a01 * a01 );
		var s0, s1, sqrDist, extDet;

		if ( det >= 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						var invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );

		}

		return sqrDist;

	},

	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	intersectSphere: function () {

		// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

		var v1 = new THREE.Vector3();

		return function ( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );

			var tca = v1.dot( this.direction );

			var d2 = v1.dot( v1 ) - tca * tca;

			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0 
			return this.at( t0, optionalTarget );

		}

	}(),

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator == 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) == 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;
		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {

		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	}(),

	intersectBox: function ( box , optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin,tmax,tymin,tymax,tzmin,tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;
		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;
		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;
		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;
	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	},

	clone: function () {

		return new THREE.Ray().copy( this );

	}

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;
	},

	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter )  {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

 		};

	}(),

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	},

	clone: function () {

		return new THREE.Sphere().copy( this );

	}

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function ( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}
			}

			return true;
		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	clone: function () {

		return new THREE.Frustum().copy( this );

	}

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),


	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function () {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) == 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

	},

	clone: function () {

		return new THREE.Plane().copy( this );

	}

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

					uuid[ i ] = '-';

				} else if ( i == 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}
			}

			return uuid.join( '' );

		};

	}(),

	// Clamp value to range <a, b>

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	// Clamp value to range <a, inf)

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function () {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function () {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}(),

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function ( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i ++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( ! nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint != oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			linearDistance, realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i ++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j ++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// colinear or singular triangle
		if ( denom == 0 ) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );
		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycoordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function () {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	},

	clone: function () {

		return new THREE.Triangle().copy( this );

	}

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance !== undefined && self.performance.now !== undefined
					 ? self.performance.now()
					 : Date.now();

		this.oldTime = this.startTime;
		this.running = true;
	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance !== undefined && self.performance.now !== undefined
					 ? self.performance.now()
					 : Date.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {}

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [];
			var length = listenerArray.length;

			for ( var i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( var i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Sprite: {},
			Mesh: {},
			PointCloud: { threshold: 1 },
			LOD: {},
			Line: {}
		};

	};

	var descSort = function ( a, b ) {

		return a.distance - b.distance;

	};

	var intersectObject = function ( object, raycaster, intersects, recursive ) {

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	};

	//

	THREE.Raycaster.prototype = {

		constructor: THREE.Raycaster,

		precision: 0.0001,
		linePrecision: 1,

		set: function ( origin, direction ) {

			this.ray.set( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( descSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( objects instanceof Array === false ) {

				console.log( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( descSort );

			return intersects;

		}

	};

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Object3D = function () {

	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = undefined;
	this.children = [];

	this.up = THREE.Object3D.DefaultUp.clone();

	var scope = this;

	var position = new THREE.Vector3();
	var rotation = new THREE.Euler();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3( 1, 1, 1 );

	var onRotationChange = function () {
		quaternion.setFromEuler( rotation, false );
	};

	var onQuaternionChange = function () {
		rotation.setFromQuaternion( quaternion, undefined, false );
	};

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
	} );

	this.renderDepth = null;

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = true;
	this.matrixWorldNeedsUpdate = false;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;

	this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );

THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	get eulerOrder () {

		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		}

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		}

	}(),

	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		};

		if ( object === this ) {

			console.error( "THREE.Object3D.add:", object, "can't be added as a child of itself." );
			return this;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== undefined ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add:", object, "is not an instance of THREE.Object3D." );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i++ ) {

				this.remove( arguments[ i ] );

			}

		};

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = undefined;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getChildByName: function ( name, recursive ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name, recursive );

	},

	getObjectById: function ( id, recursive ) {

		if ( this.id === id ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectById( id, recursive );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getObjectByName: function ( name, recursive ) {

		if ( this.name === name ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByName( name, recursive );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new THREE.Vector3();
		var scale = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		}

	}(),

	getWorldRotation: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		}

	}(),

	getWorldScale: function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		}

	}(),

	getWorldDirection: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		}

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverseVisible( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === undefined ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.3,
				type: 'Object',
				generator: 'ObjectExporter'
			}
		};

		//

		var geometries = {};

		var parseGeometry = function ( geometry ) {

			if ( output.geometries === undefined ) {

				output.geometries = [];

			}

			if ( geometries[ geometry.uuid ] === undefined ) {

				var json = geometry.toJSON();

				delete json.metadata;

				geometries[ geometry.uuid ] = json;

				output.geometries.push( json );

			}

			return geometry.uuid;

		};

		//

		var materials = {};

		var parseMaterial = function ( material ) {

			if ( output.materials === undefined ) {

				output.materials = [];

			}

			if ( materials[ material.uuid ] === undefined ) {

				var json = material.toJSON();

				delete json.metadata;

				materials[ material.uuid ] = json;

				output.materials.push( json );

			}

			return material.uuid;

		};

		//

		var parseObject = function ( object ) {

			var data = {};

			data.uuid = object.uuid;
			data.type = object.type;

			if ( object.name !== '' ) data.name = object.name;
			if ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;
			if ( object.visible !== true ) data.visible = object.visible;

			if ( object instanceof THREE.PerspectiveCamera ) {

				data.fov = object.fov;
				data.aspect = object.aspect;
				data.near = object.near;
				data.far = object.far;

			} else if ( object instanceof THREE.OrthographicCamera ) {

				data.left = object.left;
				data.right = object.right;
				data.top = object.top;
				data.bottom = object.bottom;
				data.near = object.near;
				data.far = object.far;

			} else if ( object instanceof THREE.AmbientLight ) {

				data.color = object.color.getHex();

			} else if ( object instanceof THREE.DirectionalLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;

			} else if ( object instanceof THREE.PointLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;
				data.distance = object.distance;

			} else if ( object instanceof THREE.SpotLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;
				data.distance = object.distance;
				data.angle = object.angle;
				data.exponent = object.exponent;

			} else if ( object instanceof THREE.HemisphereLight ) {

				data.color = object.color.getHex();
				data.groundColor = object.groundColor.getHex();

			} else if ( object instanceof THREE.Mesh ) {

				data.geometry = parseGeometry( object.geometry );
				data.material = parseMaterial( object.material );

			} else if ( object instanceof THREE.Line ) {

				data.geometry = parseGeometry( object.geometry );
				data.material = parseMaterial( object.material );

			} else if ( object instanceof THREE.Sprite ) {

				data.material = parseMaterial( object.material );

			}

			data.matrix = object.matrix.toArray();

			if ( object.children.length > 0 ) {

				data.children = [];

				for ( var i = 0; i < object.children.length; i ++ ) {

					data.children.push( parseObject( object.children[ i ] ) );

				}

			}

			return data;

		}

		output.object = parseObject( this );

		return output;

	},

	clone: function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Object3D();
		if ( recursive === undefined ) recursive = true;

		object.name = this.name;

		object.up.copy( this.up );

		object.position.copy( this.position );
		object.quaternion.copy( this.quaternion );
		object.scale.copy( this.scale );

		object.renderDepth = this.renderDepth;

		object.rotationAutoUpdate = this.rotationAutoUpdate;

		object.matrix.copy( this.matrix );
		object.matrixWorld.copy( this.matrixWorld );

		object.matrixAutoUpdate = this.matrixAutoUpdate;
		object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

		object.visible = this.visible;

		object.castShadow = this.castShadow;
		object.receiveShadow = this.receiveShadow;

		object.frustumCulled = this.frustumCulled;

		object.userData = JSON.parse( JSON.stringify( this.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < this.children.length; i ++ ) {

				var child = this.children[ i ];
				object.add( child.clone() );

			}

		}

		return object;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Projector.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Projector = function () {

	console.warn( 'THREE.Projector has been moved to /examples/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function ( vector, camera ) {

		console.error( 'THREE.Projector: .pickingRay() has been removed.' );

	};

};

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		var face = new THREE.Face3( this.a, this.b, this.c );

		face.normal.copy( this.normal );
		face.color.copy( this.color );

		face.materialIndex = this.materialIndex;

		for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {

			face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {

			face.vertexColors[ i ] = this.vertexColors[ i ].clone();

		}

		for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {

			face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

		}

		return face;

	}

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )
	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

	this.array = array;
	this.itemSize = itemSize;

	this.needsUpdate = false;

};

THREE.BufferAttribute.prototype = {

	constructor: THREE.BufferAttribute,

	get length () {

		return this.array.length;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

	},

	set: function ( value ) {

		this.array.set( value );

		return this;

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	clone: function () {

		return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );

	}

};

//

THREE.Int8Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint8Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint8ClampedAttribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );


};

THREE.Int16Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint16Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Int32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Float32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Float64Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.attributes = {};
	this.attributesKeys = [];

	this.drawcalls = [];
	this.offsets = this.drawcalls; // backwards compatibility

	this.boundingBox = null;
	this.boundingSphere = null;

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addAttribute: function ( name, attribute ) {

		if ( attribute instanceof THREE.BufferAttribute === false ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

			return;

		}

		this.attributes[ name ] = attribute;
		this.attributesKeys = Object.keys( this.attributes );

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	addDrawCall: function ( start, count, indexOffset ) {

		this.drawcalls.push( {

			start: start,
			count: count,
			index: indexOffset !== undefined ? indexOffset : 0

		} );

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToVector3Array( normal.array );
			normal.needsUpdate = true;

		}

	},

	center: function () {

		// TODO

	},

	fromGeometry: function ( geometry, settings ) {

		settings = settings || { 'vertexColors': THREE.NoColors };

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var faceVertexUvs = geometry.faceVertexUvs;
		var vertexColors = settings.vertexColors;
		var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;

		var positions = new Float32Array( faces.length * 3 * 3 );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		var normals = new Float32Array( faces.length * 3 * 3 );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

		if ( vertexColors !== THREE.NoColors ) {

			var colors = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		}

		if ( hasFaceVertexUv === true ) {

			var uvs = new Float32Array( faces.length * 3 * 2 );
			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		}

		for ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {

			var face = faces[ i ];

			var a = vertices[ face.a ];
			var b = vertices[ face.b ];
			var c = vertices[ face.c ];

			positions[ i3     ] = a.x;
			positions[ i3 + 1 ] = a.y;
			positions[ i3 + 2 ] = a.z;

			positions[ i3 + 3 ] = b.x;
			positions[ i3 + 4 ] = b.y;
			positions[ i3 + 5 ] = b.z;

			positions[ i3 + 6 ] = c.x;
			positions[ i3 + 7 ] = c.y;
			positions[ i3 + 8 ] = c.z;

			if ( hasFaceVertexNormals === true ) {

				var na = face.vertexNormals[ 0 ];
				var nb = face.vertexNormals[ 1 ];
				var nc = face.vertexNormals[ 2 ];

				normals[ i3     ] = na.x;
				normals[ i3 + 1 ] = na.y;
				normals[ i3 + 2 ] = na.z;

				normals[ i3 + 3 ] = nb.x;
				normals[ i3 + 4 ] = nb.y;
				normals[ i3 + 5 ] = nb.z;

				normals[ i3 + 6 ] = nc.x;
				normals[ i3 + 7 ] = nc.y;
				normals[ i3 + 8 ] = nc.z;

			} else {

				var n = face.normal;

				normals[ i3     ] = n.x;
				normals[ i3 + 1 ] = n.y;
				normals[ i3 + 2 ] = n.z;

				normals[ i3 + 3 ] = n.x;
				normals[ i3 + 4 ] = n.y;
				normals[ i3 + 5 ] = n.z;

				normals[ i3 + 6 ] = n.x;
				normals[ i3 + 7 ] = n.y;
				normals[ i3 + 8 ] = n.z;

			}

			if ( vertexColors === THREE.FaceColors ) {

				var fc = face.color;

				colors[ i3     ] = fc.r;
				colors[ i3 + 1 ] = fc.g;
				colors[ i3 + 2 ] = fc.b;

				colors[ i3 + 3 ] = fc.r;
				colors[ i3 + 4 ] = fc.g;
				colors[ i3 + 5 ] = fc.b;

				colors[ i3 + 6 ] = fc.r;
				colors[ i3 + 7 ] = fc.g;
				colors[ i3 + 8 ] = fc.b;

			} else if ( vertexColors === THREE.VertexColors ) {

				var vca = face.vertexColors[ 0 ];
				var vcb = face.vertexColors[ 1 ];
				var vcc = face.vertexColors[ 2 ];

				colors[ i3     ] = vca.r;
				colors[ i3 + 1 ] = vca.g;
				colors[ i3 + 2 ] = vca.b;

				colors[ i3 + 3 ] = vcb.r;
				colors[ i3 + 4 ] = vcb.g;
				colors[ i3 + 5 ] = vcb.b;

				colors[ i3 + 6 ] = vcc.r;
				colors[ i3 + 7 ] = vcc.g;
				colors[ i3 + 8 ] = vcc.b;

			}

			if ( hasFaceVertexUv === true ) {

				var uva = faceVertexUvs[ 0 ][ i ][ 0 ];
				var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];
				var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];

				uvs[ i2     ] = uva.x;
				uvs[ i2 + 1 ] = uva.y;

				uvs[ i2 + 2 ] = uvb.x;
				uvs[ i2 + 3 ] = uvb.y;

				uvs[ i2 + 4 ] = uvc.x;
				uvs[ i2 + 5 ] = uvc.y;

			}

		}

		this.computeBoundingSphere()

		return this;

	},

	computeBoundingBox: function () {

		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				var bb = this.boundingBox;
				bb.makeEmpty();

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					bb.expandByPoint( vector );

				}

			}

			if ( positions === undefined || positions.length === 0 ) {

				this.boundingBox.min.set( 0, 0, 0 );
				this.boundingBox.max.set( 0, 0, 0 );

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.' );

			}

		}

	}(),

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				box.makeEmpty();

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					box.expandByPoint( vector );

				}

				box.center( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );

				}

			}

		}

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var attributes = this.attributes;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var normals = attributes.normal.array;

				for ( var i = 0, il = normals.length; i < il; i ++ ) {

					normals[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( attributes.index ) {

				var indices = attributes.index.array;

				var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );

				for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {

					var start = offsets[ j ].start;
					var count = offsets[ j ].count;
					var index = offsets[ j ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = ( index + indices[ i     ] ) * 3;
						vB = ( index + indices[ i + 1 ] ) * 3;
						vC = ( index + indices[ i + 2 ] ) * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA     ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB     ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC     ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i     ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( this.attributes.index === undefined ||
			 this.attributes.position === undefined ||
			 this.attributes.normal === undefined ||
			 this.attributes.uv === undefined ) {

			console.warn( 'Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
			return;

		}

		var indices = this.attributes.index.array;
		var positions = this.attributes.position.array;
		var normals = this.attributes.normal.array;
		var uvs = this.attributes.uv.array;

		var nVertices = positions.length / 3;

		if ( this.attributes.tangent === undefined ) {

			this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		var tangents = this.attributes.tangent.array;

		var tan1 = [], tan2 = [];

		for ( var k = 0; k < nVertices; k ++ ) {

			tan1[ k ] = new THREE.Vector3();
			tan2[ k ] = new THREE.Vector3();

		}

		var vA = new THREE.Vector3(),
			vB = new THREE.Vector3(),
			vC = new THREE.Vector3(),

			uvA = new THREE.Vector2(),
			uvB = new THREE.Vector2(),
			uvC = new THREE.Vector2(),

			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r;

		var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;

			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;

			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;

			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );

			sdir.set(
				( t2 * x1 - t1 * x2 ) * r,
				( t2 * y1 - t1 * y2 ) * r,
				( t2 * z1 - t1 * z2 ) * r
			);

			tdir.set(
				( s1 * x2 - s2 * x1 ) * r,
				( s1 * y2 - s2 * y1 ) * r,
				( s1 * z2 - s2 * z1 ) * r
			);

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		var i, il;
		var j, jl;
		var iA, iB, iC;

		if ( this.drawcalls.length === 0 ) {

			this.addDrawCall( 0, indices.length, 0 );

		}

		var drawcalls = this.drawcalls;

		for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

			var start = drawcalls[ j ].start;
			var count = drawcalls[ j ].count;
			var index = drawcalls[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleTriangle( iA, iB, iC );

			}

		}

		var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
		var n = new THREE.Vector3(), n2 = new THREE.Vector3();
		var w, t, test;

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			test = tmp2.dot( tan2[ v ] );
			w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4     ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

			var start = drawcalls[ j ].start;
			var count = drawcalls[ j ].count;
			var index = drawcalls[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleVertex( iA );
				handleVertex( iB );
				handleVertex( iC );

			}

		}

	},

	/*
		computeOffsets
		Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
		This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
		WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
		indexBufferSize - Defaults to 65535, but allows for larger or smaller chunks.
	*/
	computeOffsets: function ( indexBufferSize ) {

		var size = indexBufferSize;
		if ( indexBufferSize === undefined )
			size = 65535; //WebGL limits type of index buffer values to 16-bit.

		var s = Date.now();

		var indices = this.attributes.index.array;
		var vertices = this.attributes.position.array;

		var verticesCount = ( vertices.length / 3 );
		var facesCount = ( indices.length / 3 );

		/*
		console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
		console.log("Faces to process: "+(indices.length/3));
		console.log("Reordering "+verticesCount+" vertices.");
		*/

		var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
		var indexPtr = 0;
		var vertexPtr = 0;

		var offsets = [ { start:0, count:0, index:0 } ];
		var offset = offsets[ 0 ];

		var duplicatedVertices = 0;
		var newVerticeMaps = 0;
		var faceVertices = new Int32Array( 6 );
		var vertexMap = new Int32Array( vertices.length );
		var revVertexMap = new Int32Array( vertices.length );
		for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }

		/*
			Traverse every face and reorder vertices in the proper offsets of 65k.
			We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
		*/
		for ( var findex = 0; findex < facesCount; findex ++ ) {
			newVerticeMaps = 0;

			for ( var vo = 0; vo < 3; vo ++ ) {
				var vid = indices[ findex * 3 + vo ];
				if ( vertexMap[ vid ] == - 1 ) {
					//Unmapped vertice
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = - 1;
					newVerticeMaps ++;
				} else if ( vertexMap[ vid ] < offset.index ) {
					//Reused vertices from previous block (duplicate)
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = - 1;
					duplicatedVertices ++;
				} else {
					//Reused vertice in the current block
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
				}
			}

			var faceMax = vertexPtr + newVerticeMaps;
			if ( faceMax > ( offset.index + size ) ) {
				var new_offset = { start:indexPtr, count:0, index:vertexPtr };
				offsets.push( new_offset );
				offset = new_offset;

				//Re-evaluate reused vertices in light of new offset.
				for ( var v = 0; v < 6; v += 2 ) {
					var new_vid = faceVertices[ v + 1 ];
					if ( new_vid > - 1 && new_vid < offset.index )
						faceVertices[ v + 1 ] = - 1;
				}
			}

			//Reindex the face.
			for ( var v = 0; v < 6; v += 2 ) {
				var vid = faceVertices[ v ];
				var new_vid = faceVertices[ v + 1 ];

				if ( new_vid === - 1 )
					new_vid = vertexPtr ++;

				vertexMap[ vid ] = new_vid;
				revVertexMap[ new_vid ] = vid;
				sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
				offset.count ++;
			}
		}

		/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
		this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
		this.offsets = offsets;

		/*
		var orderTime = Date.now();
		console.log("Reorder time: "+(orderTime-s)+"ms");
		console.log("Duplicated "+duplicatedVertices+" vertices.");
		console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
		console.log("Draw offsets: "+offsets.length);
		*/

		return offsets;
	},

	merge: function () {

		console.log( 'BufferGeometry.merge(): TODO' );

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i     ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	/*
		reoderBuffers:
		Reorder attributes based on a new indexBuffer and indexMap.
		indexBuffer - Uint16Array of the new ordered indices.
		indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
		vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
	*/
	reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {

		/* Create a copy of all attributes for reordering. */
		var sortedAttributes = {};
		for ( var attr in this.attributes ) {
			if ( attr == 'index' )
				continue;
			var sourceArray = this.attributes[ attr ].array;
			sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
		}

		/* Move attribute positions based on the new index map */
		for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
			var vid = indexMap[ new_vid ];
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				var attrArray = this.attributes[ attr ].array;
				var attrSize = this.attributes[ attr ].itemSize;
				var sortedAttr = sortedAttributes[ attr ];
				for ( var k = 0; k < attrSize; k ++ )
					sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
			}
		}

		/* Carry the new sorted buffers locally */
		this.attributes[ 'index' ].array = indexBuffer;
		for ( var attr in this.attributes ) {
			if ( attr == 'index' )
				continue;
			this.attributes[ attr ].array = sortedAttributes[ attr ];
			this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
		}
	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.0,
				type: 'BufferGeometry',
				generator: 'BufferGeometryExporter'
			},
			uuid: this.uuid,
			type: this.type,
			data: {
				attributes: {}
			}
		};

		var attributes = this.attributes;
		var offsets = this.offsets;
		var boundingSphere = this.boundingSphere;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = [], typeArray = attribute.array;

			for ( var i = 0, l = typeArray.length; i < l; i ++ ) {

				array[ i ] = typeArray[ i ];

			}

			output.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array
			}

		}

		if ( offsets.length > 0 ) {

			output.data.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		if ( boundingSphere !== null ) {

			output.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			}

		}

		return output;

	},

	clone: function () {

		var geometry = new THREE.BufferGeometry();

		for ( var attr in this.attributes ) {

			var sourceAttr = this.attributes[ attr ];
			geometry.addAttribute( attr, sourceAttr.clone() );

		}

		for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

			var offset = this.offsets[ i ];

			geometry.offsets.push( {

				start: offset.start,
				index: offset.index,
				count: offset.count

			} );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];  // one-to-one vertex colors, used in Points and Line

	this.faces = [];

	this.faceVertexUvs = [ [] ];

	this.morphTargets = [];
	this.morphColors = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.tangentsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;

	this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox instanceof THREE.Box3 ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere instanceof THREE.Sphere ) {

			this.computeBoundingSphere();

		}

	},

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var attributes = geometry.attributes;

		var vertices = attributes.position.array;
		var indices = attributes.index !== undefined ? attributes.index.array : undefined;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;

		var tempNormals = [];
		var tempUVs = [];

		for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {

			scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

		}

		var addFace = function ( a, b, c ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );
			scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ], tempUVs[ b ], tempUVs[ c ] ] );

		};

		if ( indices !== undefined ) {

			for ( var i = 0; i < indices.length; i += 3 ) {

				addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

			}

		} else {

			for ( var i = 0; i < vertices.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}
		
		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = new THREE.Vector3();

		offset.addVectors( this.boundingBox.min, this.boundingBox.max );
		offset.multiplyScalar( - 0.5 );

		this.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
		this.computeBoundingBox();

		return offset;

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC, vD;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
				db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
			face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
			face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// tangents go to vertices

		var f, fl, v, vl, i, il, vertexIndex,
			face, uv, vA, vB, vC, uvA, uvB, uvC,
			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r, t, test,
			tan1 = [], tan2 = [],
			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
			n = new THREE.Vector3(), w;

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			tan1[ v ] = new THREE.Vector3();
			tan2[ v ] = new THREE.Vector3();

		}

		function handleTriangle( context, a, b, c, ua, ub, uc ) {

			vA = context.vertices[ a ];
			vB = context.vertices[ b ];
			vC = context.vertices[ c ];

			uvA = uv[ ua ];
			uvB = uv[ ub ];
			uvC = uv[ uc ];

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;
			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;
			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;
			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );
			sdir.set( ( t2 * x1 - t1 * x2 ) * r,
					  ( t2 * y1 - t1 * y2 ) * r,
					  ( t2 * z1 - t1 * z2 ) * r );
			tdir.set( ( s1 * x2 - s2 * x1 ) * r,
					  ( s1 * y2 - s2 * y1 ) * r,
					  ( s1 * z2 - s2 * z1 ) * r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

			handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

		}

		var faceIndex = [ 'a', 'b', 'c', 'd' ];

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

				n.copy( face.vertexNormals[ i ] );

				vertexIndex = face[ faceIndex[ i ] ];

				t = tan1[ vertexIndex ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( face.vertexNormals[ i ], t );
				test = tmp2.dot( tan2[ vertexIndex ] );
				w = ( test < 0.0 ) ? - 1.0 : 1.0;

				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

			}

		}

		this.hasTangents = true;

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( geometry instanceof THREE.Geometry === false ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			uvs1.push( uvCopy );

		}

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i,il, face;
		var indices, k, j, jl, u;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		};


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = - 1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {
				if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}
			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.0,
				type: 'BufferGeometry',
				generator: 'BufferGeometryExporter'
			},
			uuid: this.uuid,
			type: this.type
		};

		if ( this.name !== "" ) output.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];

			}

			return output;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = false; // face.materialIndex !== undefined;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 );
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );


			/*
			if ( hasMaterial ) {

				faces.push( face.materialIndex );

			}
			*/

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		output.data = {};

		output.data.vertices = vertices;
		output.data.normals = normals;
		if ( colors.length > 0 ) output.data.colors = colors;
		if ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility
		output.data.faces = faces;

		//

		return output;

	},

	clone: function () {

		var geometry = new THREE.Geometry();

		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			geometry.vertices.push( vertices[ i ].clone() );

		}

		var faces = this.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			geometry.faces.push( faces[ i ].clone() );

		}

		var uvs = this.faceVertexUvs[ 0 ];

		for ( var i = 0, il = uvs.length; i < il; i ++ ) {

			var uv = uvs[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			geometry.faceVertexUvs[ 0 ].push( uvCopy );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );

THREE.Camera.prototype.getWorldDirection = function () {

	var quaternion = new THREE.Quaternion();

	return function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	}

}();

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function ( camera ) {

	if ( camera === undefined ) camera = new THREE.Camera();

	THREE.Object3D.prototype.clone.call( this, camera );

	camera.matrixWorldInverse.copy( this.matrixWorldInverse );
	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.generateMipmaps;

		renderTarget.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	var dx = ( this.right - this.left ) / ( 2 * this.zoom );
	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
	var cx = ( this.right + this.left ) / 2;
	var cy = ( this.top + this.bottom ) / 2;

	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

	var camera = new THREE.OrthographicCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.zoom = this.zoom;

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;

	camera.near = this.near;
	camera.far = this.far;

	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.zoom = 1;

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
		var bottom = - top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.clone = function () {

	var camera = new THREE.PerspectiveCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.zoom = this.zoom;

	camera.fov = this.fov;
	camera.aspect = this.aspect;
	camera.near = this.near;
	camera.far = this.far;

	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

	THREE.Object3D.call( this );

	this.type = 'Light';
	
	this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );

THREE.Light.prototype.clone = function ( light ) {

	if ( light === undefined ) light = new THREE.Light();

	THREE.Object3D.prototype.clone.call( this, light );

	light.color.copy( this.color );

	return light;

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

	THREE.Light.call( this, color );

	this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );

THREE.AmbientLight.prototype.clone = function () {

	var light = new THREE.AmbientLight();

	THREE.Light.prototype.clone.call( this, light );

	return light;

};

// File:src/lights/AreaLight.js

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'AreaLight';

	this.normal = new THREE.Vector3( 0, - 1, 0 );
	this.right = new THREE.Vector3( 1, 0, 0 );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.width = 1.0;
	this.height = 1.0;

	this.constantAttenuation = 1.5;
	this.linearAttenuation = 0.5;
	this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );


// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'DirectionalLight';

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;

	this.shadowCameraLeft = - 500;
	this.shadowCameraRight = 500;
	this.shadowCameraTop = 500;
	this.shadowCameraBottom = - 500;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowCascade = false;

	this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
	this.shadowCascadeCount = 2;

	this.shadowCascadeBias = [ 0, 0, 0 ];
	this.shadowCascadeWidth = [ 512, 512, 512 ];
	this.shadowCascadeHeight = [ 512, 512, 512 ];

	this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
	this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

	this.shadowCascadeArray = [];

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );

THREE.DirectionalLight.prototype.clone = function () {

	var light = new THREE.DirectionalLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	//

	light.shadowCameraNear = this.shadowCameraNear;
	light.shadowCameraFar = this.shadowCameraFar;

	light.shadowCameraLeft = this.shadowCameraLeft;
	light.shadowCameraRight = this.shadowCameraRight;
	light.shadowCameraTop = this.shadowCameraTop;
	light.shadowCameraBottom = this.shadowCameraBottom;

	light.shadowCameraVisible = this.shadowCameraVisible;

	light.shadowBias = this.shadowBias;
	light.shadowDarkness = this.shadowDarkness;

	light.shadowMapWidth = this.shadowMapWidth;
	light.shadowMapHeight = this.shadowMapHeight;

	//

	light.shadowCascade = this.shadowCascade;

	light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
	light.shadowCascadeCount = this.shadowCascadeCount;

	light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
	light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
	light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );

	light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
	light.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );

	return light;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	THREE.Light.call( this, skyColor );

	this.type = 'HemisphereLight';

	this.position.set( 0, 100, 0 );

	this.groundColor = new THREE.Color( groundColor );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );

THREE.HemisphereLight.prototype.clone = function () {

	var light = new THREE.HemisphereLight();

	THREE.Light.prototype.clone.call( this, light );

	light.groundColor.copy( this.groundColor );
	light.intensity = this.intensity;

	return light;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( color, intensity, distance ) {

	THREE.Light.call( this, color );

	this.type = 'PointLight';

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );

THREE.PointLight.prototype.clone = function () {

	var light = new THREE.PointLight();

	THREE.Light.prototype.clone.call( this, light );

	light.intensity = this.intensity;
	light.distance = this.distance;

	return light;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent ) {

	THREE.Light.call( this, color );

	this.type = 'SpotLight';

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;
	this.shadowCameraFov = 50;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );

THREE.SpotLight.prototype.clone = function () {

	var light = new THREE.SpotLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;
	light.distance = this.distance;
	light.angle = this.angle;
	light.exponent = this.exponent;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	//

	light.shadowCameraNear = this.shadowCameraNear;
	light.shadowCameraFar = this.shadowCameraFar;
	light.shadowCameraFov = this.shadowCameraFov;

	light.shadowCameraVisible = this.shadowCameraVisible;

	light.shadowBias = this.shadowBias;
	light.shadowDarkness = this.shadowDarkness;

	light.shadowMapWidth = this.shadowMapWidth;
	light.shadowMapHeight = this.shadowMapHeight;

	return light;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = function () {

	this.files = {};

};

THREE.Cache.prototype = {

	constructor: THREE.Cache,

	add: function ( key, file ) {

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {}

	}

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

	this.showStatus = showStatus;
	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

	this.imageLoader = new THREE.ImageLoader();

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	addStatusElement: function () {

		var e = document.createElement( 'div' );

		e.style.position = 'absolute';
		e.style.right = '0px';
		e.style.top = '0px';
		e.style.fontSize = '0.8em';
		e.style.textAlign = 'left';
		e.style.background = 'rgba(0,0,0,0.25)';
		e.style.color = '#fff';
		e.style.width = '120px';
		e.style.padding = '0.5em 0.5em 0.5em 0.5em';
		e.style.zIndex = 1000;

		e.innerHTML = 'Loading ...';

		return e;

	},

	updateProgress: function ( progress ) {

		var message = 'Loaded ';

		if ( progress.total ) {

			message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';


		} else {

			message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';

		}

		this.statusDomElement.innerHTML = message;

	},

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath );

		}

		return array;

	},

	needsTangents: function ( materials ) {

		for ( var i = 0, il = materials.length; i < il; i ++ ) {

			var m = materials[ i ];

			if ( m instanceof THREE.ShaderMaterial ) return true;

		}

		return false;

	},

	createMaterial: function ( m, texturePath ) {

		var scope = this;

		function nearest_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.pow( 2, Math.round(  l ) );

		}

		function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

			var fullPath = texturePath + sourceFile;

			var texture;

			var loader = THREE.Loader.Handlers.get( fullPath );

			if ( loader !== null ) {

				texture = loader.load( fullPath );

			} else {

				texture = new THREE.Texture();

				loader = scope.imageLoader;
				loader.crossOrigin = scope.crossOrigin;
				loader.load( fullPath, function ( image ) {

					if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
						 THREE.Math.isPowerOfTwo( image.height ) === false ) {

						var width = nearest_pow2( image.width );
						var height = nearest_pow2( image.height );

						var canvas = document.createElement( 'canvas' );
						canvas.width = width;
						canvas.height = height;

						var context = canvas.getContext( '2d' );
						context.drawImage( image, 0, 0, width, height );

						texture.image = canvas;

					} else {

						texture.image = image;

					}

					texture.needsUpdate = true;

				} );

			}

			texture.sourceFile = sourceFile;

			if ( repeat ) {

				texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

				if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

			}

			if ( offset ) {

				texture.offset.set( offset[ 0 ], offset[ 1 ] );

			}

			if ( wrap ) {

				var wrapMap = {
					'repeat': THREE.RepeatWrapping,
					'mirror': THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

			}

			if ( anisotropy ) {

				texture.anisotropy = anisotropy;

			}

			where[ name ] = texture;

		}

		function rgb2hex( rgb ) {

			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

		}

		// defaults

		var mtype = 'MeshLambertMaterial';
		var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

		// parameters from model file

		if ( m.shading ) {

			var shading = m.shading.toLowerCase();

			if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
			else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

		}

		if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

			mpars.blending = THREE[ m.blending ];

		}

		if ( m.transparent !== undefined || m.opacity < 1.0 ) {

			mpars.transparent = m.transparent;

		}

		if ( m.depthTest !== undefined ) {

			mpars.depthTest = m.depthTest;

		}

		if ( m.depthWrite !== undefined ) {

			mpars.depthWrite = m.depthWrite;

		}

		if ( m.visible !== undefined ) {

			mpars.visible = m.visible;

		}

		if ( m.flipSided !== undefined ) {

			mpars.side = THREE.BackSide;

		}

		if ( m.doubleSided !== undefined ) {

			mpars.side = THREE.DoubleSide;

		}

		if ( m.wireframe !== undefined ) {

			mpars.wireframe = m.wireframe;

		}

		if ( m.vertexColors !== undefined ) {

			if ( m.vertexColors === 'face' ) {

				mpars.vertexColors = THREE.FaceColors;

			} else if ( m.vertexColors ) {

				mpars.vertexColors = THREE.VertexColors;

			}

		}

		// colors

		if ( m.colorDiffuse ) {

			mpars.color = rgb2hex( m.colorDiffuse );

		} else if ( m.DbgColor ) {

			mpars.color = m.DbgColor;

		}

		if ( m.colorSpecular ) {

			mpars.specular = rgb2hex( m.colorSpecular );

		}

		if ( m.colorAmbient ) {

			mpars.ambient = rgb2hex( m.colorAmbient );

		}

		if ( m.colorEmissive ) {

			mpars.emissive = rgb2hex( m.colorEmissive );

		}

		// modifiers

		if ( m.transparency ) {

			mpars.opacity = m.transparency;

		}

		if ( m.specularCoef ) {

			mpars.shininess = m.specularCoef;

		}

		// textures

		if ( m.mapDiffuse && texturePath ) {

			create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

		}

		if ( m.mapLight && texturePath ) {

			create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

		}

		if ( m.mapBump && texturePath ) {

			create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

		}

		if ( m.mapNormal && texturePath ) {

			create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

		}

		if ( m.mapSpecular && texturePath ) {

			create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

		}

		if ( m.mapAlpha && texturePath ) {

			create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

		}

		//

		if ( m.mapBumpScale ) {

			mpars.bumpScale = m.mapBumpScale;

		}

		// special case for normal mapped material

		if ( m.mapNormal ) {

			var shader = THREE.ShaderLib[ 'normalmap' ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			uniforms[ 'tNormal' ].value = mpars.normalMap;

			if ( m.mapNormalFactor ) {

				uniforms[ 'uNormalScale' ].value.set( m.mapNormalFactor, m.mapNormalFactor );

			}

			if ( mpars.map ) {

				uniforms[ 'tDiffuse' ].value = mpars.map;
				uniforms[ 'enableDiffuse' ].value = true;

			}

			if ( mpars.specularMap ) {

				uniforms[ 'tSpecular' ].value = mpars.specularMap;
				uniforms[ 'enableSpecular' ].value = true;

			}

			if ( mpars.lightMap ) {

				uniforms[ 'tAO' ].value = mpars.lightMap;
				uniforms[ 'enableAO' ].value = true;

			}

			// for the moment don't handle displacement texture

			uniforms[ 'diffuse' ].value.setHex( mpars.color );
			uniforms[ 'specular' ].value.setHex( mpars.specular );
			uniforms[ 'ambient' ].value.setHex( mpars.ambient );

			uniforms[ 'shininess' ].value = mpars.shininess;

			if ( mpars.opacity !== undefined ) {

				uniforms[ 'opacity' ].value = mpars.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
			var material = new THREE.ShaderMaterial( parameters );

			if ( mpars.transparent ) {

				material.transparent = true;

			}

		} else {

			var material = new THREE[ mtype ]( mpars );

		}

		if ( m.DbgName !== undefined ) material.name = m.DbgName;

		return material;

	}

};

THREE.Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

			var regex = this.handlers[ i ];
			var loader  = this.handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.cache = new THREE.Cache();
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = scope.cache.get( url );

		if ( cached !== undefined ) {

			if ( onLoad ) onLoad( cached );
			return;

		}

		var request = new XMLHttpRequest();
		request.open( 'GET', url, true );

		request.addEventListener( 'load', function ( event ) {

			scope.cache.add( url, this.response );

			if ( onLoad ) onLoad( this.response );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			request.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
		if ( this.responseType !== undefined ) request.responseType = this.responseType;

		request.send( null );

		scope.manager.itemStart( url );

	},

	setResponseType: function ( value ) {

		this.responseType = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.cache = new THREE.Cache();
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = scope.cache.get( url );

		if ( cached !== undefined ) {

			onLoad( cached );
			return;

		}

		var image = document.createElement( 'img' );

		if ( onLoad !== undefined ) {

			image.addEventListener( 'load', function ( event ) {

				scope.cache.add( url, this );

				onLoad( this );
				scope.manager.itemEnd( url );

			}, false );

		}

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			image.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		image.src = url;

		scope.manager.itemStart( url );

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

}

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

	var scope = this;

	// todo: unify load API to for easier SceneLoader use

	texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

	this.onLoadStart();
	this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	var length = 0;

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === xhr.DONE ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				if ( xhr.responseText ) {

					var json = JSON.parse( xhr.responseText );

					if ( json.metadata !== undefined && json.metadata.type === 'scene' ) {

						console.error( 'THREE.JSONLoader: "' + url + '" seems to be a Scene. Use THREE.SceneLoader instead.' );
						return;

					}

					var result = context.parse( json, texturePath );
					callback( result.geometry, result.materials );

				} else {

					console.error( 'THREE.JSONLoader: "' + url + '" seems to be unreachable or the file is empty.' );

				}

				// in context of more complex asset initialization
				// do not block on single failed file
				// maybe should go even one more level up

				context.onLoadComplete();

			} else {

				console.error( 'THREE.JSONLoader: Couldn\'t load "' + url + '" (' + xhr.status + ')' );

			}

		} else if ( xhr.readyState === xhr.LOADING ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( 'Content-Length' );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

			if ( callbackProgress !== undefined ) {

				length = xhr.getResponseHeader( 'Content-Length' );

			}

		}

	};

	xhr.open( 'GET', url, true );
	xhr.withCredentials = this.withCredentials;
	xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

	var scope = this,
	geometry = new THREE.Geometry(),
	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

	parseModel( scale );

	parseSkin();
	parseMorphing( scale );

	geometry.computeFaceNormals();
	geometry.computeBoundingSphere();

	function parseModel( scale ) {

		function isBitSet( value, position ) {

			return value & ( 1 << position );

		}

		var i, j, fi,

		offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

		type,
		isQuad,
		hasMaterial,
		hasFaceVertexUv,
		hasFaceNormal, hasFaceVertexNormal,
		hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, color, hex, normal,

		uvLayer, uv, u, v,

		faces = json.faces,
		vertices = json.vertices,
		normals = json.normals,
		colors = json.colors,

		nUvLayers = 0;

		if ( json.uvs !== undefined ) {

			// disregard empty arrays

			for ( i = 0; i < json.uvs.length; i ++ ) {

				if ( json.uvs[ i ].length ) nUvLayers ++;

			}

			for ( i = 0; i < nUvLayers; i ++ ) {

				geometry.faceVertexUvs[ i ] = [];

			}

		}

		offset = 0;
		zLength = vertices.length;

		while ( offset < zLength ) {

			vertex = new THREE.Vector3();

			vertex.x = vertices[ offset ++ ] * scale;
			vertex.y = vertices[ offset ++ ] * scale;
			vertex.z = vertices[ offset ++ ] * scale;

			geometry.vertices.push( vertex );

		}

		offset = 0;
		zLength = faces.length;

		while ( offset < zLength ) {

			type = faces[ offset ++ ];


			isQuad              = isBitSet( type, 0 );
			hasMaterial         = isBitSet( type, 1 );
			hasFaceVertexUv     = isBitSet( type, 3 );
			hasFaceNormal       = isBitSet( type, 4 );
			hasFaceVertexNormal = isBitSet( type, 5 );
			hasFaceColor	     = isBitSet( type, 6 );
			hasFaceVertexColor  = isBitSet( type, 7 );

			// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

			if ( isQuad ) {

				faceA = new THREE.Face3();
				faceA.a = faces[ offset ];
				faceA.b = faces[ offset + 1 ];
				faceA.c = faces[ offset + 3 ];

				faceB = new THREE.Face3();
				faceB.a = faces[ offset + 1 ];
				faceB.b = faces[ offset + 2 ];
				faceB.c = faces[ offset + 3 ];

				offset += 4;

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					faceA.materialIndex = materialIndex;
					faceB.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i ++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];
						geometry.faceVertexUvs[ i ][ fi + 1 ] = []

						for ( j = 0; j < 4; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
							if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					faceA.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

					faceB.normal.copy( faceA.normal );

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 4; i ++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);


						if ( i !== 2 ) faceA.vertexNormals.push( normal );
						if ( i !== 0 ) faceB.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					hex = colors[ colorIndex ];

					faceA.color.setHex( hex );
					faceB.color.setHex( hex );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 4; i ++ ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
						if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

					}

				}

				geometry.faces.push( faceA );
				geometry.faces.push( faceB );

			} else {

				face = new THREE.Face3();
				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					face.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i ++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];

						for ( j = 0; j < 3; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							geometry.faceVertexUvs[ i ][ fi ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					face.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 3; i ++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						face.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					face.color.setHex( colors[ colorIndex ] );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 3; i ++ ) {

						colorIndex = faces[ offset ++ ];
						face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

					}

				}

				geometry.faces.push( face );

			}

		}

	};

	function parseSkin() {
		var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

		if ( json.skinWeights ) {

			for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

				var x =                               json.skinWeights[ i     ];
				var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
				var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
				var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

			}

		}

		if ( json.skinIndices ) {

			for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

				var a =                               json.skinIndices[ i     ];
				var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
				var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
				var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

			}

		}

		geometry.bones = json.bones;

		if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

		}


		// could change this to json.animations[0] or remove completely

		geometry.animation = json.animation;
		geometry.animations = json.animations;

	};

	function parseMorphing( scale ) {

		if ( json.morphTargets !== undefined ) {

			var i, l, v, vl, dstVertices, srcVertices;

			for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

				geometry.morphTargets[ i ] = {};
				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
				geometry.morphTargets[ i ].vertices = [];

				dstVertices = geometry.morphTargets[ i ].vertices;
				srcVertices = json.morphTargets [ i ].vertices;

				for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

					var vertex = new THREE.Vector3();
					vertex.x = srcVertices[ v ] * scale;
					vertex.y = srcVertices[ v + 1 ] * scale;
					vertex.z = srcVertices[ v + 2 ] * scale;

					dstVertices.push( vertex );

				}

			}

		}

		if ( json.morphColors !== undefined ) {

			var i, l, c, cl, dstColors, srcColors, color;

			for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

				geometry.morphColors[ i ] = {};
				geometry.morphColors[ i ].name = json.morphColors[ i ].name;
				geometry.morphColors[ i ].colors = [];

				dstColors = geometry.morphColors[ i ].colors;
				srcColors = json.morphColors [ i ].colors;

				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

					color = new THREE.Color( 0xffaa00 );
					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
					dstColors.push( color );

				}

			}

		}

	};

	if ( json.materials === undefined || json.materials.length === 0 ) {

		return { geometry: geometry };

	} else {

		var materials = this.initMaterials( json.materials, texturePath );

		if ( this.needsTangents( materials ) ) {

			geometry.computeTangents();

		}

		return { geometry: geometry, materials: materials };

	}

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var loaded = 0, total = 0;

	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		total ++;

	};

	this.itemEnd = function ( url ) {

		loaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, loaded, total );

		}

		if ( loaded === total && scope.onLoad !== undefined ) {

			scope.onLoad();

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var attributes = json.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new self[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

		}

		var offsets = json.offsets;

		if ( offsets !== undefined ) {

			geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		var boundingSphere = json.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new THREE.Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];

		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;		
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometries = this.parseGeometries( json.geometries );
		var materials = this.parseMaterials( json.materials );
		var object = this.parseObject( json.object, geometries, materials );

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':

						geometry = new THREE.PlaneGeometry(
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new THREE.BoxGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data.data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data ).geometry;

						break;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];
				var material = loader.parse( data );

				material.uuid = data.uuid;

				if ( data.name !== undefined ) material.name = data.name;

				materials[ data.uuid ] = material;

			}

		}

		return materials;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

					}

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Mesh( geometry, material );

					break;

				case 'Line':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

					}

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Line( geometry, material );

					break;

				case 'Sprite':

					var material = materials[ data.material ];

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Sprite( material );

					break;

				case 'Group':

					object = new THREE.Group();

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			return object;

		}

	}()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.ImageLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			var texture = new THREE.Texture( image );
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function () {

	// override in sub classes
	this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

	constructor: THREE.CompressedTextureLoader,

	load: function ( url, onLoad, onError ) {

		var scope = this;

		var images = [];

		var texture = new THREE.CompressedTexture();
		texture.image = images;

		var loader = new THREE.XHRLoader();
		loader.setResponseType( 'arraybuffer' );

		if ( url instanceof Array ) {

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

 						if (texDatas.mipmapCount == 1)
 							texture.minFilter = THREE.LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				} );

			};

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			} );

		}

		return texture;

	}

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.depthTest = true;
	this.depthWrite = true;

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this.needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			if ( key in this ) {

				var currentValue = this[ key ];

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key == 'overdraw' ) {

					// ensure overdraw is backwards-compatable with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		}

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type
		};

		if ( this.name !== "" ) output.name = this.name;

		if ( this instanceof THREE.MeshBasicMaterial ) {

			output.color = this.color.getHex();
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshLambertMaterial ) {

			output.color = this.color.getHex();
			output.ambient = this.ambient.getHex();
			output.emissive = this.emissive.getHex();
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshPhongMaterial ) {

			output.color = this.color.getHex();
			output.ambient = this.ambient.getHex();
			output.emissive = this.emissive.getHex();
			output.specular = this.specular.getHex();
			output.shininess = this.shininess;
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshNormalMaterial ) {

			if ( this.shading !== THREE.FlatShading ) output.shading = this.shading;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshDepthMaterial ) {

			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.ShaderMaterial ) {

			output.uniforms = this.uniforms;
			output.vertexShader = this.vertexShader;
			output.fragmentShader = this.fragmentShader;

		} else if ( this instanceof THREE.SpriteMaterial ) {

			output.color = this.color.getHex();

		}

		if ( this.opacity < 1 ) output.opacity = this.opacity;
		if ( this.transparent !== false ) output.transparent = this.transparent;
		if ( this.wireframe !== false ) output.wireframe = this.wireframe;

		return output;

	},

	clone: function ( material ) {

		if ( material === undefined ) material = new THREE.Material();

		material.name = this.name;

		material.side = this.side;

		material.opacity = this.opacity;
		material.transparent = this.transparent;

		material.blending = this.blending;

		material.blendSrc = this.blendSrc;
		material.blendDst = this.blendDst;
		material.blendEquation = this.blendEquation;

		material.depthTest = this.depthTest;
		material.depthWrite = this.depthWrite;

		material.polygonOffset = this.polygonOffset;
		material.polygonOffsetFactor = this.polygonOffsetFactor;
		material.polygonOffsetUnits = this.polygonOffsetUnits;

		material.alphaTest = this.alphaTest;

		material.overdraw = this.overdraw;

		material.visible = this.visible;

		return material;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineBasicMaterial.prototype.clone = function () {

	var material = new THREE.LineBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;
	material.linecap = this.linecap;
	material.linejoin = this.linejoin;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineDashedMaterial.prototype.clone = function () {

	var material = new THREE.LineDashedMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;

	material.scale = this.scale;
	material.dashSize = this.dashSize;
	material.gapSize = this.gapSize;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshBasicMaterial.prototype.clone = function () {

	var material = new THREE.MeshBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;

	return material;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshLambertMaterial.prototype.clone = function () {

	var material = new THREE.MeshLambertMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhongMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhongMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );
	material.specular.copy( this.specular );
	material.shininess = this.shininess;

	material.metal = this.metal;

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.morphTargets = false;
	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshDepthMaterial.prototype.clone = function () {

	var material = new THREE.MeshDepthMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.shading = THREE.FlatShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshNormalMaterial.prototype.clone = function () {

	var material = new THREE.MeshNormalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

// File:src/materials/MeshFaceMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

	this.uuid = THREE.Math.generateUUID();

	this.type = 'MeshFaceMaterial';
	
	this.materials = materials instanceof Array ? materials : [];

};

THREE.MeshFaceMaterial.prototype = {

	constructor: THREE.MeshFaceMaterial,

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

			output.materials.push( this.materials[ i ].toJSON() );

		}

		return output;

	},

	clone: function () {

		var material = new THREE.MeshFaceMaterial();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		return material;

	}

};

// File:src/materials/PointCloudMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointCloudMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'PointCloudMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.PointCloudMaterial.prototype.clone = function () {

	var material = new THREE.PointCloudMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.size = this.size;
	material.sizeAttenuation = this.sizeAttenuation;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
	return new THREE.PointCloudMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
	return new THREE.PointCloudMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};
	this.attributes = null;

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	this.setValues( parameters );

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ShaderMaterial.prototype.clone = function () {

	var material = new THREE.ShaderMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.fragmentShader = this.fragmentShader;
	material.vertexShader = this.vertexShader;

	material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

	material.attributes = this.attributes;
	material.defines = this.defines;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	material.fog = this.fog;

	material.lights = this.lights;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;

	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

	THREE.ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );

THREE.RawShaderMaterial.prototype.clone = function () {

	var material = new THREE.RawShaderMaterial();

	THREE.ShaderMaterial.prototype.clone.call( this, material );

	return material;

};

// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteMaterial.prototype.clone = function () {

	var material = new THREE.SpriteMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;

	material.rotation = this.rotation;

	material.fog = this.fog;

	return material;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this._needsUpdate = false;
	this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = new THREE.UVMapping();

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	clone: function ( texture ) {

		if ( texture === undefined ) texture = new THREE.Texture();

		texture.image = this.image;
		texture.mipmaps = this.mipmaps.slice( 0 );

		texture.mapping = this.mapping;

		texture.wrapS = this.wrapS;
		texture.wrapT = this.wrapT;

		texture.magFilter = this.magFilter;
		texture.minFilter = this.minFilter;

		texture.anisotropy = this.anisotropy;

		texture.format = this.format;
		texture.type = this.type;

		texture.offset.copy( this.offset );
		texture.repeat.copy( this.repeat );

		texture.generateMipmaps = this.generateMipmaps;
		texture.premultiplyAlpha = this.premultiplyAlpha;
		texture.flipY = this.flipY;
		texture.unpackAlignment = this.unpackAlignment;

		return texture;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.images = images;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CubeTexture.clone = function ( texture ) {

	if ( texture === undefined ) texture = new THREE.CubeTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	texture.images = this.images;

	return texture;

};

// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CompressedTexture.prototype.clone = function () {

	var texture = new THREE.CompressedTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.DataTexture.prototype.clone = function () {

	var texture = new THREE.DataTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	var update = function () {

		requestAnimationFrame( update );

		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

			scope.needsUpdate = true;

		}

	};

	update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

	THREE.Object3D.call( this );

	this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );

// File:src/objects/PointCloud.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.PointCloud = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'PointCloud';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

	this.sortParticles = false;

};

THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );

THREE.PointCloud.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();

	return function ( raycaster, intersects ) {

		var object = this;
		var geometry = object.geometry;
		var threshold = raycaster.params.PointCloud.threshold;

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

				return;

			}

		}

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var position = new THREE.Vector3();

		var testPoint = function ( point, index ) {

			var rayPointDistance = ray.distanceToPoint( point );

			if ( rayPointDistance < localThreshold ) {

				var intersectPoint = ray.closestPointToPoint( point );
				intersectPoint.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				intersects.push( {

					distance: distance,
					distanceToRay: rayPointDistance,
					point: intersectPoint.clone(),
					index: index,
					face: null,
					object: object

				} );

			}

		};

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( attributes.index !== undefined ) {

				var indices = attributes.index.array;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					var offset = {
						start: 0,
						count: indices.length,
						index: 0
					};

					offsets = [ offset ];

				}

				for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

					var start = offsets[ oi ].start;
					var count = offsets[ oi ].count;
					var index = offsets[ oi ].index;

					for ( var i = start, il = start + count; i < il; i ++ ) {

						var a = index + indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				}

			} else {

				var pointCount = positions.length / 3;

				for ( var i = 0; i < pointCount; i ++ ) {

					position.set(
						positions[ 3 * i ],
						positions[ 3 * i + 1 ],
						positions[ 3 * i + 2 ]
					);

					testPoint( position, i );

				}

			}

		} else {

			var vertices = this.geometry.vertices;

			for ( var i = 0; i < vertices.length; i ++ ) {

				testPoint( vertices[ i ], i );

			}

		}

	};

}() );

THREE.PointCloud.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );

	object.sortParticles = this.sortParticles;

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.ParticleSystem = function ( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
	return new THREE.PointCloud( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

	THREE.Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	this.mode = ( mode !== undefined ) ? mode : THREE.LineStrip;

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );

THREE.Line.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	return function ( raycaster, intersects ) {

		var precision = raycaster.linePrecision;
		var precisionSq = precision * precision;

		var geometry = this.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		// Checking boundingSphere distance to ray

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		/* if ( geometry instanceof THREE.BufferGeometry ) {

		} else */ if ( geometry instanceof THREE.Geometry ) {

			var vertices = geometry.vertices;
			var nbVertices = vertices.length;
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this.mode === THREE.LineStrip ? 1 : 2;

			for ( var i = 0; i < nbVertices - 1; i = i + step ) {

				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > precisionSq ) continue;

				var distance = ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	};

}() );

THREE.Line.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Mesh';
	
	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = - 1;
		this.morphTargetForcedOrder = [];
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.log( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

	return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		var geometry = this.geometry;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		// Check boundingBox before continuing

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false )  {

				return;

			}

		}

		if ( geometry instanceof THREE.BufferGeometry ) {

			var material = this.material;

			if ( material === undefined ) return;

			var attributes = geometry.attributes;

			var a, b, c;
			var precision = raycaster.precision;

			if ( attributes.index !== undefined ) {

				var indices = attributes.index.array;
				var positions = attributes.position.array;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					offsets = [ { start: 0, count: indices.length, index: 0 } ];

				}

				for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

					var start = offsets[ oi ].start;
					var count = offsets[ oi ].count;
					var index = offsets[ oi ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						a = index + indices[ i ];
						b = index + indices[ i + 1 ];
						c = index + indices[ i + 2 ];

						vA.fromArray( positions, a * 3 );
						vB.fromArray( positions, b * 3 );
						vC.fromArray( positions, c * 3 );

						if ( material.side === THREE.BackSide ) {

							var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

						} else {

							var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							faceIndex: null,
							object: this

						} );

					}

				}

			} else {

				var positions = attributes.position.array;

				for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {

					a = i;
					b = i + 1;
					c = i + 2;

					vA.fromArray( positions, j );
					vB.fromArray( positions, j + 3 );
					vC.fromArray( positions, j + 6 );

					if ( material.side === THREE.BackSide ) {

						var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

					} else {

						var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
			var objectMaterials = isFaceMaterial === true ? this.material.materials : null;

			var a, b, c, d;
			var precision = raycaster.precision;

			var vertices = geometry.vertices;

			for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

				var face = geometry.faces[ f ];

				var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;

				if ( material === undefined ) continue;

				a = vertices[ face.a ];
				b = vertices[ face.b ];
				c = vertices[ face.c ];

				if ( material.morphTargets === true ) {

					var morphTargets = geometry.morphTargets;
					var morphInfluences = this.morphTargetInfluences;

					vA.set( 0, 0, 0 );
					vB.set( 0, 0, 0 );
					vC.set( 0, 0, 0 );

					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

						var influence = morphInfluences[ t ];

						if ( influence === 0 ) continue;

						var targets = morphTargets[ t ].vertices;

						vA.x += ( targets[ face.a ].x - a.x ) * influence;
						vA.y += ( targets[ face.a ].y - a.y ) * influence;
						vA.z += ( targets[ face.a ].z - a.z ) * influence;

						vB.x += ( targets[ face.b ].x - b.x ) * influence;
						vB.y += ( targets[ face.b ].y - b.y ) * influence;
						vB.z += ( targets[ face.b ].z - b.z ) * influence;

						vC.x += ( targets[ face.c ].x - c.x ) * influence;
						vC.y += ( targets[ face.c ].y - c.y ) * influence;
						vC.z += ( targets[ face.c ].z - c.z ) * influence;

					}

					vA.add( a );
					vB.add( b );
					vC.add( c );

					a = vA;
					b = vB;
					c = vC;

				}

				if ( material.side === THREE.BackSide ) {

					var intersectionPoint = ray.intersectTriangle( c, b, a, true );

				} else {

					var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

				}

				if ( intersectionPoint === null ) continue;

				intersectionPoint.applyMatrix4( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

				if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					point: intersectionPoint,
					face: face,
					faceIndex: f,
					object: this

				} );

			}

		}

	};

}() );

THREE.Mesh.prototype.clone = function ( object, recursive ) {

	if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object, recursive );

	return object;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( belongsToSkin ) {

	THREE.Object3D.call( this );

	this.skin = belongsToSkin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );


// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new THREE.Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
		//       16x16 pixel texture max   64 bones (16 * 16 / 4)
		//       32x32 pixel texture max  256 bones (32 * 32 / 4)
		//       64x64 pixel texture max 1024 bones (64 * 64 / 4)

		var size;

		if ( this.bones.length > 256 )
			size = 64;
		else if ( this.bones.length > 64 )
			size = 32;
		else if ( this.bones.length > 16 )
			size = 16;
		else
			size = 8;

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
		this.boneTexture.minFilter = THREE.NearestFilter;
		this.boneTexture.magFilter = THREE.NearestFilter;
		this.boneTexture.generateMipmaps = false;
		this.boneTexture.flipY = false;

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new THREE.Matrix4() );

			}

		}

	}

};

THREE.Skeleton.prototype.calculateInverses = function () {

	this.boneInverses = [];

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		var inverse = new THREE.Matrix4();

		if ( this.bones[ b ] ) {

			inverse.getInverse( this.bones[ b ].matrixWorld );

		}

		this.boneInverses.push( inverse );

	}

};

THREE.Skeleton.prototype.pose = function () {

	var bone;

	// recover the bind-time world matrices

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			bone.matrixWorld.getInverse( this.boneInverses[ b ] );

		}

	}

	// compute the local matrices, positions, rotations and scales

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			if ( bone.parent ) {

				bone.matrix.getInverse( bone.parent.matrixWorld );
				bone.matrix.multiply( bone.matrixWorld );

			} else {

				bone.matrix.copy( bone.matrixWorld );

			}

			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

		}

	}

};

THREE.Skeleton.prototype.update = ( function () {

	var offsetMatrix = new THREE.Matrix4();
	
	return function () {

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform

			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}
		
	};

} )();


// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new THREE.Matrix4();
	this.bindMatrixInverse = new THREE.Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone, p, q, s;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

			gbone = this.geometry.bones[ b ];

			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;

			bone = new THREE.Bone( this );
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
			bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );

			if ( s !== undefined ) {

				bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );

			} else {

				bone.scale.set( 1, 1, 1 );

			}

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 ) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

	this.skeleton = skeleton;

	if ( bindMatrix === undefined ) {

		this.updateMatrixWorld( true );

		bindMatrix = this.matrixWorld;

	}

	this.bindMatrix.copy( bindMatrix );
	this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

	this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

	THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

	if ( this.bindMode === "attached" ) {

		this.bindMatrixInverse.getInverse( this.matrixWorld );

	} else if ( this.bindMode === "detached" ) {

		this.bindMatrixInverse.getInverse( this.bindMatrix );

	} else {

		console.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );

	}

};

THREE.SkinnedMesh.prototype.clone = function( object ) {

	if ( object === undefined ) {

		object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

	}

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};


// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'MorphAnimMesh';

	// API

	this.duration = 1000; // milliseconds
	this.mirroredLoop = false;
	this.time = 0;

	// internals

	this.lastKeyframe = 0;
	this.currentKeyframe = 0;

	this.direction = 1;
	this.directionBackwards = false;

	this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

	this.startKeyframe = start;
	this.endKeyframe = end;

	this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

	this.direction = 1;
	this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

	this.direction = - 1;
	this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

	var geometry = this.geometry;

	if ( ! geometry.animations ) geometry.animations = {};

	var firstAnimation, animations = geometry.animations;

	var pattern = /([a-z]+)_?(\d+)/;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var parts = morph.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var label = parts[ 1 ];
			var num = parts[ 2 ];

			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

			var animation = animations[ label ];

			if ( i < animation.start ) animation.start = i;
			if ( i > animation.end ) animation.end = i;

			if ( ! firstAnimation ) firstAnimation = label;

		}

	}

	geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

	if ( ! this.geometry.animations ) this.geometry.animations = {};

	this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

	var animation = this.geometry.animations[ label ];

	if ( animation ) {

		this.setFrameRange( animation.start, animation.end );
		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
		this.time = 0;

	} else {

		console.warn( 'animation[' + label + '] undefined' );

	}

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

	var frameTime = this.duration / this.length;

	this.time += this.direction * delta;

	if ( this.mirroredLoop ) {

		if ( this.time > this.duration || this.time < 0 ) {

			this.direction *= - 1;

			if ( this.time > this.duration ) {

				this.time = this.duration;
				this.directionBackwards = true;

			}

			if ( this.time < 0 ) {

				this.time = 0;
				this.directionBackwards = false;

			}

		}

	} else {

		this.time = this.time % this.duration;

		if ( this.time < 0 ) this.time += this.duration;

	}

	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

	if ( keyframe !== this.currentKeyframe ) {

		this.morphTargetInfluences[ this.lastKeyframe ] = 0;
		this.morphTargetInfluences[ this.currentKeyframe ] = 1;

		this.morphTargetInfluences[ keyframe ] = 0;

		this.lastKeyframe = this.currentKeyframe;
		this.currentKeyframe = keyframe;

	}

	var mix = ( this.time % frameTime ) / frameTime;

	if ( this.directionBackwards ) {

		mix = 1 - mix;

	}

	this.morphTargetInfluences[ this.currentKeyframe ] = mix;
	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

	var influences = this.morphTargetInfluences;

	for ( var i = 0, l = influences.length; i < l; i ++ ) {

		influences[ i ] = 0;

	}

	if ( a > -1 ) influences[ a ] = 1 - t;
	if ( b > -1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

	object.duration = this.duration;
	object.mirroredLoop = this.mirroredLoop;
	object.time = this.time;

	object.lastKeyframe = this.lastKeyframe;
	object.currentKeyframe = this.currentKeyframe;

	object.direction = this.direction;
	object.directionBackwards = this.directionBackwards;

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	for ( var l = 0; l < this.objects.length; l ++ ) {

		if ( distance < this.objects[ l ].distance ) {

			break;

		}

	}

	this.objects.splice( l, 0, { distance: distance, object: object } );
	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

		if ( distance < this.objects[ i ].distance ) {

			break;

		}

	}

	return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( matrixPosition );

		this.getObjectForDistance( distance ).raycast( raycaster, intersects );

	};

}() );

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( camera ) {

		if ( this.objects.length > 1 ) {

			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			this.objects[ 0 ].object.visible = true;

			for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

				if ( distance >= this.objects[ i ].distance ) {

					this.objects[ i - 1 ].object.visible = false;
					this.objects[ i     ].object.visible = true;

				} else {

					break;

				}

			}

			for ( ; i < l; i ++ ) {

				this.objects[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.LOD();

	THREE.Object3D.prototype.clone.call( this, object );

	for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
		var x = this.objects[ i ].object.clone();
		x.visible = i === 0;
		object.addLevel( x, this.objects[ i ].distance );
	}

	return object;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	return function ( material ) {

		THREE.Object3D.call( this );

		this.type = 'Sprite';

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

	};

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );

THREE.Sprite.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.distanceToPoint( matrixPosition );

		if ( distance > this.scale.x ) {

			return;

		}

		intersects.push( {

			distance: distance,
			point: this.position,
			face: null,
			object: this

		} );

	};

}() );

THREE.Sprite.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Sprite( this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if ( size === undefined ) size = - 1;
	if ( distance === undefined ) distance = 0;
	if ( opacity === undefined ) opacity = 1;
	if ( color === undefined ) color = new THREE.Color( 0xffffff );
	if ( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( {
		texture: texture, 			// THREE.Texture
		size: size, 				// size in pixels (-1 = use texture.width)
		distance: distance, 		// distance (0-1) from light source (0=at light source)
		x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
		scale: 1, 					// scale
		rotation: 1, 				// rotation
		opacity: opacity,			// opacity
		color: color,				// color
		blending: blending			// blending
	} );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = - this.positionScreen.x * 2;
	var vecY = - this.positionScreen.y * 2;

	for( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};


// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.type = 'Scene';

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );

THREE.Scene.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Scene();

	THREE.Object3D.prototype.clone.call( this, object );

	if ( this.fog !== null ) object.fog = this.fog.clone();
	if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

	object.autoUpdate = this.autoUpdate;
	object.matrixAutoUpdate = this.matrixAutoUpdate;

	return object;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new THREE.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new THREE.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n	vec3 dirVector = normalize( lDirection.xyz );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float lDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

THREE.ShaderChunk[ 'default_vertex'] = "vec4 mvPosition;\n\n#ifdef USE_SKINNING\n\n	mvPosition = modelViewMatrix * skinned;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\n	mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl

THREE.ShaderChunk[ 'lightmap_pars_vertex'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n	normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	vec3 pointDiffuse = vec3( 0.0 );\n	vec3 pointSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n				// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	vec3 spotDiffuse = vec3( 0.0 );\n	vec3 spotSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( spotLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n					// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n					// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	vec3 dirDiffuse = vec3( 0.0 );\n	vec3 dirSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n		vec3 dirVector = normalize( lDirection.xyz );\n\n				// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	vec3 hemiDiffuse = vec3( 0.0 );\n	vec3 hemiSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		hemiDiffuse += diffuse * hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n	totalDiffuse += dirDiffuse;\n	totalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	totalDiffuse += hemiDiffuse;\n	totalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	totalDiffuse += pointDiffuse;\n	totalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	totalDiffuse += spotDiffuse;\n	totalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	uniform samplerCube envMap;\n	uniform float flipEnvMap;\n	uniform int combine;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform bool useRefract;\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n			// Per-Pixel Tangent Space Normal Mapping\n			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	#ifdef GAMMA_INPUT\n\n		texelColor.xyz *= texelColor.xyz;\n\n	#endif\n\n	gl_FragColor = gl_FragColor * texelColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl

THREE.ShaderChunk[ 'lightmap_vertex'] = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	#ifdef GAMMA_INPUT\n\n		vColor = color * color;\n\n	#else\n\n		vColor = color;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n	uniform bool useRefract;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "#ifdef GAMMA_OUTPUT\n\n	gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl

THREE.ShaderChunk[ 'map_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	vec3 reflectVec;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n		// Transforming Normal Vectors with the Inverse Transformation\n\n		vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n		if ( useRefract ) {\n\n			reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		} else { \n\n			reflectVec = reflect( cameraToVertex, worldNormal );\n\n		}\n\n	#else\n\n		reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n		vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#else\n\n		vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#endif\n\n	#ifdef GAMMA_INPUT\n\n		cubeColor.xyz *= cubeColor.xyz;\n\n	#endif\n\n	if ( combine == 1 ) {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\n	} else if ( combine == 2 ) {\n\n		gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\n	} else {\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		const float LOG2 = 1.442695;\n		float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "vec3 objectNormal;\n\n#ifdef USE_SKINNING\n\n	objectNormal = skinnedNormal.xyz;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\n	objectNormal = morphedNormal;\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\n	objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl

THREE.ShaderChunk[ 'map_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n	worldNormal = normalize( worldNormal );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	if ( useRefract ) {\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	} else {\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	#ifdef GAMMA_OUTPUT\n\n		shadowColor *= shadowColor;\n\n	#endif\n\n	gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#endif\n\n	#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#endif\n\n	#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( parameter_src instanceof Array ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"lightMap" : { type: "t", value: null },
		"specularMap" : { type: "t", value: null },
		"alphaMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: - 1 },
		"useRefract" : { type: "i", value: 0 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 },
		"combine" : { type: "i", value: 0 },

		"morphTargetInfluences" : { type: "f", value: 0 }

	},

	bump: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] }

	},

	particle: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

			"	#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	#endif",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

			"	#ifdef DOUBLE_SIDED",

					//"float isFront = float( gl_FrontFacing );",
					//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

			"		if ( gl_FrontFacing )",
			"			gl_FragColor.xyz *= vLightFront;",
			"		else",
			"			gl_FragColor.xyz *= vLightBack;",

			"	#else",

			"		gl_FragColor.xyz *= vLightFront;",

			"	#endif",

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bump" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	vNormal = normalize( transformedNormal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"	vViewPosition = -mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"#define PHONG",

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'particle_basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "particle" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

			"	#ifdef USE_SIZEATTENUATION",
			"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
			"	#else",
			"		gl_PointSize = size;",
			"	#endif",

			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],
				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( psColor, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale"    : { type: "f", value: 1 },
				"dashSize" : { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vLineDistance = scale * lineDistance;",

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

			"		discard;",

			"	}",

			"	gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

			"	#else",

			"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"	#endif",

			"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
			"	gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join("\n")

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Normal map shader
	//		- Blinn-Phong
	//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
	//		- point and directional lights (use with "lights: true" material option)
	 ------------------------------------------------------------------------- */

	'normalmap' : {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{

			"enableAO"          : { type: "i", value: 0 },
			"enableDiffuse"     : { type: "i", value: 0 },
			"enableSpecular"    : { type: "i", value: 0 },
			"enableReflection"  : { type: "i", value: 0 },
			"enableDisplacement": { type: "i", value: 0 },

			"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
			"tDiffuse"     : { type: "t", value: null },
			"tCube"        : { type: "t", value: null },
			"tNormal"      : { type: "t", value: null },
			"tSpecular"    : { type: "t", value: null },
			"tAO"          : { type: "t", value: null },

			"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"uDisplacementBias": { type: "f", value: 0.0 },
			"uDisplacementScale": { type: "f", value: 1.0 },

			"diffuse": { type: "c", value: new THREE.Color( 0xffffff ) },
			"specular": { type: "c", value: new THREE.Color( 0x111111 ) },
			"ambient": { type: "c", value: new THREE.Color( 0xffffff ) },
			"shininess": { type: "f", value: 30 },
			"opacity": { type: "f", value: 1 },

			"useRefract": { type: "i", value: 0 },
			"refractionRatio": { type: "f", value: 0.98 },
			"reflectivity": { type: "f", value: 0.5 },

			"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
			"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"wrapRGB" : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

			}

		] ),

		fragmentShader: [

			"uniform vec3 ambient;",
			"uniform vec3 diffuse;",
			"uniform vec3 specular;",
			"uniform float shininess;",
			"uniform float opacity;",

			"uniform bool enableDiffuse;",
			"uniform bool enableSpecular;",
			"uniform bool enableAO;",
			"uniform bool enableReflection;",

			"uniform sampler2D tDiffuse;",
			"uniform sampler2D tNormal;",
			"uniform sampler2D tSpecular;",
			"uniform sampler2D tAO;",

			"uniform samplerCube tCube;",

			"uniform vec2 uNormalScale;",

			"uniform bool useRefract;",
			"uniform float refractionRatio;",
			"uniform float reflectivity;",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"uniform vec3 ambientLightColor;",

			"#if MAX_DIR_LIGHTS > 0",

			"	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

			"#endif",

			"#if MAX_HEMI_LIGHTS > 0",

			"	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

			"#endif",

			"#if MAX_POINT_LIGHTS > 0",

			"	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#endif",

			"#if MAX_SPOT_LIGHTS > 0",

			"	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
			"	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#endif",

			"#ifdef WRAP_AROUND",

			"	uniform vec3 wrapRGB;",

			"#endif",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",
				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

			"	vec3 specularTex = vec3( 1.0 );",

			"	vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
			"	normalTex.xy *= uNormalScale;",
			"	normalTex = normalize( normalTex );",

			"	if( enableDiffuse ) {",

			"		#ifdef GAMMA_INPUT",

			"			vec4 texelColor = texture2D( tDiffuse, vUv );",
			"			texelColor.xyz *= texelColor.xyz;",

			"			gl_FragColor = gl_FragColor * texelColor;",

			"		#else",

			"			gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

			"		#endif",

			"	}",

			"	if( enableAO ) {",

			"		#ifdef GAMMA_INPUT",

			"			vec4 aoColor = texture2D( tAO, vUv );",
			"			aoColor.xyz *= aoColor.xyz;",

			"			gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",

			"		#else",

			"			gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

			"		#endif",

			"	}",
			
			THREE.ShaderChunk[ "alphatest_fragment" ],

			"	if( enableSpecular )",
			"		specularTex = texture2D( tSpecular, vUv ).xyz;",

			"	mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
			"	vec3 finalNormal = tsb * normalTex;",

			"	#ifdef FLIP_SIDED",

			"		finalNormal = -finalNormal;",

			"	#endif",

			"	vec3 normal = normalize( finalNormal );",
			"	vec3 viewPosition = normalize( vViewPosition );",

				// point lights

			"	#if MAX_POINT_LIGHTS > 0",

			"		vec3 pointDiffuse = vec3( 0.0 );",
			"		vec3 pointSpecular = vec3( 0.0 );",

			"		for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

			"			vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
			"			vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

			"			float pointDistance = 1.0;",
			"			if ( pointLightDistance[ i ] > 0.0 )",
			"				pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

			"			pointVector = normalize( pointVector );",

						// diffuse

			"			#ifdef WRAP_AROUND",

			"				float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
			"				float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

			"				vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

			"			#else",

			"				float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

			"			#endif",

			"			pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;",

						// specular

			"			vec3 pointHalfVector = normalize( pointVector + viewPosition );",
			"			float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
			"			float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

			"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );",
			"			pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

			"		}",

			"	#endif",

				// spot lights

			"	#if MAX_SPOT_LIGHTS > 0",

			"		vec3 spotDiffuse = vec3( 0.0 );",
			"		vec3 spotSpecular = vec3( 0.0 );",

			"		for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

			"			vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
			"			vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

			"			float spotDistance = 1.0;",
			"			if ( spotLightDistance[ i ] > 0.0 )",
			"				spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

			"			spotVector = normalize( spotVector );",

			"			float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

			"			if ( spotEffect > spotLightAngleCos[ i ] ) {",

			"				spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );",

							// diffuse

			"				#ifdef WRAP_AROUND",

			"					float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
			"					float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

			"					vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

			"				#else",

			"					float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

			"				#endif",

			"				spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;",

							// specular

			"				vec3 spotHalfVector = normalize( spotVector + viewPosition );",
			"				float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
			"				float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

			"				float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"				vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );",
			"				spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

			"			}",

			"		}",

			"	#endif",

				// directional lights

			"	#if MAX_DIR_LIGHTS > 0",

			"		vec3 dirDiffuse = vec3( 0.0 );",
			"		vec3 dirSpecular = vec3( 0.0 );",

			"		for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

			"			vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
			"			vec3 dirVector = normalize( lDirection.xyz );",

						// diffuse

			"			#ifdef WRAP_AROUND",

			"				float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
			"				float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

			"				vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

			"			#else",

			"				float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

			"			#endif",

			"			dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;",

						// specular

			"			vec3 dirHalfVector = normalize( dirVector + viewPosition );",
			"			float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
			"			float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

			"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );",
			"			dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

			"		}",

			"	#endif",

				// hemisphere lights

			"	#if MAX_HEMI_LIGHTS > 0",

			"		vec3 hemiDiffuse = vec3( 0.0 );",
			"		vec3 hemiSpecular = vec3( 0.0 );" ,

			"		for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

			"			vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
			"			vec3 lVector = normalize( lDirection.xyz );",

						// diffuse

			"			float dotProduct = dot( normal, lVector );",
			"			float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

			"			vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

			"			hemiDiffuse += diffuse * hemiColor;",

						// specular (sky light)


			"			vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
			"			float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
			"			float hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );",

						// specular (ground light)

			"			vec3 lVectorGround = -lVector;",

			"			vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
			"			float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
			"			float hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );",

			"			float dotProductGround = dot( normal, lVectorGround );",

			"			float specularNormalization = ( shininess + 2.0 ) / 8.0;",

			"			vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );",
			"			vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );",
			"			hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

			"		}",

			"	#endif",

				// all lights contribution summation

			"	vec3 totalDiffuse = vec3( 0.0 );",
			"	vec3 totalSpecular = vec3( 0.0 );",

			"	#if MAX_DIR_LIGHTS > 0",

			"		totalDiffuse += dirDiffuse;",
			"		totalSpecular += dirSpecular;",

			"	#endif",

			"	#if MAX_HEMI_LIGHTS > 0",

			"		totalDiffuse += hemiDiffuse;",
			"		totalSpecular += hemiSpecular;",

			"	#endif",

			"	#if MAX_POINT_LIGHTS > 0",

			"		totalDiffuse += pointDiffuse;",
			"		totalSpecular += pointSpecular;",

			"	#endif",

			"	#if MAX_SPOT_LIGHTS > 0",

			"		totalDiffuse += spotDiffuse;",
			"		totalSpecular += spotSpecular;",

			"	#endif",

			"	#ifdef METAL",

			"		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );",

			"	#else",

			"		gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

			"	#endif",

			"	if ( enableReflection ) {",

			"		vec3 vReflect;",
			"		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

			"		if ( useRefract ) {",

			"			vReflect = refract( cameraToVertex, normal, refractionRatio );",

			"		} else {",

			"			vReflect = reflect( cameraToVertex, normal );",

			"		}",

			"		vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

			"		#ifdef GAMMA_INPUT",

			"			cubeColor.xyz *= cubeColor.xyz;",

			"		#endif",

			"		gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );",

			"	}",

				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n"),

		vertexShader: [

			"attribute vec4 tangent;",

			"uniform vec2 uOffset;",
			"uniform vec2 uRepeat;",

			"uniform bool enableDisplacement;",

			"#ifdef VERTEX_TEXTURES",

			"	uniform sampler2D tDisplacement;",
			"	uniform float uDisplacementScale;",
			"	uniform float uDisplacementBias;",

			"#endif",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],

				// normal, tangent and binormal vectors

			"	#ifdef USE_SKINNING",

			"		vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

			"		vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
			"		vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

			"	#else",

			"		vNormal = normalize( normalMatrix * normal );",
			"		vTangent = normalize( normalMatrix * tangent.xyz );",

			"	#endif",

			"	vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

			"	vUv = uv * uRepeat + uOffset;",

				// displacement mapping

			"	vec3 displacedPosition;",

			"	#ifdef VERTEX_TEXTURES",

			"		if ( enableDisplacement ) {",

			"			vec3 dv = texture2D( tDisplacement, uv ).xyz;",
			"			float df = uDisplacementScale * dv.x + uDisplacementBias;",
			"			displacedPosition = position + normalize( normal ) * df;",

			"		} else {",

			"			#ifdef USE_SKINNING",

			"				vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

			"				vec4 skinned = vec4( 0.0 );",
			"				skinned += boneMatX * skinVertex * skinWeight.x;",
			"				skinned += boneMatY * skinVertex * skinWeight.y;",
			"				skinned += boneMatZ * skinVertex * skinWeight.z;",
			"				skinned += boneMatW * skinVertex * skinWeight.w;",
			"				skinned  = bindMatrixInverse * skinned;",

			"				displacedPosition = skinned.xyz;",

			"			#else",

			"				displacedPosition = position;",

			"			#endif",

			"		}",

			"	#else",

			"		#ifdef USE_SKINNING",

			"			vec4 skinVertex = bindMatrix * vec4( position, 1.0 );",

			"			vec4 skinned = vec4( 0.0 );",
			"			skinned += boneMatX * skinVertex * skinWeight.x;",
			"			skinned += boneMatY * skinVertex * skinWeight.y;",
			"			skinned += boneMatZ * skinVertex * skinWeight.z;",
			"			skinned += boneMatW * skinVertex * skinWeight.w;",
			"			skinned  = bindMatrixInverse * skinned;",

			"			displacedPosition = skinned.xyz;",

			"		#else",

			"			displacedPosition = position;",

			"		#endif",

			"	#endif",

				//

			"	vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
			"	vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				//

			"	vWorldPosition = worldPosition.xyz;",
			"	vViewPosition = -mvPosition.xyz;",

				// shadows

			"	#ifdef USE_SHADOWMAP",

			"		for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

			"			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

			"		}",

			"	#endif",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
			"	vWorldPosition = worldPosition.xyz;",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join("\n")

	},

	/* Depth encoding into RGBA texture
	 *
	 * based on SpiderGL shadow map example
	 * http://spidergl.org/example.php?id=6
	 *
	 * originally from
	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	 *
	 * see also
	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	 */

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"vec4 pack_depth( const in float depth ) {",

			"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
			"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
			"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
			"	res -= res.xxyz * bit_mask;",
			"	return res;",

			"}",

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

			"	#else",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

			"	#endif",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join("\n")

	}

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_depth = parameters.depth !== undefined ? parameters.depth : true,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
	_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	var lights = [];

	var _webglObjects = {};
	var _webglObjectsImmediate = [];

	var opaqueObjects = [];
	var transparentObjects = [];

	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;
	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				 ? parameters.devicePixelRatio
				 : self.devicePixelRatio !== undefined
					 ? self.devicePixelRatio
					 : 1;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = - 1,
	_currentGeometryGroupHash = - 1,
	_currentCamera = null,

	_usedTextureUnits = 0,

	// GL state cache

	_oldDoubleSided = - 1,
	_oldFlipSided = - 1,

	_oldBlending = - 1,

	_oldBlendEquation = - 1,
	_oldBlendSrc = - 1,
	_oldBlendDst = - 1,

	_oldDepthTest = - 1,
	_oldDepthWrite = - 1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	_newAttributes = new Uint8Array( 16 ),
	_enabledAttributes = new Uint8Array( 16 ),

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_projScreenMatrixPS = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors:[], positions: [] },
		point: { length: 0, colors: [], positions: [], distances: [] },
		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [] },
		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

	};

	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl') !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

	} catch ( error ) {

		console.error( error );

	}

	if ( _gl.getShaderPrecisionFormat === undefined ) {

		_gl.getShaderPrecisionFormat = function () {

			return {
				'rangeMin': 1,
				'rangeMax': 1,
				'precision': 1
			};

		}

	}

	var extensions = new THREE.WebGLExtensions( _gl );

	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_standard_derivatives' );

	if ( _logarithmicDepthBuffer ) {

		extensions.get( 'EXT_frag_depth' );

	}

	//

	function setDefaultGLState() {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}

	setDefaultGLState();

	this.context = _gl;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _supportsVertexTextures = _maxVertexTextures > 0;
	var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );

	//

	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

	var getCompressedTextureFormats = ( function () {

		var array;

		return function () {

			if ( array !== undefined ) {

				return array;

			}

			array = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

				var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ){

					array.push( formats[ i ] );

				}

			}
			
			return array;

		};

	} )();

	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precision === 'highp' && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precision = 'mediump';
			console.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );

		} else {

			_precision = 'lowp';
			console.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );

		}

	}

	if ( _precision === 'mediump' && ! mediumpAvailable ) {

		_precision = 'lowp';
		console.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );

	}

	// Plugins

	var shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );

	var spritePlugin = new THREE.SpritePlugin( this, sprites );
	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return extensions.get( 'OES_texture_float' );

	};

	this.supportsStandardDerivatives = function () {

		return extensions.get( 'OES_standard_derivatives' );

	};

	this.supportsCompressedTextureS3TC = function () {

		return extensions.get( 'WEBGL_compressed_texture_s3tc' );

	};

	this.supportsCompressedTexturePVRTC = function () {

		return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	};

	this.supportsBlendMinMax = function () {

		return extensions.get( 'EXT_blend_minmax' );

	};

	this.getMaxAnisotropy = ( function () {

		var value;

		return function () {

			if ( value !== undefined ) {

				return value;

			}

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

			return value;

		}

	} )();

	this.getPrecision = function () {

		return _precision;

	};

	this.setSize = function ( width, height, updateStyle ) {

		_canvas.width = width * this.devicePixelRatio;
		_canvas.height = height * this.devicePixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x * this.devicePixelRatio;
		_viewportY = y * this.devicePixelRatio;

		_viewportWidth = width * this.devicePixelRatio;
		_viewportHeight = height * this.devicePixelRatio;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor(
			x * this.devicePixelRatio,
			y * this.devicePixelRatio,
			width * this.devicePixelRatio,
			height * this.devicePixelRatio
		);

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.setClearColorHex = function ( hex, alpha ) {

		console.warn( 'THREE.WebGLRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getClearColor = function () {

		return _clearColor;

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = function () {

		_currentProgram = null;
		_currentCamera = null;

		_oldBlending = - 1;
		_oldDepthTest = - 1;
		_oldDepthWrite = - 1;
		_oldDoubleSided = - 1;
		_oldFlipSided = - 1;
		_currentGeometryGroupHash = - 1;
		_currentMaterialId = - 1;

		_lightsNeedUpdate = true;

	};

	// Buffer allocation

	function createParticleBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

			}

		}

		_this.info.memory.geometries ++;

	};

	// Events

	var onObjectRemoved = function ( event ) {

		var object = event.target;

		object.traverse( function ( child ) {

			child.removeEventListener( 'remove', onObjectRemoved );

			removeObject( child );

		} );

	};

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deleteBuffers = function ( geometry ) {
	
		var buffers = [
			'__webglVertexBuffer',
			'__webglNormalBuffer',
			'__webglTangentBuffer',
			'__webglColorBuffer',
			'__webglUVBuffer',
			'__webglUV2Buffer',
			
			'__webglSkinIndicesBuffer',
			'__webglSkinWeightsBuffer',
			
			'__webglFaceBuffer',
			'__webglLineBuffer',
			
			'__webglLineDistanceBuffer'
		];

		for ( var i = 0, l = buffers.length; i < l; i ++ ) {

			var name = buffers[ i ];

			if ( geometry[ name ] !== undefined ) {

				_gl.deleteBuffer( geometry[ name ] );

				delete geometry[ name ];

			}

		}

		// custom attributes

		if ( geometry.__webglCustomAttributesList !== undefined ) {

			for ( var name in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );

			}

			delete geometry.__webglCustomAttributesList;

		}

		_this.info.memory.geometries --;

	};

	var deallocateGeometry = function ( geometry ) {

		delete geometry.__webglInit;

		if ( geometry instanceof THREE.BufferGeometry ) {

			for ( var name in geometry.attributes ) {
			
				var attribute = geometry.attributes[ name ];

				if ( attribute.buffer !== undefined ) {

					_gl.deleteBuffer( attribute.buffer );

					delete attribute.buffer;

				}

			}

			_this.info.memory.geometries --;

		} else {

			var geometryGroupsList = geometryGroups[ geometry.id ];

			if ( geometryGroupsList !== undefined ) {

				for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

					var geometryGroup = geometryGroupsList[ i ];

					if ( geometryGroup.numMorphTargets !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

						}

						delete geometryGroup.__webglMorphTargetsBuffers;

					}

					if ( geometryGroup.numMorphNormals !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

						}

						delete geometryGroup.__webglMorphNormalsBuffers;

					}

					deleteBuffers( geometryGroup );

				}

				delete geometryGroups[ geometry.id ];

			} else {

				deleteBuffers( geometry );

			}

		}

		// TOFIX: Workaround for deleted geometry being currently bound

		_currentGeometryGroupHash = - 1;

	};

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

			delete texture.image.__webglTextureCube;

		} else {

			// 2D texture

			if ( texture.__webglInit === undefined ) return;

			_gl.deleteTexture( texture.__webglTexture );

			delete texture.__webglTexture;
			delete texture.__webglInit;

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		delete renderTarget.__webglTexture;

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

		delete renderTarget.__webglFramebuffer;
		delete renderTarget.__webglRenderbuffer;

	};

	var deallocateMaterial = function ( material ) {

		var program = material.program.program;

		if ( program === undefined ) return;

		material.program = undefined;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	// Buffer initialization

	function initCustomAttributes ( object ) {

		var geometry = object.geometry;
		var material = object.material;

		var nvertices = geometry.vertices.length;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var name in material.attributes ) {

				var attribute = material.attributes[ name ];

				if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;   // "f" and "i"

					if ( attribute.type === 'v2' ) size = 2;
					else if ( attribute.type === 'v3' ) size = 3;
					else if ( attribute.type === 'v4' ) size = 4;
					else if ( attribute.type === 'c'  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = name;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initParticleBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes( object );

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes( object );

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,

			nvertices = faces3.length * 3,
			ntris     = faces3.length * 1,
			nlines    = faces3.length * 3,

			material = getBufferMaterial( object, geometryGroup );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
		geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
		geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
		geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

		if ( geometry.faceVertexUvs.length > 1 ) {

			geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3

		geometryGroup.__typeArray = UintArray;
		geometryGroup.__faceArray = new UintArray( ntris * 3 );
		geometryGroup.__lineArray = new UintArray( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__morphTargetsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__morphNormalsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var name in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ name ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;   // "f" and "i"

					if ( attribute.type === 'v2' ) size = 2;
					else if ( attribute.type === 'v3' ) size = 3;
					else if ( attribute.type === 'v4' ) size = 4;
					else if ( attribute.type === 'c'  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = name;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial
			 ? object.material.materials[ geometryGroup.materialIndex ]
			 : object.material;

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	// Buffer setting

	function setParticleBuffers ( geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.copy( _projScreenMatrix );
			_projScreenMatrixPS.multiply( object.matrixWorld );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.copy( vertex );
				_vector3.applyProjection( _projScreenMatrixPS );

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( numericalSort );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ sortArray[ v ][ 1 ] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c < cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[ c ][ 1 ] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]   = value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === 'c' ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
							 customAttribute.boundTo === 'vertices' ) ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === 'c' ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ]   = value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}

	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
						 customAttribute.boundTo === 'vertices' ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ]   = value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === 'c' ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ]    = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	}

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var needsSmoothNormals = materialNeedsSmoothNormals( material );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

				offset_morphTarget = 0;

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ]     = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ]     = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( obj_skinWeights.length ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			if ( offset_skin > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ]   = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ]     = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ]     = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ]     = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === 'c' ) {

						pp = [ 'r', 'g', 'b' ];

					} else {

						pp = [ 'x', 'y', 'z' ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === 'faceVertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === 'faceVertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};

	function setDirectBuffers( geometry ) {

		var attributes = geometry.attributes;
		var attributesKeys = geometry.attributesKeys;

		for ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {

			var key = attributesKeys[ i ];
			var attribute = attributes[ key ];

			if ( attribute.buffer === undefined ) {

				attribute.buffer = _gl.createBuffer();
				attribute.needsUpdate = true;

			}

			if ( attribute.needsUpdate === true ) {

				var bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;

				_gl.bindBuffer( bufferType, attribute.buffer );
				_gl.bufferData( bufferType, attribute.array, _gl.STATIC_DRAW );

				attribute.needsUpdate = false;

			}

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		initAttributes();

		if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
		if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
		if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
		if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.position );
			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

			if ( material.shading === THREE.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for ( i = 0; i < il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ]   = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.normal );
			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.uv );
			_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.color );
			_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.attributes;
		var programAttributesKeys = program.attributesKeys;

		for ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {

			var key = programAttributesKeys[ i ];
			var programAttribute = programAttributes[ key ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ key ];

				if ( geometryAttribute !== undefined ) {

					var size = geometryAttribute.itemSize;

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );

					enableAttribute( programAttribute );

					_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

				} else if ( material.defaultAttributeValues !== undefined ) {

					if ( material.defaultAttributeValues[ key ].length === 2 ) {

						_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );

					} else if ( material.defaultAttributeValues[ key ].length === 3 ) {

						_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

		if ( material.visible === false ) return;

		var program = setProgram( camera, lights, fog, material, object );

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			initAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;

			var index = geometry.attributes.index;

			if ( index ) {

				// indexed triangles

				var type, size;

				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}

				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					_gl.drawElements( mode, index.array.length, type, 0 );

					_this.info.render.calls ++;
					_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
					_this.info.render.faces += index.array.length / 3;

				} else {

					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change

					updateBuffers = true;

					for ( var i = 0, il = offsets.length; i < il; i ++ ) {

						var startIndex = offsets[ i ].index;

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, startIndex );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						// render indexed triangles

						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

						_this.info.render.calls ++;
						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
						_this.info.render.faces += offsets[ i ].count / 3;

					}

				}

			} else {

				// non-indexed triangles

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry, 0 );

				}

				var position = geometry.attributes[ 'position' ];

				// render non-indexed triangles

				_gl.drawArrays( mode, 0, position.array.length / 3 );

				_this.info.render.calls ++;
				_this.info.render.vertices += position.array.length / 3;
				_this.info.render.faces += position.array.length / 9;

			}

		} else if ( object instanceof THREE.PointCloud ) {

			// render particles

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry, 0 );

			}

			var position = geometry.attributes.position;

			// render particles

			_gl.drawArrays( _gl.POINTS, 0, position.array.length / 3 );

			_this.info.render.calls ++;
			_this.info.render.points += position.array.length / 3;

		} else if ( object instanceof THREE.Line ) {

			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			var index = geometry.attributes.index;

			if ( index ) {

				// indexed lines

				var type, size;

				if ( index.array instanceof Uint32Array ) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}

				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array

					_this.info.render.calls ++;
					_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared

				} else {

					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change

					if ( offsets.length > 1 ) updateBuffers = true;

					for ( var i = 0, il = offsets.length; i < il; i ++ ) {

						var startIndex = offsets[ i ].index;

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, startIndex );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						// render indexed lines

						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array

						_this.info.render.calls ++;
						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

					}

				}

			} else {

				// non-indexed lines

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry, 0 );

				}

				var position = geometry.attributes.position;

				_gl.drawArrays( mode, 0, position.array.length / 3 );

				_this.info.render.calls ++;
				_this.info.render.points += position.array.length / 3;

			}

		}

	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		var program = setProgram( camera, lights, fog, material, object );

		var attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			initAttributes();

		}

		// vertices

		if ( ! material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( object.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, object );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					var attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

				}

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( object.geometry.faceVertexUvs[ 0 ] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( object.geometry.faceVertexUvs[ 1 ] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

				}

			}

			if ( material.skinning &&
				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes.skinIndex );
				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes.skinWeight );
				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		disableUnusedAttributes();

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );
				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );

			}

			_this.info.render.calls ++;
			_this.info.render.vertices += geometryGroup.__webglFaceCount;
			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

		// render lines

		} else if ( object instanceof THREE.Line ) {

			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );

			_this.info.render.calls ++;

		// render particles

		} else if ( object instanceof THREE.PointCloud ) {

			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

			_this.info.render.calls ++;
			_this.info.render.points += geometryGroup.__webglParticleCount;

		}

	};

	function initAttributes() {

		for ( var i = 0, l = _newAttributes.length; i < l; i ++ ) {

			_newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		_newAttributes[ attribute ] = 1;

		if ( _enabledAttributes[ attribute ] === 0 ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ attribute ] = 1;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = _enabledAttributes.length; i < l; i ++ ) {

			if ( _enabledAttributes[ i ] !== _newAttributes[ i ] ) {

				_gl.disableVertexAttribArray( i );
				_enabledAttributes[ i ] = 0;

			}

		}

	}

	function setupMorphTargets ( material, geometryGroup, object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		} else if ( attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m < material.numSupportedMorphTargets && m < order.length ) {

				if ( attributes[ 'morphTarget' + m ] >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ 'morphTarget' + m ] );
					_gl.vertexAttribPointer( attributes[ 'morphTarget' + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( attributes[ 'morphNormal' + m ] >= 0 && material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ 'morphNormal' + m ] );
					_gl.vertexAttribPointer( attributes[ 'morphNormal' + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;
			}

		} else {

			// find the most influencing

			var influence, activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i < il; i ++ ) {

				influence = influences[ i ];

				if ( influence > 0 ) {

					activeInfluenceIndices.push( [ influence, i ] );

				}

			}

			if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length === 0 ) {

				activeInfluenceIndices.push( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m < material.numSupportedMorphTargets ) {

				if ( activeInfluenceIndices[ m ] ) {

					influenceIndex = activeInfluenceIndices[ m ][ 1 ];

					if ( attributes[ 'morphTarget' + m ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ 'morphTarget' + m ] );
						_gl.vertexAttribPointer( attributes[ 'morphTarget' + m ], 3, _gl.FLOAT, false, 0, 0 );

					}

					if ( attributes[ 'morphNormal' + m ] >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ 'morphNormal' + m ] );
						_gl.vertexAttribPointer( attributes[ 'morphNormal' + m ], 3, _gl.FLOAT, false, 0, 0 );


					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

				} else {

					/*
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}
					*/

					object.__webglMorphTargetInfluences[ m ] = 0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms.morphTargetInfluences !== null ) {

			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

		}

	}

	// Sorting

	function painterSortStable ( a, b ) {

		if ( a.material.id !== b.material.id ) {

			return b.material.id - a.material.id;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var fog = scene.fog;

		// reset caching for this frame

		_currentGeometryGroupHash = - 1;
		_currentMaterialId = - 1;
		_currentCamera = null;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		// update Skeleton objects

		scene.traverse( function ( object ) {

			if ( object instanceof THREE.SkinnedMesh ) {

				object.skeleton.update();

			}

		} );

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;
		opaqueObjects.length = 0;
		transparentObjects.length = 0;

		sprites.length = 0;
		lensFlares.length = 0;

		projectObject( scene, scene );

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );

		}

		// custom render plugins (pre pass)

		shadowMapPlugin.render( scene, camera );

		//

		_this.info.render.calls = 0;
		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;
		_this.info.render.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		// set matrices for immediate objects

		for ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {

			var webglObject = _webglObjectsImmediate[ i ];
			var object = webglObject.object;

			if ( object.visible ) {

				setupMatrices( object, camera );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial ) {

			var material = scene.overrideMaterial;

			this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			this.setDepthTest( material.depthTest );
			this.setDepthWrite( material.depthWrite );
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			renderObjects( opaqueObjects, camera, lights, fog, true, material );
			renderObjects( transparentObjects, camera, lights, fog, true, material );
			renderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, false, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			this.setBlending( THREE.NoBlending );

			renderObjects( opaqueObjects, camera, lights, fog, false, material );
			renderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, camera, lights, fog, true, material );
			renderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		this.setDepthTest( true );
		this.setDepthWrite( true );

		// _gl.finish();

	};

	function projectObject( scene, object ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

			// skip

		} else {

			initObject( object, scene );

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else if ( object instanceof THREE.Sprite ) {

				sprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				lensFlares.push( object );

			} else {

				var webglObjects = _webglObjects[ object.id ];

				if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

					updateObject( object, scene );

					for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

						var webglObject = webglObjects[i];

						unrollBufferMaterial( webglObject );

						webglObject.render = true;

						if ( _this.sortObjects === true ) {

							if ( object.renderDepth !== null ) {

								webglObject.z = object.renderDepth;

							} else {

								_vector3.setFromMatrixPosition( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );

								webglObject.z = _vector3.z;

							}

						}

					}

				}

			}

		}

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			projectObject( scene, object.children[ i ] );

		}

	}

	function renderObjects( renderList, camera, lights, fog, useBlending, overrideMaterial ) {

		var material;

		for ( var i = renderList.length - 1; i !== - 1; i -- ) {

			var webglObject = renderList[ i ];

			var object = webglObject.object;
			var buffer = webglObject.buffer;

			setupMatrices( object, camera );

			if ( overrideMaterial ) {

				material = overrideMaterial;

			} else {

				material = webglObject.material;

				if ( ! material ) continue;

				if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

				_this.setDepthTest( material.depthTest );
				_this.setDepthWrite( material.depthWrite );
				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			}

			_this.setMaterialFaces( material );

			if ( buffer instanceof THREE.BufferGeometry ) {

				_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

			} else {

				_this.renderBuffer( camera, lights, fog, material, buffer, object );

			}

		}

	}

	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var material;

		for ( var i = 0, il = renderList.length; i < il; i ++ ) {

			var webglObject = renderList[ i ];
			var object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	}

	this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = - 1;

		_this.setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );

		}

	};

	function unrollImmediateBufferMaterial ( globject ) {

		var object = globject.object,
			material = object.material;

		if ( material.transparent ) {

			globject.transparent = material;
			globject.opaque = null;

		} else {

			globject.opaque = material;
			globject.transparent = null;

		}

	}

	function unrollBufferMaterial ( globject ) {

		var object = globject.object;
		var buffer = globject.buffer;

		var geometry = object.geometry;
		var material = object.material;

		if ( material instanceof THREE.MeshFaceMaterial ) {

			var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

			material = material.materials[ materialIndex ];

			globject.material = material;

			if ( material.transparent ) {

				transparentObjects.push( globject );

			} else {

				opaqueObjects.push( globject );

			}

		} else if ( material ) {

			globject.material = material;

			if ( material.transparent ) {

				transparentObjects.push( globject );

			} else {

				opaqueObjects.push( globject );

			}

		}

	}

	function initObject( object, scene ) {

		if ( object.__webglInit === undefined ) {

			object.__webglInit = true;
			object._modelViewMatrix = new THREE.Matrix4();
			object._normalMatrix = new THREE.Matrix3();

			object.addEventListener( 'removed', onObjectRemoved );

		}

		var geometry = object.geometry;

		if ( geometry === undefined ) {

			// ImmediateRenderObject

		} else if ( geometry.__webglInit === undefined ) {

			geometry.__webglInit = true;
			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry instanceof THREE.BufferGeometry ) {

				//

			} else if ( object instanceof THREE.Mesh ) {

				initGeometryGroups( scene, object, geometry );

			} else if ( object instanceof THREE.Line ) {

				if ( geometry.__webglVertexBuffer === undefined ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			} else if ( object instanceof THREE.PointCloud ) {

				if ( geometry.__webglVertexBuffer === undefined ) {

					createParticleBuffers( geometry );
					initParticleBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			}

		}

		if ( object.__webglActive === undefined) {

			object.__webglActive = true;

			if ( object instanceof THREE.Mesh ) {

				if ( geometry instanceof THREE.BufferGeometry ) {

					addBuffer( _webglObjects, geometry, object );

				} else if ( geometry instanceof THREE.Geometry ) {

					var geometryGroupsList = geometryGroups[ geometry.id ];

					for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

						addBuffer( _webglObjects, geometryGroupsList[ i ], object );

					}

				}

			} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

				addBuffer( _webglObjects, geometry, object );

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				addBufferImmediate( _webglObjectsImmediate, object );

			}

		}

	}

	// Geometry splitting

	var geometryGroups = {};
	var geometryGroupCounter = 0;

	function makeGroups( geometry, usesFaceMaterial ) {

		var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;

		var groupHash, hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;
		var numMorphNormals = geometry.morphNormals.length;

		var group;
		var groups = {};
		var groupsList = [];

		for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

			var face = geometry.faces[ f ];
			var materialIndex = usesFaceMaterial ? face.materialIndex : 0;

			if ( ! ( materialIndex in hash_map ) ) {

				hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };

			}

			groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

			if ( ! ( groupHash in groups ) ) {

				group = {
					id: geometryGroupCounter ++,
					faces3: [],
					materialIndex: materialIndex,
					vertices: 0,
					numMorphTargets: numMorphTargets,
					numMorphNormals: numMorphNormals
				};
				
				groups[ groupHash ] = group;
				groupsList.push( group );

			}

			if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {

				hash_map[ materialIndex ].counter += 1;
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( ! ( groupHash in groups ) ) {

					group = {
						id: geometryGroupCounter ++,
						faces3: [],
						materialIndex: materialIndex,
						vertices: 0,
						numMorphTargets: numMorphTargets,
						numMorphNormals: numMorphNormals
					};
					
					groups[ groupHash ] = group;
					groupsList.push( group );

				}

			}

			groups[ groupHash ].faces3.push( f );
			groups[ groupHash ].vertices += 3;

		}

		return groupsList;

	}

	function initGeometryGroups( scene, object, geometry ) {

		var material = object.material, addBuffers = false;

		if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {

			delete _webglObjects[ object.id ];

			geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );

			geometry.groupsNeedUpdate = false;

		}

		var geometryGroupsList = geometryGroups[ geometry.id ];

		// create separate VBOs per geometry chunk

		for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

			var geometryGroup = geometryGroupsList[ i ];

			// initialise VBO on the first access

			if ( geometryGroup.__webglVertexBuffer === undefined ) {

				createMeshBuffers( geometryGroup );
				initMeshBuffers( geometryGroup, object );

				geometry.verticesNeedUpdate = true;
				geometry.morphTargetsNeedUpdate = true;
				geometry.elementsNeedUpdate = true;
				geometry.uvsNeedUpdate = true;
				geometry.normalsNeedUpdate = true;
				geometry.tangentsNeedUpdate = true;
				geometry.colorsNeedUpdate = true;

				addBuffers = true;

			} else {

				addBuffers = false;

			}

			if ( addBuffers || object.__webglActive === undefined ) {

				addBuffer( _webglObjects, geometryGroup, object );

			}

		}

		object.__webglActive = true;

	}

	function addBuffer( objlist, buffer, object ) {

		var id = object.id;
		objlist[id] = objlist[id] || [];
		objlist[id].push(
			{
				id: id,
				buffer: buffer,
				object: object,
				material: null,
				z: 0
			}
		);

	};

	function addBufferImmediate( objlist, object ) {

		objlist.push(
			{
				id: null,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	// Objects updates

	function updateObject( object, scene ) {

		var geometry = object.geometry, customAttributesDirty, material;

		if ( geometry instanceof THREE.BufferGeometry ) {

			setDirectBuffers( geometry );

		} else if ( object instanceof THREE.Mesh ) {

			// check all geometry groups

			if ( geometry.groupsNeedUpdate === true ) {

				initGeometryGroups( scene, object, geometry );

			}

			var geometryGroupsList = geometryGroups[ geometry.id ];

			for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

				var geometryGroup = geometryGroupsList[ i ];

				material = getBufferMaterial( object, geometryGroup );

				if ( geometry.groupsNeedUpdate === true ) {

					initMeshBuffers( geometryGroup, object );

				}

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );

				}

			}

			geometry.verticesNeedUpdate = false;
			geometry.morphTargetsNeedUpdate = false;
			geometry.elementsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.tangentsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );


		} else if ( object instanceof THREE.PointCloud ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

				setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		}

	}

	// Objects updates - custom attributes check

	function areCustomAttributesDirty( material ) {

		for ( var name in material.attributes ) {

			if ( material.attributes[ name ].needsUpdate ) return true;

		}

		return false;

	}

	function clearCustomAttributes( material ) {

		for ( var name in material.attributes ) {

			material.attributes[ name ].needsUpdate = false;

		}

	}

	// Objects removal

	function removeObject( object ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.PointCloud ||
			 object instanceof THREE.Line ) {

			delete _webglObjects[ object.id ];

		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

			removeInstances( _webglObjectsImmediate, object );

		}

		delete object.__webglInit;
		delete object._modelViewMatrix;
		delete object._normalMatrix;

		delete object.__webglActive;

	}

	function removeInstances( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	}

	// Materials

	function initMaterial( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var shaderID;

		if ( material instanceof THREE.MeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material instanceof THREE.MeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material instanceof THREE.MeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material instanceof THREE.LineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			shaderID = 'dashed';

		} else if ( material instanceof THREE.PointCloudMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID ) {

			var shader = THREE.ShaderLib[ shaderID ];

			material.__webglShader = {
				uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			}

		} else {

			material.__webglShader = {
				uniforms: material.uniforms,
				vertexShader: material.vertexShader,
				fragmentShader: material.fragmentShader
			}

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxLightCount = allocateLights( lights );
		var maxShadows = allocateShadows( lights );
		var maxBones = allocateBones( object );

		var parameters = {

			precision: _precision,
			supportsVertexTextures: _supportsVertexTextures,

			map: !! material.map,
			envMap: !! material.envMap,
			lightMap: !! material.lightMap,
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: _logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: _this.maxMorphTargets,
			maxMorphNormals: _this.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: maxShadows,
			shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
			shadowMapType: _this.shadowMapType,
			shadowMapDebug: _this.shadowMapDebug,
			shadowMapCascade: _this.shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		// Generate code

		var chunks = [];

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( material.fragmentShader );
			chunks.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				chunks.push( name );
				chunks.push( material.defines[ name ] );

			}

		}

		for ( var name in parameters ) {

			chunks.push( name );
			chunks.push( parameters[ name ] );

		}

		var code = chunks.join();

		var program;

		// Check if code has been already compiled

		for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				program.usedTimes ++;

				break;

			}

		}

		if ( program === undefined ) {

			program = new THREE.WebGLProgram( _this, code, material, parameters );
			_programs.push( program );

			_this.info.memory.programs = _programs.length;

		}

		material.program = program;

		var attributes = program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = 'morphTarget';

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = 'morphNormal';

			for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		for ( var u in material.__webglShader.uniforms ) {

			var location = material.program.uniforms[ u ];

			if ( location ) {
				material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
			}

		}

	}

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program ) deallocateMaterial( material );

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

			}

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			if ( _currentMaterialId === -1 ) refreshLights = true;
			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( _logarithmicDepthBuffer ) {

				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) _currentCamera = camera;

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

			}

			if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

			}

			if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.skeleton.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

				}

			} else if ( object.skeleton && object.skeleton.boneMatrices ) {

				if ( p_uniforms.boneGlobalMatrices !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					refreshLights = true;
					setupLights( lights );
					_lightsNeedUpdate = false;
				}

				if ( refreshLights ) {
					refreshUniformsLights( m_uniforms, _lights );
					markUniformsLightsNeedsUpdate( m_uniforms, true );
				} else {
					markUniformsLightsNeedsUpdate( m_uniforms, false );
				}

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.PointCloudMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( material.uniformsList );

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value = material.color;

		}

		uniforms.map.value = material.map;
		uniforms.lightMap.value = material.lightMap;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//  1. color map
		//  2. specular map
		//  3. normal map
		//  4. bump map
		//  5. alpha map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

		if ( _this.gammaInput ) {

			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
			uniforms.reflectivity.value = material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;
		uniforms.combine.value = material.combine;
		uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

	}

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

	}

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.specular.value.copyGammaToLinear( material.specular );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	}

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	}

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, boolean ) {

		uniforms.ambientLightColor.needsUpdate = boolean;

		uniforms.directionalLightColor.needsUpdate = boolean;
		uniforms.directionalLightDirection.needsUpdate = boolean;

		uniforms.pointLightColor.needsUpdate = boolean;
		uniforms.pointLightPosition.needsUpdate = boolean;
		uniforms.pointLightDistance.needsUpdate = boolean;

		uniforms.spotLightColor.needsUpdate = boolean;
		uniforms.spotLightPosition.needsUpdate = boolean;
		uniforms.spotLightDistance.needsUpdate = boolean;
		uniforms.spotLightDirection.needsUpdate = boolean;
		uniforms.spotLightAngleCos.needsUpdate = boolean;
		uniforms.spotLightExponent.needsUpdate = boolean;

		uniforms.hemisphereLightSkyColor.needsUpdate = boolean;
		uniforms.hemisphereLightGroundColor.needsUpdate = boolean;
		uniforms.hemisphereLightDirection.needsUpdate = boolean;

	}

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	}

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

		}

	}

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	function loadUniformsGeneric ( uniforms ) {

		var texture, textureUnit, offset;

		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

			var uniform = uniforms[ j ][ 0 ];

			// needsUpdate property is not added to all uniforms.
			if ( uniform.needsUpdate === false ) continue;

			var type = uniform.type;
			var value = uniform.value;
			var location = uniforms[ j ][ 1 ];

			switch ( type ) {

				case '1i':
					_gl.uniform1i( location, value );
					break;

				case '1f':
					_gl.uniform1f( location, value );
					break;

				case '2f':
					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
					break;

				case '3f':
					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
					break;

				case '4f':
					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
					break;

				case '1iv':
					_gl.uniform1iv( location, value );
					break;

				case '3iv':
					_gl.uniform3iv( location, value );
					break;

				case '1fv':
					_gl.uniform1fv( location, value );
					break;

				case '2fv':
					_gl.uniform2fv( location, value );
					break;

				case '3fv':
					_gl.uniform3fv( location, value );
					break;

				case '4fv':
					_gl.uniform4fv( location, value );
					break;

				case 'Matrix3fv':
					_gl.uniformMatrix3fv( location, false, value );
					break;

				case 'Matrix4fv':
					_gl.uniformMatrix4fv( location, false, value );
					break;

				//

				case 'i':

					// single integer
					_gl.uniform1i( location, value );

					break;

				case 'f':

					// single float
					_gl.uniform1f( location, value );

					break;

				case 'v2':

					// single THREE.Vector2
					_gl.uniform2f( location, value.x, value.y );

					break;

				case 'v3':

					// single THREE.Vector3
					_gl.uniform3f( location, value.x, value.y, value.z );

					break;

				case 'v4':

					// single THREE.Vector4
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );

					break;

				case 'c':

					// single THREE.Color
					_gl.uniform3f( location, value.r, value.g, value.b );

					break;

				case 'iv1':

					// flat array of integers (JS or typed array)
					_gl.uniform1iv( location, value );

					break;

				case 'iv':

					// flat array of integers with 3 x N size (JS or typed array)
					_gl.uniform3iv( location, value );

					break;

				case 'fv1':

					// flat array of floats (JS or typed array)
					_gl.uniform1fv( location, value );

					break;

				case 'fv':

					// flat array of floats with 3 x N size (JS or typed array)
					_gl.uniform3fv( location, value );

					break;

				case 'v2v':

					// array of THREE.Vector2

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 2 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 2;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;

					}

					_gl.uniform2fv( location, uniform._array );

					break;

				case 'v3v':

					// array of THREE.Vector3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 3 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 3;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;

					}

					_gl.uniform3fv( location, uniform._array );

					break;

				case 'v4v':

					// array of THREE.Vector4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 4 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 4;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;
						uniform._array[ offset + 3 ] = value[ i ].w;

					}

					_gl.uniform4fv( location, uniform._array );

					break;

				case 'm3':

					// single THREE.Matrix3
					_gl.uniformMatrix3fv( location, false, value.elements );

					break;

				case 'm3v':

					// array of THREE.Matrix3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 9 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

					}

					_gl.uniformMatrix3fv( location, false, uniform._array );

					break;

				case 'm4':

					// single THREE.Matrix4
					_gl.uniformMatrix4fv( location, false, value.elements );

					break;

				case 'm4v':

					// array of THREE.Matrix4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 16 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

					}

					_gl.uniformMatrix4fv( location, false, uniform._array );

					break;

				case 't':

					// single THREE.Texture (2d or cube)

					texture = value;
					textureUnit = getTextureUnit();

					_gl.uniform1i( location, textureUnit );

					if ( ! texture ) continue;

					if ( texture instanceof THREE.CubeTexture ||
					   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

						setCubeTexture( texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

						setCubeTextureDynamic( texture, textureUnit );

					} else {

						_this.setTexture( texture, textureUnit );

					}

					break;

				case 'tv':

					// array of THREE.Texture (2d)

					if ( uniform._array === undefined ) {

						uniform._array = [];

					}

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						uniform._array[ i ] = getTextureUnit();

					}

					_gl.uniform1iv( location, uniform._array );

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];

						if ( ! texture ) continue;

						_this.setTexture( texture, textureUnit );

					}

					break;

				default:

					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	}

	function setupMatrices ( object, camera ) {

		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

	}

	//

	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	}

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	}

	function setupLights ( lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				if ( _this.gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				_direction.setFromMatrixPosition( light.matrixWorld );

				spotPositions[ spotOffset ]     = _direction.x;
				spotPositions[ spotOffset + 1 ] = _direction.y;
				spotPositions[ spotOffset + 2 ] = _direction.z;

				spotDistances[ spotLength ] = distance;

				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.normalize();

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( _this.gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};

	this.setMaterialFaces = function ( material ) {

		var doubleSided = material.side === THREE.DoubleSide;
		var flipSided = material.side === THREE.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	}

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	}

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

		if ( blending !== _oldBlending ) {

			if ( blending === THREE.NoBlending ) {

				_gl.disable( _gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				_gl.enable( _gl.BLEND );

			} else {

				_gl.enable( _gl.BLEND );
				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	};

	// Textures

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		var extension;

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension && texture.type !== THREE.FloatType ) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	}

	this.uploadTexture = function ( texture ) {

		if ( texture.__webglInit === undefined ) {

			texture.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			texture.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

		}

		_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		texture.image = clampToMaxSize( texture.image, _maxTextureSize );

		var image = texture.image,
		isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture instanceof THREE.DataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture instanceof THREE.CompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

					if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "Attempt to load unsupported compressed texture format" );

					}

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else { // regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

			}

		}

		if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

		texture.needsUpdate = false;

		if ( texture.onUpdate ) texture.onUpdate();

	};

	this.setTexture = function ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );

		if ( texture.needsUpdate ) {

			_this.uploadTexture( texture );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElement( 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.log( 'THREE.WebGLRenderer:', image, 'is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height + '.' );

			return canvas;

		}

		return image;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;
				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

								if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

									_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "Attempt to load unsupported compressed texture format" );

								}

							} else {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	}

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	}

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	}

	function setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/
		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	}

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	function updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

		}

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		var extension;

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			if ( p === THREE.MinEquation ) return extension.MIN_EXT;
			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

		}

		return 0;

	}

	// Allocations

	function allocateBones ( object ) {

		if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.onlyShadow || light.visible === false ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

	}

	function allocateShadows( lights ) {

		var maxShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	}

	// DEPRECATED
	
	this.initMaterial = function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	};

	this.addPrePlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	};

	this.addPostPlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	};

	this.updateShadowMap = function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	};

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.width = width;
	this.height = height;

	options = options || {};

	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.generateMipmaps = true;

	this.shareDepthFrom = null;

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	setSize: function ( width, height ) {

		this.width = width;
		this.height = height;

	},

	clone: function () {

		var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;

		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;

		tmp.anisotropy = this.anisotropy;

		tmp.offset.copy( this.offset );
		tmp.repeat.copy( this.repeat );

		tmp.format = this.format;
		tmp.type = this.type;

		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;

		tmp.generateMipmaps = this.generateMipmaps;

		tmp.shareDepthFrom = this.shareDepthFrom;

		return tmp;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/webgl/WebGLExtensions.js

THREE.WebGLExtensions = function ( gl ) {

	var extensions = {};

	this.get = function ( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		var extension;

		switch ( name ) {
		
			case 'OES_texture_float':
				extension = gl.getExtension( 'OES_texture_float' );
				break;

			case 'OES_texture_float_linear':
				extension = gl.getExtension( 'OES_texture_float_linear' );
				break;

			case 'OES_standard_derivatives':
				extension = gl.getExtension( 'OES_standard_derivatives' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			case 'OES_element_index_uint':
				extension = gl.getExtension( 'OES_element_index_uint' );
				break;

			case 'EXT_blend_minmax':
				extension = gl.getExtension( 'EXT_blend_minmax' );
				break;

			case 'EXT_frag_depth':
				extension = gl.getExtension( 'EXT_frag_depth' );
				break;

		}

		if ( extension === null ) {

			console.log( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

		}

		extensions[ name ] = extension;

		return extension;

	};

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

	var programIdCount = 0;

	var generateDefines = function ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = "#define " + d + " " + value;
			chunks.push( chunk );

		}

		return chunks.join( "\n" );

	};

	var cacheUniformLocations = function ( gl, program, identifiers ) {

		var uniforms = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			uniforms[ id ] = gl.getUniformLocation( program, id );

		}

		return uniforms;

	};

	var cacheAttributeLocations = function ( gl, program, identifiers ) {

		var attributes = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			attributes[ id ] = gl.getAttribLocation( program, id );

		}

		return attributes;

	};

	return function ( renderer, code, material, parameters ) {

		var _this = renderer;
		var _gl = _this.context;

		var defines = material.defines;
		var uniforms = material.__webglShader.uniforms;
		var attributes = material.attributes;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var index0AttributeName = material.index0AttributeName;

		if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0

			index0AttributeName = 'position';

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		// console.log( "building new program " );

		//

		var customDefines = generateDefines( defines );

		//

		var program = _gl.createProgram();

		var prefix_vertex, prefix_fragment;

		if ( material instanceof THREE.RawShaderMaterial ) {

			prefix_vertex = '';
			prefix_fragment = '';

		} else {

			prefix_vertex = [

				"precision " + parameters.precision + " float;",
				"precision " + parameters.precision + " int;",

				customDefines,

				parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

				"#define MAX_SHADOWS " + parameters.maxShadows,

				"#define MAX_BONES " + parameters.maxBones,

				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",

				parameters.skinning ? "#define USE_SKINNING" : "",
				parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

				parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
				parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",

				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

				parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

				parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
				//_this._glExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",


				"uniform mat4 modelMatrix;",
				"uniform mat4 modelViewMatrix;",
				"uniform mat4 projectionMatrix;",
				"uniform mat4 viewMatrix;",
				"uniform mat3 normalMatrix;",
				"uniform vec3 cameraPosition;",

				"attribute vec3 position;",
				"attribute vec3 normal;",
				"attribute vec2 uv;",
				"attribute vec2 uv2;",

				"#ifdef USE_COLOR",

				"	attribute vec3 color;",

				"#endif",

				"#ifdef USE_MORPHTARGETS",

				"	attribute vec3 morphTarget0;",
				"	attribute vec3 morphTarget1;",
				"	attribute vec3 morphTarget2;",
				"	attribute vec3 morphTarget3;",

				"	#ifdef USE_MORPHNORMALS",

				"		attribute vec3 morphNormal0;",
				"		attribute vec3 morphNormal1;",
				"		attribute vec3 morphNormal2;",
				"		attribute vec3 morphNormal3;",

				"	#else",

				"		attribute vec3 morphTarget4;",
				"		attribute vec3 morphTarget5;",
				"		attribute vec3 morphTarget6;",
				"		attribute vec3 morphTarget7;",

				"	#endif",

				"#endif",

				"#ifdef USE_SKINNING",

				"	attribute vec4 skinIndex;",
				"	attribute vec4 skinWeight;",

				"#endif",

				""

			].join( '\n' );

			prefix_fragment = [

				"precision " + parameters.precision + " float;",
				"precision " + parameters.precision + " int;",

				( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

				customDefines,

				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

				"#define MAX_SHADOWS " + parameters.maxShadows,

				parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

				( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
				( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",

				parameters.metal ? "#define METAL" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",

				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

				parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
				//_this._glExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",

				"uniform mat4 viewMatrix;",
				"uniform vec3 cameraPosition;",
				""

			].join( '\n' );

		}

		var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
		var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		if ( index0AttributeName !== undefined ) {

			// Force a particular attribute to index 0.
			// because potentially expensive emulation is done by browser if attribute 0 is disabled.
			// And, color, for example is often automatically bound to index 0 so disabling it

			_gl.bindAttribLocation( program, 0, index0AttributeName );

		}

		_gl.linkProgram( program );

		if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

			console.error( 'THREE.WebGLProgram: Could not initialise shader.' );
			console.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
			console.error( 'gl.getError()', _gl.getError() );

		}

		if ( _gl.getProgramInfoLog( program ) !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );

		}

		// clean up

		_gl.deleteShader( glVertexShader );
		_gl.deleteShader( glFragmentShader );

		// cache uniform locations

		var identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition', 'morphTargetInfluences', 'bindMatrix', 'bindMatrixInverse'

		];

		if ( parameters.useVertexTexture ) {

			identifiers.push( 'boneTexture' );
			identifiers.push( 'boneTextureWidth' );
			identifiers.push( 'boneTextureHeight' );

		} else {

			identifiers.push( 'boneGlobalMatrices' );

		}

		if ( parameters.logarithmicDepthBuffer ) {

			identifiers.push('logDepthBufFC');

		}


		for ( var u in uniforms ) {

			identifiers.push( u );

		}

		this.uniforms = cacheUniformLocations( _gl, program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinIndex", "skinWeight", "lineDistance"

		];

		for ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {

			identifiers.push( "morphTarget" + i );

		}

		for ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {

			identifiers.push( "morphNormal" + i );

		}

		for ( var a in attributes ) {

			identifiers.push( a );

		}

		this.attributes = cacheAttributeLocations( _gl, program, identifiers );
		this.attributesKeys = Object.keys( this.attributes );

		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

	var addLineNumbers = function ( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	};

	return function ( gl, type, string ) {

		var shader = gl.createShader( type ); 

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ) );
			console.warn( addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	};

} )();

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

	var gl = renderer.context;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;
	var hasVertexTexture;

	var tempTexture, occlusionTexture;

	var init = function () {

		var vertices = new Float32Array( [
			-1, -1,  0, 0,
			 1, -1,  1, 0,
			 1,  1,  1, 1,
			-1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		gl.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

		var shader;

		if ( hasVertexTexture ) {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"uniform sampler2D occlusionMap;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if( renderType == 2 ) {",

							"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

							"vVisibility =        visibility.r / 9.0;",
							"vVisibility *= 1.0 - visibility.g / 9.0;",
							"vVisibility *=       visibility.b / 9.0;",
							"vVisibility *= 1.0 - visibility.a / 9.0;",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						// pink square

						"if( renderType == 0 ) {",

							"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

						// restore

						"} else if( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * vVisibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		} else {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if( renderType == 2 ) {",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"precision mediump float;",

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform sampler2D occlusionMap;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",

					"void main() {",

						// pink square

						"if( renderType == 0 ) {",

							"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

						// restore

						"} else if( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
							"visibility = ( 1.0 - visibility / 4.0 );",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * visibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		}

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		}

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	};

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		gl.enableVertexAttribArray( attributes.vertex );
		gl.enableVertexAttribArray( attributes.uv );

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/unforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.disable( gl.CULL_FACE );
		gl.depthMask( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];
			
			tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition )

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				gl.activeTexture( gl.TEXTURE1 );
				gl.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				gl.disable( gl.BLEND );
				gl.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				gl.activeTexture( gl.TEXTURE0 );
				gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				gl.disable( gl.DEPTH_TEST );

				gl.activeTexture( gl.TEXTURE1 );
				gl.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition )

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				gl.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		gl.enable( gl.CULL_FACE );
		gl.enable( gl.DEPTH_TEST );
		gl.depthMask( true );

		renderer.resetGLState();

	};

	function createProgram ( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

};

// File:src/renderers/webgl/plugins/ShadowMapPlugin.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {

	var _gl = _renderer.context;

	var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_matrixPosition = new THREE.Vector3(),
	
	_renderList = [];

	// init

	var depthShader = THREE.ShaderLib[ "depthRGBA" ];
	var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

	_depthMaterial = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader
	 } );

	_depthMaterialMorph = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		morphTargets: true
	} );

	_depthMaterialSkin = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		skinning: true
	} );

	_depthMaterialMorphSkin = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		morphTargets: true,
		skinning: true
	} );

	_depthMaterial._shadowPass = true;
	_depthMaterialMorph._shadowPass = true;
	_depthMaterialSkin._shadowPass = true;
	_depthMaterialMorphSkin._shadowPass = true;

	this.render = function ( scene, camera ) {

		if ( _renderer.shadowMapEnabled === false ) return;

		var i, il, j, jl, n,

		shadowMap, shadowMatrix, shadowCamera,
		program, buffer, material,
		webglObject, object, light,

		lights = [],
		k = 0,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_gl.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.FRONT );

		} else {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.setDepthTest( true );

		// preprocess lights
		// 	- skip lights that are not casting shadows
		//	- create virtual lights for cascaded shadow maps

		for ( i = 0, il = _lights.length; i < il; i ++ ) {

			light = _lights[ i ];

			if ( ! light.castShadow ) continue;

			if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

				for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

					var virtualLight;

					if ( ! light.shadowCascadeArray[ n ] ) {

						virtualLight = createVirtualLight( light, n );
						virtualLight.originalCamera = camera;

						var gyro = new THREE.Gyroscope();
						gyro.position.copy( light.shadowCascadeOffset );

						gyro.add( virtualLight );
						gyro.add( virtualLight.target );

						camera.add( gyro );

						light.shadowCascadeArray[ n ] = virtualLight;

						console.log( "Created virtualLight", virtualLight );

					} else {

						virtualLight = light.shadowCascadeArray[ n ];

					}

					updateVirtualLight( light, n );

					lights[ k ] = virtualLight;
					k ++;

				}

			} else {

				lights[ k ] = light;
				k ++;

			}

		}

		// render depth map

		for ( i = 0, il = lights.length; i < il; i ++ ) {

			light = lights[ i ];

			if ( ! light.shadowMap ) {

				var shadowFilter = THREE.LinearFilter;

				if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

					shadowFilter = THREE.NearestFilter;

				}

				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

				light.shadowMatrix = new THREE.Matrix4();

			}

			if ( ! light.shadowCamera ) {

				if ( light instanceof THREE.SpotLight ) {

					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

				} else if ( light instanceof THREE.DirectionalLight ) {

					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

				} else {

					console.error( "Unsupported light type for shadow" );
					continue;

				}

				scene.add( light.shadowCamera );

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			}

			if ( light.shadowCameraVisible && ! light.cameraHelper ) {

				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
				scene.add( light.cameraHelper );

			}

			if ( light.isVirtual && virtualLight.originalCamera == camera ) {

				updateShadowCamera( camera, light );

			}

			shadowMap = light.shadowMap;
			shadowMatrix = light.shadowMatrix;
			shadowCamera = light.shadowCamera;

			//

			shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
			_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _matrixPosition );
			shadowCamera.updateMatrixWorld();

			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

			//

			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
			if ( light.shadowCameraVisible ) light.cameraHelper.update();

			// compute shadow matrix

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			// update camera matrices and frustum

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			// render shadow map

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// set object matrices & frustum culling

			_renderList.length = 0;

			projectObject( scene, scene, shadowCamera );


			// render regular objects

			var objectMaterial, useMorphing, useSkinning;

			for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {

				webglObject = _renderList[ j ];

				object = webglObject.object;
				buffer = webglObject.buffer;

				// culling is overriden globally for all objects
				// while rendering depth map

				// need to deal with MeshFaceMaterial somehow
				// in that case just use the first of material.materials for now
				// (proper solution would require to break objects by materials
				//  similarly to regular rendering and then set corresponding
				//  depth materials per each chunk instead of just once per object)

				objectMaterial = getObjectMaterial( object );

				useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
				useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

				if ( object.customDepthMaterial ) {

					material = object.customDepthMaterial;

				} else if ( useSkinning ) {

					material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

				} else if ( useMorphing ) {

					material = _depthMaterialMorph;

				} else {

					material = _depthMaterial;

				}

				_renderer.setMaterialFaces( objectMaterial );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );

				} else {

					_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );

				}

			}

			// set matrices and render immediate objects

			for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {

				webglObject = _webglObjectsImmediate[ j ];
				object = webglObject.object;

				if ( object.visible && object.castShadow ) {

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );

				}

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.resetGLState();

	};

	function projectObject( scene, object, shadowCamera ){

		if ( object.visible ) {

			var webglObjects = _webglObjects[ object.id ];

			if ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {

				for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

					var webglObject = webglObjects[ i ];

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( webglObject );

				}

			}

			for ( var i = 0, l = object.children.length; i < l; i ++ ) {

				projectObject( scene, object.children[ i ], shadowCamera );

			}

		}

	}

	function createVirtualLight( light, cascade ) {

		var virtualLight = new THREE.DirectionalLight();

		virtualLight.isVirtual = true;

		virtualLight.onlyShadow = true;
		virtualLight.castShadow = true;

		virtualLight.shadowCameraNear = light.shadowCameraNear;
		virtualLight.shadowCameraFar = light.shadowCameraFar;

		virtualLight.shadowCameraLeft = light.shadowCameraLeft;
		virtualLight.shadowCameraRight = light.shadowCameraRight;
		virtualLight.shadowCameraBottom = light.shadowCameraBottom;
		virtualLight.shadowCameraTop = light.shadowCameraTop;

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;

		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
		virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
		virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

		virtualLight.pointsWorld = [];
		virtualLight.pointsFrustum = [];

		var pointsWorld = virtualLight.pointsWorld,
			pointsFrustum = virtualLight.pointsFrustum;

		for ( var i = 0; i < 8; i ++ ) {

			pointsWorld[ i ] = new THREE.Vector3();
			pointsFrustum[ i ] = new THREE.Vector3();

		}

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
		pointsFrustum[ 1 ].set(  1, - 1, nearZ );
		pointsFrustum[ 2 ].set( - 1,  1, nearZ );
		pointsFrustum[ 3 ].set(  1,  1, nearZ );

		pointsFrustum[ 4 ].set( - 1, - 1, farZ );
		pointsFrustum[ 5 ].set(  1, - 1, farZ );
		pointsFrustum[ 6 ].set( - 1,  1, farZ );
		pointsFrustum[ 7 ].set(  1,  1, farZ );

		return virtualLight;

	}

	// Synchronize virtual light with the original light

	function updateVirtualLight( light, cascade ) {

		var virtualLight = light.shadowCascadeArray[ cascade ];

		virtualLight.position.copy( light.position );
		virtualLight.target.position.copy( light.target.position );
		virtualLight.lookAt( virtualLight.target );

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;
		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		var pointsFrustum = virtualLight.pointsFrustum;

		pointsFrustum[ 0 ].z = nearZ;
		pointsFrustum[ 1 ].z = nearZ;
		pointsFrustum[ 2 ].z = nearZ;
		pointsFrustum[ 3 ].z = nearZ;

		pointsFrustum[ 4 ].z = farZ;
		pointsFrustum[ 5 ].z = farZ;
		pointsFrustum[ 6 ].z = farZ;
		pointsFrustum[ 7 ].z = farZ;

	}

	// Fit shadow camera's ortho frustum to camera frustum

	function updateShadowCamera( camera, light ) {

		var shadowCamera = light.shadowCamera,
			pointsFrustum = light.pointsFrustum,
			pointsWorld = light.pointsWorld;

		_min.set( Infinity, Infinity, Infinity );
		_max.set( - Infinity, - Infinity, - Infinity );

		for ( var i = 0; i < 8; i ++ ) {

			var p = pointsWorld[ i ];

			p.copy( pointsFrustum[ i ] );
			p.unproject( camera );

			p.applyMatrix4( shadowCamera.matrixWorldInverse );

			if ( p.x < _min.x ) _min.x = p.x;
			if ( p.x > _max.x ) _max.x = p.x;

			if ( p.y < _min.y ) _min.y = p.y;
			if ( p.y > _max.y ) _max.y = p.y;

			if ( p.z < _min.z ) _min.z = p.z;
			if ( p.z > _max.z ) _max.z = p.z;

		}

		shadowCamera.left = _min.x;
		shadowCamera.right = _max.x;
		shadowCamera.top = _max.y;
		shadowCamera.bottom = _min.y;

		// can't really fit near/far
		//shadowCamera.near = _min.z;
		//shadowCamera.far = _max.z;

		shadowCamera.updateProjectionMatrix();

	}

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use for shadow maps

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

	var gl = renderer.context;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;
	
	var init = function () {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new THREE.Texture( canvas );
		texture.needsUpdate = true;

	};

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		gl.enableVertexAttribArray( attributes.position );
		gl.enableVertexAttribArray( attributes.uv );

		gl.disable( gl.CULL_FACE );
		gl.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		gl.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );

			if ( sprite.renderDepth === null ) {

				sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

			} else {

				sprite.z = sprite.renderDepth;

			}

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

			scale[ 0 ] = sprite.scale.x;
			scale[ 1 ] = sprite.scale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			renderer.setDepthTest( material.depthTest );
			renderer.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				renderer.setTexture( material.map, 0 );

			} else {

				renderer.setTexture( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		gl.enable( gl.CULL_FACE );
		
		renderer.resetGLState();

	};

	function createProgram () {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	};

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	};

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

		var matrix;

		if ( geometry2 instanceof THREE.Mesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.Texture( undefined, mapping );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		}, undefined, function ( event ) {

			if ( onError ) onError( event );

		} );

		texture.sourceFile = url;

		return texture;

	},

	loadTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.CubeTexture( images, mapping );

		// no flipping needed for cube textures

		texture.flipY = false;

		var loaded = 0;

		var loadTexture = function ( i ) {

			loader.load( array[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded += 1;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			} );

		}

		for ( var i = 0, il = array.length; i < il; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

	},

	getNormalMap: function ( image, depth ) {

		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

		var cross = function ( a, b ) {

			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

		}

		var subtract = function ( a, b ) {

			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

		}

		var normalize = function ( a ) {

			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

		}

		depth = depth | 1;

		var width = image.width;
		var height = image.height;

		var canvas = document.createElement( 'canvas' );
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext( '2d' );
		context.drawImage( image, 0, 0 );

		var data = context.getImageData( 0, 0, width, height ).data;
		var imageData = context.createImageData( width, height );
		var output = imageData.data;

		for ( var x = 0; x < width; x ++ ) {

			for ( var y = 0; y < height; y ++ ) {

				var ly = y - 1 < 0 ? 0 : y - 1;
				var uy = y + 1 > height - 1 ? height - 1 : y + 1;
				var lx = x - 1 < 0 ? 0 : x - 1;
				var ux = x + 1 > width - 1 ? width - 1 : x + 1;

				var points = [];
				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

				var normals = [];
				var num_points = points.length;

				for ( var i = 0; i < num_points; i ++ ) {

					var v1 = points[ i ];
					var v2 = points[ ( i + 1 ) % num_points ];
					v1 = subtract( v1, origin );
					v2 = subtract( v2, origin );
					normals.push( normalize( cross( v1, v2 ) ) );

				}

				var normal = [ 0, 0, 0 ];

				for ( var i = 0; i < normals.length; i ++ ) {

					normal[ 0 ] += normals[ i ][ 0 ];
					normal[ 1 ] += normals[ i ][ 1 ];
					normal[ 2 ] += normals[ i ][ 2 ];

				}

				normal[ 0 ] /= normals.length;
				normal[ 1 ] /= normals.length;
				normal[ 2 ] /= normals.length;

				var idx = ( y * width + x ) * 4;

				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
				output[ idx + 3 ] = 255;

			}

		}

		context.putImageData( imageData, 0, 0 );

		return canvas;

	},

	generateDataTexture: function ( width, height, color ) {

		var size = width * height;
		var data = new Uint8Array( 3 * size );

		var r = Math.floor( color.r * 255 );
		var g = Math.floor( color.g * 255 );
		var b = Math.floor( color.b * 255 );

		for ( var i = 0; i < size; i ++ ) {

			data[ i * 3 ] 	   = r;
			data[ i * 3 + 1 ] = g;
			data[ i * 3 + 2 ] = b;

		}

		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
		texture.needsUpdate = true;

		return texture;

	}

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Object3D();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 * 	typeface.js and canvastext
 * 		For converting fonts and rendering with javascript
 *		http://typeface.neocracy.org
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

	faces: {},

	// Just for now. face[weight][style]

	face: 'helvetiker',
	weight: 'normal',
	style: 'normal',
	size: 150,
	divisions: 10,

	getFace: function () {

		try {

			return this.faces[ this.face ][ this.weight ][ this.style ];

		} catch (e) {

			throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

		};

	},

	loadFace: function ( data ) {

		var family = data.familyName.toLowerCase();

		var ThreeFont = this;

		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		return data;

	},

	drawText: function ( text ) {

		var characterPts = [], allPts = [];

		// RenderText

		var i, p,
			face = this.getFace(),
			scale = this.size / face.resolution,
			offset = 0,
			chars = String( text ).split( '' ),
			length = chars.length;

		var fontPaths = [];

		for ( i = 0; i < length; i ++ ) {

			var path = new THREE.Path();

			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
			offset += ret.offset;

			fontPaths.push( ret.path );

		}

		// get the width

		var width = offset / 2;
		//
		// for ( p = 0; p < allPts.length; p++ ) {
		//
		// 	allPts[ p ].x -= width;
		//
		// }

		//var extract = this.extractPoints( allPts, characterPts );
		//extract.contour = allPts;

		//extract.paths = fontPaths;
		//extract.offset = width;

		return { paths: fontPaths, offset: width };

	},




	extractGlyphPoints: function ( c, face, scale, offset, path ) {

		var pts = [];

		var i, i2, divisions,
			outline, action, length,
			scaleX, scaleY,
			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
			laste,
			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

		if ( ! glyph ) return;

		if ( glyph.o ) {

			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
			length = outline.length;

			scaleX = scale;
			scaleY = scale;

			for ( i = 0; i < length; ) {

				action = outline[ i ++ ];

				//console.log( action );

				switch ( action ) {

				case 'm':

					// Move To

					x = outline[ i ++ ] * scaleX + offset;
					y = outline[ i ++ ] * scaleY;

					path.moveTo( x, y );
					break;

				case 'l':

					// Line To

					x = outline[ i ++ ] * scaleX + offset;
					y = outline[ i ++ ] * scaleY;
					path.lineTo( x,y );
					break;

				case 'q':

					// QuadraticCurveTo

					cpx  = outline[ i ++ ] * scaleX + offset;
					cpy  = outline[ i ++ ] * scaleY;
					cpx1 = outline[ i ++ ] * scaleX + offset;
					cpy1 = outline[ i ++ ] * scaleY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
					  }

				  }

				  break;

				case 'b':

					// Cubic Bezier Curve

					cpx  = outline[ i ++ ] *  scaleX + offset;
					cpy  = outline[ i ++ ] *  scaleY;
					cpx1 = outline[ i ++ ] *  scaleX + offset;
					cpy1 = outline[ i ++ ] *  scaleY;
					cpx2 = outline[ i ++ ] *  scaleX + offset;
					cpy2 = outline[ i ++ ] *  scaleY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

						}

					}

					break;

				}

			}
		}



		return { offset: glyph.ha * scale, path:path };
	}

};


THREE.FontUtils.generateShapes = function ( text, parameters ) {

	// Parameters 

	parameters = parameters || {};

	var size = parameters.size !== undefined ? parameters.size : 100;
	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

	var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
	var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
	var style = parameters.style !== undefined ? parameters.style : 'normal';

	THREE.FontUtils.size = size;
	THREE.FontUtils.divisions = curveSegments;

	THREE.FontUtils.face = font;
	THREE.FontUtils.weight = weight;
	THREE.FontUtils.style = style;

	// Get a Font data json object

	var data = THREE.FontUtils.drawText( text );

	var paths = data.paths;
	var shapes = [];

	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

	}

	return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function ( namespace ) {

	var EPSILON = 0.0000000001;

	// takes in an contour array and returns

	var process = function ( contour, indices ) {

		var n = contour.length;

		if ( n < 3 ) return null;

		var result = [],
			verts = [],
			vertIndices = [];

		/* we want a counter-clockwise polygon in verts */

		var u, v, w;

		if ( area( contour ) > 0.0 ) {

			for ( v = 0; v < n; v ++ ) verts[ v ] = v;

		} else {

			for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

		}

		var nv = n;

		/*  remove nv - 2 vertices, creating 1 triangle every time */

		var count = 2 * nv;   /* error detection */

		for ( v = nv - 1; nv > 2; ) {

			/* if we loop, it is probably a non-simple polygon */

			if ( ( count -- ) <= 0 ) {

				//** Triangulate: ERROR - probable bad polygon!

				//throw ( "Warning, unable to triangulate polygon!" );
				//return null;
				// Sometimes warning is fine, especially polygons are triangulated in reverse.
				console.log( 'Warning, unable to triangulate polygon!' );

				if ( indices ) return vertIndices;
				return result;

			}

			/* three consecutive vertices in current polygon, <u,v,w> */

			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

			if ( snip( contour, u, v, w, nv, verts ) ) {

				var a, b, c, s, t;

				/* true names of the vertices */

				a = verts[ u ];
				b = verts[ v ];
				c = verts[ w ];

				/* output Triangle */

				result.push( [ contour[ a ],
					contour[ b ],
					contour[ c ] ] );


				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

				/* remove v from the remaining polygon */

				for ( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv --;

				/* reset error detection counter */

				count = 2 * nv;

			}

		}

		if ( indices ) return vertIndices;
		return result;

	};

	// calculate area of the contour polygon

	var area = function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	};

	var snip = function ( contour, u, v, w, n, verts ) {

		var p;
		var ax, ay, bx, by;
		var cx, cy, px, py;

		ax = contour[ verts[ u ] ].x;
		ay = contour[ verts[ u ] ].y;

		bx = contour[ verts[ v ] ].x;
		by = contour[ verts[ v ] ].y;

		cx = contour[ verts[ w ] ].x;
		cy = contour[ verts[ w ] ].y;

		if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

		var aX, aY, bX, bY, cX, cY;
		var apx, apy, bpx, bpy, cpx, cpy;
		var cCROSSap, bCROSScp, aCROSSbp;

		aX = cx - bx;  aY = cy - by;
		bX = ax - cx;  bY = ay - cy;
		cX = bx - ax;  cY = by - ay;

		for ( p = 0; p < n; p ++ ) {

			px = contour[ verts[ p ] ].x
			py = contour[ verts[ p ] ].y

			if ( ( ( px === ax ) && ( py === ay ) ) ||
				 ( ( px === bx ) && ( py === by ) ) ||
				 ( ( px === cx ) && ( py === cy ) ) )	continue;

			apx = px - ax;  apy = py - ay;
			bpx = px - bx;  bpy = py - by;
			cpx = px - cx;  cpy = py - cy;

			// see if p is inside triangle abc

			aCROSSbp = aX * bpy - aY * bpx;
			cCROSSap = cX * apy - cY * apx;
			bCROSScp = bX * cpy - bY * cpx;

			if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

		}

		return true;

	};


	namespace.Triangulate = process;
	namespace.Triangulate.area = area;

	return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
THREE.typeface_js = self._typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

	THREE.Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;
	this.source = this.context.createBufferSource();

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );

THREE.Audio.prototype.load = function ( file ) {

	var scope = this;

	var request = new XMLHttpRequest();
	request.open( 'GET', file, true );
	request.responseType = 'arraybuffer';
	request.onload = function ( e ) {

		scope.context.decodeAudioData( this.response, function ( buffer ) {

			scope.source.buffer = buffer;
			scope.source.connect( scope.panner );
			scope.source.start( 0 );

		} );

	};
	request.send();

	return this;

};

THREE.Audio.prototype.setLoop = function ( value ) {

	this.source.loop = value;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

	this.panner.refDistance = value;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

	this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();

	return function ( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		position.setFromMatrixPosition( this.matrixWorld );

		this.panner.setPosition( position.x, position.y, position.z );

	};

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

	THREE.Object3D.call( this );

	this.type = 'AudioListener';

	this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3();

	var orientation = new THREE.Vector3();
	var velocity = new THREE.Vector3();

	var positionPrev = new THREE.Vector3();

	return function ( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		var listener = this.context.listener;

		this.matrixWorld.decompose( position, quaternion, scale );

		orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );
		velocity.subVectors( position, positionPrev );

		listener.setPosition( position.x, position.y, position.z );
		listener.setOrientation( orientation.x, orientation.y, orientation.z, this.up.x, this.up.y, this.up.z );
		listener.setVelocity( velocity.x, velocity.y, velocity.z );

		positionPrev.copy( position );

	};

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

	console.log( "Warning, getPoint() not implemented!" );
	return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

	if ( ! divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPoint( d / divisions ) );

	}

	return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

	if ( ! divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPointAt( d / divisions ) );

	}

	return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

	var lengths = this.getLengths();
	return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

	if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

	if ( this.cacheArcLengths
		&& ( this.cacheArcLengths.length == divisions + 1 )
		&& ! this.needsUpdate) {

		//console.log( "cached", this.cacheArcLengths );
		return this.cacheArcLengths;

	}

	this.needsUpdate = false;

	var cache = [];
	var current, last = this.getPoint( 0 );
	var p, sum = 0;

	cache.push( 0 );

	for ( p = 1; p <= divisions; p ++ ) {

		current = this.getPoint ( p / divisions );
		sum += current.distanceTo( last );
		cache.push( sum );
		last = current;

	}

	this.cacheArcLengths = cache;

	return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
	this.needsUpdate = true;
	this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

	var arcLengths = this.getLengths();

	var i = 0, il = arcLengths.length;

	var targetArcLength; // The targeted u distance value to get

	if ( distance ) {

		targetArcLength = distance;

	} else {

		targetArcLength = u * arcLengths[ il - 1 ];

	}

	//var time = Date.now();

	// binary search for the index with largest value smaller than target u distance

	var low = 0, high = il - 1, comparison;

	while ( low <= high ) {

		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

		comparison = arcLengths[ i ] - targetArcLength;

		if ( comparison < 0 ) {

			low = i + 1;
			continue;

		} else if ( comparison > 0 ) {

			high = i - 1;
			continue;

		} else {

			high = i;
			break;

			// DONE

		}

	}

	i = high;

	//console.log('b' , i, low, high, Date.now()- time);

	if ( arcLengths[ i ] == targetArcLength ) {

		var t = i / ( il - 1 );
		return t;

	}

	// we could get finer grain at lengths, or use simple interpolatation between two points

	var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il -1 );

	return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

	var delta = 0.0001;
	var t1 = t - delta;
	var t2 = t + delta;

	// Capping in case of danger

	if ( t1 < 0 ) t1 = 0;
	if ( t2 > 1 ) t2 = 1;

	var pt1 = this.getPoint( t1 );
	var pt2 = this.getPoint( t2 );

	var vec = pt2.clone().sub(pt1);
	return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

		return - 3 * p0 * (1 - t) * (1 - t)  +
			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
			6 * t *  p2 * (1-t) - 3 * t * t * p2 +
			3 * t * t * p3;

	},

	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
		var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3  t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];
	this.bends = [];
	
	this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[0].getPoint(0);
	var endPoint = this.curves[this.curves.length-1].getPoint(1);
	
	if (! startPoint.equals(endPoint)) {
		this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
	}
	
};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0, diff, curve;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			diff = curveLengths[ i ] - d;
			curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

			break;
		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

		return this.cacheLengths;

	};

	// Get length of subsurve
	// Push sums into cached array

	var lengths = [], sums = 0;
	var i, il = this.curves.length;

	for ( i = 0; i < il; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function () {

	var points = this.getPoints();

	var maxX, maxY, maxZ;
	var minX, minY, minZ;

	maxX = maxY = Number.NEGATIVE_INFINITY;
	minX = minY = Number.POSITIVE_INFINITY;

	var p, i, il, sum;

	var v3 = points[0] instanceof THREE.Vector3;

	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		if ( p.x > maxX ) maxX = p.x;
		else if ( p.x < minX ) minX = p.x;

		if ( p.y > maxY ) maxY = p.y;
		else if ( p.y < minY ) minY = p.y;

		if ( v3 ) {

			if ( p.z > maxZ ) maxZ = p.z;
			else if ( p.z < minZ ) minZ = p.z;

		}

		sum.add( p );

	}

	var ret = {

		minX: minX,
		minY: minY,
		maxX: maxX,
		maxY: maxY

	};

	if ( v3 ) {

		ret.maxZ = maxZ;
		ret.minZ = minZ;

	}

	return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < points.length; i ++ ) {

		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

	}

	return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

	this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
	var i, il;

	if ( ! bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

	var oldPts = this.getSpacedPoints( segments );

	var i, il;

	if ( ! bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

	var bounds = this.getBoundingBox();

	var i, il, p, oldX, oldY, xNorm;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[ i ];

		oldX = p.x;
		oldY = p.y;

		xNorm = oldX / bounds.maxX;

		// If using actual distance, for length > path, requires line extrusions
		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

		xNorm = path.getUtoTmapping( xNorm, oldX );

		// check for out of bounds?

		var pathPt = path.getPoint( xNorm );
		var normal = path.getTangent( xNorm );
		normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

		p.x = pathPt.x + normal.x;
		p.y = pathPt.y + normal.y;

	}

	return oldPts;

};


// File:src/extras/core/Gyroscope.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

	THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );

THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {

	var translationObject = new THREE.Vector3();
	var quaternionObject = new THREE.Quaternion();
	var scaleObject = new THREE.Vector3();

	var translationWorld = new THREE.Vector3();
	var quaternionWorld = new THREE.Quaternion();
	var scaleWorld = new THREE.Vector3();

	return function ( force ) {

		this.matrixAutoUpdate && this.updateMatrix();

		// update matrixWorld

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent ) {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
				this.matrix.decompose( translationObject, quaternionObject, scaleObject );

				this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );


			} else {

				this.matrixWorld.copy( this.matrix );

			}


			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	};
	
}() );

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call(this);

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );

THREE.PathActions = {

	MOVE_TO: 'moveTo',
	LINE_TO: 'lineTo',
	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
	ARC: 'arc',								// Circle
	ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

		this.lineTo( vectors[ v ].x, vectors[ v ].y );

	};

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );
	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCPx, aCPy ),
												new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
											   aCP2x, aCP2y,
											   aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
											new THREE.Vector2( aCP1x, aCP1y ),
											new THREE.Vector2( aCP2x, aCP2y ),
											new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );
	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];
//---
	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc(aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {
	this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
		aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var args = Array.prototype.slice.call( arguments );
	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
									aStartAngle, aEndAngle, aClockwise );
	this.curves.push( curve );

	var lastPoint = curve.getPoint(1);
	args.push(lastPoint.x);
	args.push(lastPoint.y);

	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	if (this.useSpacedPoints) {
		console.log('tata');
		return this.getSpacedPoints( divisions, closedPath );
	}

	divisions = divisions || 12;

	var points = [];

	var i, il, item, action, args;
	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, j,
		t, tx, ty;

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		action = item.action;
		args = item.args;

		switch( action ) {

		case THREE.PathActions.MOVE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.LINE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.QUADRATIC_CURVE_TO:

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.BEZIER_CURVE_TO:

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.CSPLINE_THRU:

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) ) ;

			}

			break;

		case THREE.PathActions.ARC:

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !! args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;
		  
		case THREE.PathActions.ELLIPSE:

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !! args[ 6 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1];
	var EPSILON = 0.0000000001;
	if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
			 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
		points.splice( points.length - 1, 1);
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

	function extractSubpaths( inActions ) {

		var i, il, item, action, args;

		var subPaths = [], lastPath = new THREE.Path();

		for ( i = 0, il = inActions.length; i < il; i ++ ) {

			item = inActions[ i ];

			args = item.args;
			action = item.action;

			if ( action == THREE.PathActions.MOVE_TO ) {

				if ( lastPath.actions.length != 0 ) {

					subPaths.push( lastPath );
					lastPath = new THREE.Path();

				}

			}

			lastPath[ action ].apply( lastPath, args );

		}

		if ( lastPath.actions.length != 0 ) {

			subPaths.push( lastPath );

		}

		// console.log(subPaths);

		return	subPaths;
	}

	function toShapesNoHoles( inSubpaths ) {

		var shapes = [];

		for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

			var tmpPath = inSubpaths[ i ];

			var tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;

			shapes.push( tmpShape );
		}

		//console.log("shape", shapes);

		return shapes;
	};

	function isPointInsidePolygon( inPt, inPolygon ) {
		var EPSILON = 0.0000000001;

		var polyLen = inPolygon.length;

		// inPt on polygon contour => immediate success    or
		// toggling of inside/outside at every single! intersection point of an edge
		//  with the horizontal line through inPt, left of inPt
		//  not counting lowerY endpoints of edges and whole edges on that line
		var inside = false;
		for( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
			var edgeLowPt  = inPolygon[ p ];
			var edgeHighPt = inPolygon[ q ];

			var edgeDx = edgeHighPt.x - edgeLowPt.x;
			var edgeDy = edgeHighPt.y - edgeLowPt.y;

			if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel
				if ( edgeDy < 0 ) {
					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
				}
				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

				if ( inPt.y == edgeLowPt.y ) {
					if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?
					// continue;				// no intersection or edgeLowPt => doesn't count !!!
				} else {
					var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
					if ( perpEdge == 0 )				return	true;		// inPt is on contour ?
					if ( perpEdge < 0 ) 				continue;
					inside = ! inside;		// true intersection left of inPt
				}
			} else {		// parallel or colinear
				if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel
				// egde lies on the same horizontal line as inPt
				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
				// continue;
			}
		}

		return	inside;
	}


	var subPaths = extractSubpaths( this.actions );
	if ( subPaths.length == 0 ) return [];

	if ( noHoles === true )	return	toShapesNoHoles( subPaths );


	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length == 1) {

		tmpPath = subPaths[0];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? ! holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);
	
	var betterShapeHoles = [];
	var newShapes = [];
	var newShapeHoles = [];
	var mainIdx = 0;
	var tmpPoints;

	newShapes[mainIdx] = undefined;
	newShapeHoles[mainIdx] = [];

	var i, il;

	for ( i = 0, il = subPaths.length; i < il; i ++ ) {

		tmpPath = subPaths[ i ];
		tmpPoints = tmpPath.getPoints();
		solid = THREE.Shape.Utils.isClockWise( tmpPoints );
		solid = isCCW ? ! solid : solid;

		if ( solid ) {

			if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx ++;

			newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
			newShapes[mainIdx].s.actions = tmpPath.actions;
			newShapes[mainIdx].s.curves = tmpPath.curves;
			
			if ( holesFirst )	mainIdx ++;
			newShapeHoles[mainIdx] = [];

			//console.log('cw', i);

		} else {

			newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

			//console.log('ccw', i);

		}

	}

	// only Holes? -> probably all Shapes with wrong orientation
	if ( ! newShapes[0] )	return	toShapesNoHoles( subPaths );


	if ( newShapes.length > 1 ) {
		var ambigious = false;
		var toChange = [];

		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
			betterShapeHoles[sIdx] = [];
		}
		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
			var sh = newShapes[sIdx];
			var sho = newShapeHoles[sIdx];
			for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
				var ho = sho[hIdx];
				var hole_unassigned = true;
				for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
					if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
						if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
						if ( hole_unassigned ) {
							hole_unassigned = false;
							betterShapeHoles[s2Idx].push( ho );
						} else {
							ambigious = true;
						}
					}
				}
				if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
			}
		}
		// console.log("ambigious: ", ambigious);
		if ( toChange.length > 0 ) {
			// console.log("to change: ", toChange);
			if (! ambigious)	newShapeHoles = betterShapeHoles;
		}
	}

	var tmpHoles, j, jl;
	for ( i = 0, il = newShapes.length; i < il; i ++ ) {
		tmpShape = newShapes[i].s;
		shapes.push( tmpShape );
		tmpHoles = newShapeHoles[i];
		for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
			tmpShape.holes.push( tmpHoles[j].h );
		}
	}

	//console.log("shape", shapes);

	return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );
	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	var extruded = new THREE.ExtrudeGeometry( this, options );
	return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	var geometry = new THREE.ShapeGeometry( this, options );
	return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

	}

	return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getTransformedPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	if (this.useSpacedPoints) {
		return this.extractAllSpacedPoints(divisions);
	}

	return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

	return {

		shape: this.getTransformedSpacedPoints( divisions ),
		holes: this.getSpacedPointsHoles( divisions )

	};

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
			// inOtherPt needs to be colinear to the inSegment
			if ( inSegPt1.x != inSegPt2.x ) {
				if ( inSegPt1.x < inSegPt2.x ) {
					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
				} else {
					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
				}
			} else {
				if ( inSegPt1.y < inSegPt2.y ) {
					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
				} else {
					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
				}
			}
		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
			var EPSILON = 0.0000000001;

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs(limit) > EPSILON ) {			// not parallel

				var perpSeg2;
				if ( limit > 0 ) {
					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
				} else {
					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 == 0 ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt1 ];
				}
				if ( perpSeg2 == limit ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt2 ];
				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 == 0 )		return  [ inSeg2Pt1 ];
				if ( perpSeg1 == limit )	return  [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {		// parallel or colinear
				if ( ( perpSeg1 != 0 ) ||
					 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?
				var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {
					if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
						 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points
					return  [ inSeg1Pt1 ];                 					// they are the same point
				}
				// segment#1  is a single point
				if ( seg1Pt ) {
					if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return  [ inSeg1Pt1 ];
				}
				// segment#2  is a single point
				if ( seg2Pt ) {
					if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return  [ inSeg2Pt1 ];
				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if (seg1dx != 0) {		// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
					}
				} else {				// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
					}
				}
				if ( seg1minVal <= seg2minVal ) {
					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal == seg2minVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];
				} else {
					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal == seg2maxVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];
				}
			}
		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
			// The order of legs is important

			var EPSILON = 0.0000000001;

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {				// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
				} else {								// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
				}
			} else {										// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );
			}
		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;
				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;
				}

				return	true;
			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {
				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
					nextIdx = sIdx+1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
					if ( intersection.length > 0 )		return	true;
				}

				return	false;
			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {
				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
					chkHole = holes[indepHoles[ihIdx]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
						nextIdx = hIdx+1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
						if ( intersection.length > 0 )		return	true;
					}
				}
				return	false;
			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {
				counter --;
				if ( counter < 0 ) {
					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;
				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {
						holeIdx = indepHoles[h];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[cutKey] !== undefined )			continue;

						hole = holes[holeIdx];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
							holePt = hole[ h2 ];
							if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice(h,1);

							tmpShape1 = shape.slice( 0, shapeIndex+1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex+1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[cutKey] = true;			// remember failure
					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found
				}
			}

			return shape; 			/* shape with no holes */
		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[h] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.log( "Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return THREE.FontUtils.Triangulate.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * p;

	},

	b2p1: function ( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	},

	b2p2: function ( t, p ) {

		return t * t * p;

	},

	b2: function ( t, p0, p1, p2 ) {

		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

	},

	// Cubic Bezier Functions

	b3p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	},

	b3p1: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	},

	b3p2: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * t * t * p;

	},

	b3p3: function ( t, p ) {

		return t * t * t * p;

	},

	b3: function ( t, p0, p1, p2, p3 ) {

		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

	}

};


// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub(this.v1);
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub(this.v1);

	return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var vector = new THREE.Vector2();

	vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
	vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

	return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var vector = new THREE.Vector2();

	vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
	vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

	// returns unit vector

	return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]
	var point1 = points[ intPoint ]
	var point2 = points[ intPoint > points.length - 2 ? points.length -1 : intPoint + 1 ]
	var point3 = points[ intPoint > points.length - 3 ? points.length -1 : intPoint + 2 ]

	var vector = new THREE.Vector2();

	vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
	vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

	return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	var angle;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}
	
	var vector = new THREE.Vector2();

	vector.x = this.aX + this.xRadius * Math.cos( angle );
	vector.y = this.aY + this.yRadius * Math.sin( angle );

	return vector;

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.subVectors( this.v2, this.v1 ); // diff
		vector.multiplyScalar( t );
		vector.add( this.v1 );

		return vector;

	}

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
		vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

		return vector;

	}

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
		vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

		return vector;

	}

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var vector = new THREE.Vector3();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

		return vector;

	}

);

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

		var point0 = points[ ( intPoint - 1 ) % points.length ];
		var point1 = points[ ( intPoint     ) % points.length ];
		var point2 = points[ ( intPoint + 1 ) % points.length ];
		var point3 = points[ ( intPoint + 2 ) % points.length ];

		var vector = new THREE.Vector3();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

		return vector;

	}

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

	LINEAR: 0,
	CATMULLROM: 1,
	CATMULLROM_FORWARD: 2,

	//

	add: function () { console.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
	get: function () { console.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
	remove: function () { console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },

	//

	animations: [],

	init: function ( data ) {

		if ( data.initialized === true ) return;

		// loop through all keys

		for ( var h = 0; h < data.hierarchy.length; h ++ ) {

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				// remove minus times

				if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

					 data.hierarchy[ h ].keys[ k ].time = 0;

				}

				// create quaternions

				if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
				  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

					var quat = data.hierarchy[ h ].keys[ k ].rot;
					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

				}

			}

			// prepare morph target keys

			if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

				// get all used

				var usedMorphTargets = {};

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
						usedMorphTargets[ morphTargetName ] = - 1;

					}

				}

				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


				// set all used on all frames

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					var influences = {};

					for ( var morphTargetName in usedMorphTargets ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
								break;

							}

						}

						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

							influences[ morphTargetName ] = 0;

						}

					}

					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

				}

			}


			// remove all keys that are on the same time

			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

					data.hierarchy[ h ].keys.splice( k, 1 );
					k --;

				}

			}


			// set index

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				data.hierarchy[ h ].keys[ k ].index = k;

			}

		}

		data.initialized = true;

		return data;

	},

	parse: function ( root ) {

		var parseRecurseHierarchy = function ( root, hierarchy ) {

			hierarchy.push( root );

			for ( var c = 0; c < root.children.length; c ++ )
				parseRecurseHierarchy( root.children[ c ], hierarchy );

		};

		// setup hierarchy

		var hierarchy = [];

		if ( root instanceof THREE.SkinnedMesh ) {

			for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

				hierarchy.push( root.skeleton.bones[ b ] );

			}

		} else {

			parseRecurseHierarchy( root, hierarchy );

		}

		return hierarchy;

	},

	play: function ( animation ) {

		if ( this.animations.indexOf( animation ) === - 1 ) {

			this.animations.push( animation );

		}

	},

	stop: function ( animation ) {

		var index = this.animations.indexOf( animation );

		if ( index !== - 1 ) {

			this.animations.splice( index, 1 );

		}

	},

	update: function ( deltaTimeMS ) {

		for ( var i = 0; i < this.animations.length; i ++ ) {

			this.animations[ i ].resetBlendWeights( );

		}

		for ( var i = 0; i < this.animations.length; i ++ ) {

			this.animations[ i ].update( deltaTimeMS );

		}

	}

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, data ) {

	this.root = root;
	this.data = THREE.AnimationHandler.init( data );
	this.hierarchy = THREE.AnimationHandler.parse( root );

	this.currentTime = 0;
	this.timeScale = 1;

	this.isPlaying = false;
	this.loop = true;
	this.weight = 0;

	this.interpolationType = THREE.AnimationHandler.LINEAR;

};


THREE.Animation.prototype.keyTypes = [ "pos", "rot", "scl" ];


THREE.Animation.prototype.play = function ( startTime, weight ) {

	this.currentTime = startTime !== undefined ? startTime : 0;
	this.weight = weight !== undefined ? weight: 1;

	this.isPlaying = true;

	this.reset();

	THREE.AnimationHandler.play( this );

};


THREE.Animation.prototype.stop = function() {

	this.isPlaying = false;

	THREE.AnimationHandler.stop( this );

};

THREE.Animation.prototype.reset = function () {

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];

		object.matrixAutoUpdate = true;

		if ( object.animationCache === undefined ) {

			object.animationCache = {
				animations: {},
				blending: {
					positionWeight: 0.0,
					quaternionWeight: 0.0,
					scaleWeight: 0.0
				}
			};
		}

		if ( object.animationCache.animations[this.data.name] === undefined ) {

			object.animationCache.animations[this.data.name] = {};
			object.animationCache.animations[this.data.name].prevKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.animations[this.data.name].nextKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.animations[this.data.name].originalMatrix = object.matrix;

		}

		var animationCache = object.animationCache.animations[this.data.name];

		// Get keys to match our current time

		for ( var t = 0; t < 3; t ++ ) {

			var type = this.keyTypes[ t ];

			var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
			var nextKey = this.getNextKeyWith( type, h, 1 );

			while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

				prevKey = nextKey;
				nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

			}

			animationCache.prevKey[ type ] = prevKey;
			animationCache.nextKey[ type ] = nextKey;

		}

	}

};

THREE.Animation.prototype.resetBlendWeights = function () {

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];

		if ( object.animationCache !== undefined ) {

			object.animationCache.blending.positionWeight = 0.0;
			object.animationCache.blending.quaternionWeight = 0.0;
			object.animationCache.blending.scaleWeight = 0.0;

		}

	}

};

THREE.Animation.prototype.update = (function(){

	var points = [];
	var target = new THREE.Vector3();
	var newVector = new THREE.Vector3();
	var newQuat = new THREE.Quaternion();

	// Catmull-Rom spline

	var interpolateCatmullRom = function ( points, scale ) {

		var c = [], v3 = [],
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;

		point = ( points.length - 1 ) * scale;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
		c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

		pa = points[ c[ 0 ] ];
		pb = points[ c[ 1 ] ];
		pc = points[ c[ 2 ] ];
		pd = points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
		v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
		v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

		return v3;

	};

	var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

	return function ( delta ) {

		if ( this.isPlaying === false ) return;

		this.currentTime += delta * this.timeScale;

		if ( this.weight === 0 )
			return;

		//

		var duration = this.data.length;

		if ( this.currentTime > duration || this.currentTime < 0 ) {

			if ( this.loop ) {

				this.currentTime %= duration;

				if ( this.currentTime < 0 )
					this.currentTime += duration;

				this.reset();

			} else {

				this.stop();
				return;

			}

		}

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var object = this.hierarchy[ h ];
			var animationCache = object.animationCache.animations[this.data.name];
			var blending = object.animationCache.blending;

			// loop through pos/rot/scl

			for ( var t = 0; t < 3; t ++ ) {

				// get keys

				var type    = this.keyTypes[ t ];
				var prevKey = animationCache.prevKey[ type ];
				var nextKey = animationCache.nextKey[ type ];

				if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
					( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

					prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					nextKey = this.getNextKeyWith( type, h, 1 );

					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					}

					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;

				}

				object.matrixAutoUpdate = true;
				object.matrixWorldNeedsUpdate = true;

				var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

				var prevXYZ = prevKey[ type ];
				var nextXYZ = nextKey[ type ];

				if ( scale < 0 ) scale = 0;
				if ( scale > 1 ) scale = 1;

				// interpolate

				if ( type === "pos" ) {

					if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

						newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
						newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
						newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

						// blend
						var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
						object.position.lerp( newVector, proportionalWeight );
						blending.positionWeight += this.weight;

					} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
								this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

						points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
						points[ 1 ] = prevXYZ;
						points[ 2 ] = nextXYZ;
						points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

						scale = scale * 0.33 + 0.33;

						var currentPoint = interpolateCatmullRom( points, scale );
						var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
						blending.positionWeight += this.weight;

						// blend

						var vector = object.position;
						
						vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
						vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
						vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

						if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

							var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

							target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
							target.sub( vector );
							target.y = 0;
							target.normalize();

							var angle = Math.atan2( target.x, target.z );
							object.rotation.set( 0, angle, 0 );

						}

					}

				} else if ( type === "rot" ) {

					THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

					// Avoid paying the cost of an additional slerp if we don't have to
					if ( blending.quaternionWeight === 0 ) {

						object.quaternion.copy(newQuat);
						blending.quaternionWeight = this.weight;

					} else {

						var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
						THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
						blending.quaternionWeight += this.weight;

					}

				} else if ( type === "scl" ) {

					newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

					var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
					object.scale.lerp( newVector, proportionalWeight );
					blending.scaleWeight += this.weight;

				}

			}

		}

		return true;

	};

})();





// Get next key with

THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key < keys.length - 1 ? key : keys.length - 1;

	} else {

		key = key % keys.length;

	}

	for ( ; key < keys.length; key ++ ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ 0 ];

};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key > 0 ? key : 0;

	} else {

		key = key >= 0 ? key : key + keys.length;

	}


	for ( ; key >= 0; key -- ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function ( data ) {

	this.root = data.node;
	this.data = THREE.AnimationHandler.init( data );
	this.hierarchy = THREE.AnimationHandler.parse( this.root );
	this.currentTime = 0;
	this.timeScale = 0.001;
	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	// initialize to first keyframes

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var keys = this.data.hierarchy[h].keys,
			sids = this.data.hierarchy[h].sids,
			obj = this.hierarchy[h];

		if ( keys.length && sids ) {

			for ( var s = 0; s < sids.length; s ++ ) {

				var sid = sids[ s ],
					next = this.getNextKeyWith( sid, h, 0 );

				if ( next ) {

					next.apply( sid );

				}

			}

			obj.matrixAutoUpdate = false;
			this.data.hierarchy[h].node.updateMatrix();
			obj.matrixWorldNeedsUpdate = true;

		}

	}

};


THREE.KeyFrameAnimation.prototype.play = function ( startTime ) {

	this.currentTime = startTime !== undefined ? startTime : 0;

	if ( this.isPlaying === false ) {

		this.isPlaying = true;

		// reset key cache

		var h, hl = this.hierarchy.length,
			object,
			node;

		for ( h = 0; h < hl; h ++ ) {

			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];

			if ( node.animationCache === undefined ) {

				node.animationCache = {};
				node.animationCache.prevKey = null;
				node.animationCache.nextKey = null;
				node.animationCache.originalMatrix = object.matrix;

			}

			var keys = this.data.hierarchy[h].keys;

			if (keys.length) {

				node.animationCache.prevKey = keys[ 0 ];
				node.animationCache.nextKey = keys[ 1 ];

				this.startTime = Math.min( keys[0].time, this.startTime );
				this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

			}

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.play( this );

};


THREE.KeyFrameAnimation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;

	THREE.AnimationHandler.stop( this );

	// reset JIT matrix and remove cache

	for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {
		
		var obj = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		if ( node.animationCache !== undefined ) {

			var original = node.animationCache.originalMatrix;

			original.copy( obj.matrix );
			obj.matrix = original;

			delete node.animationCache;

		}

	}

};


// Update

THREE.KeyFrameAnimation.prototype.update = function ( delta ) {

	if ( this.isPlaying === false ) return;

	this.currentTime += delta * this.timeScale;

	//

	var duration = this.data.length;

	if ( this.loop === true && this.currentTime > duration ) {

		this.currentTime %= duration;

	}

	this.currentTime = Math.min( this.currentTime, duration );

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		var keys = node.keys,
			animationCache = node.animationCache;


		if ( keys.length ) {

			var prevKey = animationCache.prevKey;
			var nextKey = animationCache.nextKey;

			if ( nextKey.time <= this.currentTime ) {

				while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

					prevKey = nextKey;
					nextKey = keys[ prevKey.index + 1 ];

				}

				animationCache.prevKey = prevKey;
				animationCache.nextKey = nextKey;

			}

			if ( nextKey.time >= this.currentTime ) {

				prevKey.interpolate( nextKey, this.currentTime );

			} else {

				prevKey.interpolate( nextKey, nextKey.time );

			}

			this.data.hierarchy[ h ].node.updateMatrix();
			object.matrixWorldNeedsUpdate = true;

		}

	}

};

// Get next key with

THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key % keys.length;

	for ( ; key < keys.length; key ++ ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ 0 ];

};

// Get previous key with

THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key >= 0 ? key : key + keys.length;

	for ( ; key >= 0; key -- ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ keys.length - 1 ];

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 */

THREE.MorphAnimation = function ( mesh ) {

	this.mesh = mesh;
	this.frames = mesh.morphTargetInfluences.length;
	this.currentTime = 0;
	this.duration = 1000;
	this.loop = true;

	this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

	play: function () {

		this.isPlaying = true;

	},

	pause: function () {

		this.isPlaying = false;

	},

	update: ( function () {

		var lastFrame = 0;
		var currentFrame = 0;

		return function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta;

			if ( this.loop === true && this.currentTime > this.duration ) {

				this.currentTime %= this.duration;

			}

			this.currentTime = Math.min( this.currentTime, this.duration );

			var interpolation = this.duration / this.frames;
			var frame = Math.floor( this.currentTime / interpolation );

			if ( frame != currentFrame ) {

				this.mesh.morphTargetInfluences[ lastFrame ] = 0;
				this.mesh.morphTargetInfluences[ currentFrame ] = 1;
				this.mesh.morphTargetInfluences[ frame ] = 0;

				lastFrame = currentFrame;
				currentFrame = frame;

			}

			this.mesh.morphTargetInfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
			this.mesh.morphTargetInfluences[ lastFrame ] = 1 - this.mesh.morphTargetInfluences[ frame ];

		}

	} )()

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var scope = this;

	var width_half = width / 2;
	var height_half = height / 2;
	var depth_half = depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var i, uvs = [],
	center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

	this.vertices.push(center);
	uvs.push( centerUV );

	for ( i = 0; i <= segments; i ++ ) {

		var vertex = new THREE.Vector3();
		var segment = thetaStart + i / segments * thetaLength;

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		this.vertices.push( vertex );
		uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 1; i <= segments; i ++ ) {

		this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
		this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/CubeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	console.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );
	return new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );

 };

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

	THREE.Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded
	};

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = radialSegments || 8;
	heightSegments = heightSegments || 1;

	openEnded = openEnded !== undefined ? openEnded : false;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * Math.PI * 2 );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * Math.PI * 2 );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeFaceNormals();

}

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  material: <int> // material index for front and back faces
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {
		shapes = [];
		return;
	}

	THREE.Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = shapes instanceof Array ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {
		var shape = shapes[ s ];
		this.addShape( shape, options );
	}
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	var material = options.material;
	var extrudeMaterial = options.extrudeMaterial;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initalization

	var ahole, h, hl; // looping of holes
	var scope = this;
	var bevelPoints = [];

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( ! vec ) console.log( "die" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length,
		cont, clen = contour.length;


	// Find directions for point movement

	var RAD_TO_DEGREES = 180 / Math.PI;


	function getBevelVec( inPt, inPrev, inNext ) {

		var EPSILON = 0.0000000001;
		
		// computes for inPt the corresponding point inPt' on a new contour
		//   shiftet by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.
		
		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
		
		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
		
		// check for colinear edges
		var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		
		if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear
			
			// length of vectors for normalizing
	
			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
			
			// shift adjacent points by unit vectors to the left
	
			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
			
			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
			// scaling factor for v_prev to intersection point
	
			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
			// vector from inPt to intersection point
	
			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
			if ( v_trans_lensq <= 2 ) {
				return	new THREE.Vector2( v_trans_x, v_trans_y );
			} else {
				shrink_by = Math.sqrt( v_trans_lensq / 2 );
			}
			
		} else {		// handle special case of colinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > EPSILON ) {
				if ( v_next_x > EPSILON ) { direction_eq = true; }
			} else {
				if ( v_prev_x < - EPSILON ) {
					if ( v_next_x < - EPSILON ) { direction_eq = true; }
				} else {
					if ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }
				}
			}

			if ( direction_eq ) {
				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );
			} else {
				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );
			}

		}

		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		var pt_i = contour[ i ];
		var pt_j = contour[ j ];
		var pt_k = contour[ k ];

		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {
	//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
		//bs = bevelSize * t ; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
			binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

			position2.copy( extrudePts[0] ).add(normal).add(binormal);

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[s] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0 ; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}
		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( --i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}
		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		// normal, color, material
		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

 		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

 		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new THREE.Vector2( a.x, a.y ),
			new THREE.Vector2( b.x, b.y ),
			new THREE.Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {
			return [
				new THREE.Vector2( a.x, 1 - a.z ),
				new THREE.Vector2( b.x, 1 - b.z ),
				new THREE.Vector2( c.x, 1 - c.z ),
				new THREE.Vector2( d.x, 1 - d.z )
			];
		} else {
			return [
				new THREE.Vector2( a.y, 1 - a.z ),
				new THREE.Vector2( b.y, 1 - b.z ),
				new THREE.Vector2( c.y, 1 - c.z ),
				new THREE.Vector2( d.y, 1 - d.z )
			];
		}
	}
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( shapes instanceof Array === false ) shapes = [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	//

	var i, l, hole, s;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];

			if ( THREE.Shape.Utils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

	// Vertices

	var contour = vertices;

	for ( i = 0, l = holes.length; i < l; i ++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;
	var cont, clen = contour.length;

	for ( i = 0; i < vlen; i ++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i ++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

	}

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	console.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );

	THREE.Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = widthSegments || 1;
	var gridY = heightSegments || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
	var normals = new Float32Array( gridX1 * gridY1 * 3 );
	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

	var offset = 0;
	var offset2 = 0;

	for ( var iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( var ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices[ offset     ] = x;
			vertices[ offset + 1 ] = - y;

			normals[ offset + 2 ] = 1;

			uvs[ offset2     ] = ix / gridX;
			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

			offset += 3;
			offset2 += 2;

		}

	}

	offset = 0;

	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

	for ( var iy = 0; iy < gridY; iy ++ ) {

		for ( var ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			indices[ offset     ] = a;
			indices[ offset + 1 ] = b;
			indices[ offset + 2 ] = d;

			indices[ offset + 3 ] = b;
			indices[ offset + 4 ] = c;
			indices[ offset + 5 ] = d;

			offset += 6;

		}

	}

	this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring

		for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

		var thetaSegment = i * (thetaSegments + 1);

		for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment;
			var v2 = segment + thetaSegments + 1;
			var v3 = segment + thetaSegments + 2;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			v1 = segment;
			v2 = segment + thetaSegments + 2;
			v3 = segment + 1;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

		}
	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );


// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength 
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		for ( x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;
			var v = y / heightSegments;

			var vertex = new THREE.Vector3();
			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < heightSegments; y ++ ) {

		for ( x = 0; x < widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			var n1 = this.vertices[ v1 ].clone().normalize();
			var n2 = this.vertices[ v2 ].clone().normalize();
			var n3 = this.vertices[ v3 ].clone().normalize();
			var n4 = this.vertices[ v4 ].clone().normalize();

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x ].clone();
			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

			if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

				uv1.x = ( uv1.x + uv2.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

			} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

				uv3.x = ( uv3.x + uv4.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			} else {

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

	parameters = parameters || {};

	var textShapes = THREE.FontUtils.generateShapes( text, parameters );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	THREE.ExtrudeGeometry.call( this, textShapes, parameters );

	this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 8;
	tubularSegments = tubularSegments || 6;
	arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= radialSegments; j ++ ) {

		for ( var i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}

	}

	for ( var j = 1; j <= radialSegments; j ++ ) {

		for ( var i = 1; i <= tubularSegments; i ++ ) {

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

		}

	}

	this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		p: p,
		q: q,
		heightScale: heightScale
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 64;
	tubularSegments = tubularSegments || 8;
	p = p || 2;
	q = q || 3;
	heightScale = heightScale || 1;
	
	var grid = new Array( radialSegments );
	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < radialSegments; ++ i ) {

		grid[ i ] = new Array( tubularSegments );
		var u = i / radialSegments * 2 * p * Math.PI;
		var p1 = getPos( u, q, p, radius, heightScale );
		var p2 = getPos( u + 0.01, q, p, radius, heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var v = j / tubularSegments * 2 * Math.PI;
			var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			grid[ i ][ j ] = this.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < radialSegments; ++ i ) {

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % radialSegments;
			var jp = ( j + 1 ) % tubularSegments;

			var a = grid[ i ][ j ];
			var b = grid[ ip ][ j ];
			var c = grid[ ip ][ jp ];
			var d = grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
			var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed ) {

	THREE.Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		segments: segments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	segments = segments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;

	var grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = segments + 1,

		x, y, z,
		tx, ty, tz,
		u, v,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}

	// consruct the grid

	for ( i = 0; i < numpoints; i ++ ) {

		grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		for ( j = 0; j < radialSegments; j ++ ) {

			v = j / radialSegments * 2 * Math.PI;

			cx = - radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = radius * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}
	}


	// construct the mesh

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < radialSegments; j ++ ) {

			ip = ( closed ) ? (i + 1) % segments : i + 1;
			jp = (j + 1) % radialSegments;

			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = grid[ ip ][ j ];
			c = grid[ ip ][ jp ];
			d = grid[ i ][ jp ];

			uva = new THREE.Vector2( i / segments, j / radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );


// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

	var	tangent = new THREE.Vector3(),
		normal = new THREE.Vector3(),
		binormal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		epsilon = 0.0001,
		smallest,

		tx, ty, tz,
		i, u, v;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i ++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	/*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

	function initialNormal3() {
		// select an initial normal vector perpenicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {
			smallest = tx;
			normal.set( 1, 0, 0 );
		}

		if ( ty <= smallest ) {
			smallest = ty;
			normal.set( 0, 1, 0 );
		}

		if ( tz <= smallest ) {
			normal.set( 0, 0, 1 );
		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i ++ ) {

		normals[ i ] = normals[ i-1 ].clone();

		binormals[ i ] = binormals[ i-1 ].clone();

		vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

		if ( vec.length() > epsilon ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), - 1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

			theta = - theta;

		}

		for ( i = 1; i < numpoints; i ++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}
};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

	THREE.Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

	}

	var midpoints = [], p = this.vertices;

	var faces = [];

	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

		var v1 = p[ indices[ i     ] ];
		var v2 = p[ indices[ i + 1 ] ];
		var v3 = p[ indices[ i + 2 ] ];

		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

	}

	var centroid = new THREE.Vector3();

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		subdivide( faces[ i ], detail );

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, Math.max( x1, x2 ) );
		var min = Math.min( x0, Math.min( x1, x2 ) );

		if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3 ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
		that.faces.push( face );

		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

		var azi = azimuth( centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide( face, detail ) {

		var cols = Math.pow(2, detail);
		var cells = Math.pow(4, detail);
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++) {

				if ( j == 0 && i == cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 == 0 ) {

					make(
						v[ i ][ k + 1],
						v[ i + 1 ][ k ],
						v[ i ][ k ]
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1][ k + 1],
						v[ i + 1 ][ k ]
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

	this.parameters = {
		radius: radius,
		detail: detail
	};

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (1, 1, 1)
		-1, -1, -1,    -1, -1,  1,
		-1,  1, -1,    -1,  1,  1,
		 1, -1, -1,     1, -1,  1,
		 1,  1, -1,     1,  1,  1,

		// (0, 1/, )
		 0, -r, -t,     0, -r,  t,
		 0,  r, -t,     0,  r,  t,

		// (1/, , 0)
		-r, -t,  0,    -r,  t,  0,
		 r, -t,  0,     r,  t,  0,

		// (, 0, 1/)
		-t,  0, -r,     t,  0, -r,
		-t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};
};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	this.parameters = {
		radius: radius,
		detail: detail
	};

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, il, j, p;
	var u, v;

	var stackCount = stacks + 1;
	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}
	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = (i + 1) * sliceCount + j + 1;
			d = (i + 1) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var vertices = new Float32Array( [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	] );

	var colors = new Float32Array( [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

	return function ( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		THREE.Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.position.copy( origin );

		this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.ArrowHelper.prototype.setDirection = ( function () {

	var axis = new THREE.Vector3();
	var radians;

	return function ( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, length, 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.set( color );
	this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );

THREE.BoxHelper.prototype.update = function ( object ) {

	var geometry = object.geometry;

	if ( geometry.boundingBox === null ) {

		geometry.computeBoundingBox();

	}

	var min = geometry.boundingBox.min;
	var max = geometry.boundingBox.max;

	/*
	  5____4
	1/___0/|
	| 6__|_7
	2/___3/

	0: max.x, max.y, max.z
	1: min.x, max.y, max.z
	2: min.x, min.y, max.z
	3: max.x, min.y, max.z
	4: max.x, max.y, min.z
	5: min.x, max.y, min.z
	6: min.x, min.y, min.z
	7: max.x, min.y, min.z
	*/

	var vertices = this.geometry.attributes.position.array;

	vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
	vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;

	vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
	vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

	vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
	vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

	vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
	vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

	//

	vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
	vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

	vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
	vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

	vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
	vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

	vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
	vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

	//

	vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
	vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

	vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
	vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

	vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
	vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

	vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
	vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

	this.geometry.attributes.position.needsUpdate = true;

	this.geometry.computeBoundingSphere();

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.camera = camera;
	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );

THREE.CameraHelper.prototype.update = function () {

	var geometry, pointMap;
	
	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();

	var setPoint = function ( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				geometry.vertices[ points[ i ] ].copy( vector );

			}

		}

	};

	return function () {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.verticesNeedUpdate = true;

	};

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3( - size,   size, 0 ),
		new THREE.Vector3(   size,   size, 0 ),
		new THREE.Vector3(   size, - size, 0 ),
		new THREE.Vector3( - size, - size, 0 ),
		new THREE.Vector3( - size,   size, 0 )
	);

	var material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Line( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3(),
		new THREE.Vector3()
	);

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	};

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	var geometry2 = object.geometry.clone();

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;
	var numEdges = 0;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
				numEdges ++;

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	var coords = new Float32Array( numEdges * 2 * 3 );

	var index = 0;

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

			var vertex = vertices[ h.vert1 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

			vertex = vertices[ h.vert2 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

		}

	}

	geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var faces = this.object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.FaceNormalsHelper.prototype.update = function () {

	var vertices = this.geometry.vertices;

	var object = this.object;
	var objectVertices = object.geometry.vertices;
	var objectFaces = object.geometry.faces;
	var objectWorldMatrix = object.matrixWorld;

	object.updateMatrixWorld( true );

	this.normalMatrix.getNormalMatrix( objectWorldMatrix );

	for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {

		var face = objectFaces[ i ];

		vertices[ i2 ].copy( objectVertices[ face.a ] )
			.add( objectVertices[ face.b ] )
			.add( objectVertices[ face.c ] )
			.divideScalar( 3 )
			.applyMatrix4( objectWorldMatrix );

		vertices[ i2 + 1 ].copy( face.normal )
			.applyMatrix3( this.normalMatrix )
			.normalize()
			.multiplyScalar( this.size )
			.add( vertices[ i2 ] );

	}

	this.geometry.verticesNeedUpdate = true;

	return this;

};


// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

}

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.HemisphereLightHelper.prototype.dispose = function () {
	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

		}

	}

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object instanceof THREE.Bone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

	var geometry = this.geometry;

	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

	var boneMatrix = new THREE.Matrix4();

	var j = 0;

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

			j += 2;

		}

	}

	geometry.verticesNeedUpdate = true;

	geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.SpotLightHelper.prototype.dispose = function () {
	this.cone.geometry.dispose();
	this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var normal = face.vertexNormals[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

// File:src/extras/helpers/VertexTangentsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0x0000ff;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var tangent = face.vertexTangents[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	if ( object.geometry instanceof THREE.Geometry ) {

		var vertices = object.geometry.vertices;
		var faces = object.geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

		geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	} else if ( object.geometry instanceof THREE.BufferGeometry ) {

		if ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry

			var vertices = object.geometry.attributes.position.array;
			var indices = object.geometry.attributes.index.array;
			var drawcalls = object.geometry.drawcalls;
			var numEdges = 0;

			if ( drawcalls.length === 0 ) {

				drawcalls = [ { count : indices.length, index : 0, start : 0 } ];

			}

			// allocate maximal size
			var edges = new Uint32Array( 2 * indices.length );

			for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

				var start = drawcalls[ o ].start;
				var count = drawcalls[ o ].count;
				var index = drawcalls[ o ].index;

				for ( var i = start, il = start + count; i < il; i += 3 ) {

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = index + indices[ i + j ];
						edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var index = 6 * i + 3 * j;
					var index2 = 3 * edges[ 2 * i + j];
					coords[ index + 0 ] = vertices[ index2 ];
					coords[ index + 1 ] = vertices[ index2 + 1 ];
					coords[ index + 2 ] = vertices[ index2 + 2 ];

				}

			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else { // non-indexed BufferGeometry

			var vertices = object.geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numTris; i < l; i ++ ) {

				for ( var j = 0; j < 3; j ++ ) {

					var index = 18 * i + 6 * j;

					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];

					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];

				}

			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

	THREE.Object3D.call( this );

	this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		startFrame: start,
		endFrame: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];
			var num = chunks[ 2 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "animation[" + name + "] undefined" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
		this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

	}

};


// Export the THREE object for **Node.js**, with
// backwards-compatibility for the old `require()` API. If we're in
// the browser, add `_` as a global object via a string identifier,
// for Closure Compiler "advanced" mode.
if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/three/three.js","/node_modules/three")
},{"IrXUsu":44,"buffer":41}],116:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
!function() {
  var topojson = {
    version: "1.6.18",
    mesh: function(topology) { return object(topology, meshArcs.apply(this, arguments)); },
    meshArcs: meshArcs,
    merge: function(topology) { return object(topology, mergeArcs.apply(this, arguments)); },
    mergeArcs: mergeArcs,
    feature: featureOrCollection,
    neighbors: neighbors,
    presimplify: presimplify
  };

  function stitchArcs(topology, arcs) {
    var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

    // Stitch empty arcs first, since they may be subsumed by other arcs.
    arcs.forEach(function(i, j) {
      var arc = topology.arcs[i < 0 ? ~i : i], t;
      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
      }
    });

    arcs.forEach(function(i) {
      var e = ends(i),
          start = e[0],
          end = e[1],
          f, g;

      if (f = fragmentByEnd[start]) {
        delete fragmentByEnd[f.end];
        f.push(i);
        f.end = end;
        if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[end]) {
        delete fragmentByStart[f.start];
        f.unshift(i);
        f.start = start;
        if (g = fragmentByEnd[start]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else {
        f = [i];
        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
      }
    });

    function ends(i) {
      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
      else p1 = arc[arc.length - 1];
      return i < 0 ? [p1, p0] : [p0, p1];
    }

    function flush(fragmentByEnd, fragmentByStart) {
      for (var k in fragmentByEnd) {
        var f = fragmentByEnd[k];
        delete fragmentByStart[f.start];
        delete f.start;
        delete f.end;
        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
        fragments.push(f);
      }
    }

    flush(fragmentByEnd, fragmentByStart);
    flush(fragmentByStart, fragmentByEnd);
    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

    return fragments;
  }

  function meshArcs(topology, o, filter) {
    var arcs = [];

    if (arguments.length > 1) {
      var geomsByArc = [],
          geom;

      function arc(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
      }

      function line(arcs) {
        arcs.forEach(arc);
      }

      function polygon(arcs) {
        arcs.forEach(line);
      }

      function geometry(o) {
        if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
        else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
      }

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function(arcs) { arcs.forEach(polygon); }
      };

      geometry(o);

      geomsByArc.forEach(arguments.length < 3
          ? function(geoms) { arcs.push(geoms[0].i); }
          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });
    } else {
      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
    }

    return {type: "MultiLineString", arcs: stitchArcs(topology, arcs)};
  }

  function mergeArcs(topology, objects) {
    var polygonsByArc = {},
        polygons = [],
        components = [];

    objects.forEach(function(o) {
      if (o.type === "Polygon") register(o.arcs);
      else if (o.type === "MultiPolygon") o.arcs.forEach(register);
    });

    function register(polygon) {
      polygon.forEach(function(ring) {
        ring.forEach(function(arc) {
          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
        });
      });
      polygons.push(polygon);
    }

    function exterior(ring) {
      return cartesianRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]) > 0; // TODO allow spherical?
    }

    polygons.forEach(function(polygon) {
      if (!polygon._) {
        var component = [],
            neighbors = [polygon];
        polygon._ = 1;
        components.push(component);
        while (polygon = neighbors.pop()) {
          component.push(polygon);
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                if (!polygon._) {
                  polygon._ = 1;
                  neighbors.push(polygon);
                }
              });
            });
          });
        }
      }
    });

    polygons.forEach(function(polygon) {
      delete polygon._;
    });

    return {
      type: "MultiPolygon",
      arcs: components.map(function(polygons) {
        var arcs = [];

        // Extract the exterior (unique) arcs.
        polygons.forEach(function(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                arcs.push(arc);
              }
            });
          });
        });

        // Stitch the arcs into one or more rings.
        arcs = stitchArcs(topology, arcs);

        // If more than one ring is returned,
        // at most one of these rings can be the exterior;
        // this exterior ring has the same winding order
        // as any exterior ring in the original polygons.
        if ((n = arcs.length) > 1) {
          var sgn = exterior(polygons[0][0]);
          for (var i = 0, t; i < n; ++i) {
            if (sgn === exterior(arcs[i])) {
              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
              break;
            }
          }
        }

        return arcs;
      })
    };
  }

  function featureOrCollection(topology, o) {
    return o.type === "GeometryCollection" ? {
      type: "FeatureCollection",
      features: o.geometries.map(function(o) { return feature(topology, o); })
    } : feature(topology, o);
  }

  function feature(topology, o) {
    var f = {
      type: "Feature",
      id: o.id,
      properties: o.properties || {},
      geometry: object(topology, o)
    };
    if (o.id == null) delete f.id;
    return f;
  }

  function object(topology, o) {
    var absolute = transformAbsolute(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
        points.push(p = a[k].slice());
        absolute(p, k);
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      p = p.slice();
      absolute(p, 0);
      return p;
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
      if (points.length < 2) points.push(points[0].slice());
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) points.push(points[0].slice());
      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var t = o.type;
      return t === "GeometryCollection" ? {type: t, geometries: o.geometries.map(geometry)}
          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}
          : null;
    }

    var geometryType = {
      Point: function(o) { return point(o.coordinates); },
      MultiPoint: function(o) { return o.coordinates.map(point); },
      LineString: function(o) { return line(o.arcs); },
      MultiLineString: function(o) { return o.arcs.map(line); },
      Polygon: function(o) { return polygon(o.arcs); },
      MultiPolygon: function(o) { return o.arcs.map(polygon); }
    };

    return geometry(o);
  }

  function reverse(array, n) {
    var t, j = array.length, i = j - n; while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
  }

  function bisect(a, x) {
    var lo = 0, hi = a.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid] < x) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function neighbors(objects) {
    var indexesByArc = {}, // arc index -> array of object indexes
        neighbors = objects.map(function() { return []; });

    function line(arcs, i) {
      arcs.forEach(function(a) {
        if (a < 0) a = ~a;
        var o = indexesByArc[a];
        if (o) o.push(i);
        else indexesByArc[a] = [i];
      });
    }

    function polygon(arcs, i) {
      arcs.forEach(function(arc) { line(arc, i); });
    }

    function geometry(o, i) {
      if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
    };

    objects.forEach(geometry);

    for (var i in indexesByArc) {
      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
        for (var k = j + 1; k < m; ++k) {
          var ij = indexes[j], ik = indexes[k], n;
          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
        }
      }
    }

    return neighbors;
  }

  function presimplify(topology, triangleArea) {
    var absolute = transformAbsolute(topology.transform),
        relative = transformRelative(topology.transform),
        heap = minAreaHeap();

    if (!triangleArea) triangleArea = cartesianTriangleArea;

    topology.arcs.forEach(function(arc) {
      var triangles = [],
          maxArea = 0,
          triangle;

      // To store each points effective area, we create a new array rather than
      // extending the passed-in point to workaround a Chrome/V8 bug (getting
      // stuck in smi mode). For midpoints, the initial effective area of
      // Infinity will be computed in the next step.
      for (var i = 0, n = arc.length, p; i < n; ++i) {
        p = arc[i];
        absolute(arc[i] = [p[0], p[1], Infinity], i);
      }

      for (var i = 1, n = arc.length - 1; i < n; ++i) {
        triangle = arc.slice(i - 1, i + 2);
        triangle[1][2] = triangleArea(triangle);
        triangles.push(triangle);
        heap.push(triangle);
      }

      for (var i = 0, n = triangles.length; i < n; ++i) {
        triangle = triangles[i];
        triangle.previous = triangles[i - 1];
        triangle.next = triangles[i + 1];
      }

      while (triangle = heap.pop()) {
        var previous = triangle.previous,
            next = triangle.next;

        // If the area of the current point is less than that of the previous point
        // to be eliminated, use the latter's area instead. This ensures that the
        // current point cannot be eliminated without eliminating previously-
        // eliminated points.
        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
        else maxArea = triangle[1][2];

        if (previous) {
          previous.next = next;
          previous[2] = triangle[2];
          update(previous);
        }

        if (next) {
          next.previous = previous;
          next[0] = triangle[0];
          update(next);
        }
      }

      arc.forEach(relative);
    });

    function update(triangle) {
      heap.remove(triangle);
      triangle[1][2] = triangleArea(triangle);
      heap.push(triangle);
    }

    return topology;
  };

  function cartesianRingArea(ring) {
    var i = -1,
        n = ring.length,
        a,
        b = ring[n - 1],
        area = 0;

    while (++i < n) {
      a = b;
      b = ring[i];
      area += a[0] * b[1] - a[1] * b[0];
    }

    return area * .5;
  }

  function cartesianTriangleArea(triangle) {
    var a = triangle[0], b = triangle[1], c = triangle[2];
    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
  }

  function compareArea(a, b) {
    return a[1][2] - b[1][2];
  }

  function minAreaHeap() {
    var heap = {},
        array = [],
        size = 0;

    heap.push = function(object) {
      up(array[object._ = size] = object, size++);
      return size;
    };

    heap.pop = function() {
      if (size <= 0) return;
      var removed = array[0], object;
      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
      return removed;
    };

    heap.remove = function(removed) {
      var i = removed._, object;
      if (array[i] !== removed) return; // invalid request
      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
      return i;
    };

    function up(object, i) {
      while (i > 0) {
        var j = ((i + 1) >> 1) - 1,
            parent = array[j];
        if (compareArea(object, parent) >= 0) break;
        array[parent._ = i] = parent;
        array[object._ = i = j] = object;
      }
    }

    function down(object, i) {
      while (true) {
        var r = (i + 1) << 1,
            l = r - 1,
            j = i,
            child = array[j];
        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
        if (j === i) break;
        array[child._ = i] = child;
        array[object._ = i = j] = object;
      }
    }

    return heap;
  }

  function transformAbsolute(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      point[0] = (x0 += point[0]) * kx + dx;
      point[1] = (y0 += point[1]) * ky + dy;
    };
  }

  function transformRelative(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      var x1 = (point[0] - dx) / kx | 0,
          y1 = (point[1] - dy) / ky | 0;
      point[0] = x1 - x0;
      point[1] = y1 - y0;
      x0 = x1;
      y0 = y1;
    };
  }

  function noop() {}

  if (typeof define === "function" && define.amd) define(topojson);
  else if (typeof module === "object" && module.exports) module.exports = topojson;
  else this.topojson = topojson;
}();

}).call(this,require("IrXUsu"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/topojson/topojson.js","/node_modules/topojson")
},{"IrXUsu":44,"buffer":41}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50LmV4cG9ydC5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9jbGllbnQvYnVpbGQvYXJlYXMuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2J1aWxkL2J1aWxkaW5ncy5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9jbGllbnQvYnVpbGQvcm9hZHMuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2NsYXNzZXMvYW5pbWF0aW9uLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC9jbGFzc2VzL2JvdW5kaW5nYm94LmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC9jbGFzc2VzL2NvbXBhc3MuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2NsYXNzZXMvZnguanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2NsYXNzZXMvZ2VvLWNhbWVyYS5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9jbGllbnQvY2xhc3Nlcy9sYXllcjNkLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC9jbGFzc2VzL2xvYWRlci5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9jbGllbnQvY2xhc3Nlcy9tYXAyLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC9jbGFzc2VzL21vdXNlLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC9jbGFzc2VzL3Byb2plY3Rpb24uanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2NsYXNzZXMvcmVuZGVyLW1hbmFnZXIuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2NsYXNzZXMvd29ybGQuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2luZGV4LmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC9saWIvY29weS1zaGFkZXIuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2xpYi9lZmZlY3QtY29tcG9zZXIuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2xpYi9maWxtLXBhc3MuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2xpYi9maWxtLXNoYWRlci5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9jbGllbnQvbGliL2Z4YWEuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2xpYi9ob3Jpem9udGFsLXRpbHQtc2hpZnQtc2hhZGVyLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC9saWIvcmVuZGVyLXBhc3MuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L2xpYi9zaGFkZXItcGFzcy5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9jbGllbnQvbGliL3ZlcnRpY2FsLXRpbHQtc2hpZnQtc2hhZGVyLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC90b29scy9hY3Rpb24tZXh0ZW5kLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC90b29scy9jcmVhdGUtdGhyZWUuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L3Rvb2xzL2Rlc3Ryb3ktZ3JvdXAuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vY2xpZW50L3Rvb2xzL2Z4L2NvcHktc2hhZGVyLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC90b29scy9meC9maWxtLWdyYWluLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC90b29scy9meC9meGFhLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC90b29scy9meC90aWx0LXNoaWZ0LmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC90b29scy9sZXJwLTNkLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC90b29scy9tZXJnZS1tYXBzLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL2NsaWVudC90b29scy9wYXJzZS1oZWlnaHQuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vaXNvbW9ycGhpYy9jbGFzc2VzL2NvbGxlY3Rpb24uanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vaXNvbW9ycGhpYy9jbGFzc2VzL2ZlYXR1cmUuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vaXNvbW9ycGhpYy9jbGFzc2VzL2dlby5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvZDMvZDMuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL1BvaW50LmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvUHJvai5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2FkanVzdF9heGlzLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2FkanVzdF9sYXQuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vYWRqdXN0X2xvbi5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9hc2luei5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9lMGZuLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2UxZm4uanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vZTJmbi5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9lM2ZuLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2dOLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2ltbGZuLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2lxc2Zuei5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9tbGZuLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL21zZm56LmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL3BoaTJ6LmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL3BqX2VuZm4uanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vcGpfaW52X21sZm4uanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vcGpfbWxmbi5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9xc2Zuei5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9zaWduLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL3NyYXQuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vdG9Qb2ludC5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi90c2Zuei5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy9EYXR1bS5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy9FbGxpcHNvaWQuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb25zdGFudHMvUHJpbWVNZXJpZGlhbi5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvcmUuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kYXR1bS5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2RhdHVtX3RyYW5zZm9ybS5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL2RlZnMuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kZXJpdmVDb25zdGFudHMuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9leHRlbmQuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9nbG9iYWwuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9pbmNsdWRlZFByb2plY3Rpb25zLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvaW5kZXguanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wYXJzZUNvZGUuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qU3RyaW5nLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9hZWEuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9hZXFkLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvY2Fzcy5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2NlYS5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2VxYy5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2VxZGMuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9nYXVzcy5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2dub20uanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9rcm92YWsuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9sYWVhLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbGNjLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbG9uZ2xhdC5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL21lcmMuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9taWxsLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbW9sbC5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL256bWcuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9vbWVyYy5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL3BvbHkuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zaW51LmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvc29tZXJjLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvc3RlcmUuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zdGVyZWEuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy90bWVyYy5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL3V0bS5qcyIsIi9Vc2Vycy9kYXZleXZhbmRlcndvZXJ0L3Byb2plY3RzL0NpdHlJTy9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL3ZhbmRnLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvdHJhbnNmb3JtLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvd2t0LmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9ub2RlX21vZHVsZXMvbWdycy9tZ3JzLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9wcm9qNC9wYWNrYWdlLmpzb24iLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3EteGhyL3EteGhyLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy9xL3EuanMiLCIvVXNlcnMvZGF2ZXl2YW5kZXJ3b2VydC9wcm9qZWN0cy9DaXR5SU8vbm9kZV9tb2R1bGVzL3RocmVlL3RocmVlLmpzIiwiL1VzZXJzL2RhdmV5dmFuZGVyd29lcnQvcHJvamVjdHMvQ2l0eUlPL25vZGVfbW9kdWxlcy90b3BvanNvbi90b3BvanNvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6N2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xud2luZG93LklPID0gcmVxdWlyZSgnLi9jbGllbnQnKTtcblxuY29uc29sZS5sb2cod2luZG93LklPKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQuZXhwb3J0LmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxuLy9zaGFkZXJzXG52YXIgdmVydGV4U2hhZGVyID0gWyd2YXJ5aW5nIGZsb2F0IHo7Jyxcbid2b2lkIG1haW4odm9pZCkgeycsXG4gICAgJ2dsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7JyxcbiAgICAneiA9IHBvc2l0aW9uLno7Jyxcbid9J10uam9pbihcIlxcblwiKTtcblxudmFyIGZyYWdtZW50U2hhZGVyID0gWyd1bmlmb3JtIHZlYzMgY29sb3JEYXk7Jyxcbid1bmlmb3JtIHZlYzMgY29sb3JOaWdodDsnLFxuJ3VuaWZvcm0gdmVjMyBmb2dOaWdodDsnLFxuJ3VuaWZvcm0gdmVjMyBmb2dEYXk7Jyxcbid1bmlmb3JtIGZsb2F0IGN1cnJlbnRUaW1lOycsXG5cbid2YXJ5aW5nIGZsb2F0IHo7JyxcblxuJyNpZmRlZiBVU0VfRk9HJyxcblxuXHQndW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOycsXG5cdCd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7JyxcblxuJyNlbmRpZicsXG5cbid2b2lkIG1haW4oKSB7JyxcblxuXHQndmVjNCBjMSA9IHZlYzQoY29sb3JEYXksMS4wKTsnLFxuXHQndmVjNCBjMiA9IHZlYzQoY29sb3JOaWdodCwxLjApOycsXG5cdCdnbF9GcmFnQ29sb3IgPSBtaXgoYzEsYzIsIHNtb290aHN0ZXAoMC4wLCAxLjAsIGN1cnJlbnRUaW1lKSk7JyxcblxuXHQndmVjMyBmb2dDb2xvck1peCA9IG1peChmb2dEYXksZm9nTmlnaHQsIHNtb290aHN0ZXAoMC4wLCAxLjAsIGN1cnJlbnRUaW1lKSk7JyxcblxuXHQnZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53OycsXG5cdCdjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7JyArXG5cdCdmbG9hdCBmb2dGYWN0b3IgPSBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZGVwdGggKiBkZXB0aCAqIExPRzIgKTsnLFxuXHQnZm9nRmFjdG9yID0gMS4wIC0gY2xhbXAoIGZvZ0ZhY3RvciwgMC4wLCAxLjAgKTsnLFxuXHQnZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yTWl4LCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTsnLFxuXG4nfSddLmpvaW4oXCJcXG5cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od29ybGQpe1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy9maXhlZCBoZWlnaHRcbiAgICB0aGlzLm9wdGlvbnMuaGVpZ2h0ID0gZnVuY3Rpb24ocHJvcGVydGllcywgZ3JvdXApe1xuICAgICAgICByZXR1cm4gKDEgKiBncm91cC5ucik7XG4gICAgfTtcblxuICAgIC8vY29sb3IgbWF0ZXJpYWxcbiAgICB0aGlzLm9wdGlvbnMuY3JlYXRlTWF0ZXJpYWwgPSBmdW5jdGlvbihjb2xvciwgaSl7XG5cbiAgICAgICAgLy9nZXQgbmlnaHQgY29sb3JcbiAgICAgICAgdmFyIGNvbG9yTmlnaHQgPSBzZWxmLm9wdGlvbnMubmlnaHRbaV07XG5cbiAgICAgICAgLy91bmlmb3Jtc1xuICAgIFx0dmFyIHVuaWZvcm1zID0ge1xuICAgIFx0XHRcImN1cnJlbnRUaW1lXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wIH0sXG4gICAgXHRcdFwiY29sb3JEYXlcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoY29sb3IpIH0sXG4gICAgXHRcdFwiY29sb3JOaWdodFwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcihjb2xvck5pZ2h0KSB9LFxuXG4gICAgXHRcdFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiB3b3JsZC5zY2VuZS5mb2cuY29sb3IgfSxcbiAgICBcdFx0XCJmb2dOaWdodFwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IHdvcmxkLnNjZW5lLmZvZy5uaWdodCB9LFxuICAgIFx0XHRcImZvZ0RheVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IHdvcmxkLnNjZW5lLmZvZy5kYXkgfSxcbiAgICBcdFx0XCJmb2dEZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogd29ybGQuc2NlbmUuZm9nLmRlbnNpdHkgfSxcbiAgICBcdH07XG5cbiAgICBcdC8vbWF0ZXJpYWxcbiAgICBcdHJldHVybiBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgIFx0XHR1bmlmb3JtczogdW5pZm9ybXMsXG4gICAgXHQgICAgdmVydGV4U2hhZGVyOiB2ZXJ0ZXhTaGFkZXIsXG4gICAgXHQgICAgZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50U2hhZGVyLFxuICAgIFx0ICAgIGZvZzogdHJ1ZVxuICAgIFx0fSk7XG5cbiAgICB9O1xuXG4gICAgLy9kZWZlciB0byBidWlsZGluZ3NcbiAgICByZXR1cm4gSU8uYnVpbGQuYnVpbGRpbmdzLmNhbGwodGhpcywgd29ybGQpO1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9idWlsZC9hcmVhcy5qc1wiLFwiL2NsaWVudC9idWlsZFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBUSFJFRSA9IHJlcXVpcmUoJ3RocmVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od29ybGQpe1xuXG5cdHZhciBtZXNoO1xuXG5cdC8vc2V0IHZhcmlhYmxlc1xuXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0dmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cdHZhciB6ID0gdGhpcy56O1xuXHR2YXIgY29sb3JzID0gb3B0aW9ucy5jb2xvcnMgfHwgWzB4ZmZmZmZmXTtcblx0dmFyIGdyb3VwcyA9IFtdO1xuXG5cdC8vZ3JvdXAgZGV0ZWN0aW9uXG5cdHZhciBiYXNlR3JvdXBEZXRlY3QgPSBmdW5jdGlvbihncm91cHMsIGlucHV0KXtcblx0XHRyZXR1cm4gZ3JvdXBzWzBdO1xuXHR9O1xuXG5cdC8vYmFzZSBvciBjdXN0b20/XG5cdHZhciBncm91cERldGVjdCA9IG9wdGlvbnMuZ3JvdXBzIHx8IGJhc2VHcm91cERldGVjdDtcblxuXHQvL2Jhc2Vcblx0dmFyIGJhc2UgPSBvcHRpb25zLm1hdGVyaWFsIHx8IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtcbiAgICBcdGNvbG9yOiAweGZmZmZmZixcbiAgICBcdHNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nXG5cdH0pO1xuXG5cdC8vZ3JvdXBzXG5cdGZvciggdmFyIGkgPSAwIDsgaSA8IGNvbG9ycy5sZW5ndGggOyBpKysgKXtcblxuXHRcdHZhciBtYXRlcmlhbDtcblxuXHRcdGlmKCFvcHRpb25zLmNyZWF0ZU1hdGVyaWFsKXtcblxuXHRcdFx0Ly9jcmVhdGUgbWF0ZXJpYWwgZm9yIGdyb3VwXG5cdFx0XHRtYXRlcmlhbCA9IGJhc2UuY2xvbmUoKTtcblx0XHRcdG1hdGVyaWFsLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKGNvbG9yc1tpXSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0ZXJpYWwgPSBvcHRpb25zLmNyZWF0ZU1hdGVyaWFsKGNvbG9yc1tpXSwgaSk7XG5cdFx0fVxuXG5cdFx0Ly9jcmVhdGUgZ2VvbWV0cnkgZm9yIGdyb3VwXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cblx0XHRncm91cHMucHVzaCh7XG5cdFx0XHQnbnInOiBpLFxuXHRcdFx0J21hdGVyaWFsJzogbWF0ZXJpYWwsXG5cdFx0XHQnZ2VvbWV0cnknOiBnZW9tZXRyeVxuXHRcdH0pO1xuXG5cdH1cblxuXHQvL2ZpbmFsaXNlXG5cdHZhciBmaW5hbGlzZSA9IGZ1bmN0aW9uKCl7XG5cblx0XHRncm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCl7XG5cblx0XHRcdHZhciBidWZmZXIgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdC8vIGJ1ZmZlci5mcm9tR2VvbWV0cnkoZ3JvdXAuZ2VvbWV0cnkpO1xuXHRcdFx0Ly8gZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXG5cdFx0XHQvL2NyZWF0ZSBtZXNoXG5cdFx0XHQvLyBncm91cC5tZXNoID0gbmV3IFRIUkVFLk1lc2goIGJ1ZmZlciwgZ3JvdXAubWF0ZXJpYWwgKTtcblx0XHRcdGdyb3VwLm1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ3JvdXAuZ2VvbWV0cnksIGdyb3VwLm1hdGVyaWFsICk7XG5cdFx0XHR3b3JsZC5ncm91cC5hZGQoIGdyb3VwLm1lc2ggKTtcblxuXHRcdH0pO1xuXG5cdH07XG5cblx0Ly9jcmVhdGUgYnVpbGRpbmdcblx0dmFyIGNyZWF0ZUJ1aWxkaW5nID0gZnVuY3Rpb24ocG9zLCBwcm9wZXJ0aWVzKXtcblxuXHRcdHRyeXtcblxuXHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBEZXRlY3QoZ3JvdXBzLCBwcm9wZXJ0aWVzKTtcblx0XHRcdHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodChwcm9wZXJ0aWVzLCBncm91cCk7XG5cdFx0XHQvLyBoZWlnaHQgPSBJTy50b29scy5wYXJzZUhlaWdodChoZWlnaHQpO1xuXG5cdFx0XHQvL3ByZXZlbnRcblx0XHRcdGlmKGlzTmFOKGhlaWdodCkpIGhlaWdodCA9IDE7XG5cblx0XHRcdC8vY3JlYXRlIHNoYXBlXG5cdFx0XHR2YXIgc2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUocG9zKTtcblx0XHRcdHZhciBleHRydXNpb25TZXR0aW5ncyA9IHtcblx0XHRcdFx0YW1vdW50OiBoZWlnaHQsXG5cdFx0XHRcdC8vYmV2ZWxTaXplOiAxNSxcblx0XHRcdFx0YmV2ZWxFbmFibGVkOiBmYWxzZSxcblx0XHRcdFx0Ly9zdGVwczogMCxcblx0XHRcdFx0YmV2ZWxUaGlja25lc3M6IDAsXG5cdFx0XHRcdHN0ZXBzOiAxXG5cdFx0XHR9O1xuXG5cdFx0XHQvL2V4dHJ1ZGUgJiBtYWtlIG1lc2hcblx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5FeHRydWRlR2VvbWV0cnkoIHNoYXBlLCBleHRydXNpb25TZXR0aW5ncyApO1xuXHRcdFx0Z3JvdXAuZ2VvbWV0cnkubWVyZ2UoIGdlb21ldHJ5ICk7XG5cdFx0XHRnZW9tZXRyeS5kaXNwb3NlKCk7XG5cblx0XHR9IGNhdGNoKGUpe1xuXHRcdFx0Y29uc29sZS53YXJuKGUpO1xuXHRcdH1cblxuXHR9O1xuXG5cdC8vYWRkIGFsbCBidWlsZGluZ3MgZnJvbSBsaXN0XG5cdHZhciBidWlsZGluZ3MgPSBkYXRhLmdldCgpO1xuXHRmb3IoIHZhciBpID0gMCA7IGkgPCBidWlsZGluZ3MubGVuZ3RoIDsgaSsrICl7XG5cblx0XHR0aGlzLnJlbmRlci5wdXNoKGZ1bmN0aW9uKCl7XG5cblx0XHRcdGNyZWF0ZUJ1aWxkaW5nKCB0aGlzLm9iamVjdC5nZXQzRCh3b3JsZC5wcm9qZWN0aW9uKSwgdGhpcy5vYmplY3QucHJvcGVydGllcyApO1xuXG5cdFx0XHQvL2VuZD9cblx0XHRcdGlmKHRoaXMuY3VycmVudCA+PSBidWlsZGluZ3MubGVuZ3RoIC0gMSl7XG5cdFx0XHRcdGZpbmFsaXNlKCk7XG5cdFx0XHR9XG5cblx0XHR9LmJpbmQoeyBvYmplY3Q6IGJ1aWxkaW5nc1tpXSwgY3VycmVudDogaSB9KSk7XG5cdH1cblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQvYnVpbGQvYnVpbGRpbmdzLmpzXCIsXCIvY2xpZW50L2J1aWxkXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih3b3JsZCl7XG5cblx0dmFyIG1lc2g7XG5cblx0Ly9zZXQgdmFyaWFibGVzXG5cdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblx0dmFyIHogPSB0aGlzLno7XG5cblx0Ly9kZWZhdWx0c1xuXHRvcHRpb25zLmNvbG9yID0gb3B0aW9ucy5jb2xvciB8fCAnI0ZGRkZGRic7XG5cdG9wdGlvbnMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3Iob3B0aW9ucy5jb2xvcik7XG5cdG9wdGlvbnMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDEuNTtcblx0b3B0aW9ucy5tYXhTZWdtZW50cyA9IG9wdGlvbnMubWF4U2VnbWVudHMgfHwgNTA7XG5cdC8vb3B0aW9ucy5zZWdtZW50cyA9IG9wdGlvbnMuc2VnbWVudHMgfHwgNTtcblx0b3B0aW9ucy5yYWRpdXNTZWdtZW50cyA9IG9wdGlvbnMucmFkaXVzU2VnbWVudHMgfHwgMztcblx0b3B0aW9ucy5xdWFsaXR5ID0gb3B0aW9ucy5xdWFsaXR5IHx8IDE7XG5cdG9wdGlvbnMub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eSB8fCAxO1xuXG5cdC8vY3JlYXRlIGdlb21ldHJ5XG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRcblx0Ly9hZGQgdG8gc2NlbmUgd2hlbiBkb25lXG5cdHZhciBmaW5hbGlzZSA9IGZ1bmN0aW9uKCl7XG5cblx0XHQvL2NyZWF0ZSBtYXRlcmlhbCBzZXR0aW5nc1xuXHRcdHZhciBtYXRlcmlhbFNldHRpbmdzID0ge307XG5cdFx0bWF0ZXJpYWxTZXR0aW5ncy5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cblx0XHQvL3RyYW5zcGFyZW5jeT9cblx0XHRpZihvcHRpb25zLm9wYWNpdHkgPCAxKXtcblx0XHRcdG1hdGVyaWFsU2V0dGluZ3Mub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblx0XHRcdG1hdGVyaWFsU2V0dGluZ3MudHJhbnNwYXJlbnQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHZhciBidWZmZXIgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRidWZmZXIuZnJvbUdlb21ldHJ5KGdlb21ldHJ5KTtcblx0XHRnZW9tZXRyeS5kaXNwb3NlKCk7XG5cblx0XHQvL2NyZWF0ZSBtZXNoXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwobWF0ZXJpYWxTZXR0aW5ncyk7XG5cdFx0bWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBidWZmZXIsIG1hdGVyaWFsICk7XG5cdFx0Ly8gbWVzaC5wb3NpdGlvbi56ID0gSU8udG9vbHMucGFyc2VIZWlnaHQoeik7XG5cblx0XHQvL2FkZCB0byBzY2VuZVxuXHRcdHdvcmxkLmdyb3VwLmFkZChtZXNoKTtcblxuXHR9LmJpbmQodGhpcyk7XG5cblx0Ly9hZGQgcGF0aHMgdG8gM2Qgb2JqZWN0XG5cdHZhciBjcmVhdGVUdWJlID0gZnVuY3Rpb24oZGF0YSl7XG5cblx0XHQvL2NyZWF0ZSB0dWJlc1xuXHRcdHZhciBwYXRoM0QgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUzKGRhdGEpO1xuXHRcdHZhciBzZWdtZW50cyA9IGRhdGEubGVuZ3RoIDwgb3B0aW9ucy5tYXhTZWdtZW50cyA/IGRhdGEubGVuZ3RoIDogb3B0aW9ucy5tYXhTZWdtZW50cztcblx0XHRzZWdtZW50cyA9IE1hdGguY2VpbChvcHRpb25zLnF1YWxpdHkgKiBzZWdtZW50cyk7XG5cdFx0dmFyIHR1YmUgPSBuZXcgVEhSRUUuVHViZUdlb21ldHJ5KHBhdGgzRCwgc2VnbWVudHMsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMucmFkaXVzU2VnbWVudHMsIGZhbHNlKTtcblxuXHRcdGdlb21ldHJ5Lm1lcmdlKHR1YmUpO1xuXHRcdHR1YmUuZGlzcG9zZSgpO1xuXHRcdHBhdGgzRCA9IG51bGw7XG5cblx0fTtcblxuXHQvL2FkZCBhbGwgcm9hZHNcblx0dmFyIHJvYWRzID0gZGF0YS5nZXQoKTtcblx0Zm9yKCB2YXIgaSA9IDAgOyBpIDwgcm9hZHMubGVuZ3RoIDsgaSsrICl7XG5cblx0XHR0aGlzLnJlbmRlci5wdXNoKGZ1bmN0aW9uKCl7XG5cblx0XHRcdGNyZWF0ZVR1YmUoIHRoaXMub2JqZWN0LmdldDNEKHdvcmxkLnByb2plY3Rpb24pICk7XG5cblx0XHRcdC8vZW5kP1xuXHRcdFx0aWYodGhpcy5jdXJyZW50ID49IHJvYWRzLmxlbmd0aCAtIDEpe1xuXHRcdFx0XHRmaW5hbGlzZSgpO1xuXHRcdFx0fVxuXG5cdFx0fS5iaW5kKHsgb2JqZWN0OiByb2Fkc1tpXSwgY3VycmVudDogaSB9KSk7XG5cdH1cblxuXHQvL2FjdGlvbnMgLSB0b2RvXG5cdC8vIHJldHVybiB7fTtcblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQvYnVpbGQvcm9hZHMuanNcIixcIi9jbGllbnQvYnVpbGRcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHdvcmxkKXtcblxuXHR2YXIgc3RvcCA9IGZhbHNlO1xuXHR2YXIgX3Byb2Nlc3M7XG5cdHZhciBsaXN0ID0gW107XG5cblx0dmFyIGxlcnAgPSBmdW5jdGlvbihmcm9tLCB0bywgcHJvZ3Jlc3Mpe1xuXHRcdHZhciBkZWx0YSA9IHRvIC0gZnJvbTtcblx0XHRyZXR1cm4gZnJvbSArIChkZWx0YSpwcm9ncmVzcyk7XG5cdH07XG5cblx0dmFyIGFuaW1hdGUgPSBmdW5jdGlvbihwcm9wZXJ0eSwgcHJvZ3Jlc3MsIG9wdGlvbnMpe1xuXG5cdFx0Ly9hbmltYXRlIHZlY3RvcnNcblx0XHRpZihwcm9wZXJ0eSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMpe1xuXHRcdFx0cHJvcGVydHkuY29weShJTy50b29scy5sZXJwMyhvcHRpb25zLmZyb20sIG9wdGlvbnMudG8sIHByb2dyZXNzKSk7XG5cdFx0fVxuXG5cdFx0Ly9hbmltYXRlIG1hdGVyaWFsXG5cdFx0aWYocHJvcGVydHkgaW5zdGFuY2VvZiBUSFJFRS5NYXRlcmlhbCl7XG5cblx0XHRcdGlmKG9wdGlvbnMudHlwZSA9PT0gJ29wYWNpdHknKXtcblxuXHRcdFx0XHRwcm9wZXJ0eS50cmFuc3BhcmVudCA9IHRydWU7XG5cdFx0XHRcdC8vIHZhciBkZWx0YSA9IG9wdGlvbnMudG8gLSBvcHRpb25zLmZyb207XG5cdFx0XHRcdC8vIHByb3BlcnR5Lm9wYWNpdHkgPSBvcHRpb25zLmZyb20gKyAoZGVsdGEqcHJvZ3Jlc3MpO1xuXHRcdFx0XHRwcm9wZXJ0eS5vcGFjaXR5ID0gbGVycChvcHRpb25zLmZyb20sIG9wdGlvbnMudG8sIHByb2dyZXNzKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZihvcHRpb25zLnR5cGUgPT09ICdjb2xvcicpe1xuXG5cdFx0XHRcdHByb3BlcnR5LmNvbG9yID0gb3B0aW9ucy5mcm9tLmxlcnAob3B0aW9ucy50bywgcHJvZ3Jlc3MpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL2FuaW1hdGUgbWVzaGVzIChzY2FsZSlcblx0XHRpZihwcm9wZXJ0eSBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpe1xuXHRcdFx0cHJvcGVydHkuc2NhbGUuY29weShJTy50b29scy5sZXJwMyhvcHRpb25zLmZyb20sIG9wdGlvbnMudG8sIHByb2dyZXNzKSk7XG5cdFx0fVxuXG5cdFx0Ly9jdXN0b21cblx0XHRpZihvcHRpb25zLnRpY2sgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG5cdFx0XHRvcHRpb25zLnRpY2socHJvcGVydHksIHByb2dyZXNzLCBvcHRpb25zLCBsZXJwKTtcblx0XHR9XG5cblx0fTtcblxuXHR2YXIgZGV0ZWN0RnJvbSA9IGZ1bmN0aW9uKHByb3BlcnR5LCBvcHRpb25zKXtcblxuXHRcdC8vYW5pbWF0ZSB2ZWN0b3JzXG5cdFx0aWYocHJvcGVydHkgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzKXtcblx0XHRcdHJldHVybiBwcm9wZXJ0eS5jbG9uZSgpO1xuXHRcdH1cblxuXHRcdC8vYW5pbWF0ZSBtYXRlcmlhbFxuXHRcdGlmKHByb3BlcnR5IGluc3RhbmNlb2YgVEhSRUUuTWF0ZXJpYWwpe1xuXG5cdFx0XHRpZihvcHRpb25zLnR5cGUgPT09ICdvcGFjaXR5Jyl7XG5cdFx0XHRcdHJldHVybiBwcm9wZXJ0eS5vcGFjaXR5O1xuXHRcdFx0fVxuXG5cdFx0XHRpZihvcHRpb25zLnR5cGUgPT09ICdjb2xvcicpe1xuXHRcdFx0XHRyZXR1cm4gcHJvcGVydHkuY29sb3IuY2xvbmUoKTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vYW5pbWF0ZSBtZXNoZXMgKHNjYWxlKVxuXHRcdGlmKHByb3BlcnR5IGluc3RhbmNlb2YgVEhSRUUuTWVzaCl7XG5cblx0XHRcdHJldHVybiBwcm9wZXJ0eS5zY2FsZS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG5cblx0XHQvL3N0b3Agd2hlbiBuZWVkZWRcblx0XHRpZihzdG9wKXtcblx0XHRcdHdvcmxkLnJlbmRlci5yZW1vdmUoX3Byb2Nlc3MpO1xuXHRcdH1cblxuXHRcdGZvciggdmFyIGkgPSAwIDsgaSA8IGxpc3QubGVuZ3RoIDsgaSsrICl7XG5cblx0XHRcdHZhciBhbmltID0gbGlzdFtpXTtcblx0XHRcdHZhciBmaW5pc2hlZCA9IGZhbHNlO1xuXG5cdFx0XHQvL09uIGZpcnN0IGl0ZXJhdGlvbiBzZXQgdGhpcyBhcyBzdGFydCBwb2ludCBpbiB0aW1lXG5cdFx0XHRpZighYW5pbS5zdGFydCl7XG5cdFx0XHRcdGFuaW0uc3RhcnQgPSArRGF0ZS5ub3coKTtcblx0XHRcdH1cblxuXHRcdFx0Ly93aGVuIHBhdXNlZCwgcmVjYWxjdWxhdGUgc3RhcnRpbmcgcG9pbnRcblx0XHRcdGlmKHBhdXNlVGltZSl7XG5cdFx0XHRcdGFuaW0uc3RhcnQgKz0gK0RhdGUubm93KCkgLSBwYXVzZVRpbWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vY2FsY3VsYXRlIHByb2dyZXNzXG5cdFx0XHR2YXIgbm93ID0gK0RhdGUubm93KCkgLSBhbmltLnN0YXJ0O1xuXHRcdFx0dmFyIHByb2dyZXNzID0gbm93L2FuaW0uZHVyYXRpb247XG5cblx0XHRcdC8vY2hlY2sgaWYgZmluaXNoZWRcblx0XHRcdGlmKHByb2dyZXNzID4gMSl7XG5cdFx0XHRcdHByb2dyZXNzID0gMTtcblx0XHRcdFx0ZmluaXNoZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2ludGVycG9sYXRlXG5cdFx0XHRhbmltYXRlKGFuaW0ucHJvcGVydHksIHByb2dyZXNzLCBhbmltKTtcblxuXHRcdFx0Ly9maW5pc2hlZCBzbyByZW1vdmUgZnJvbSBsaXN0XG5cdFx0XHRpZihmaW5pc2hlZCl7XG5cdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9yZXNldCBwYXVzZVxuXHRcdGlmKHBhdXNlVGltZSl7XG5cdFx0XHRwYXVzZVRpbWUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly9yZXJ1biBuZXh0IHRpbWUgKHdoZW4gbmVlZGVkKVxuXHRcdGlmKGxpc3QubGVuZ3RoID4gMCl7XG5cdFx0XHR3b3JsZC5yZW5kZXIucmVtb3ZlKF9wcm9jZXNzKTtcblx0XHR9XG5cblx0fS5iaW5kKHRoaXMpO1xuXG5cdHZhciBwYXVzZVRpbWU7XG5cdHZhciBwYXVzZSA9IGZ1bmN0aW9uKCl7XG5cdFx0cGF1c2VUaW1lID0gK0RhdGUubm93KCk7XG5cdH07XG5cblx0dGhpcy5hZGQgPSBmdW5jdGlvbihwcm9wZXJ0eSwgb3B0aW9ucyl7XG5cblx0XHR2YXIgZnJvbSA9IG9wdGlvbnMuZnJvbSB8fCBkZXRlY3RGcm9tKHByb3BlcnR5LCBvcHRpb25zKTtcblxuXHRcdGxpc3QucHVzaCh7XG5cblx0XHRcdGZyb206IGZyb20sXG5cdFx0XHR0bzogb3B0aW9ucy50byxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uIHx8IDEwMDAsXG5cdFx0XHRlYXNlOiAnZWFzZUluT3V0Q3ViaWMnLFxuXHRcdFx0cHJvcGVydHk6IHByb3BlcnR5LFxuXHRcdFx0dHlwZTogb3B0aW9ucy50eXBlLFxuXHRcdFx0dGljazogb3B0aW9ucy50aWNrXG5cblx0XHR9KTtcblxuXHR9O1xuXG5cdHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpe1xuXHRcdHN0b3AgPSBmYWxzZTtcblx0XHRfcHJvY2VzcyA9IHdvcmxkLnJlbmRlci5hZGQodXBkYXRlLCBwYXVzZSk7XG5cdH07XG5cblx0dGhpcy5zdG9wID0gZnVuY3Rpb24oKXtcblx0XHRzdG9wID0gdHJ1ZTtcblx0XHR3b3JsZC5yZW5kZXIucmVtb3ZlKF9wcm9jZXNzKTtcblx0fTtcblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQvY2xhc3Nlcy9hbmltYXRpb24uanNcIixcIi9jbGllbnQvY2xhc3Nlc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWluLCBtYXgsIHByb2plY3Rpb24pe1xuXG4gICAgdGhpcy5nZXRHZW8gPSBmdW5jdGlvbigpe1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0MkQgPSBmdW5jdGlvbigpe1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0M0QgPSBmdW5jdGlvbigpe1xuXG4gICAgfTtcblxuICAgIHRoaXMuaW5Cb3ggPSBmdW5jdGlvbihsYXQsIGxvbil7XG5cbiAgICB9O1xuXG5cbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQvY2xhc3Nlcy9ib3VuZGluZ2JveC5qc1wiLFwiL2NsaWVudC9jbGFzc2VzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih3b3JsZCl7XG5cblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YXIgdXBkYXRlO1xuXG5cdHRoaXMuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24oKXtcblxuXHRcdHZhciBxID0gd29ybGQuY2FtZXJhLnF1YXRlcm5pb247XG5cdFx0dmFyIHBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApLmFwcGx5UXVhdGVybmlvbiggcSApO1xuXG5cdFx0dmFyIGhlYWRpbmcgPSBNYXRoLmF0YW4yKCBwVmVjLnosIHBWZWMueCApO1xuXHRcdGhlYWRpbmcgKz0gTWF0aC5QSS8yO1xuXHRcdGhlYWRpbmcgKj0gMTgwIC8gTWF0aC5QSTtcblx0XHRoZWFkaW5nID0gaGVhZGluZyA+IDAgPyBoZWFkaW5nIDogaGVhZGluZyArIDM2MDtcblx0XHRoZWFkaW5nID0gTWF0aC5mbG9vcihoZWFkaW5nICUgMzYwKTtcblxuXHRcdHJldHVybiBoZWFkaW5nO1xuXG5cdH07XG5cblx0dGhpcy51cGRhdGVFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCl7XG5cblx0XHR1cGRhdGUgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcblxuXHRcdFx0dmFyIHJvdGF0aW9uID0gc2VsZi5nZXREaXJlY3Rpb24oKTtcblxuXHRcdFx0Ly90cmFuc2Zvcm1cblx0XHRcdGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3JvdGF0ZSgnK3JvdGF0aW9uKydkZWcpJztcblx0XHRcdGVsZW1lbnQuc3R5bGUubW96VHJhbnNmb3JtID0gJ3JvdGF0ZSgnK3JvdGF0aW9uKydkZWcpJztcblx0XHRcdGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ3JvdGF0ZSgnK3JvdGF0aW9uKydkZWcpJztcblxuXHRcdH0sIDI1MCk7XG5cblx0fTtcblxuXHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuXG5cdFx0d2luZG93LmNsZWFySW50ZXJ2YWwodXBkYXRlKTtcblxuXHR9O1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9jbGFzc2VzL2NvbXBhc3MuanNcIixcIi9jbGllbnQvY2xhc3Nlc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBUSFJFRSA9IHJlcXVpcmUoJ3RocmVlJyk7XG52YXIgRWZmZWN0Q29tcG9zZXIgPSByZXF1aXJlKCcuLi9saWIvZWZmZWN0LWNvbXBvc2VyLmpzJyk7XG52YXIgUmVuZGVyUGFzcyA9IHJlcXVpcmUoJy4uL2xpYi9yZW5kZXItcGFzcy5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCB3b3JsZCl7XG5cblx0Ly8gdGhpcy5kcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXHR0aGlzLmRwciA9IDI7XG5cblx0Ly9DcmVhdGUgU2hhZGVyIFBhc3Nlc1xuXHR0aGlzLmNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcblx0dGhpcy5jb21wb3Nlci5zZXRTaXplKHJlbmRlcmVyLmRvbUVsZW1lbnQub2Zmc2V0V2lkdGggKiB0aGlzLmRwciwgcmVuZGVyZXIuZG9tRWxlbWVudC5vZmZzZXRIZWlnaHQgKiB0aGlzLmRwcik7XG5cdHRoaXMucmVuZGVyUGFzcyA9IG5ldyBSZW5kZXJQYXNzKHNjZW5lLCBjYW1lcmEsIG51bGwsIG5ldyBUSFJFRS5Db2xvcigweEZGRkZGRikpO1xuXHR0aGlzLmNvbXBvc2VyLmFkZFBhc3ModGhpcy5yZW5kZXJQYXNzKTtcblxuXHQvL2dldCBtYXggc2l6ZVxuXHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuXHR2YXIgbWF4ID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpO1xuXG5cdC8vYWJiaWxpdHkgdG8gYWRkIEZYXG5cdHRoaXMuYWRkID0gZnVuY3Rpb24obmFtZSl7XG5cdFx0SU8uRlhsaWJbbmFtZV0uY2FsbCh0aGlzLCBzY2VuZSwgY2FtZXJhLCByZW5kZXJlciwgd29ybGQpO1xuXHRcdHJldHVybiB0aGlzOyAvL2NoYWluYWJsZVxuXHR9O1xuXG5cdC8vYWx3YXlzIGFkZCBGWEFBXG5cdC8vIHRoaXMuYWRkKCdGWEFBJyk7XG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbihkZWx0YSl7XG5cdFx0dGhpcy5jb21wb3Nlci5yZW5kZXIoZGVsdGEpO1xuXHR9LmJpbmQodGhpcyk7XG5cblx0dGhpcy5zZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24oY29sb3Ipe1xuXHRcdHRoaXMucmVuZGVyUGFzcy5jbGVhckNvbG9yID0gY29sb3I7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0dGhpcy5yZXNpemUgPSBmdW5jdGlvbigpe1xuXG5cdFx0dmFyIHdpZHRoID0gcmVuZGVyZXIuZG9tRWxlbWVudC5vZmZzZXRXaWR0aCAqIHRoaXMuZHByO1xuXHRcdHZhciBoZWlnaHQgPSByZW5kZXJlci5kb21FbGVtZW50Lm9mZnNldEhlaWdodCAqIHRoaXMuZHByO1xuXHRcdHZhciByYXRpbztcblxuXHRcdGlmKHdpZHRoIDwgMTAyNCl7XG5cdFx0XHR3aWR0aCA9IDEwMjQ7XG5cdFx0fVxuXG5cdFx0Ly9jaGVjayBmb3IgbWF4LiB0ZXh0dXJlIHNpemUgZm9yIGRpbWVuc2lvbnNcblx0XHRpZih3aWR0aCA+IGhlaWdodCAmJiB3aWR0aCA+IG1heCl7XG5cblx0XHRcdHJhdGlvID0gaGVpZ2h0L3dpZHRoO1xuXHRcdFx0d2lkdGggPSBtYXg7XG5cdFx0XHRoZWlnaHQgKj0gcmF0aW87XG5cblx0XHR9XG5cdFx0ZWxzZSBpZiggaGVpZ2h0ID4gd2lkdGggJiYgaGVpZ2h0ID4gbWF4ICl7XG5cblx0XHRcdHJhdGlvID0gd2lkdGgvaGVpZ2h0O1xuXHRcdFx0aGVpZ2h0ID0gbWF4O1xuXHRcdFx0bWF4ICo9IHJhdGlvO1xuXG5cdFx0fVxuXG5cdFx0Ly9vbiByZXNpemVcblx0XHR0aGlzLmNvbXBvc2VyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG5cdFx0aWYodGhpcy5lZmZlY3RGWEFBKXtcblx0XHRcdHRoaXMuZWZmZWN0RlhBQS51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnNldCgxIC8gd2lkdGgsIDEgLyBoZWlnaHQpO1xuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG5cblx0XHR0aGlzLmNvbXBvc2VyLnJlc2V0KCk7XG5cdFx0dGhpcy5jb21wb3Nlci5yZW5kZXJUYXJnZXQxLmRpc3Bvc2UoKTtcblx0XHR0aGlzLmNvbXBvc2VyLnJlbmRlclRhcmdldDIuZGlzcG9zZSgpO1xuXG5cdFx0dGhpcy5jb21wb3Nlci5yZW5kZXJUYXJnZXQxID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29tcG9zZXIucmVuZGVyVGFyZ2V0MiA9IHVuZGVmaW5lZDtcblxuXHR9O1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9jbGFzc2VzL2Z4LmpzXCIsXCIvY2xpZW50L2NsYXNzZXNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIsIGdyb3VwKXtcblxuXHR2YXIgcHJvamVjdGlvbiwgY3VycmVudCwgY3VycmVudExvb2s7XG5cdHZhciBhbmltYXRpb24gPSB7fTtcblx0dmFyIHByZXZBbmltYXRpb24gPSB7fTtcblx0dmFyIHN0YXR1cyA9ICdmaXhlZCc7XG5cblx0Ly9jcmVhdGUgY2FtZXJhXG5cdHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG5cdGNhbWVyYS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdC8vY2hhbmdlIHogYW5kIHkgYXhpc1xuXHRjYW1lcmEudXAgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG5cdHZhciBjb252ZXJ0ID0gZnVuY3Rpb24ocG9zKXtcblxuXHRcdHJldHVybiBwb3M7XG5cblx0XHQvLyBncm91cC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdHZhciBjb252ZXJ0ZWQgPSBncm91cC5sb2NhbFRvV29ybGQocG9zKTtcblx0XHRjb252ZXJ0ZWQueSAqPSAtMTtcblx0XHRyZXR1cm4gY29udmVydGVkO1xuXG5cdH07XG5cblx0Y2FtZXJhLnNldFByb2plY3Rpb24gPSBmdW5jdGlvbihfcHJvamVjdGlvbil7XG5cblx0XHQvL3NhdmVcblx0XHRwcm9qZWN0aW9uID0gX3Byb2plY3Rpb247XG5cblx0XHQvL2NoYWluYWJsZVxuXHRcdHJldHVybiBjYW1lcmE7XG5cdH07XG5cblx0Y2FtZXJhLmdvdG9HZW8gPSBmdW5jdGlvbihsYXQsIGxvbiwgaGVpZ2h0KXtcblxuXHRcdC8vZ2V0IHBvc2l0aW9uIGZyb20gcHJvamVjdGlvblxuXHRcdHZhciBuZXdQb3MgPSBwcm9qZWN0aW9uLnRyYW5zbGF0ZTNEKGxhdCwgbG9uKTtcblx0XHR2YXIgbmV3UG9zMyA9IGNvbnZlcnQoIG5ldyBUSFJFRS5WZWN0b3IzKG5ld1Bvcy54LCBuZXdQb3MueSwgaGVpZ2h0KSApO1xuXG5cdFx0Ly9zYXZlXG5cdFx0Y2FtZXJhLnBvc2l0aW9uLmNvcHkobmV3UG9zMyk7XG5cblx0XHQvL3NhdmVcblx0XHRjdXJyZW50ID0gbmV3UG9zMy5jbG9uZSgpO1xuXG5cdFx0Ly9jaGFpbmFibGVcblx0XHRyZXR1cm4gY2FtZXJhO1xuXHR9O1xuXG5cdGNhbWVyYS5sb29rQXRHZW8gPSBmdW5jdGlvbihsYXQsIGxvbiwgaGVpZ2h0KXtcblxuXHRcdC8vZ2V0IHBvc2l0aW9uIGZyb20gcHJvamVjdGlvblxuXHRcdHZhciBuZXdQb3MgPSBwcm9qZWN0aW9uLnRyYW5zbGF0ZTNEKGxhdCwgbG9uKTtcblx0XHR2YXIgbG9va0F0ID0gY29udmVydCggbmV3IFRIUkVFLlZlY3RvcjMobmV3UG9zLngsIG5ld1Bvcy55LCBoZWlnaHQpICk7XG5cblx0XHRjYW1lcmEubG9va0F0KCBsb29rQXQgKTtcblxuXHRcdC8vc2F2ZVxuXHRcdGN1cnJlbnRMb29rID0gbG9va0F0LmNsb25lKCk7XG5cblx0XHQvL2NoYWluYWJsZVxuXHRcdHJldHVybiBjYW1lcmE7XG5cblx0fTtcblxuXHRjYW1lcmEuaW50ZXJwb2xhdGVUbyA9IGZ1bmN0aW9uKGNlbnRlciwgZGVzdCwgZGlzdGFuY2UsIGV4dHJhcG9sYXRlKXtcblxuXHRcdHZhciBfY2VudGVyO1xuXHRcdF9jZW50ZXIgPSBwcm9qZWN0aW9uLnRyYW5zbGF0ZTNEKGNlbnRlci5sYXQsIGNlbnRlci5sb24pO1xuXHRcdF9jZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhfY2VudGVyLngsIF9jZW50ZXIueSwgY2VudGVyLmhlaWdodCk7XG5cblx0XHR2YXIgX2Rlc3Q7XG5cdFx0X2Rlc3QgPSBwcm9qZWN0aW9uLnRyYW5zbGF0ZTNEKGRlc3QubGF0LCBkZXN0Lmxvbik7XG5cdFx0X2Rlc3QgPSBuZXcgVEhSRUUuVmVjdG9yMyhfZGVzdC54LCBfZGVzdC55LCBjZW50ZXIuaGVpZ2h0KTtcblxuXG5cdFx0dmFyIGxpbmUgPSBuZXcgVEhSRUUuTGluZTMoX2NlbnRlciwgX2Rlc3QpO1xuXHRcdHZhciB0b3RhbERpc3RhbmNlID0gbGluZS5kaXN0YW5jZSgpO1xuXHRcdHZhciByZWxEaXN0YW5jZSA9IGRpc3RhbmNlIC8gdG90YWxEaXN0YW5jZTtcblxuXHRcdGlmKHJlbERpc3RhbmNlID4gMC44KXtcblx0XHRcdHJlbERpc3RhbmNlID0gMC44O1xuXHRcdH1cblxuXHRcdHZhciBuZXdQb2ludDtcblx0XHRpZihleHRyYXBvbGF0ZSl7XG5cdFx0XHRyZWxEaXN0YW5jZSArPSAxO1xuXHRcdFx0bmV3UG9pbnQgPSBsaW5lLmF0KHJlbERpc3RhbmNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3UG9pbnQgPSBsaW5lLmF0KDEtcmVsRGlzdGFuY2UpO1xuXHRcdH1cblxuXHRcdGNhbWVyYS5hbmltYXRlVG8oY29udmVydChuZXdQb2ludCksIGRlc3QpO1xuXG5cdH07XG5cblx0Y2FtZXJhLmFuaW1hdGVUbyA9IGZ1bmN0aW9uKHRvLCBsb29rVG8sIHRpbWUsIGNhbGxiYWNrKXtcblxuXHRcdHZhciBfdG8sIF9sb29rVG87XG5cdFx0dGltZSA9IHRpbWUgfHwgMjAwMDtcblxuXHRcdGlmKHRvIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyA9PT0gZmFsc2Upe1xuXG5cdFx0XHQvL2dlbmVyYXRlIHRvXG5cdFx0XHRfdG8gPSBwcm9qZWN0aW9uLnRyYW5zbGF0ZTNEKHRvLmxhdCwgdG8ubG9uKTtcblx0XHRcdF90byA9IGNvbnZlcnQoIG5ldyBUSFJFRS5WZWN0b3IzKF90by54LCBfdG8ueSwgdG8uaGVpZ2h0KSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly90byBhbHJlYWR5IGdpdmVuXG5cdFx0XHRfdG8gPSB0bztcblxuXHRcdH1cblxuXHRcdGlmKGxvb2tUbyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgPT09IGZhbHNlKXtcblxuXHRcdFx0Ly9nZW5lcmF0ZSBsb29rIHRvXG5cdFx0XHRfbG9va1RvID0gcHJvamVjdGlvbi50cmFuc2xhdGUzRChsb29rVG8ubGF0LCBsb29rVG8ubG9uKTtcblx0XHRcdF9sb29rVG8gPSBjb252ZXJ0KCBuZXcgVEhSRUUuVmVjdG9yMyhfbG9va1RvLngsIF9sb29rVG8ueSwgbG9va1RvLmhlaWdodCkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGxvb2sgdG8gYWxyZWFkeSBnaXZlblxuXHRcdFx0X2xvb2tUbyA9IGxvb2tUby5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly9zYXZlIGFuaW1hdGlvbiBvYmplY3QgZm9yIHJlbmRlcmluZ1xuXHRcdGFuaW1hdGlvbiA9IHtcblxuXHRcdFx0J3R5cGUnOiAnZmx5JyxcblxuXHRcdFx0J2Zyb20nOiBjdXJyZW50LmNsb25lKCksXG5cdFx0XHQnbG9va0Zyb20nOiBjdXJyZW50TG9vay5jbG9uZSgpLFxuXG5cdFx0XHQndG8nOiBfdG8sXG5cdFx0XHQnbG9va1RvJzogX2xvb2tUbyxcblxuXHRcdFx0J3RpbWVGcm9tJzogK0RhdGUubm93KCksXG5cdFx0XHQndGltZVRvJzogK0RhdGUubm93KCkgKyB0aW1lXG5cblx0XHR9O1xuXG5cdFx0Ly9jYWxsYmFjaz9cblx0XHRpZihjYWxsYmFjayl7XG5cdFx0XHRhbmltYXRpb24uY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHR9XG5cblx0XHQvL3RyaWdnZXIgcmVuZGVyaW5nXG5cdFx0Y2FtZXJhLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdC8vY2hhaW5hYmxlXG5cdFx0cmV0dXJuIGNhbWVyYTtcblx0fTtcblxuXHR2YXIgZ2VuZXJhdGVIb3ZlclBsYWNlID0gZnVuY3Rpb24oY2VudGVyLCByYWRpdXMsIGhlaWdodCwgc3BlZWQsIGVsYXBzZWRUaW1lKXtcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXG5cdFx0XHRjZW50ZXIueCArIHJhZGl1cyAqIE1hdGguY29zKCBzcGVlZCAqIGVsYXBzZWRUaW1lICksXG5cdFx0XHRjZW50ZXIueSArIHJhZGl1cyAqIE1hdGguc2luKCBzcGVlZCAqIGVsYXBzZWRUaW1lICksXG5cdFx0XHRoZWlnaHRcblx0XHQpO1xuXHR9O1xuXG5cdGNhbWVyYS5mbHlBcm91bmQgPSBmdW5jdGlvbihjZW50ZXIsIHJhZGl1cywgaGVpZ2h0LCBzcGVlZCwgZnJvbUNhbGxiYWNrKXtcblxuXHRcdC8vc2V0dGluZ3Ncblx0XHRyYWRpdXMgPSByYWRpdXMgfHwgNTAwO1xuXHRcdGhlaWdodCA9IGhlaWdodCB8fCAyNTA7XG5cdFx0c3BlZWQgPSBzcGVlZCB8fCAwLjEwO1xuXG5cdFx0dmFyIF9jZW50ZXIsIF9sb29rO1xuXHRcdGlmKGNlbnRlciBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMpe1xuXG5cdFx0XHRfY2VudGVyID0gY29udmVydCggY2VudGVyLmNsb25lKCkgKTtcblx0XHRcdC8vIGNlbnRlciA9IGNvbnZlcnQoY2VudGVyLmNsb25lKCkpO1xuXHRcdFx0X2xvb2sgPSBfY2VudGVyLmNsb25lKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvL2dldCBjZW50ZXIgcG9pbnRcblx0XHRcdGNlbnRlci5oZWlnaHQgPSBjZW50ZXIuaGVpZ2h0IHx8IC01MDtcblx0XHRcdHZhciBwb2ludCA9IHByb2plY3Rpb24udHJhbnNsYXRlM0QoY2VudGVyLmxhdCwgY2VudGVyLmxvbik7XG5cdFx0XHRfY2VudGVyID0gY29udmVydCggbmV3IFRIUkVFLlZlY3RvcjMocG9pbnQueCwgcG9pbnQueSwgY2VudGVyLmhlaWdodCkgKTtcblx0XHRcdF9sb29rID0gX2NlbnRlci5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly9nZW5lcmF0ZSBzdGFydCBwb2ludFxuXHRcdHZhciBzdGFydFBvaW50ID0gZ2VuZXJhdGVIb3ZlclBsYWNlKF9jZW50ZXIsIHJhZGl1cywgaGVpZ2h0LCBzcGVlZCwgMCk7XG5cblx0XHQvL21vdmUgdG8gcGxhY2U/XG5cdFx0aWYoIWZyb21DYWxsYmFjayl7XG5cblx0XHRcdGNhbWVyYS5hbmltYXRlVG8oc3RhcnRQb2ludCwgX2xvb2ssIDEwMDAsIGZ1bmN0aW9uKCl7XG5cblx0XHRcdFx0Ly93aGVuIG9uIGNvcnJlY3QgcG9zaXRpb24gc3RhcnQgYW5pbWF0aW5nXG5cdFx0XHRcdGNhbWVyYS5mbHlBcm91bmQoY2VudGVyLCByYWRpdXMsIGhlaWdodCwgc3BlZWQsIHRydWUpO1xuXG5cdFx0XHR9KTtcblxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly9jaGFuZ2UgYW5pbWF0aW9uIG9iamVjdFxuXHRcdFx0YW5pbWF0aW9uID0ge1xuXHRcdFx0XHQndHlwZSc6ICdob3ZlcicsXG5cdFx0XHRcdCdzdGFydCc6ICtEYXRlLm5vdygpLFxuXHRcdFx0XHQnY291bnQnOiAwLFxuXHRcdFx0XHQnc3BlZWQnOiBzcGVlZCxcblx0XHRcdFx0J3JhZGl1cyc6IHJhZGl1cyxcblx0XHRcdFx0J2NlbnRlcic6IF9jZW50ZXIsXG5cdFx0XHRcdCdoZWlnaHQnOiBoZWlnaHRcblx0XHRcdH07XG5cblx0XHRcdGN1cnJlbnRMb29rID0gYW5pbWF0aW9uLmNlbnRlci5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly9zYXZlIGZvciBhbmltYXRpb25cblx0XHRjYW1lcmEubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH07XG5cblx0dmFyIHBhdXNlZCA9IGZhbHNlO1xuXHRjYW1lcmEucGF1c2UgPSBmdW5jdGlvbigpe1xuXHRcdHBhdXNlZCA9IHRydWU7XG5cdH07XG5cblx0Y2FtZXJhLnJlbmRlciA9IGZ1bmN0aW9uKCl7XG5cblx0XHQvL2NoZWNrIGlmIG5lZWRzIHRvIHJlbmRlclxuXHRcdGlmKCFjYW1lcmEubmVlZHNVcGRhdGUpe1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHN0YXR1cyA9ICdtb3ZpbmcnO1xuXG5cdFx0aWYoYW5pbWF0aW9uLnR5cGUgPT09ICdob3Zlcicpe1xuXG5cdFx0XHQvLyBhbmltYXRpb24uY291bnQgKz0gZGVsdGE7XG5cdFx0XHRhbmltYXRpb24uY291bnQgKz0gMC4wMjtcblx0XHRcdC8vIHZhciBlbGFwc2VkVGltZSA9ICtEYXRlLm5vdygpIC0gYW5pbWF0aW9uLnN0YXJ0O1xuXG5cdFx0XHR2YXIgbmV3UG9zID0gZ2VuZXJhdGVIb3ZlclBsYWNlKGFuaW1hdGlvbi5jZW50ZXIsIGFuaW1hdGlvbi5yYWRpdXMsIGFuaW1hdGlvbi5oZWlnaHQsIGFuaW1hdGlvbi5zcGVlZCwgYW5pbWF0aW9uLmNvdW50KTtcblx0XHRcdGNhbWVyYS5wb3NpdGlvbi5jb3B5KG5ld1Bvcyk7XG5cdFx0XHRjYW1lcmEubG9va0F0KCBhbmltYXRpb24uY2VudGVyICk7XG5cblx0XHRcdGN1cnJlbnQgPSBjYW1lcmEucG9zaXRpb24uY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdGVsc2UgaWYoYW5pbWF0aW9uLnR5cGUgPT09ICdmbHknKXtcblxuXHRcdFx0Ly9jYWxjdWxhdGUgcHJvZ3Jlc3Ncblx0XHRcdHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbi50aW1lVG8gLSBhbmltYXRpb24udGltZUZyb207XG5cdFx0XHR2YXIgbm93ID0gK0RhdGUubm93KCkgLSBhbmltYXRpb24udGltZUZyb207XG5cdFx0XHR2YXIgcHJvZ3Jlc3MgPSBub3cvZHVyYXRpb247XG5cblx0XHRcdC8vd2hlbiBwYXVzZWQgbWFrZSBzdXJlIGxhc3QgZnJhbWUgaXMgdHJpZ2dlcmVkXG5cdFx0XHRpZihwYXVzZWQgJiYgcHJvZ3Jlc3MgPiAxKXtcblx0XHRcdFx0cHJvZ3Jlc3MgPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvL25vdCBwYXVzZWQgbm93XG5cdFx0XHRwYXVzZWQgPSBmYWxzZTtcblxuXHRcdFx0Ly9jaGVjayBpZiBkb25lXG5cdFx0XHRpZihwcm9ncmVzcyA8PSAxKXtcblxuXHRcdFx0XHQvL3ByZXZlbnQgb3ZlcmRvaW5nXG5cdFx0XHRcdGlmKHByb2dyZXNzID4gMSl7XG5cdFx0XHRcdFx0cHJvZ3Jlc3MgPSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9sZXJwIGFuZCBlYXNlXG5cdFx0XHRcdHZhciBwb3MgPSBJTy50b29scy5sZXJwMyhhbmltYXRpb24uZnJvbSwgYW5pbWF0aW9uLnRvLCBwcm9ncmVzcyk7XG5cdFx0XHRcdHZhciBsb29rID0gSU8udG9vbHMubGVycDMoYW5pbWF0aW9uLmxvb2tGcm9tLCBhbmltYXRpb24ubG9va1RvLCBwcm9ncmVzcyk7XG5cblx0XHRcdFx0Ly9kbyB1cGRhdGluZ1xuXHRcdFx0XHRjYW1lcmEucG9zaXRpb24ueCA9IHBvcy54O1xuXHRcdFx0XHRjYW1lcmEucG9zaXRpb24ueSA9IHBvcy55O1xuXHRcdFx0XHRjYW1lcmEucG9zaXRpb24ueiA9IHBvcy56O1xuXHRcdFx0XHRjYW1lcmEubG9va0F0KGxvb2spO1xuXG5cdFx0XHRcdC8vc2F2ZSBjdXJyZW50IHBvc1xuXHRcdFx0XHRjdXJyZW50ID0gcG9zLmNsb25lKCk7XG5cdFx0XHRcdGN1cnJlbnRMb29rID0gbG9vay5jbG9uZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vcHJldmVudCByZW5kZXJpbmcgbmV4dCB0aW1lXG5cdFx0XHRcdGNhbWVyYS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRwcmV2QW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuXHRcdFx0XHRzdGF0dXMgPSAnZml4ZWQnO1xuXG5cdFx0XHRcdC8vc2F2ZSBjYWxsYmFja1xuXHRcdFx0XHR2YXIgY2FsbGJhY2sgPSBhbmltYXRpb24uY2FsbGJhY2sgfHwgdW5kZWZpbmVkO1xuXG5cdFx0XHRcdC8vcmVzZXRcblx0XHRcdFx0YW5pbWF0aW9uID0ge307XG5cblx0XHRcdFx0Ly9leGVjdXRlIGNhbGxiYWNrIHdoZW4gc2V0XG5cdFx0XHRcdGlmKGNhbGxiYWNrICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly9yZXR1cm4gY2FtZXJhXG5cdHJldHVybiBjYW1lcmE7XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY2xpZW50L2NsYXNzZXMvZ2VvLWNhbWVyYS5qc1wiLFwiL2NsaWVudC9jbGFzc2VzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHEgPSByZXF1aXJlKCdxJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od29ybGQpe1xuXG5cdC8vZGVmZXIgb2JqZWN0IGZvciB1c2Ugd2l0aGluIHByb21pc2VzXG5cdHZhciBzZWxmID0gdGhpcztcblxuXHR2YXIgbWFwLCBkYXRhLCB6LCBiYm94O1xuXHR2YXIgb3B0aW9ucyA9IHt9O1xuXHR2YXIgYWN0aW9ucyA9IFtdO1xuXHR2YXIgcmVuZGVyID0gW107XG5cdHZhciBsb2FkZWQgPSBxLmRlZmVyKCk7XG5cdHRoaXMubmVlZHNSZW5kZXJpbmcgPSBmYWxzZTtcblxuXHR0aGlzLmRhdGEgPSBmdW5jdGlvbihtYXBEYXRhLCBfeil7XG5cblx0XHQvL3NhdmUgZGF0YVxuXHRcdG1hcCA9IG1hcERhdGE7XG5cdFx0eiA9IF96O1xuXG5cdFx0Ly9jaGFpbmFibGVcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8vc2V0IG9wdGlvbnNcblx0dGhpcy5vcHRpb25zID0gZnVuY3Rpb24oX29wdGlvbnMpe1xuXG5cdFx0Ly9zYXZlXG5cdFx0b3B0aW9ucyA9IF9vcHRpb25zO1xuXG5cdFx0Ly9jaGFpbmFibGVcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvL2xvYWQgZGF0YVxuXHR0aGlzLmZldGNoID0gZnVuY3Rpb24oKXtcblxuXHRcdHZhciBfbG9hZCA9IG1hcC5sb2FkKCk7XG5cblx0XHQvL3Byb21pc2UgZm9yIGxheWVyXG5cdFx0X2xvYWQudGhlbihmdW5jdGlvbigpe1xuXHRcdFx0bG9hZGVkLnJlc29sdmUoKTtcblx0XHR9KTtcblxuXHRcdC8vcHJvbWlzZSBmb3IgbG9hZGVyXG5cdFx0cmV0dXJuIF9sb2FkO1xuXG5cdH07XG5cblx0Ly9idWlsZCBtZXNoIHdpdGggY29ycmVjdCBidWlsZHNjcmlwdFxuXHR0aGlzLmJ1aWxkID0gZnVuY3Rpb24oYnVpbGQsIGN1c3RvbVope1xuXG5cdFx0bG9hZGVkLnByb21pc2UuZG9uZShmdW5jdGlvbigpe1xuXG5cdFx0XHR2YXIgX3ogPSBjdXN0b21aIHx8IHo7XG5cblx0XHRcdC8vY29udmVydCBkYXRhIHRvIDNEIHdoZW4gbm90IGFscmVhZHkgY29udmVydGVkXG5cdFx0XHRpZighZGF0YSl7XG5cblx0XHRcdFx0Y29uc29sZS5sb2coJ2NvbnZlcnRpbmcnKTtcblxuXHRcdFx0XHQvLyAvL3doZW4gYW4gYXJyYXkgbG9hZCBtdWx0aXBsZSBtYXBzXG5cdFx0XHRcdC8vIGlmKG1hcCBpbnN0YW5jZW9mIEFycmF5KXtcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gXHRkYXRhID0gW107XG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIFx0Ly9tZXJnZSBtdWx0aXBsZSByb2FkIG1hcHMgaW50byBvbmVcblx0XHRcdFx0Ly8gXHRmb3IoIHZhciBpID0gMCA7IGkgPCBtYXBEYXRhLmxlbmd0aCA7IGkrKyApe1xuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBcdFx0ZGF0YSA9IF9kYXRhLmNvbmNhdCggbWFwW2ldLmdldERhdGEoKSApO1xuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBcdH1cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gXHQvL2dldCBib3VuZGluZyBib3ggb2YgZmlyc3QgbWFwXG5cdFx0XHRcdC8vIFx0Ly9iYm94ID0gbWFwRGF0YVswXS5nZXRCb3VuZGluZ0JveCgpO1xuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyB9IGVsc2Uge1xuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBcdC8vc2luZ2xlIG1hcFxuXHRcdFx0XHQvLyBcdGRhdGEgPSBtYXAuY29udmVydDNEKHdvcmxkLnByb2plY3Rpb24sIF96KTtcblx0XHRcdFx0Ly8gXHQvLyBiYm94ID0gbWFwRGF0YS5nZXRCb3VuZGluZ0JveCgpO1xuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyB9XG5cblx0XHRcdFx0ZGF0YSA9IG1hcC5nZXREYXRhKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG1ldGEgPSB7XG5cdFx0XHRcdCdkYXRhJzogZGF0YSxcblx0XHRcdFx0J3JlbmRlcic6IHJlbmRlcixcblx0XHRcdFx0J2JvdW5kaW5nYm94JzogYmJveCxcblx0XHRcdFx0J29wdGlvbnMnOiBvcHRpb25zLFxuXHRcdFx0XHQneic6IF96XG5cdFx0XHR9O1xuXG5cdFx0XHQvL3N0YXJ0IGJ1aWxkIHNjcmlwdFxuXHRcdFx0dmFyIGFjdGlvbiA9IGJ1aWxkLmNhbGwobWV0YSwgd29ybGQpO1xuXG5cdFx0XHQvL2FkZCBhY3Rpb25zXG5cdFx0XHRhY3Rpb25zID0gSU8udG9vbHMuYWN0aW9uRXh0ZW5kKGFjdGlvbnMsIGFjdGlvbik7XG5cblx0XHRcdC8vbmVlZHMgcmVuZGVyaW5nP1xuXHRcdFx0aWYocmVuZGVyLmxlbmd0aCA+IDApe1xuXHRcdFx0XHRzZWxmLm5lZWRzUmVuZGVyaW5nID0gcmVuZGVyLmxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYubmVlZHNSZW5kZXJpbmcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdH0pXG5cblx0XHQvL2NoYWluYWJsZVxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Ly9hZGQgYWJiaWxpdHkgdG8gcmVuZGVyIGRhdGEgaW4gbXVsdGlwbGUgY3ljbGVzIHRvIHByZXZlbnQgQ1BVIG92ZXJsb2FkaW5nXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oc3RhcnQsIGVuZCl7XG5cblx0XHRmb3IodmFyIGkgPSBzdGFydCA7IGkgPCBlbmQgOyBpKyspe1xuXHRcdFx0cmVuZGVyW2ldKCk7XG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5hY3Rpb24gPSBmdW5jdGlvbihuYW1lLCBwcm9wZXJ0aWVzKXtcblxuXHRcdHZhciByZXNwb25zZTtcblxuXHRcdGlmKGFjdGlvbnNbbmFtZV0gaW5zdGFuY2VvZiBBcnJheSl7XG5cblx0XHRcdHJlc3BvbnNlID0gW107XG5cblx0XHRcdGZvciggdmFyIGkgPSAwIDsgaSA8IGFjdGlvbnNbbmFtZV0ubGVuZ3RoIDsgaSsrICl7XG5cdFx0XHRcdHJlc3BvbnNlLnB1c2goIGFjdGlvbnNbbmFtZV1baV0uY2FsbCh3b3JsZCwgcHJvcGVydGllcykgKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXNwb25zZSA9IGFjdGlvbnNbbmFtZV0uY2FsbCh3b3JsZCwgcHJvcGVydGllcyk7XG5cdFx0fVxuXG5cdFx0Ly9tYWtlIGl0IHBvc3NpYmxlIHRvIGNhbGwgYmFja1xuXHRcdHJldHVybiByZXNwb25zZTtcblxuXHR9O1xuXG5cdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG5cdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHRvcHRpb25zID0gdW5kZWZpbmVkO1xuXHRcdHogPSB1bmRlZmluZWQ7XG5cdFx0YmJveCA9IHVuZGVmaW5lZDtcblx0XHRhY3Rpb25zID0gdW5kZWZpbmVkO1xuXHR9O1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9jbGFzc2VzL2xheWVyM2QuanNcIixcIi9jbGllbnQvY2xhc3Nlc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcblxuICAgIC8vZGVmZXIgb2JqZWN0IG5lZWRlZCBpbiBwcm9taXNlc1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBsaXN0ID0gW107XG4gICAgdmFyIHEgPSByZXF1aXJlKCdxJyk7XG4gICAgdmFyIG9iamVjdHMgPSAwO1xuICAgIHZhciByZW5kZXJlZCA9IDA7XG5cbiAgICAvL2Ftb3VudCBvZiBvYmplY3RzIHRvIHJlbmRlciBhdCBvbmNlXG4gICAgdGhpcy50aHJvdHRsZSA9IDE1O1xuXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbihfbGlzdCl7XG5cbiAgICAgICAgaWYoX2xpc3QgaW5zdGFuY2VvZiBBcnJheSl7XG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5jb25jYXQoX2xpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5wdXNoKF9saXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hhaW5hYmxlXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpe1xuXG4gICAgICAgIC8vY29sbGVjdGlvbiBvZiBwcm9taXNlZFxuICAgICAgICB2YXIgbG9hZExpc3QgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMCA7IGkgPCBsaXN0Lmxlbmd0aCA7IGkrKyApe1xuICAgICAgICAgICAgbG9hZExpc3QucHVzaCggbGlzdFtpXS5mZXRjaCgpICk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3Nob3cgd2UncmUgbm93IGRvd25sb2FkaW5nXG4gICAgICAgIHRoaXMuc3RhdGUoJ2Rvd25sb2FkaW5nJyk7XG5cbiAgICAgICAgLy9jcmVhdGUgZ3JvdXBlZCBwcm9taXNlXG4gICAgICAgIHZhciBsb2FkUHJvbWlzZSA9IHEuYWxsKGxvYWRMaXN0KTtcbiAgICAgICAgdmFyIHJlbmRlclByb21pc2UgPSBxLmRlZmVyKCk7XG5cbiAgICAgICAgLy9vbiBmaW5pc2hlZCBzdGFydCByZW5kZXJpbmdcbiAgICAgICAgbG9hZFByb21pc2UudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5yZW5kZXIocmVuZGVyUHJvbWlzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZW5kZXJQcm9taXNlLnByb21pc2U7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbihkZWZlcil7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vd2UncmUgbm93IHJlbmRlcmluZ1xuICAgICAgICB0aGlzLnN0YXRlKCdyZW5kZXJpbmcnKTtcblxuICAgICAgICAvL2RldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIHJlbmRlclxuICAgICAgICBmb3IoIHZhciBpID0gMCA7IGkgPCBsaXN0Lmxlbmd0aCA7IGkrKyApe1xuXG4gICAgICAgICAgICBpZihsaXN0W2ldLm5lZWRzUmVuZGVyaW5nKXtcbiAgICAgICAgICAgICAgICBvYmplY3RzICs9IGxpc3RbaV0ubmVlZHNSZW5kZXJpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmVuZGVyIGFsbCBvYmplY3RzXG4gICAgICAgIGZvciggdmFyIGkgPSAwIDsgaSA8IGxpc3QubGVuZ3RoIDsgaSsrICl7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGogPSAwIDsgaiA8IGxpc3RbaV0ubmVlZHNSZW5kZXJpbmcgOyBqKz10aGlzLnRocm90dGxlICl7XG5cbiAgICAgICAgICAgICAgICAvL3Rocm90dGxlIHRvIHByZXZlbnQgQ1BVIG92ZXJsb2FkXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZXJtaW5lIGVuZFxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5zdGFydCArIHNlbGYudGhyb3R0bGU7XG4gICAgICAgICAgICAgICAgICAgIGlmKGVuZCA+IGxpc3RbdGhpcy5jdXJyZW50XS5uZWVkc1JlbmRlcmluZyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBsaXN0W3RoaXMuY3VycmVudF0ubmVlZHNSZW5kZXJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2RvIHJlbmRlcmluZ1xuICAgICAgICAgICAgICAgICAgICBsaXN0W3RoaXMuY3VycmVudF0ucmVuZGVyKHRoaXMuc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9kZXRlcm1pbmUgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQgKz0gZW5kIC0gdGhpcy5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gcmVuZGVyZWQgLyBvYmplY3RzO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIGhvb2tcbiAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGUocHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vZmluaXNoZWQ/XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlbmRlcmVkID09PSBvYmplY3RzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3RhdGUoJ2xvYWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LmJpbmQoeyAnc3RhcnQnOiBqLCAnY3VycmVudCc6IGkgfSksIDApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY3JlYXRlIGFzIHByb21pc2VcbiAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG5cbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihwcm9ncmVzcyl7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ2xvYWRlZDogJyArIE1hdGgucm91bmQocHJvZ3Jlc3MgKiAxMDApICsgJyUnKTtcblxuICAgIH07XG5cbiAgICAvL2hvb2sgZm9yIGNoYW5nZXMgb2Ygc3RhdGUgW2lkbGUsIGRvd25sb2FkaW5nLCByZW5kZXJpbmcsIGRvbmVdXG4gICAgdGhpcy5zdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKXtcbiAgICAgICAgY29uc29sZS5sb2coJ3N0YXRlJywgc3RhdGUgKTtcbiAgICB9O1xuXG4gICAgLy9zZXQgaW5pdGlhbCBzdGF0ZSB0byBpZGxlXG4gICAgdGhpcy5zdGF0ZSgnaWRsZScpO1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9jbGFzc2VzL2xvYWRlci5qc1wiLFwiL2NsaWVudC9jbGFzc2VzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcbnZhciBxID0gcmVxdWlyZSgncS14aHInKSh3aW5kb3cuWE1MSHR0cFJlcXVlc3QsIHJlcXVpcmUoJ3EnKSlcbnZhciB0b3BvanNvbiA9IHJlcXVpcmUoJ3RvcG9qc29uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBwYXJhbXMpe1xuXG4gICAgdmFyIHJhd0RhdGEsIHR5cGU7XG4gICAgdmFyIGlzTG9hZGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY29udmVydFRvcG8gPSBmdW5jdGlvbihkYXRhLCBrZXkpe1xuICAgICAgICBpZiAoZGF0YS50eXBlICYmIGRhdGEudHlwZSA9PT0gJ1RvcG9sb2d5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRvcG9qc29uLmZlYXR1cmUoZGF0YSwgZGF0YS5vYmplY3RzW2tleV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgLy9jcmVhdGUgcHJvbWlzZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZlciA9IHEuZGVmZXIoKTtcblxuICAgICAgICAvL2dldCBmaWxlIGV4dGVudGlvblxuICAgICAgICB2YXIgc3BsaXR0ZWQgPSB1cmwuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIGV4dCA9IHNwbGl0dGVkW3NwbGl0dGVkLmxlbmd0aC0xXTtcblxuICAgICAgICAvL2dldCBmaWxlIG5hbWVcbiAgICAgICAgc3BsaXR0ZWQgPSBzcGxpdHRlZFtzcGxpdHRlZC5sZW5ndGgtMl0uc3BsaXQoJy8nKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gc3BsaXR0ZWRbc3BsaXR0ZWQubGVuZ3RoLTFdO1xuXG4gICAgICAgIC8vc2VydmUgZnJvbSBjYWNoZVxuICAgICAgICBpZihpc0xvYWRlZCl7XG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlKHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZihleHQgPT09ICdwbmcnIHx8IGV4dCA9PT0gJ2pwZycpe1xuXG4gICAgICAgICAgICAvL2dldCB0ZXh0dXJlXG4gICAgICAgICAgICByYXdEYXRhID0gVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSh1cmwpO1xuICAgICAgICAgICAgdHlwZSA9ICdpbWFnZSc7XG5cbiAgICAgICAgICAgIC8vcmVzb2x2ZSAoY2hhaW5hYmxlKVxuICAgICAgICAgICAgZGVmZXIucmVzb2x2ZShzZWxmKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy9yZXF1ZXN0IGRhdGEgZnJvbSBzZXJ2ZXJcbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIHEueGhyXG4gICAgICAgICAgICAgICAgLmdldCh1cmwpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSl7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jb252ZXJ0IHRvIEpTT05cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YS5kYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZXh0JywgZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICAvL2dldCB0eXBlIGFuZCBwb3NzaWJseSBjb252ZXJ0XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChleHQudG9Mb3dlckNhc2UoKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcG9qc29uJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwYXJhbXMgfHwgZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGNvbnZlcnRUb3BvKGRhdGEsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvbnZlcnRlZCB0byB0b3BvJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dlb2pzb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZ2VvSlNPTic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2pzb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHR5cGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vc2F2ZSBpbiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcmF3RGF0YSA9IGRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9yZXNvbHZlIChjaGFpbmFibGUpXG4gICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoc2VsZik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9sb2FkIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBpc0xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB9LGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yIHJldHJpZXZpbmcgbWFwIGRhdGEnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZGF0YSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiByYXdEYXRhO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oeiwgZmVhdHVyZSl7XG5cbiAgICAgICAgaWYoeiBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgICAgICAgIHJldHVybiB6KGZlYXR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIElPLnRvb2xzLnBhcnNlSGVpZ2h0KHopO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdmFyIGxvYWRGZWF0dXJlID0gZnVuY3Rpb24ocHJvamVjdGlvbiwgY29vcmRpbmF0ZXMsIHosIHBvbHlnb24pe1xuXG4gICAgICAgIHZhciBwYXRoID0gW107XG5cbiAgICAgICAgLy9wb2x5Z29uIGZpeFxuICAgICAgICBpZihwb2x5Z29uKXtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXNbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvL2xvb3AgdGhyb3VnaCBjb29yZGluYXRlc1xuICAgICAgICBjb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGNvb3JkaW5hdGUpe1xuXG4gICAgICAgICAgICAvL2NoZWNrIGZvciBqdW5rXG4gICAgICAgICAgICBpZihjb29yZGluYXRlWzBdICE9PSAwICYmIGNvb3JkaW5hdGVbMV0gIT09IDApe1xuXG4gICAgICAgICAgICAgICAgdmFyIHYyID0gcHJvamVjdGlvbi50cmFuc2xhdGUzRChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdKTtcblxuICAgICAgICAgICAgICAgIC8vIFB1c2ggcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKCB2Mi54LCB2Mi55LCBnZXRIZWlnaHQoeikgKSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcblxuICAgIH07XG5cbiAgICB0aGlzLmdldERhdGEgPSBmdW5jdGlvbigpe1xuXG4gICAgICAgIC8vZGV0ZXJtaW5lIHdoYXQgdG8gcmV0dXJuXG4gICAgICAgIHN3aXRjaCh0eXBlKXtcblxuICAgICAgICAgICAgY2FzZSAnZ2VvSlNPTic6XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBJTy5jbGFzc2VzLkNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnBhcnNlKHJhd0RhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZ2VvR3JpZCc6XG4gICAgICAgICAgICBjYXNlICdpbWFnZSc6XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY2xpZW50L2NsYXNzZXMvbWFwMi5qc1wiLFwiL2NsaWVudC9jbGFzc2VzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih3b3JsZCl7XG5cblx0Ly9pbml0XG5cdC8vIHZhciBwcm9qZWN0b3IgPSBuZXcgVEhSRUUuUHJvamVjdG9yKCk7XG5cdHZhciBjbGlja2FibGUgPSBbXTtcblx0dmFyIGVsZW1lbnQgPSB3b3JsZC5yZW5kZXJlci5kb21FbGVtZW50O1xuXG5cdC8vbGlzdGVuIHRvIGNsaWNrIGV2ZW50XG5cdHZhciBjbGlja0V2dCA9IGZ1bmN0aW9uKGV2dCl7XG5cblx0XHQvL3RyYW5zbGF0ZSBtb3VzZSBZIHZhbHVlXG5cdFx0dmFyIHRvcCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG5cdFx0dmFyIHkgPSBldnQuY2xpZW50WSAtIHRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuXG5cdFx0Ly90cmFuc2xhdGUgbW91c2UgdG8gVmVjdG9yXG5cdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuXHRcdFx0KCBldnQuY2xpZW50WCAvIHdpbmRvdy5pbm5lcldpZHRoICkgKiAyIC0gMSxcblx0XHRcdC0gKCB5IC8gd2luZG93LmlubmVySGVpZ2h0ICkgKiAyICsgMSxcblx0XHRcdDAuNVxuXHRcdCk7XG5cblx0XHQvL2dldCBvYmplY3RzIGluIHJheVxuXHRcdHZlY3Rvci51bnByb2plY3QoIHdvcmxkLmNhbWVyYSApO1xuXHRcdHZhciByYXkgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKCB3b3JsZC5jYW1lcmEucG9zaXRpb24sIHZlY3Rvci5zdWIoIHdvcmxkLmNhbWVyYS5wb3NpdGlvbiApLm5vcm1hbGl6ZSgpICk7XG5cdFx0dmFyIGludGVyc2VjdHMgPSByYXkuaW50ZXJzZWN0T2JqZWN0cyggY2xpY2thYmxlICk7XG5cblx0XHRpZiAoIGludGVyc2VjdHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dmFyIGludGVyc2VjdGlvbiA9IGludGVyc2VjdHNbMF07XG5cdFx0XHR2YXIgb2JqZWN0ID0gaW50ZXJzZWN0aW9uLm9iamVjdDtcblxuXHRcdFx0Ly9nZXQgZ2VvIGNvb3JkaW5hdGVcblx0XHRcdHZhciBjbGlja2VkID0gaW50ZXJzZWN0aW9uLnBvaW50O1xuXHRcdFx0aW50ZXJzZWN0aW9uLmdlbyA9IHdvcmxkLnByb2plY3Rpb24ucmV2ZXJzZShjbGlja2VkKTtcblxuXHRcdFx0Ly8gYWxlcnQoJ2NsaWNrZWQgYXQgJyArIGdlb1swXSArICcsICcgKyBnZW9bMV0pO1xuXG5cdFx0XHQvL2NsaWNrIGV2ZW50XG5cdFx0XHRpZihvYmplY3Qub25DbGljayl7XG5cdFx0XHRcdG9iamVjdC5vbkNsaWNrKGludGVyc2VjdGlvbik7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tFdnQpO1xuXG5cdHRoaXMuYWRkU3BvdCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrKXtcblxuXHRcdC8vY2xpY2tcblx0XHRpZihjYWxsYmFjayl7XG5cdFx0XHRlbGVtZW50Lm9uQ2xpY2sgPSBjYWxsYmFjaztcblx0XHR9XG5cblx0XHRjbGlja2FibGUucHVzaChlbGVtZW50KTtcblx0fTtcblxuXHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuXHRcdGNsaWNrYWJsZSA9IHVuZGVmaW5lZDtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgY2xpY2tFdnQsIGZhbHNlKTtcblx0fTtcblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQvY2xhc3Nlcy9tb3VzZS5qc1wiLFwiL2NsaWVudC9jbGFzc2VzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcbnZhciBkMyA9IHJlcXVpcmUoJ2QzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2VudGVyLCB6b29tKXtcblxuICAgIC8vdG9kbyBzd2l0Y2ggYmV0d2VlbiBwcm9qZWN0aW9ucyBbZ2xvYmUgLSBtYXBdXG5cblx0em9vbSA9IHpvb20gfHwgMjA7XG5cblx0Ly9jcmVhdGUgZDMgcHJvamVjdGlvblxuXHR2YXIgcHJvamVjdGlvbiA9IGQzLmdlby5tZXJjYXRvcigpXG5cdFx0XHQuc2NhbGUoTWF0aC5wb3coMix6b29tKSlcblx0XHRcdC5jZW50ZXIoY2VudGVyKTtcblxuXHR0aGlzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGxhdCwgbG9uKXtcblx0XHRyZXR1cm4gcHJvamVjdGlvbihbbGF0LCBsb25dKTtcblx0fTtcblxuXHR0aGlzLnRyYW5zbGF0ZTNEID0gZnVuY3Rpb24obGF0LCBsb24pe1xuXHRcdHZhciBjb29yZHMgPSBwcm9qZWN0aW9uKFtsYXQsIGxvbl0pO1xuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihjb29yZHNbMF0sIGNvb3Jkc1sxXSk7XG5cdH07XG5cblx0dGhpcy5yZXZlcnNlID0gZnVuY3Rpb24odmVjMyl7XG5cblx0XHQvL3JldmVyc2UgdGhyb3VnaCBwcm9qZWN0aW9uXG5cdFx0cmV0dXJuIHByb2plY3Rpb24uaW52ZXJ0KFt2ZWMzLngsdmVjMy55XSk7XG5cblx0fTtcblxuXHQvL21ha2UgcHVibGljLCBtYXliZSBuZWVkZWRcblx0dGhpcy5kMyA9IHByb2plY3Rpb247XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY2xpZW50L2NsYXNzZXMvcHJvamVjdGlvbi5qc1wiLFwiL2NsaWVudC9jbGFzc2VzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuXG5cdHZhciBsaXN0ID0gW107XG5cdHZhciBlbmQgPSBmYWxzZTtcblx0dmFyIGNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7XG5cblx0dGhpcy5hZGQgPSBmdW5jdGlvbihmbil7XG5cblx0XHR2YXIgaWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0bGlzdC5wdXNoKHtcblx0XHRcdCd0YXNrJzogZm4sXG5cdFx0XHQnaWQnOiBpZFxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGlkO1xuXHR9O1xuXG5cdHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oaWQpe1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwIDsgaSA8IGxpc3QubGVuZ3RoIDsgaSsrICl7XG5cbiAgICAgICAgICAgIGlmKCBsaXN0W2ldLmlkID09PSBpZCl7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgICAgICBsaXN0ID0gW107XG5cdFx0Y2xvY2suc3RvcCgpO1xuICAgIH07XG5cblx0dmFyIHJlbmRlciA9IGZ1bmN0aW9uKCl7XG5cblx0XHQvL3N0b3Agd2hlbiBuZWVkZWRcbiAgICAgICAgaWYoZW5kKSB7XG4gICAgICAgICAgICBlbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2hlZHVsZSBuZXh0IGZyYW1lIFtUT0RPIGFkZCBzaGltXVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJlbmRlciApO1xuXG4gICAgICAgIC8vZGVsdGFcbiAgICAgICAgdmFyIGRlbHRhID0gY2xvY2suZ2V0RGVsdGEoKTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMCA7IGkgPCBsaXN0Lmxlbmd0aCA7IGkrKyApe1xuXG4gICAgICAgICAgICBsaXN0W2ldLnRhc2soZGVsdGEpO1xuXG4gICAgICAgIH1cblxuXHR9O1xuXG5cdHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpe1xuXHRcdGVuZCA9IGZhbHNlO1xuICAgICAgICByZW5kZXIoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdG9wID0gZnVuY3Rpb24oY2xlYXIpe1xuICAgICAgICBlbmQgPSB0cnVlO1xuXG5cdFx0aWYoY2xlYXIpe1xuXHRcdFx0dGhpcy5jbGVhcigpO1xuXHRcdH1cbiAgICB9O1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9jbGFzc2VzL3JlbmRlci1tYW5hZ2VyLmpzXCIsXCIvY2xpZW50L2NsYXNzZXNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNhbnZhcywgcHJvamVjdGlvbiwgRlhsaXN0KXtcblxuXHR2YXIgcGF1c2UgPSB0cnVlO1xuXHR2YXIgd29ybGQgPSB0aGlzO1xuXG5cdC8vY3JlYXRlIHByb2plY3Rpb25cblx0dGhpcy5wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcblxuXHQvL1NldHVwIHJlbmRlcmVyIGFuZCBjYW1lcmFzXG5cdElPLnRvb2xzLmNyZWF0ZVRocmVlLmNhbGwodGhpcywgY2FudmFzKTtcblxuXHQvL2dldCBtb3VzZSBwb3NpdGlvbnNcblx0dGhpcy5tb3VzZSA9IG5ldyBJTy5jbGFzc2VzLk1vdXNlKHRoaXMpO1xuXG5cdC8vc2V0dXAgZ2VvXG5cdHRoaXMuY2FtZXJhLnNldFByb2plY3Rpb24odGhpcy5wcm9qZWN0aW9uKTtcblxuXHQvL2FkZCBGWFxuXHR0aGlzLkZYID0gbmV3IElPLmNsYXNzZXMuRlgodGhpcy5yZW5kZXJlciwgdGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMpO1xuXG5cdC8vYWRkIEZYIGZyb20gbGlzdFxuXHRGWGxpc3QgPSBGWGxpc3QgfHwgW107XG5cdGZvciggdmFyIGkgPSAwIDsgaSA8IEZYbGlzdC5sZW5ndGggOyBpKysgKXtcblx0XHR0aGlzLkZYLmFkZChGWGxpc3RbaV0pO1xuXHR9XG5cblx0Ly90cmlnZ2VyIGFwcGx5aW5nIEZYXG5cdHRoaXMuRlhcblx0XHQuYWRkKCdGWEFBJylcblx0XHQuYWRkKCdjb3B5U2hhZGVyJylcblx0XHQucmVzaXplKCk7XG5cblx0Ly9wcmV2ZW50IHNob3dpbmcgYmVmb3JlIHBsYXlpbmdcblx0Y2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuXHQvL2FkZCBsaXN0XG5cdHRoaXMucmVuZGVyID0gbmV3IElPLmNsYXNzZXMuUmVuZGVyTWFuYWdlcigpO1xuXG5cdC8vYWRkIHRvIHRoZSBsaXN0IG9mIHJlbmRlcmFibGUgZnVuY3Rpb25cblx0dGhpcy5yZW5kZXIuYWRkKHRoaXMuY2FtZXJhLnJlbmRlciwgdGhpcy5jYW1lcmEucGF1c2UpO1xuXHR0aGlzLnJlbmRlci5hZGQodGhpcy5GWC5yZW5kZXIpO1xuXHQvLyB0aGlzLnJlbmRlci5hZGQodGhpcy5yZW5kZXJlci5yZW5kZXIpO1xuXG5cdC8vYWRkIHByZWxvYWRlclxuXHR0aGlzLnByZWxvYWRlciA9IG5ldyBJTy5jbGFzc2VzLkxvYWRlcigpO1xuXG5cdC8vc2hvcnRjdXQgdG8gcHJlbG9hZGVyXG5cdHRoaXMubG9hZCA9IGZ1bmN0aW9uKGxpc3Qpe1xuXG5cdFx0cmV0dXJuIHRoaXMucHJlbG9hZGVyXG5cdFx0XHQuYWRkKGxpc3QpXG5cdFx0XHQuc3RhcnQoKTtcblxuXHR9XG5cblx0Ly9wbGF5YmFjayBjb250cm9sc1xuXHR0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKXtcblxuXHRcdGNvbnNvbGUubG9nKCdzdGFydCcsIHRoaXMuc2NlbmUpO1xuXG5cdFx0dmFyIHN0YXJ0UmVuZGVyID0gcGF1c2U7XG5cdFx0Y2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG5cdFx0cGF1c2UgPSBmYWxzZTtcblxuXHRcdGlmKHN0YXJ0UmVuZGVyKXtcblx0XHRcdHdvcmxkLnJlbmRlci5zdGFydCgpO1xuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuc3RvcCA9IGZ1bmN0aW9uKCl7XG5cdFx0cGF1c2UgPSB0cnVlO1xuXHRcdHdvcmxkLnJlbmRlci5zdG9wKCk7XG5cdH07XG5cblx0Ly9yZXNpemVcblx0dmFyIHJlc2l6ZSA9IGZ1bmN0aW9uKCl7XG5cblx0XHR2YXIgdyA9IHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudC5vZmZzZXRXaWR0aDtcblx0XHR2YXIgaCA9IHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cblx0XHR0aGlzLnJlbmRlcmVyLnNldFNpemUoIHcsIGggKTtcblx0XHR0aGlzLmNhbWVyYS5hc3BlY3QgPSB3IC8gaDtcblx0XHR0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0dGhpcy5GWC5yZXNpemUodywgaCk7XG5cblx0fS5iaW5kKHRoaXMpO1xuXG5cdC8vZGVzdHJveSB3ZWJHTCBidWZmZXJzIGFuZCBtZW1vcnlcblx0dmFyIGRlc3Ryb3lXZWJHTCA9IGZ1bmN0aW9uKCl7XG5cblx0XHQvL2Rlc3Ryb3kgV2ViR0wgdGhpbmdpZXNcblx0XHRJTy50b29scy5kZXN0cm95R3JvdXAodGhpcy5ncm91cCwgdGhpcy5zY2VuZSk7XG5cdFx0dGhpcy5yZW5kZXJlci5jbGVhcigpO1xuXHRcdHRoaXMuRlguZGVzdHJveSgpO1xuXHRcdHRoaXMubW91c2UuZGVzdHJveSgpO1xuXHRcdHRoaXMuRlggPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jYW1lcmEgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5zY2VuZSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmdyb3VwID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMubW91c2UgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5yZW5kZXIgPSB1bmRlZmluZWQ7XG5cblx0XHQvL3JlbW92ZSBET00gZWxlbWVudFxuXHRcdHZhciBlbGVtID0gdGhpcy5yZW5kZXJlci5kb21FbGVtZW50O1xuXHRcdGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtKTtcblxuXHRcdHdvcmxkID0gdW5kZWZpbmVkO1xuXG5cdH0uYmluZCh0aGlzKTtcblxuXHQvL2V2ZW50c1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplLCBmYWxzZSApO1xuXG5cdC8vbWFrZSBzdXJlIGV2ZW50IGxpc3RlbmVycyBhcmUgZGVzdHJveWVkXG5cdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG5cdFx0d29ybGQucmVuZGVyLnN0b3AodHJ1ZSk7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSwgZmFsc2UpO1xuXHRcdGRlc3Ryb3lXZWJHTCgpO1xuXHR9O1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9jbGFzc2VzL3dvcmxkLmpzXCIsXCIvY2xpZW50L2NsYXNzZXNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vL3JlYWQgYWxsIGZvbGRlcnNcbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgJ2NsYXNzZXMnOiB7XG5cbiAgICAgICAgLy9pc29tb3JwaGljIChzaGFyZWQpXG4gICAgICAgICdHZW8nOiByZXF1aXJlKCcuLi9pc29tb3JwaGljL2NsYXNzZXMvZ2VvLmpzJyksXG4gICAgICAgICdGZWF0dXJlJzogcmVxdWlyZSgnLi4vaXNvbW9ycGhpYy9jbGFzc2VzL2dlby5qcycpLFxuICAgICAgICAnQ29sbGVjdGlvbic6IHJlcXVpcmUoJy4uL2lzb21vcnBoaWMvY2xhc3Nlcy9jb2xsZWN0aW9uLmpzJyksXG5cbiAgICAgICAgLy9jbGllbnQgb25seVxuICAgICAgICAnV29ybGQnOiByZXF1aXJlKCcuL2NsYXNzZXMvd29ybGQuanMnKSxcbiAgICAgICAgJ1JlbmRlck1hbmFnZXInOiByZXF1aXJlKCcuL2NsYXNzZXMvcmVuZGVyLW1hbmFnZXIuanMnKSxcbiAgICAgICAgJ1Byb2plY3Rpb24nOiByZXF1aXJlKCcuL2NsYXNzZXMvcHJvamVjdGlvbi5qcycpLFxuICAgICAgICAnQm91bmRpbmdCb3gnOiByZXF1aXJlKCcuL2NsYXNzZXMvYm91bmRpbmdib3guanMnKSxcbiAgICAgICAgJ01hcCc6IHJlcXVpcmUoJy4vY2xhc3Nlcy9tYXAyLmpzJyksXG4gICAgICAgICdMb2FkZXInOiByZXF1aXJlKCcuL2NsYXNzZXMvbG9hZGVyLmpzJyksXG4gICAgICAgICdMYXllcjNEJzogcmVxdWlyZSgnLi9jbGFzc2VzL2xheWVyM2QuanMnKSxcbiAgICAgICAgJ0ZYJzogcmVxdWlyZSgnLi9jbGFzc2VzL2Z4LmpzJyksXG4gICAgICAgICdHZW9DYW1lcmEnOiByZXF1aXJlKCcuL2NsYXNzZXMvZ2VvLWNhbWVyYS5qcycpLFxuICAgICAgICAnQW5pbWF0aW9uJzogcmVxdWlyZSgnLi9jbGFzc2VzL2FuaW1hdGlvbi5qcycpLFxuICAgICAgICAnTW91c2UnOiByZXF1aXJlKCcuL2NsYXNzZXMvbW91c2UuanMnKSxcbiAgICAgICAgJ0NvbXBhc3MnOiByZXF1aXJlKCcuL2NsYXNzZXMvY29tcGFzcy5qcycpXG5cbiAgICB9LFxuXG4gICAgJ3Rvb2xzJzoge1xuXG4gICAgICAgICdhY3Rpb25FeHRlbmQnOiByZXF1aXJlKCcuL3Rvb2xzL2FjdGlvbi1leHRlbmQuanMnKSxcbiAgICAgICAgJ2NyZWF0ZVRocmVlJzogcmVxdWlyZSgnLi90b29scy9jcmVhdGUtdGhyZWUuanMnKSxcbiAgICAgICAgJ2Rlc3Ryb3lHcm91cCc6IHJlcXVpcmUoJy4vdG9vbHMvZGVzdHJveS1ncm91cC5qcycpLFxuICAgICAgICAnbGVycDMnOiByZXF1aXJlKCcuL3Rvb2xzL2xlcnAtM2QuanMnKSxcbiAgICAgICAgJ21lcmdlTWFwcyc6IHJlcXVpcmUoJy4vdG9vbHMvbWVyZ2UtbWFwcy5qcycpLFxuICAgICAgICAncGFyc2VIZWlnaHQnOiByZXF1aXJlKCcuL3Rvb2xzL3BhcnNlLWhlaWdodC5qcycpLFxuXG4gICAgfSxcblxuICAgICdidWlsZCc6IHtcblxuICAgICAgICAncm9hZHMnOiByZXF1aXJlKCcuL2J1aWxkL3JvYWRzLmpzJyksXG4gICAgICAgICdidWlsZGluZ3MnOiByZXF1aXJlKCcuL2J1aWxkL2J1aWxkaW5ncy5qcycpLFxuICAgICAgICAnYXJlYXMnOiByZXF1aXJlKCcuL2J1aWxkL2FyZWFzLmpzJylcblxuICAgIH0sXG5cbiAgICAnRlhsaWInOiB7XG5cbiAgICAgICAgJ2NvcHlTaGFkZXInOiByZXF1aXJlKCcuL3Rvb2xzL2Z4L2NvcHktc2hhZGVyLmpzJyksXG4gICAgICAgICdmaWxtR3JhaW4nOiByZXF1aXJlKCcuL3Rvb2xzL2Z4L2ZpbG0tZ3JhaW4uanMnKSxcbiAgICAgICAgJ0ZYQUEnOiByZXF1aXJlKCcuL3Rvb2xzL2Z4L2Z4YWEuanMnKSxcbiAgICAgICAgJ3RpbHRTaGlmdCc6IHJlcXVpcmUoJy4vdG9vbHMvZngvdGlsdC1zaGlmdC5qcycpXG5cbiAgICB9XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY2xpZW50L2luZGV4LmpzXCIsXCIvY2xpZW50XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0dW5pZm9ybXM6IHtcblxuXHRcdFwidERpZmZ1c2VcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcIm9wYWNpdHlcIjogIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxuXG5cdH0sXG5cblx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2VXYgPSB1djtcIixcblx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIiksXG5cblx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcInZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gb3BhY2l0eSAqIHRleGVsO1wiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIilcblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQvbGliL2NvcHktc2hhZGVyLmpzXCIsXCIvY2xpZW50L2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xudmFyIFNoYWRlclBhc3MgPSByZXF1aXJlKCcuL3NoYWRlci1wYXNzLmpzJyk7XG52YXIgQ29weVNoYWRlciA9IHJlcXVpcmUoJy4vY29weS1zaGFkZXIuanMnKTtcblxudmFyIEVmZmVjdENvbXBvc2VyID0gZnVuY3Rpb24gKCByZW5kZXJlciwgcmVuZGVyVGFyZ2V0ICkge1xuXG5cdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuXHRpZiAoIHJlbmRlclRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0dmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgMTtcblx0XHR2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IDE7XG5cdFx0dmFyIHBhcmFtZXRlcnMgPSB7IG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgZm9ybWF0OiBUSFJFRS5SR0JGb3JtYXQsIHN0ZW5jaWxCdWZmZXI6IGZhbHNlIH07XG5cblx0XHRyZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0dGhpcy5yZW5kZXJUYXJnZXQxID0gcmVuZGVyVGFyZ2V0O1xuXHR0aGlzLnJlbmRlclRhcmdldDIgPSByZW5kZXJUYXJnZXQuY2xvbmUoKTtcblxuXHR0aGlzLndyaXRlQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXQxO1xuXHR0aGlzLnJlYWRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDI7XG5cblx0dGhpcy5wYXNzZXMgPSBbXTtcblxuXHRpZiAoIENvcHlTaGFkZXIgPT09IHVuZGVmaW5lZCApXG5cdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5FZmZlY3RDb21wb3NlciByZWxpZXMgb24gVEhSRUUuQ29weVNoYWRlclwiICk7XG5cblx0dGhpcy5jb3B5UGFzcyA9IG5ldyBTaGFkZXJQYXNzKCBDb3B5U2hhZGVyICk7XG5cbn07XG5cbkVmZmVjdENvbXBvc2VyLnByb3RvdHlwZSA9IHtcblxuXHRzd2FwQnVmZmVyczogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdG1wID0gdGhpcy5yZWFkQnVmZmVyO1xuXHRcdHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMud3JpdGVCdWZmZXI7XG5cdFx0dGhpcy53cml0ZUJ1ZmZlciA9IHRtcDtcblxuXHR9LFxuXG5cdGFkZFBhc3M6IGZ1bmN0aW9uICggcGFzcyApIHtcblxuXHRcdHRoaXMucGFzc2VzLnB1c2goIHBhc3MgKTtcblxuXHR9LFxuXG5cdGluc2VydFBhc3M6IGZ1bmN0aW9uICggcGFzcywgaW5kZXggKSB7XG5cblx0XHR0aGlzLnBhc3Nlcy5zcGxpY2UoIGluZGV4LCAwLCBwYXNzICk7XG5cblx0fSxcblxuXHRyZW5kZXI6IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cblx0XHR0aGlzLndyaXRlQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXQxO1xuXHRcdHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MjtcblxuXHRcdHZhciBtYXNrQWN0aXZlID0gZmFsc2U7XG5cblx0XHR2YXIgcGFzcywgaSwgaWwgPSB0aGlzLnBhc3Nlcy5sZW5ndGg7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRwYXNzID0gdGhpcy5wYXNzZXNbIGkgXTtcblxuXHRcdFx0aWYgKCAhcGFzcy5lbmFibGVkICkgY29udGludWU7XG5cblx0XHRcdHBhc3MucmVuZGVyKCB0aGlzLnJlbmRlcmVyLCB0aGlzLndyaXRlQnVmZmVyLCB0aGlzLnJlYWRCdWZmZXIsIGRlbHRhLCBtYXNrQWN0aXZlICk7XG5cblx0XHRcdGlmICggcGFzcy5uZWVkc1N3YXAgKSB7XG5cblx0XHRcdFx0aWYgKCBtYXNrQWN0aXZlICkge1xuXG5cdFx0XHRcdFx0dmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQ7XG5cblx0XHRcdFx0XHRjb250ZXh0LnN0ZW5jaWxGdW5jKCBjb250ZXh0Lk5PVEVRVUFMLCAxLCAweGZmZmZmZmZmICk7XG5cblx0XHRcdFx0XHR0aGlzLmNvcHlQYXNzLnJlbmRlciggdGhpcy5yZW5kZXJlciwgdGhpcy53cml0ZUJ1ZmZlciwgdGhpcy5yZWFkQnVmZmVyLCBkZWx0YSApO1xuXG5cdFx0XHRcdFx0Y29udGV4dC5zdGVuY2lsRnVuYyggY29udGV4dC5FUVVBTCwgMSwgMHhmZmZmZmZmZiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnN3YXBCdWZmZXJzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9DVVNUT00gW2J1ZyBmaXgsIHRvIHByZXZlbnQgZXJyb3JzXVxuXHRcdFx0Ly8gaWYgKCBwYXNzIGluc3RhbmNlb2YgVEhSRUUuTWFza1Bhc3MgKSB7XG5cdFx0XHQvL1xuXHRcdFx0Ly8gXHRtYXNrQWN0aXZlID0gdHJ1ZTtcblx0XHRcdC8vXG5cdFx0XHQvLyB9IGVsc2UgaWYgKCBwYXNzIGluc3RhbmNlb2YgVEhSRUUuQ2xlYXJNYXNrUGFzcyApIHtcblx0XHRcdC8vXG5cdFx0XHQvLyBcdG1hc2tBY3RpdmUgPSBmYWxzZTtcblx0XHRcdC8vXG5cdFx0XHQvLyB9XG5cblx0XHR9XG5cblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDEuY2xvbmUoKTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cdFx0XHRyZW5kZXJUYXJnZXQuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXQxID0gcmVuZGVyVGFyZ2V0O1xuXHRcdHRoaXMucmVuZGVyVGFyZ2V0MiA9IHJlbmRlclRhcmdldC5jbG9uZSgpO1xuXG5cdFx0dGhpcy53cml0ZUJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MTtcblx0XHR0aGlzLnJlYWRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDI7XG5cblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQxLmNsb25lKCk7XG5cblx0XHRyZW5kZXJUYXJnZXQud2lkdGggPSB3aWR0aDtcblx0XHRyZW5kZXJUYXJnZXQuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0dGhpcy5yZXNldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVmZmVjdENvbXBvc2VyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9saWIvZWZmZWN0LWNvbXBvc2VyLmpzXCIsXCIvY2xpZW50L2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xudmFyIEZpbG1TaGFkZXIgPSByZXF1aXJlKCcuL2ZpbG0tc2hhZGVyLmpzJyk7XG5cbnZhciBGaWxtUGFzcyA9IGZ1bmN0aW9uICggbm9pc2VJbnRlbnNpdHksIHNjYW5saW5lc0ludGVuc2l0eSwgc2NhbmxpbmVzQ291bnQsIGdyYXlzY2FsZSApIHtcblxuXHRpZiAoIEZpbG1TaGFkZXIgPT09IHVuZGVmaW5lZCApXG5cdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5GaWxtUGFzcyByZWxpZXMgb24gVEhSRUUuRmlsbVNoYWRlclwiICk7XG5cblx0dmFyIHNoYWRlciA9IEZpbG1TaGFkZXI7XG5cblx0dGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApO1xuXG5cdHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcblxuXHRcdHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuXHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyXG5cblx0fSApO1xuXG5cdGlmICggZ3JheXNjYWxlICE9PSB1bmRlZmluZWQgKVx0dGhpcy51bmlmb3Jtcy5ncmF5c2NhbGUudmFsdWUgPSBncmF5c2NhbGU7XG5cdGlmICggbm9pc2VJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIHRoaXMudW5pZm9ybXMubkludGVuc2l0eS52YWx1ZSA9IG5vaXNlSW50ZW5zaXR5O1xuXHRpZiAoIHNjYW5saW5lc0ludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgdGhpcy51bmlmb3Jtcy5zSW50ZW5zaXR5LnZhbHVlID0gc2NhbmxpbmVzSW50ZW5zaXR5O1xuXHRpZiAoIHNjYW5saW5lc0NvdW50ICE9PSB1bmRlZmluZWQgKSB0aGlzLnVuaWZvcm1zLnNDb3VudC52YWx1ZSA9IHNjYW5saW5lc0NvdW50O1xuXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdHRoaXMucmVuZGVyVG9TY3JlZW4gPSBmYWxzZTtcblx0dGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xuXG5cblx0dGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCAtMSwgMSwgMSwgLTEsIDAsIDEgKTtcblx0dGhpcy5zY2VuZSAgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuXHR0aGlzLnF1YWQgPSBuZXcgVEhSRUUuTWVzaCggbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoIDIsIDIgKSwgbnVsbCApO1xuXHR0aGlzLnNjZW5lLmFkZCggdGhpcy5xdWFkICk7XG5cbn07XG5cbkZpbG1QYXNzLnByb3RvdHlwZSA9IHtcblxuXHRyZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcblxuXHRcdHRoaXMudW5pZm9ybXNbIFwidERpZmZ1c2VcIiBdLnZhbHVlID0gcmVhZEJ1ZmZlcjtcblx0XHR0aGlzLnVuaWZvcm1zWyBcInRpbWVcIiBdLnZhbHVlICs9IGRlbHRhO1xuXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuXHRcdGlmICggdGhpcy5yZW5kZXJUb1NjcmVlbiApIHtcblxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCB0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCB0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgd3JpdGVCdWZmZXIsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbG1QYXNzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9saWIvZmlsbS1wYXNzLmpzXCIsXCIvY2xpZW50L2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInREaWZmdXNlXCI6ICAgeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcInRpbWVcIjogICAgICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMCB9LFxuXHRcdFwibkludGVuc2l0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC41IH0sXG5cdFx0XCJzSW50ZW5zaXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjA1IH0sXG5cdFx0XCJzQ291bnRcIjogICAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiA0MDk2IH0sXG5cdFx0XCJncmF5c2NhbGVcIjogIHsgdHlwZTogXCJpXCIsIHZhbHVlOiAxIH1cblxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidlV2ID0gdXY7XCIsXG5cdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHQvLyBjb250cm9sIHBhcmFtZXRlclxuXHRcdFwidW5pZm9ybSBmbG9hdCB0aW1lO1wiLFxuXG5cdFx0XCJ1bmlmb3JtIGJvb2wgZ3JheXNjYWxlO1wiLFxuXG5cdFx0Ly8gbm9pc2UgZWZmZWN0IGludGVuc2l0eSB2YWx1ZSAoMCA9IG5vIGVmZmVjdCwgMSA9IGZ1bGwgZWZmZWN0KVxuXHRcdFwidW5pZm9ybSBmbG9hdCBuSW50ZW5zaXR5O1wiLFxuXG5cdFx0Ly8gc2NhbmxpbmVzIGVmZmVjdCBpbnRlbnNpdHkgdmFsdWUgKDAgPSBubyBlZmZlY3QsIDEgPSBmdWxsIGVmZmVjdClcblx0XHRcInVuaWZvcm0gZmxvYXQgc0ludGVuc2l0eTtcIixcblxuXHRcdC8vIHNjYW5saW5lcyBlZmZlY3QgY291bnQgdmFsdWUgKDAgPSBubyBlZmZlY3QsIDQwOTYgPSBmdWxsIGVmZmVjdClcblx0XHRcInVuaWZvcm0gZmxvYXQgc0NvdW50O1wiLFxuXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcblxuXHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHQvLyBzYW1wbGUgdGhlIHNvdXJjZVxuXHRcdFx0XCJ2ZWM0IGNUZXh0dXJlU2NyZWVuID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XCIsXG5cblx0XHRcdC8vIG1ha2Ugc29tZSBub2lzZVxuXHRcdFx0XCJmbG9hdCB4ID0gdlV2LnggKiB2VXYueSAqIHRpbWUgKiAgMTAwMC4wO1wiLFxuXHRcdFx0XCJ4ID0gbW9kKCB4LCAxMy4wICkgKiBtb2QoIHgsIDEyMy4wICk7XCIsXG5cdFx0XHRcImZsb2F0IGR4ID0gbW9kKCB4LCAwLjAxICk7XCIsXG5cblx0XHRcdC8vIGFkZCBub2lzZVxuXHRcdFx0XCJ2ZWMzIGNSZXN1bHQgPSBjVGV4dHVyZVNjcmVlbi5yZ2IgKyBjVGV4dHVyZVNjcmVlbi5yZ2IgKiBjbGFtcCggMC4xICsgZHggKiAxMDAuMCwgMC4wLCAxLjAgKTtcIixcblxuXHRcdFx0Ly8gZ2V0IHVzIGEgc2luZSBhbmQgY29zaW5lXG5cdFx0XHRcInZlYzIgc2MgPSB2ZWMyKCBzaW4oIHZVdi55ICogc0NvdW50ICksIGNvcyggdlV2LnkgKiBzQ291bnQgKSApO1wiLFxuXG5cdFx0XHQvLyBhZGQgc2NhbmxpbmVzXG5cdFx0XHRcImNSZXN1bHQgKz0gY1RleHR1cmVTY3JlZW4ucmdiICogdmVjMyggc2MueCwgc2MueSwgc2MueCApICogc0ludGVuc2l0eTtcIixcblxuXHRcdFx0Ly8gaW50ZXJwb2xhdGUgYmV0d2VlbiBzb3VyY2UgYW5kIHJlc3VsdCBieSBpbnRlbnNpdHlcblx0XHRcdFwiY1Jlc3VsdCA9IGNUZXh0dXJlU2NyZWVuLnJnYiArIGNsYW1wKCBuSW50ZW5zaXR5LCAwLjAsMS4wICkgKiAoIGNSZXN1bHQgLSBjVGV4dHVyZVNjcmVlbi5yZ2IgKTtcIixcblxuXHRcdFx0Ly8gY29udmVydCB0byBncmF5c2NhbGUgaWYgZGVzaXJlZFxuXHRcdFx0XCJpZiggZ3JheXNjYWxlICkge1wiLFxuXG5cdFx0XHRcdFwiY1Jlc3VsdCA9IHZlYzMoIGNSZXN1bHQuciAqIDAuMyArIGNSZXN1bHQuZyAqIDAuNTkgKyBjUmVzdWx0LmIgKiAwLjExICk7XCIsXG5cblx0XHRcdFwifVwiLFxuXG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9ICB2ZWM0KCBjUmVzdWx0LCBjVGV4dHVyZVNjcmVlbi5hICk7XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9saWIvZmlsbS1zaGFkZXIuanNcIixcIi9jbGllbnQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0dW5pZm9ybXM6IHtcblxuXHRcdFwidERpZmZ1c2VcIjogICB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwicmVzb2x1dGlvblwiOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxIC8gMTAyNCwgMSAvIDUxMiApICB9XG5cblx0fSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdC8vXCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdC8vIFwidlV2ID0gdXY7XCIsXG5cdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXHRcdFwidW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XCIsXG5cblx0XHQvL1widmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFwiI2RlZmluZSBGWEFBX1JFRFVDRV9NSU4gICAoMS4wLzEyOC4wKVwiLFxuXHRcdFwiI2RlZmluZSBGWEFBX1JFRFVDRV9NVUwgICAoMS4wLzguMClcIixcblx0XHRcIiNkZWZpbmUgRlhBQV9TUEFOX01BWCAgICAgOC4wXCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgKCBnbF9GcmFnQ29vcmQueHkgKyB2ZWMyKCAtMS4wLCAtMS4wICkgKSAqIHJlc29sdXRpb24gKS54eXo7XCIsXG5cdFx0XHRcInZlYzMgcmdiTkUgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCAoIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoIDEuMCwgLTEuMCApICkgKiByZXNvbHV0aW9uICkueHl6O1wiLFxuXHRcdFx0XCJ2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgKCBnbF9GcmFnQ29vcmQueHkgKyB2ZWMyKCAtMS4wLCAxLjAgKSApICogcmVzb2x1dGlvbiApLnh5ejtcIixcblx0XHRcdFwidmVjMyByZ2JTRSA9IHRleHR1cmUyRCggdERpZmZ1c2UsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggMS4wLCAxLjAgKSApICogcmVzb2x1dGlvbiApLnh5ejtcIixcblx0XHRcdFwidmVjNCByZ2JhTSAgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCAgZ2xfRnJhZ0Nvb3JkLnh5ICAqIHJlc29sdXRpb24gKTtcIixcblx0XHRcdFwidmVjMyByZ2JNICA9IHJnYmFNLnh5ejtcIixcblx0XHRcdFwiZmxvYXQgb3BhY2l0eSAgPSByZ2JhTS53O1wiLFxuXG5cdFx0XHRcInZlYzMgbHVtYSA9IHZlYzMoIDAuMjk5LCAwLjU4NywgMC4xMTQgKTtcIixcblxuXHRcdFx0XCJmbG9hdCBsdW1hTlcgPSBkb3QoIHJnYk5XLCBsdW1hICk7XCIsXG5cdFx0XHRcImZsb2F0IGx1bWFORSA9IGRvdCggcmdiTkUsIGx1bWEgKTtcIixcblx0XHRcdFwiZmxvYXQgbHVtYVNXID0gZG90KCByZ2JTVywgbHVtYSApO1wiLFxuXHRcdFx0XCJmbG9hdCBsdW1hU0UgPSBkb3QoIHJnYlNFLCBsdW1hICk7XCIsXG5cdFx0XHRcImZsb2F0IGx1bWFNICA9IGRvdCggcmdiTSwgIGx1bWEgKTtcIixcblx0XHRcdFwiZmxvYXQgbHVtYU1pbiA9IG1pbiggbHVtYU0sIG1pbiggbWluKCBsdW1hTlcsIGx1bWFORSApLCBtaW4oIGx1bWFTVywgbHVtYVNFICkgKSApO1wiLFxuXHRcdFx0XCJmbG9hdCBsdW1hTWF4ID0gbWF4KCBsdW1hTSwgbWF4KCBtYXgoIGx1bWFOVywgbHVtYU5FKSAsIG1heCggbHVtYVNXLCBsdW1hU0UgKSApICk7XCIsXG5cblx0XHRcdFwidmVjMiBkaXI7XCIsXG5cdFx0XHRcImRpci54ID0gLSgobHVtYU5XICsgbHVtYU5FKSAtIChsdW1hU1cgKyBsdW1hU0UpKTtcIixcblx0XHRcdFwiZGlyLnkgPSAgKChsdW1hTlcgKyBsdW1hU1cpIC0gKGx1bWFORSArIGx1bWFTRSkpO1wiLFxuXG5cdFx0XHRcImZsb2F0IGRpclJlZHVjZSA9IG1heCggKCBsdW1hTlcgKyBsdW1hTkUgKyBsdW1hU1cgKyBsdW1hU0UgKSAqICggMC4yNSAqIEZYQUFfUkVEVUNFX01VTCApLCBGWEFBX1JFRFVDRV9NSU4gKTtcIixcblxuXHRcdFx0XCJmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAoIG1pbiggYWJzKCBkaXIueCApLCBhYnMoIGRpci55ICkgKSArIGRpclJlZHVjZSApO1wiLFxuXHRcdFx0XCJkaXIgPSBtaW4oIHZlYzIoIEZYQUFfU1BBTl9NQVgsICBGWEFBX1NQQU5fTUFYKSxcIixcblx0XHRcdFx0ICBcIm1heCggdmVjMigtRlhBQV9TUEFOX01BWCwgLUZYQUFfU1BBTl9NQVgpLFwiLFxuXHRcdFx0XHRcdFx0XCJkaXIgKiByY3BEaXJNaW4pKSAqIHJlc29sdXRpb247XCIsXG5cblx0XHRcdFwidmVjMyByZ2JBID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgZ2xfRnJhZ0Nvb3JkLnh5ICAqIHJlc29sdXRpb24gKyBkaXIgKiAoIDEuMCAvIDMuMCAtIDAuNSApICkueHl6O1wiLFxuXHRcdFx0XCJyZ2JBICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIGdsX0ZyYWdDb29yZC54eSAgKiByZXNvbHV0aW9uICsgZGlyICogKCAyLjAgLyAzLjAgLSAwLjUgKSApLnh5ejtcIixcblx0XHRcdFwicmdiQSAqPSAwLjU7XCIsXG5cblx0XHRcdFwidmVjMyByZ2JCID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgZ2xfRnJhZ0Nvb3JkLnh5ICAqIHJlc29sdXRpb24gKyBkaXIgKiAtMC41ICkueHl6O1wiLFxuXHRcdFx0XCJyZ2JCICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIGdsX0ZyYWdDb29yZC54eSAgKiByZXNvbHV0aW9uICsgZGlyICogMC41ICkueHl6O1wiLFxuXHRcdFx0XCJyZ2JCICo9IDAuMjU7XCIsXG5cdFx0XHRcInJnYkIgKz0gcmdiQSAqIDAuNTtcIixcblxuXHRcdFx0XCJmbG9hdCBsdW1hQiA9IGRvdCggcmdiQiwgbHVtYSApO1wiLFxuXG5cdFx0XHRcImlmICggKCBsdW1hQiA8IGx1bWFNaW4gKSB8fCAoIGx1bWFCID4gbHVtYU1heCApICkge1wiLFxuXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggcmdiQSwgb3BhY2l0eSApO1wiLFxuXG5cdFx0XHRcIn0gZWxzZSB7XCIsXG5cblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCByZ2JCLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFwifVwiLFxuXG5cdFx0XCJ9XCJcblxuXHRdLmpvaW4oXCJcXG5cIilcblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQvbGliL2Z4YWEuanNcIixcIi9jbGllbnQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIFNpbXBsZSBmYWtlIHRpbHQtc2hpZnQgZWZmZWN0LCBtb2R1bGF0aW5nIHR3byBwYXNzIEdhdXNzaWFuIGJsdXIgKHNlZSBhYm92ZSkgYnkgdmVydGljYWwgcG9zaXRpb25cbiAqXG4gKiAtIDkgc2FtcGxlcyBwZXIgcGFzc1xuICogLSBzdGFuZGFyZCBkZXZpYXRpb24gMi43XG4gKiAtIFwiaFwiIGFuZCBcInZcIiBwYXJhbWV0ZXJzIHNob3VsZCBiZSBzZXQgdG8gXCIxIC8gd2lkdGhcIiBhbmQgXCIxIC8gaGVpZ2h0XCJcbiAqIC0gXCJyXCIgcGFyYW1ldGVyIGNvbnRyb2wgd2hlcmUgXCJmb2N1c2VkXCIgaG9yaXpvbnRhbCBsaW5lIGxpZXNcbiAqL1xuXG4vL2VkaXRlZCBmb3IgY2l0eWlvXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJoXCI6ICAgICAgICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIC8gNTEyLjAgfSxcblx0XHRcInJcIjogICAgICAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjM1IH0sXG5cdFx0XCJzcHJlYWRcIjogICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4yIH1cblxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidlV2ID0gdXY7XCIsXG5cdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBoO1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCByO1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBzcHJlYWQ7XCIsXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2ZWM0IHN1bSA9IHZlYzQoIDAuMCApO1wiLFxuXG5cdFx0XHRcImZsb2F0IGhoID0gaCAqIHBvdyggYWJzKCByIC0gdlV2LnkpICwgc3ByZWFkKTtcIixcblxuXHRcdFx0XCJzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggLSA0LjAgKiBoaCwgdlV2LnkgKSApICogMC4wNTE7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCAtIDMuMCAqIGhoLCB2VXYueSApICkgKiAwLjA5MTg7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCAtIDIuMCAqIGhoLCB2VXYueSApICkgKiAwLjEyMjQ1O1wiLFxuXHRcdFx0XCJzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggLSAxLjAgKiBoaCwgdlV2LnkgKSApICogMC4xNTMxO1wiLFxuXHRcdFx0XCJzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICkgKSAqIDAuMTYzMztcIixcblx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54ICsgMS4wICogaGgsIHZVdi55ICkgKSAqIDAuMTUzMTtcIixcblx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54ICsgMi4wICogaGgsIHZVdi55ICkgKSAqIDAuMTIyNDU7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCArIDMuMCAqIGhoLCB2VXYueSApICkgKiAwLjA5MTg7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCArIDQuMCAqIGhoLCB2VXYueSApICkgKiAwLjA1MTtcIixcblxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBzdW07XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9saWIvaG9yaXpvbnRhbC10aWx0LXNoaWZ0LXNoYWRlci5qc1wiLFwiL2NsaWVudC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xuXG52YXIgUmVuZGVyUGFzcyA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCwgY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApIHtcblxuXHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG5cdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0dGhpcy5jbGVhckNvbG9yID0gY2xlYXJDb2xvcjtcblx0dGhpcy5jbGVhckFscGhhID0gKCBjbGVhckFscGhhICE9PSB1bmRlZmluZWQgKSA/IGNsZWFyQWxwaGEgOiAxO1xuXG5cdHRoaXMub2xkQ2xlYXJDb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xuXHR0aGlzLm9sZENsZWFyQWxwaGEgPSAxO1xuXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdHRoaXMuY2xlYXIgPSB0cnVlO1xuXHR0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuXG59O1xuXG5SZW5kZXJQYXNzLnByb3RvdHlwZSA9IHtcblxuXHRyZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcblxuXHRcdHRoaXMuc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IHRoaXMub3ZlcnJpZGVNYXRlcmlhbDtcblxuXHRcdGlmICggdGhpcy5jbGVhckNvbG9yICkge1xuXG5cdFx0XHR0aGlzLm9sZENsZWFyQ29sb3IuY29weSggcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpICk7XG5cdFx0XHR0aGlzLm9sZENsZWFyQWxwaGEgPSByZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cblx0XHRcdHJlbmRlcmVyLnNldENsZWFyQ29sb3IoIHRoaXMuY2xlYXJDb2xvciwgdGhpcy5jbGVhckFscGhhICk7XG5cblx0XHR9XG5cblx0XHRyZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCByZWFkQnVmZmVyLCB0aGlzLmNsZWFyICk7XG5cblx0XHRpZiAoIHRoaXMuY2xlYXJDb2xvciApIHtcblxuXHRcdFx0cmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggdGhpcy5vbGRDbGVhckNvbG9yLCB0aGlzLm9sZENsZWFyQWxwaGEgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cblx0fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlclBhc3M7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY2xpZW50L2xpYi9yZW5kZXItcGFzcy5qc1wiLFwiL2NsaWVudC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxuU2hhZGVyUGFzcyA9IGZ1bmN0aW9uICggc2hhZGVyLCB0ZXh0dXJlSUQgKSB7XG5cblx0dGhpcy50ZXh0dXJlSUQgPSAoIHRleHR1cmVJRCAhPT0gdW5kZWZpbmVkICkgPyB0ZXh0dXJlSUQgOiBcInREaWZmdXNlXCI7XG5cblx0dGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApO1xuXG5cdHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcblxuXHRcdHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuXHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyXG5cblx0fSApO1xuXG5cdHRoaXMucmVuZGVyVG9TY3JlZW4gPSBmYWxzZTtcblxuXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XG5cdHRoaXMuY2xlYXIgPSBmYWxzZTtcblxuXG5cdHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggLTEsIDEsIDEsIC0xLCAwLCAxICk7XG5cdHRoaXMuc2NlbmUgID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cblx0dGhpcy5xdWFkID0gbmV3IFRIUkVFLk1lc2goIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KCAyLCAyICksIG51bGwgKTtcblx0dGhpcy5zY2VuZS5hZGQoIHRoaXMucXVhZCApO1xuXG59O1xuXG5TaGFkZXJQYXNzLnByb3RvdHlwZSA9IHtcblxuXHRyZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcblxuXHRcdGlmICggdGhpcy51bmlmb3Jtc1sgdGhpcy50ZXh0dXJlSUQgXSApIHtcblxuXHRcdFx0dGhpcy51bmlmb3Jtc1sgdGhpcy50ZXh0dXJlSUQgXS52YWx1ZSA9IHJlYWRCdWZmZXI7XG5cblx0XHR9XG5cblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXG5cdFx0aWYgKCB0aGlzLnJlbmRlclRvU2NyZWVuICkge1xuXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB3cml0ZUJ1ZmZlciwgdGhpcy5jbGVhciApO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaGFkZXJQYXNzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9saWIvc2hhZGVyLXBhc3MuanNcIixcIi9jbGllbnQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIFNpbXBsZSBmYWtlIHRpbHQtc2hpZnQgZWZmZWN0LCBtb2R1bGF0aW5nIHR3byBwYXNzIEdhdXNzaWFuIGJsdXIgKHNlZSBhYm92ZSkgYnkgdmVydGljYWwgcG9zaXRpb25cbiAqXG4gKiAtIDkgc2FtcGxlcyBwZXIgcGFzc1xuICogLSBzdGFuZGFyZCBkZXZpYXRpb24gMi43XG4gKiAtIFwiaFwiIGFuZCBcInZcIiBwYXJhbWV0ZXJzIHNob3VsZCBiZSBzZXQgdG8gXCIxIC8gd2lkdGhcIiBhbmQgXCIxIC8gaGVpZ2h0XCJcbiAqIC0gXCJyXCIgcGFyYW1ldGVyIGNvbnRyb2wgd2hlcmUgXCJmb2N1c2VkXCIgaG9yaXpvbnRhbCBsaW5lIGxpZXNcbiAqL1xuXG4vL2VkaXRlZCBmb3IgY2l0eWlvXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdHVuaWZvcm1zOiB7XG5cblx0XHRcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJ2XCI6ICAgICAgICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIC8gNTEyLjAgfSxcblx0XHRcInJcIjogICAgICAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjM1IH0sXG5cdFx0XCJzcHJlYWRcIjogICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4yIH1cblxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG5cdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwidlV2ID0gdXY7XCIsXG5cdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFwifVwiXG5cblx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCB2O1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCByO1wiLFxuXHRcdFwidW5pZm9ybSBmbG9hdCBzcHJlYWQ7XCIsXG5cblx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cblx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJ2ZWM0IHN1bSA9IHZlYzQoIDAuMCApO1wiLFxuXG5cdFx0XHRcImZsb2F0IHZ2ID0gdiAqIHBvdyggYWJzKCByIC0gdlV2LnkgKSAsc3ByZWFkKTtcIixcblxuXHRcdFx0XCJzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55IC0gNC4wICogdnYgKSApICogMC4wNTE7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSAzLjAgKiB2diApICkgKiAwLjA5MTg7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSAyLjAgKiB2diApICkgKiAwLjEyMjQ1O1wiLFxuXHRcdFx0XCJzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55IC0gMS4wICogdnYgKSApICogMC4xNTMxO1wiLFxuXHRcdFx0XCJzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICkgKSAqIDAuMTYzMztcIixcblx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSArIDEuMCAqIHZ2ICkgKSAqIDAuMTUzMTtcIixcblx0XHRcdFwic3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSArIDIuMCAqIHZ2ICkgKSAqIDAuMTIyNDU7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgKyAzLjAgKiB2diApICkgKiAwLjA5MTg7XCIsXG5cdFx0XHRcInN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgKyA0LjAgKiB2diApICkgKiAwLjA1MTtcIixcblxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBzdW07XCIsXG5cblx0XHRcIn1cIlxuXG5cdF0uam9pbihcIlxcblwiKVxuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC9saWIvdmVydGljYWwtdGlsdC1zaGlmdC1zaGFkZXIuanNcIixcIi9jbGllbnQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzb3VyY2UsIHByb3BzKSB7XG5cblx0dmFyIHJlcyA9IHNvdXJjZTtcblxuXHQvL2NyZWF0ZSBvcmlnaW5hbCBvYmplY3Rcblx0Ly8gZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcblx0Ly8gXHRyZXNbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG5cdC8vIH1cblxuXHQvL292ZXJ3cml0ZVxuXHRmb3IgKHZhciBwcm9wIGluIHByb3BzKSB7XG5cblx0XHQvL25ld1xuXHRcdGlmKCFyZXNbcHJvcF0pe1xuXHRcdFx0cmVzW3Byb3BdID0gcHJvcHNbcHJvcF07XG5cdFx0fVxuXG5cdFx0Ly9vdmVyd3JpdGVcblx0XHRlbHNlIHtcblxuXHRcdFx0Ly9maXJzdCB0aW1lXG5cdFx0XHRpZihyZXNbcHJvcF0gaW5zdGFuY2VvZiBGdW5jdGlvbil7XG5cdFx0XHRcdHJlc1twcm9wXSA9IFsgcmVzW3Byb3BdLCBwcm9wc1twcm9wXSBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2FkZCB0byBleGlzdGluZyBsaXN0XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmVzW3Byb3BdLnB1c2goIHByb3BzW3Byb3BdICk7XG5cdFx0XHR9XG5cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzO1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC90b29scy9hY3Rpb24tZXh0ZW5kLmpzXCIsXCIvY2xpZW50L3Rvb2xzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYW52YXMsIG1pbkhlaWdodCl7XG5cblx0dmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cdHZhciBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cblx0aWYod2lkdGggPCAxMDI0KXtcblx0XHR3aWR0aCA9IDEwMjQ7XG5cdH1cblxuXHRpZihtaW5IZWlnaHQpe1xuXHRcdGhlaWdodCA9IG1pbkhlaWdodDtcblx0fVxuXG5cdHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlciggeyBhbnRpYWxpYXM6IHRydWUgfSApO1xuXHR0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoIDB4RkZGRkZGLCAxICk7XG5cdHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuXHQvL3JvdGF0ZSB3b3JsZFxuXHR0aGlzLmdyb3VwID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cblx0Ly9TZXR1cCBjYW1lcmFcblx0dGhpcy5jYW1lcmEgPSBuZXcgSU8uY2xhc3Nlcy5HZW9DYW1lcmEoNjAsIHdpZHRoL2hlaWdodCAsIDEsIDUwMDAsIHRoaXMuZ3JvdXApO1xuXHR0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gMTUwMDtcblxuXHQvL1NldHVwIHNjZW5lXG5cdHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblx0dGhpcy5zY2VuZS5mb2cgPSBuZXcgVEhSRUUuRm9nRXhwMiggMHhGRkZGRkYsIDAuMDAwNTAgKTtcblx0dGhpcy5zY2VuZS5mb2cubmlnaHQgPSBuZXcgVEhSRUUuQ29sb3IoMHgyMjIyMjIpO1xuICAgIHRoaXMuc2NlbmUuZm9nLmRheSA9IG5ldyBUSFJFRS5Db2xvcigweEZGRkZGRik7XG5cblx0Ly9BZGQgcm90YXRlZCB3b3JsZCB0byBzY2VuZVxuXHR0aGlzLnNjZW5lLmFkZCh0aGlzLmdyb3VwKTtcblx0Ly8gdGhpcy5ncm91cC5yb3RhdGVYKE1hdGguUEkvMik7XG5cdC8vIHRoaXMuZ3JvdXAucm90YXRlWigtTWF0aC5QSS8yKTtcblx0Ly8gdGhpcy5ncm91cC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdC8vY3JlYXRlIGxpZ2h0XG5cdHZhciBoZW1pc3BoZXJlID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCgweGZmZmZmZiwgMHg0NDQ0NDQsIDAuOCk7XG5cdHRoaXMuc2NlbmUuYWRkKGhlbWlzcGhlcmUpO1xuXG5cdC8vIEFwcGVuZCB0byBjYW52YXNcblx0Y2FudmFzLmFwcGVuZENoaWxkKCB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQgKTtcblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQvdG9vbHMvY3JlYXRlLXRocmVlLmpzXCIsXCIvY2xpZW50L3Rvb2xzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihncm91cCwgc2NlbmUpe1xuXG5cdC8vbm8gY2hpbGRyZW4gaW4gZ3JvdXBcblx0aWYoIWdyb3VwLmNoaWxkcmVuKXtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmb3IoIHZhciBpID0gMCA7IGkgPCBncm91cC5jaGlsZHJlbi5sZW5ndGggOyBpKysgKXtcblxuXHRcdHZhciBvYmplY3QgPSBncm91cC5jaGlsZHJlbltpXTtcblxuXHRcdHNjZW5lLnJlbW92ZShvYmplY3QpO1xuXHRcdGdyb3VwLnJlbW92ZShvYmplY3QpO1xuXG5cdFx0aWYgKG9iamVjdC5nZW9tZXRyeSkge1xuXHRcdFx0b2JqZWN0Lmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKG9iamVjdC5tYXRlcmlhbCkge1xuXG5cblx0XHRcdGlmIChvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzKXtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFsc1tpXS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmplY3QubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3QubWF0ZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChvYmplY3QudGV4dHVyZSkge1xuXHRcdFx0b2JqZWN0LnRleHR1cmUuZGlzcG9zZSgpO1xuXHRcdFx0b2JqZWN0LnRleHR1cmUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKG9iamVjdC5kaXNwb3NlKSB7XG5cdFx0XHRvYmplY3QuZGlzcG9zZSgpO1xuXHRcdH1cblxuXHRcdG9iamVjdCA9IHVuZGVmaW5lZDtcblxuXHR9XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY2xpZW50L3Rvb2xzL2Rlc3Ryb3ktZ3JvdXAuanNcIixcIi9jbGllbnQvdG9vbHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgQ29weVNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL2xpYi9jb3B5LXNoYWRlci5qcycpO1xudmFyIFNoYWRlclBhc3MgPSByZXF1aXJlKCcuLi8uLi9saWIvc2hhZGVyLXBhc3MuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuXG5cdC8vY2hlY2tcblx0aWYoIXRoaXMuY29tcG9zZXIpe1xuXHRcdGNvbnNvbGUud2FybignY29tcG9zZXIgbm90IGZvdW5kJyk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly9jb3B5IHBhc3M/XG5cdHZhciBjb3B5UGFzcyA9IG5ldyBTaGFkZXJQYXNzKENvcHlTaGFkZXIpO1xuXHRjb3B5UGFzcy5yZW5kZXJUb1NjcmVlbiA9IHRydWU7XG5cdHRoaXMuY29tcG9zZXIuYWRkUGFzcyhjb3B5UGFzcyk7XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY2xpZW50L3Rvb2xzL2Z4L2NvcHktc2hhZGVyLmpzXCIsXCIvY2xpZW50L3Rvb2xzL2Z4XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEZpbG1QYXNzID0gcmVxdWlyZSgnLi4vLi4vbGliL2ZpbG0tcGFzcy5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcblxuICAgIC8vY2hlY2tcbiAgICBpZighdGhpcy5jb21wb3Nlcil7XG4gICAgICAgIGNvbnNvbGUud2FybignY29tcG9zZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL2ZpbG0gZ3JhaW5cbiAgICB2YXIgZWZmZWN0RmlsbSA9IG5ldyBGaWxtUGFzcygwLjEsIDAsIDEwMCwgZmFsc2UpO1xuICAgIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhlZmZlY3RGaWxtKTtcblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQvdG9vbHMvZngvZmlsbS1ncmFpbi5qc1wiLFwiL2NsaWVudC90b29scy9meFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBTaGFkZXJQYXNzID0gcmVxdWlyZSgnLi4vLi4vbGliL3NoYWRlci1wYXNzLmpzJyk7XG52YXIgRlhBQVNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL2xpYi9meGFhLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcblxuXHQvL2NoZWNrXG5cdGlmKCF0aGlzLmNvbXBvc2VyKXtcblx0XHRjb25zb2xlLndhcm4oJ2NvbXBvc2VyIG5vdCBmb3VuZCcpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vRlhBQSAtIEFudGlBbGlhc2luZ1xuXHR0aGlzLmVmZmVjdEZYQUEgPSBuZXcgU2hhZGVyUGFzcyhGWEFBU2hhZGVyKTtcblx0Ly8gdmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgMjtcblx0Ly8gdmFyIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCAyO1xuXHQvLyB0aGlzLmVmZmVjdEZYQUEudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZS5zZXQoMSAvICh3aWR0aCAqIHRoaXMuZHByICksIDEgLyAoaGVpZ2h0ICogdGhpcy5kcHIgKSk7XG5cdHRoaXMuY29tcG9zZXIuYWRkUGFzcyh0aGlzLmVmZmVjdEZYQUEpO1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC90b29scy9meC9meGFhLmpzXCIsXCIvY2xpZW50L3Rvb2xzL2Z4XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFNoYWRlclBhc3MgPSByZXF1aXJlKCcuLi8uLi9saWIvc2hhZGVyLXBhc3MuanMnKTtcbnZhciBIb3Jpem9udGFsVGlsdFNoaWZ0U2hhZGVyID0gcmVxdWlyZSgnLi4vLi4vbGliL2hvcml6b250YWwtdGlsdC1zaGlmdC1zaGFkZXIuanMnKTtcbnZhciBWZXJ0aWNhbFRpbHRTaGlmdFNoYWRlciA9IHJlcXVpcmUoJy4uLy4uL2xpYi92ZXJ0aWNhbC10aWx0LXNoaWZ0LXNoYWRlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNjZW5lLCBjYW1lcmEsIHJlbmRlcmVyLCB3b3JsZCl7XG5cbiAgICAvL2NoZWNrXG4gICAgaWYoIXRoaXMuY29tcG9zZXIpe1xuICAgICAgICBjb25zb2xlLndhcm4oJ2NvbXBvc2VyIG5vdCBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnQ7XG5cbiAgICAvL2FiYmlsaXR5IHRvIHNldFxuICAgIHRoaXMuc2V0Qmx1ciA9IGZ1bmN0aW9uKGJsdXIsIHBvaW50LCBzcHJlYWQsIGFuaW1hdGUpe1xuXG4gICAgICAgIHNwcmVhZCA9IHNwcmVhZCB8fCAxO1xuXG4gICAgICAgIC8vb25seSBzZXRcbiAgICAgICAgaWYoIWFuaW1hdGUpe1xuXG4gICAgICAgICAgICB0aGlzLmhibHVyLnVuaWZvcm1zLmgudmFsdWUgPSBibHVyIC8gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICB0aGlzLnZibHVyLnVuaWZvcm1zLnYudmFsdWUgPSBibHVyIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5oYmx1ci51bmlmb3Jtcy5yLnZhbHVlID0gcG9pbnQ7XG4gICAgICAgICAgICB0aGlzLnZibHVyLnVuaWZvcm1zLnIudmFsdWUgPSBwb2ludDtcbiAgICAgICAgICAgIHRoaXMuaGJsdXIudW5pZm9ybXMuc3ByZWFkLnZhbHVlID0gc3ByZWFkO1xuICAgICAgICAgICAgdGhpcy52Ymx1ci51bmlmb3Jtcy5zcHJlYWQudmFsdWUgPSBzcHJlYWQ7XG5cbiAgICAgICAgICAgIC8vc2F2ZVxuICAgICAgICAgICAgY3VycmVudCA9IFtibHVyLCBwb2ludCwgc3ByZWFkXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy9hbmltYXRlXG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgYW5pbSA9IG5ldyBJTy5jbGFzc2VzLkFuaW1hdGlvbih3b3JsZCk7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRlID09PSB0cnVlID8gMTAwMCA6IGFuaW1hdGU7XG5cbiAgICAgICAgICAgIC8vY3VzdG9tIHNldHRlciBmdW5jdGlvbiBmb3IgYW5pbWF0aW9uXG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbihwcm9wZXJ0eSwgcHJvZ3Jlc3MsIG9wdGlvbnMsIGxlcnApe1xuXG4gICAgICAgICAgICAgICAgdmFyIGJsdXIgPSBsZXJwKG9wdGlvbnMuZnJvbVswXSwgb3B0aW9ucy50b1swXSwgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGxlcnAob3B0aW9ucy5mcm9tWzFdLCBvcHRpb25zLnRvWzFdLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgdmFyIHNwcmVhZCA9IGxlcnAob3B0aW9ucy5mcm9tWzJdLCBvcHRpb25zLnRvWzJdLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkuc2V0Qmx1cihibHVyLCBwb2ludCwgc3ByZWFkKTtcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy9hZGQgcHJvcGVydHlcbiAgICAgICAgICAgIGFuaW0uYWRkKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAnZnJvbSc6IGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgJ3RvJzogW2JsdXIsIHBvaW50LCBzcHJlYWRdLFxuICAgICAgICAgICAgICAgICdkdXJhdGlvbic6IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICd0aWNrJzogZm5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL3N0YXJ0XG4gICAgICAgICAgICBhbmltLnN0YXJ0KCk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vaW5pdFxuICAgIHRoaXMuaGJsdXIgPSBuZXcgU2hhZGVyUGFzcyhIb3Jpem9udGFsVGlsdFNoaWZ0U2hhZGVyKTtcbiAgICB0aGlzLnZibHVyID0gbmV3IFNoYWRlclBhc3MoVmVydGljYWxUaWx0U2hpZnRTaGFkZXIpO1xuICAgIHRoaXMuc2V0Qmx1cigyMCwgMC41NSwgMS42NSk7XG5cbiAgICB0aGlzLmNvbXBvc2VyLmFkZFBhc3ModGhpcy5oYmx1cik7XG4gICAgdGhpcy5jb21wb3Nlci5hZGRQYXNzKHRoaXMudmJsdXIpO1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2NsaWVudC90b29scy9meC90aWx0LXNoaWZ0LmpzXCIsXCIvY2xpZW50L3Rvb2xzL2Z4XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxuLy9hZGQgZWFzaW5nIC0gZnJvbSBodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy8jY3ViM1xuTWF0aC5lYXNlSW5PdXRRdWFkID0gZnVuY3Rpb24gKHQsIGIsIGMsIGQpIHtcblx0dCAvPSBkLzI7XG5cdGlmICh0IDwgMSkge1xuXHRcdHJldHVybiBjLzIqdCp0ICsgYjtcblx0fVxuXHR0LS07XG5cdHJldHVybiAtYy8yICogKHQqKHQtMikgLSAxKSArIGI7XG59O1xuXG5NYXRoLmVhc2VJbk91dEN1YmljID0gZnVuY3Rpb24gKHQsIGIsIGMsIGQpIHtcblx0dCAvPSBkLzI7XG5cdGlmICh0IDwgMSl7XG5cdFx0cmV0dXJuIGMvMip0KnQqdCArIGI7XG5cdH1cblx0dCAtPSAyO1xuXHRyZXR1cm4gYy8yKih0KnQqdCArIDIpICsgYjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZnJvbSwgdG8sIGNvbXBsZXRlZCl7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxuXHRcdE1hdGguZWFzZUluT3V0Q3ViaWMoY29tcGxldGVkLCBmcm9tLngsIHRvLngtZnJvbS54LCAxKSxcblx0XHRNYXRoLmVhc2VJbk91dEN1YmljKGNvbXBsZXRlZCwgZnJvbS55LCB0by55LWZyb20ueSwgMSksXG5cdFx0TWF0aC5lYXNlSW5PdXRDdWJpYyhjb21wbGV0ZWQsIGZyb20ueiwgdG8uei1mcm9tLnosIDEpXG5cdCk7XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY2xpZW50L3Rvb2xzL2xlcnAtM2QuanNcIixcIi9jbGllbnQvdG9vbHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1haW4sIG1hcExpc3Qpe1xuXG5cdGZvciggdmFyIGkgPSAwIDsgaSA8IG1hcExpc3QubGVuZ3RoIDsgaSsrICl7XG5cblx0XHRtYWluID0gbWFpbi5jb25jYXQoIG1hcExpc3RbaV0gKTtcblxuXHR9XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY2xpZW50L3Rvb2xzL21lcmdlLW1hcHMuanNcIixcIi9jbGllbnQvdG9vbHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhlaWdodCl7XG5cdHJldHVybiAtaGVpZ2h0O1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jbGllbnQvdG9vbHMvcGFyc2UtaGVpZ2h0LmpzXCIsXCIvY2xpZW50L3Rvb2xzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL2ZlYXR1cmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuXG4gICAgdmFyIGxpc3QgPSBbXTtcblxuICAgIHRoaXMucGFyc2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKXtcblxuICAgICAgICBmb3IoIHZhciBpID0gMCA7IGkgPCBjb2xsZWN0aW9uLmZlYXR1cmVzLmxlbmd0aCA7IGkrKyApe1xuICAgICAgICAgICAgdGhpcy5hZGQoY29sbGVjdGlvbi5mZWF0dXJlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIHRoaXMuYWRkID0gZnVuY3Rpb24oZmVhdHVyZSl7XG4gICAgICAgIHZhciBmZWF0dXJlID0gbmV3IEZlYXR1cmUoKS5wYXJzZShmZWF0dXJlKTtcbiAgICAgICAgbGlzdC5wdXNoKGZlYXR1cmUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9pc29tb3JwaGljL2NsYXNzZXMvY29sbGVjdGlvbi5qc1wiLFwiL2lzb21vcnBoaWMvY2xhc3Nlc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBHZW8gPSByZXF1aXJlKCcuL2dlby5qcycpO1xuXG52YXIgRmVhdHVyZSA9IGZ1bmN0aW9uKGRhdGEpe1xuXG4gICAgdmFyIGxpc3QgPSBbXTtcblxuICAgIC8vcHJvcGVydGllcyBvZiBmZWF0dXJlXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgdGhpcy50eXBlID0gJyc7XG5cbiAgICAvL2RhdGEgaW4gY29uc3RydWN0b3I/ICh3aGVuIGNsb25pbmcgZm9yIGV4YW1wbGUpXG4gICAgaWYoZGF0YSl7XG4gICAgICAgIGxpc3QgPSBkYXRhO1xuICAgIH1cblxuICAgIC8vcGFyc2UgZnJvbSBKU09OXG4gICAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGpzb24pe1xuXG4gICAgICAgIGlmKCFqc29uLmdlb21ldHJ5KXtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybignbm8gZ2VvbWV0cnknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vc2F2ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IGpzb24ucHJvcGVydGllcztcbiAgICAgICAgdGhpcy50eXBlID0ganNvbi5nZW9tZXRyeS50eXBlO1xuXG4gICAgICAgIC8vYWRkIGFsIHBvaW50cyB0byBsaXN0XG4gICAgICAgIGpzb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbihwb3Mpe1xuXG4gICAgICAgICAgICB2YXIgbXVsdGkgPSBwb3NbMF0gaW5zdGFuY2VvZiBBcnJheTtcblxuICAgICAgICAgICAgaWYoIW11bHRpKXtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gbmV3IEdlbygpLmZyb21BcnJheShwb3MpO1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaCggcG9zICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIF9saXN0ID0gW107XG5cbiAgICAgICAgICAgICAgICBwb3MuZm9yRWFjaChmdW5jdGlvbihwb3Mpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBuZXcgR2VvKCkuZnJvbUFycmF5KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIF9saXN0LnB1c2goIHBvcyApO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goX2xpc3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vY2hhaW5hYmxlXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcblxuICAgICAgICBpZihjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uID09PSBmYWxzZSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZWFjaCBsb29wIG11c3QgdXNlIGEgZnVuY3Rpb24gYXMgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBpID0gMCA7IGkgPCBsaXN0Lmxlbmd0aCA7IGkrKyApe1xuXG4gICAgICAgICAgICB2YXIgcG9zID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHZhciBtdWx0aSA9IHBvcyBpbnN0YW5jZW9mIEFycmF5O1xuXG4gICAgICAgICAgICBpZighbXVsdGkpe1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHBvcywgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDAgOyBqIDwgcG9zLmxlbmd0aCA7IGorKyApe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhsaXN0W2ldW2pdLCBqKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGFpbmFibGVcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGbGF0QXJyYXkgPSBmdW5jdGlvbigpe1xuXG4gICAgICAgIC8vY3JlYXRlIGxpc3RcbiAgICAgICAgdmFyIF9saXN0ID0gW107XG5cbiAgICAgICAgLy9hZGQgYWxsIHRvIG5ldyBsaXN0XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihwb3Mpe1xuICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgIF9saXN0LnB1c2gocG9zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9hbmQgcmV0dXJuXG4gICAgICAgIHJldHVybiBfbGlzdDtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRBcnJheSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbiAgICB0aGlzLmV4cG9ydEFycmF5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIF9saXN0ID0gW107XG5cbiAgICAgICAgLy9nZXQgb3JpZ2luYWwgZ2VvbWV0cnkgYXJyYXkgYmFja1xuICAgICAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24ocG9zKXtcblxuICAgICAgICAgICAgdmFyIG11bHRpID0gcG9zWzBdIGluc3RhbmNlb2YgQXJyYXk7XG5cbiAgICAgICAgICAgIGlmKCFtdWx0aSl7XG4gICAgICAgICAgICAgICAgX2xpc3QucHVzaCggcG9zLnRvQXJyYXkoKSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciBzdWJsaXN0ID0gW107XG5cbiAgICAgICAgICAgICAgICBwb3MuZm9yRWFjaChmdW5jdGlvbihwb3Mpe1xuICAgICAgICAgICAgICAgICAgICBzdWJsaXN0LnB1c2goIHBvcy50b0FycmF5KCkgKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIF9saXN0LnB1c2goc3VibGlzdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIF9saXN0O1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0Q2VudGVyID0gZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgX2xpc3QgPSB0aGlzLmdldEZsYXRBcnJheSgpO1xuICAgICAgICB2YXIgeCA9IF9saXN0Lm1hcChmdW5jdGlvbihhKXsgcmV0dXJuIGEubGF0IH0pO1xuICAgICAgICB2YXIgeSA9IF9saXN0Lm1hcChmdW5jdGlvbihhKXsgcmV0dXJuIGEubG9uIH0pO1xuICAgICAgICB2YXIgbWluWCA9IE1hdGgubWluLmFwcGx5KG51bGwsIHgpO1xuICAgICAgICB2YXIgbWF4WCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHgpO1xuICAgICAgICB2YXIgbWluWSA9IE1hdGgubWluLmFwcGx5KG51bGwsIHkpO1xuICAgICAgICB2YXIgbWF4WSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHkpO1xuICAgICAgICAvLyByZXR1cm4gWyhtaW5YICsgbWF4WCkvMiwgKG1pblkgKyBtYXhZKS8yXTtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW8oKG1pblggKyBtYXhYKS8yLCAobWluWSArIG1heFkpLzIpO1xuXG4gICAgfTtcblxuICAgIHRoaXMuZ2V0Q2xvc2VzdCA9IGZ1bmN0aW9uKGNvbXBhcmVMaXN0KXtcblxuICAgICAgICB2YXIgX2xpc3QgPSB0aGlzLmdldEZsYXRBcnJheSgpO1xuICAgICAgICB2YXIgbWluID0gLTE7XG4gICAgICAgIHZhciBjbG9zZXN0O1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwIDsgaSA8IF9saXN0Lmxlbmd0aCA7IGkrKyApe1xuXG4gICAgICAgICAgICAvL2NoZWNrIGFnYWlucyBsaXN0IHByb3ZpZGVkXG4gICAgICAgICAgICBmb3IoIHZhciBqID0gMCA7IGogPCBjb21wYXJlTGlzdC5sZW5ndGggOyBqKysgKXtcblxuICAgICAgICAgICAgICAgIC8vZ2V0IGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gX2xpc3RbaV0uZGlzdGFuY2VUbyhjb21wYXJlTGlzdFtqXSk7XG5cbiAgICAgICAgICAgICAgICAvL2lzIGNsb3Nlcj9cbiAgICAgICAgICAgICAgICBpZihtaW4gPCAwIHx8IGRpc3RhbmNlIDwgbWluKXtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjb21wYXJlTGlzdFtqXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb3Nlc3Q7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5zcGxpdFBhdGggPSBmdW5jdGlvbihpbnRlcnZhbCl7XG5cbiAgICAgICAgLy9zdGFuZGFyZCBsZW5ndGhcbiAgICAgICAgaW50ZXJ2YWwgPSBpbnRlcnZhbCB8fCAyMDtcbiAgICAgICAgdmFyIG5ld0xpc3QgPSBbXTtcblxuICAgICAgICB2YXIgc3BsaXQgPSBmdW5jdGlvbihwb2ludHMpe1xuXG4gICAgICAgICAgICAvL3ByZXZlbnQgbG9hZGluZyBzaW5nbGUgcG9pbnRzXG4gICAgICAgICAgICBpZighcG9pbnRzIHx8IHBvaW50cy5sZW5ndGggPCAyKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RyeWluZyB0byBzcGxpdCBwYXRoIG9mIHNpbmdsZSBwb2ludCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2xpc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aC0xIDsgaSsrKXtcblxuICAgICAgICAgICAgICAgIC8vbWFrZSBsaW5lXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgZW5kID0gcG9pbnRzW2krMV07XG5cbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSBuciBvZiBwb2ludHNcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBzdGFydC5kaXN0YW5jZVRvKGVuZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gTWF0aC5jZWlsKGRpc3RhbmNlL2ludGVydmFsKTtcblxuICAgICAgICAgICAgICAgIC8vYWRkIGludGVycG9sYXRlZCBwb2ludHNcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBqPTAgOyBqIDwgcGFydHMgOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9ICgxIC8gcGFydHMpICogajtcbiAgICAgICAgICAgICAgICAgICAgX2xpc3QucHVzaChzdGFydC5sZXJwKGVuZCwgcG9pbnQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2ZpbmFsIHBvaW50XG4gICAgICAgICAgICAgICAgX2xpc3QucHVzaChzdGFydC5sZXJwKGVuZCwgMSkpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfbGlzdDtcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vZ2V0IG9yaWdpbmFsIGdlb21ldHJ5IGFycmF5IGJhY2tcbiAgICAgICAgbGlzdCA9IHNwbGl0KCB0aGlzLmdldEZsYXRBcnJheSgpICk7XG5cbiAgICAgICAgLy9jaGFpbmFibGVcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0M0QgPSBmdW5jdGlvbihwcm9qZWN0aW9uKXtcblxuICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgIHZhciBfbGlzdCA9IHRoaXMuZ2V0RmxhdEFycmF5KCk7XG5cbiAgICAgICAgLy9jb252ZXJ0IHRvIDNkXG4gICAgICAgIGRlYnVnZ2VyXG4gICAgICAgIGZvciggdmFyIGkgPSAwIDsgaSA8IF9saXN0Lmxlbmd0aCA7IGkrKyApe1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goIF9saXN0W2ldLnRvM0QocHJvamVjdGlvbikgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmV0dXJuIG5ldyBwb2ludHNcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9O1xuXG4gICAgdGhpcy5jbG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBjbG9uZSA9IG5ldyBGZWF0dXJlKGxpc3QpO1xuICAgICAgICBjbG9uZS5wcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcblxuICAgIHRoaXMuZXhwb3J0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgICAganNvbi5wcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICBqc29uLmdlb21ldHJ5ID0ge307XG4gICAgICAgIGpzb24uZ2VvbWV0cnkudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAganNvbi5nZW9tZXRyeS5jb29yZGluYXRlcyA9IHRoaXMuZXhwb3J0QXJyYXkoKTtcbiAgICB9O1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmU7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvaXNvbW9ycGhpYy9jbGFzc2VzL2ZlYXR1cmUuanNcIixcIi9pc29tb3JwaGljL2NsYXNzZXNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgcHJvajQgPSByZXF1aXJlKCdwcm9qNCcpO1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxudmFyIEdlbyA9IGZ1bmN0aW9uKGxhdCwgbG9uLCBzcnMpe1xuXG4gICAgdGhpcy5sYXQgPSBsYXQ7XG4gICAgdGhpcy5sb24gPSBsb247XG4gICAgdGhpcy5zcnMgPSBzcnMgfHwgJ0VQU0c6NDMyNic7XG5cbiAgICB0aGlzLmRpc3RhbmNlVG8gPSBmdW5jdGlvbihnZW8pe1xuXG4gICAgICAgIC8vcHJldmVudFxuICAgICAgICBpZighKGdlby5sYXQgaW5zdGFuY2VvZiBOdW1iZXIgJiYgZ2VvLmxvbiBpbnN0YW5jZW9mIE51bWJlcikpe1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignZGVzdGluYXRpb24gb2JqZWN0IG5vdCB2YWxpZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYzOTY5NS9ob3ctdG8tY29udmVydC1sYXRpdHVkZS1vci1sb25naXR1ZGUtdG8tbWV0ZXJzXG4gICAgICAgIHZhciBSID0gNjM3OC4xMzc7IC8vIFJhZGl1cyBvZiBlYXJ0aCBpbiBLTVxuICAgICAgICB2YXIgZExhdCA9IChnZW8ubGF0IC0gdGhpcy5sYXQpICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgdmFyIGRMb24gPSAoZ2VvLmxvbiAtIHRoaXMubG9uKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIHZhciBhID0gTWF0aC5zaW4oZExhdC8yKSAqIE1hdGguc2luKGRMYXQvMikgK1xuICAgICAgICBNYXRoLmNvcyh0aGlzLmxvbiAqIE1hdGguUEkgLyAxODApICogTWF0aC5jb3MoZ2VvLmxhdCAqIE1hdGguUEkgLyAxODApICpcbiAgICAgICAgTWF0aC5zaW4oZExvbi8yKSAqIE1hdGguc2luKGRMb24vMik7XG4gICAgICAgIHZhciBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMS1hKSk7XG4gICAgICAgIHZhciBkID0gUiAqIGM7XG4gICAgICAgIHJldHVybiBkICogMTAwMDsgLy8gbWV0ZXJzXG5cbiAgICB9O1xuXG4gICAgLy9saW5lYXIgaW50ZXJwb2xhdGUgdG8gcG9zaXRpb24gKGFscGhhIGJldHdlZW4gMCwxKVxuICAgIHRoaXMubGVycCA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBhbHBoYSl7XG4gICAgICAgIHZhciBsYXQgPSB0aGlzLmxhdCAqICgxIC0gYWxwaGEpICsgZGVzdGluYXRpb24ubGF0ICogYWxwaGE7XG5cdFx0dmFyIGxvbiA9IHRoaXMubG9uICogKDEgLSBhbHBoYSkgKyBkZXN0aW5hdGlvbi5sb24gKiBhbHBoYTtcblx0XHRyZXR1cm4gbmV3IEdlbyhsYXQsIGxvbik7XG4gICAgfTtcblxuICAgIHRoaXMuY29udmVydCA9IGZ1bmN0aW9uKHNycyl7XG5cbiAgICAgICAgLy9jb252ZXJ0IHRvIGFub3RoZXIgU1JTIHdoZW4gbmVlZGVkXG4gICAgICAgIGlmKHNycyAhPSB0aGlzLnNycyl7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSBwcm9qNCh0aGlzLnNycywgc3JzLCBbdGhpcy5sYXQsIHRoaXMubG9uXSk7XG4gICAgICAgICAgICB0aGlzLmxhdCA9IGNvb3JkWzBdO1xuICAgICAgICAgICAgdGhpcy5sb24gPSBjb29yZFsxXTtcbiAgICAgICAgICAgIHRoaXMuc3JzID0gc3JzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gbmV3IEdlbyh0aGlzLmxhdCwgdGhpcy5sb24pO1xuICAgIH07XG5cbiAgICB0aGlzLmNvcHkgPSBmdW5jdGlvbihnZW8pe1xuICAgICAgICB0aGlzLmxhdCA9IGdlby5sYXQ7XG4gICAgICAgIHRoaXMubG9uID0gZ2VvLmxvbjtcbiAgICB9O1xuXG4gICAgdGhpcy5mcm9tQXJyYXkgPSBmdW5jdGlvbihwb3Mpe1xuICAgICAgICB0aGlzLmxhdCA9IHBvc1swXTtcbiAgICAgICAgdGhpcy5sb24gPSBwb3NbMV07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMudG9BcnJheSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBbdGhpcy5sYXQsIHRoaXMubG9uXTtcbiAgICB9O1xuXG4gICAgdGhpcy50bzNEID0gZnVuY3Rpb24ocHJvamVjdGlvbiwgeil7XG4gICAgICAgIHogPSB6IHx8IDA7XG4gICAgICAgIHZhciBjb29yZHMgPSBwcm9qZWN0aW9uLnRyYW5zbGF0ZTNEKHRoaXMubGF0LCB0aGlzLmxvbik7XG4gICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhjb29yZHMueCwgY29vcmRzLnksIHopO1xuICAgIH07XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2lzb21vcnBoaWMvY2xhc3Nlcy9nZW8uanNcIixcIi9pc29tb3JwaGljL2NsYXNzZXNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4hZnVuY3Rpb24oKSB7XG4gIHZhciBkMyA9IHtcbiAgICB2ZXJzaW9uOiBcIjMuNS4yXCJcbiAgfTtcbiAgaWYgKCFEYXRlLm5vdykgRGF0ZS5ub3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gK25ldyBEYXRlKCk7XG4gIH07XG4gIHZhciBkM19hcnJheVNsaWNlID0gW10uc2xpY2UsIGQzX2FycmF5ID0gZnVuY3Rpb24obGlzdCkge1xuICAgIHJldHVybiBkM19hcnJheVNsaWNlLmNhbGwobGlzdCk7XG4gIH07XG4gIHZhciBkM19kb2N1bWVudCA9IGRvY3VtZW50LCBkM19kb2N1bWVudEVsZW1lbnQgPSBkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGQzX3dpbmRvdyA9IHdpbmRvdztcbiAgdHJ5IHtcbiAgICBkM19hcnJheShkM19kb2N1bWVudEVsZW1lbnQuY2hpbGROb2RlcylbMF0ubm9kZVR5cGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkM19hcnJheSA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgIHZhciBpID0gbGlzdC5sZW5ndGgsIGFycmF5ID0gbmV3IEFycmF5KGkpO1xuICAgICAgd2hpbGUgKGktLSkgYXJyYXlbaV0gPSBsaXN0W2ldO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBkM19kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLnNldFByb3BlcnR5KFwib3BhY2l0eVwiLCAwLCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB2YXIgZDNfZWxlbWVudF9wcm90b3R5cGUgPSBkM193aW5kb3cuRWxlbWVudC5wcm90b3R5cGUsIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlID0gZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlLCBkM19lbGVtZW50X3NldEF0dHJpYnV0ZU5TID0gZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMsIGQzX3N0eWxlX3Byb3RvdHlwZSA9IGQzX3dpbmRvdy5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZSwgZDNfc3R5bGVfc2V0UHJvcGVydHkgPSBkM19zdHlsZV9wcm90b3R5cGUuc2V0UHJvcGVydHk7XG4gICAgZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgdmFsdWUgKyBcIlwiKTtcbiAgICB9O1xuICAgIGQzX2VsZW1lbnRfcHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TID0gZnVuY3Rpb24oc3BhY2UsIGxvY2FsLCB2YWx1ZSkge1xuICAgICAgZDNfZWxlbWVudF9zZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIHNwYWNlLCBsb2NhbCwgdmFsdWUgKyBcIlwiKTtcbiAgICB9O1xuICAgIGQzX3N0eWxlX3Byb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgICAgZDNfc3R5bGVfc2V0UHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSArIFwiXCIsIHByaW9yaXR5KTtcbiAgICB9O1xuICB9XG4gIGQzLmFzY2VuZGluZyA9IGQzX2FzY2VuZGluZztcbiAgZnVuY3Rpb24gZDNfYXNjZW5kaW5nKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG4gIH1cbiAgZDMuZGVzY2VuZGluZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG4gIH07XG4gIGQzLm1pbiA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgYjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYSA+IGIpIGEgPSBiO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICBkMy5tYXggPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPiBhKSBhID0gYjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+IGEpIGEgPSBiO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbiAgZDMuZXh0ZW50ID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBiLCBjO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBjID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGEgPiBiKSBhID0gYjtcbiAgICAgICAgaWYgKGMgPCBiKSBjID0gYjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYyA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhID4gYikgYSA9IGI7XG4gICAgICAgIGlmIChjIDwgYikgYyA9IGI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbIGEsIGMgXTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbnVtYmVyKHgpIHtcbiAgICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xuICB9XG4gIGZ1bmN0aW9uIGQzX251bWVyaWMoeCkge1xuICAgIHJldHVybiAhaXNOYU4oeCk7XG4gIH1cbiAgZDMuc3VtID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgcyA9IDAsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGkgPSAtMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSArYXJyYXlbaV0pKSBzICs9IGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gK2YuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkgcyArPSBhO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfTtcbiAgZDMubWVhbiA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIHMgPSAwLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBpID0gLTEsIGogPSBuO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihhcnJheVtpXSkpKSBzICs9IGE7IGVsc2UgLS1qO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkpKSBzICs9IGE7IGVsc2UgLS1qO1xuICAgIH1cbiAgICBpZiAoaikgcmV0dXJuIHMgLyBqO1xuICB9O1xuICBkMy5xdWFudGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgcCkge1xuICAgIHZhciBIID0gKHZhbHVlcy5sZW5ndGggLSAxKSAqIHAgKyAxLCBoID0gTWF0aC5mbG9vcihIKSwgdiA9ICt2YWx1ZXNbaCAtIDFdLCBlID0gSCAtIGg7XG4gICAgcmV0dXJuIGUgPyB2ICsgZSAqICh2YWx1ZXNbaF0gLSB2KSA6IHY7XG4gIH07XG4gIGQzLm1lZGlhbiA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIG51bWJlcnMgPSBbXSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgaSA9IC0xO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihhcnJheVtpXSkpKSBudW1iZXJzLnB1c2goYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkpIG51bWJlcnMucHVzaChhKTtcbiAgICB9XG4gICAgaWYgKG51bWJlcnMubGVuZ3RoKSByZXR1cm4gZDMucXVhbnRpbGUobnVtYmVycy5zb3J0KGQzX2FzY2VuZGluZyksIC41KTtcbiAgfTtcbiAgZDMudmFyaWFuY2UgPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoLCBtID0gMCwgYSwgZCwgcyA9IDAsIGkgPSAtMSwgaiA9IDA7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoYXJyYXlbaV0pKSkge1xuICAgICAgICAgIGQgPSBhIC0gbTtcbiAgICAgICAgICBtICs9IGQgLyArK2o7XG4gICAgICAgICAgcyArPSBkICogKGEgLSBtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkpIHtcbiAgICAgICAgICBkID0gYSAtIG07XG4gICAgICAgICAgbSArPSBkIC8gKytqO1xuICAgICAgICAgIHMgKz0gZCAqIChhIC0gbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGogPiAxKSByZXR1cm4gcyAvIChqIC0gMSk7XG4gIH07XG4gIGQzLmRldmlhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZDMudmFyaWFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Jpc2VjdG9yKGNvbXBhcmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgbG8gPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIGhpID0gYS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTsgZWxzZSBoaSA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG87XG4gICAgICB9LFxuICAgICAgcmlnaHQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGxvID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSBoaSA9IGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPiAwKSBoaSA9IG1pZDsgZWxzZSBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdmFyIGQzX2Jpc2VjdCA9IGQzX2Jpc2VjdG9yKGQzX2FzY2VuZGluZyk7XG4gIGQzLmJpc2VjdExlZnQgPSBkM19iaXNlY3QubGVmdDtcbiAgZDMuYmlzZWN0ID0gZDMuYmlzZWN0UmlnaHQgPSBkM19iaXNlY3QucmlnaHQ7XG4gIGQzLmJpc2VjdG9yID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBkM19iaXNlY3RvcihmLmxlbmd0aCA9PT0gMSA/IGZ1bmN0aW9uKGQsIHgpIHtcbiAgICAgIHJldHVybiBkM19hc2NlbmRpbmcoZihkKSwgeCk7XG4gICAgfSA6IGYpO1xuICB9O1xuICBkMy5zaHVmZmxlID0gZnVuY3Rpb24oYXJyYXksIGkwLCBpMSkge1xuICAgIGlmICgobSA9IGFyZ3VtZW50cy5sZW5ndGgpIDwgMykge1xuICAgICAgaTEgPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobSA8IDIpIGkwID0gMDtcbiAgICB9XG4gICAgdmFyIG0gPSBpMSAtIGkwLCB0LCBpO1xuICAgIHdoaWxlIChtKSB7XG4gICAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgICB0ID0gYXJyYXlbbSArIGkwXSwgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF0sIGFycmF5W2kgKyBpMF0gPSB0O1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG4gIGQzLnBlcm11dGUgPSBmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgIHZhciBpID0gaW5kZXhlcy5sZW5ndGgsIHBlcm11dGVzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHBlcm11dGVzW2ldID0gYXJyYXlbaW5kZXhlc1tpXV07XG4gICAgcmV0dXJuIHBlcm11dGVzO1xuICB9O1xuICBkMy5wYWlycyA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoIC0gMSwgcDAsIHAxID0gYXJyYXlbMF0sIHBhaXJzID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICAgIHdoaWxlIChpIDwgbikgcGFpcnNbaV0gPSBbIHAwID0gcDEsIHAxID0gYXJyYXlbKytpXSBdO1xuICAgIHJldHVybiBwYWlycztcbiAgfTtcbiAgZDMuemlwID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEobiA9IGFyZ3VtZW50cy5sZW5ndGgpKSByZXR1cm4gW107XG4gICAgZm9yICh2YXIgaSA9IC0xLCBtID0gZDMubWluKGFyZ3VtZW50cywgZDNfemlwTGVuZ3RoKSwgemlwcyA9IG5ldyBBcnJheShtKTsgKytpIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBqID0gLTEsIG4sIHppcCA9IHppcHNbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47ICkge1xuICAgICAgICB6aXBbal0gPSBhcmd1bWVudHNbal1baV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB6aXBzO1xuICB9O1xuICBmdW5jdGlvbiBkM196aXBMZW5ndGgoZCkge1xuICAgIHJldHVybiBkLmxlbmd0aDtcbiAgfVxuICBkMy50cmFuc3Bvc2UgPSBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICByZXR1cm4gZDMuemlwLmFwcGx5KGQzLCBtYXRyaXgpO1xuICB9O1xuICBkMy5rZXlzID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcbiAgZDMudmFsdWVzID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBtYXApIHZhbHVlcy5wdXNoKG1hcFtrZXldKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuICBkMy5lbnRyaWVzID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSBlbnRyaWVzLnB1c2goe1xuICAgICAga2V5OiBrZXksXG4gICAgICB2YWx1ZTogbWFwW2tleV1cbiAgICB9KTtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfTtcbiAgZDMubWVyZ2UgPSBmdW5jdGlvbihhcnJheXMpIHtcbiAgICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsIG0sIGkgPSAtMSwgaiA9IDAsIG1lcmdlZCwgYXJyYXk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGogKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgICBtZXJnZWQgPSBuZXcgQXJyYXkoaik7XG4gICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICBhcnJheSA9IGFycmF5c1tuXTtcbiAgICAgIG0gPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgICAgbWVyZ2VkWy0tal0gPSBhcnJheVttXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfTtcbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuICBkMy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICBzdGVwID0gMTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChzdG9wIC0gc3RhcnQpIC8gc3RlcCA9PT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcihcImluZmluaXRlIHJhbmdlXCIpO1xuICAgIHZhciByYW5nZSA9IFtdLCBrID0gZDNfcmFuZ2VfaW50ZWdlclNjYWxlKGFicyhzdGVwKSksIGkgPSAtMSwgajtcbiAgICBzdGFydCAqPSBrLCBzdG9wICo9IGssIHN0ZXAgKj0gaztcbiAgICBpZiAoc3RlcCA8IDApIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPiBzdG9wKSByYW5nZS5wdXNoKGogLyBrKTsgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqIC8gayk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuICBmdW5jdGlvbiBkM19yYW5nZV9pbnRlZ2VyU2NhbGUoeCkge1xuICAgIHZhciBrID0gMTtcbiAgICB3aGlsZSAoeCAqIGsgJSAxKSBrICo9IDEwO1xuICAgIHJldHVybiBrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2NsYXNzKGN0b3IsIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHByb3BlcnRpZXNba2V5XSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkMy5tYXAgPSBmdW5jdGlvbihvYmplY3QsIGYpIHtcbiAgICB2YXIgbWFwID0gbmV3IGQzX01hcCgpO1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBkM19NYXApIHtcbiAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gb2JqZWN0Lmxlbmd0aCwgbztcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChpLCBvYmplY3RbaV0pOyBlbHNlIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGYuY2FsbChvYmplY3QsIG8gPSBvYmplY3RbaV0sIGkpLCBvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfTWFwKCkge1xuICAgIHRoaXMuXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgdmFyIGQzX21hcF9wcm90byA9IFwiX19wcm90b19fXCIsIGQzX21hcF96ZXJvID0gXCJcXHgwMFwiO1xuICBkM19jbGFzcyhkM19NYXAsIHtcbiAgICBoYXM6IGQzX21hcF9oYXMsXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9bZDNfbWFwX2VzY2FwZShrZXkpXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX1tkM19tYXBfZXNjYXBlKGtleSldID0gdmFsdWU7XG4gICAgfSxcbiAgICByZW1vdmU6IGQzX21hcF9yZW1vdmUsXG4gICAga2V5czogZDNfbWFwX2tleXMsXG4gICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIHZhbHVlcy5wdXNoKHRoaXMuX1trZXldKTtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSxcbiAgICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBlbnRyaWVzLnB1c2goe1xuICAgICAgICBrZXk6IGQzX21hcF91bmVzY2FwZShrZXkpLFxuICAgICAgICB2YWx1ZTogdGhpcy5fW2tleV1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfSxcbiAgICBzaXplOiBkM19tYXBfc2l6ZSxcbiAgICBlbXB0eTogZDNfbWFwX2VtcHR5LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGYuY2FsbCh0aGlzLCBkM19tYXBfdW5lc2NhcGUoa2V5KSwgdGhpcy5fW2tleV0pO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX21hcF9lc2NhcGUoa2V5KSB7XG4gICAgcmV0dXJuIChrZXkgKz0gXCJcIikgPT09IGQzX21hcF9wcm90byB8fCBrZXlbMF0gPT09IGQzX21hcF96ZXJvID8gZDNfbWFwX3plcm8gKyBrZXkgOiBrZXk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX3VuZXNjYXBlKGtleSkge1xuICAgIHJldHVybiAoa2V5ICs9IFwiXCIpWzBdID09PSBkM19tYXBfemVybyA/IGtleS5zbGljZSgxKSA6IGtleTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfaGFzKGtleSkge1xuICAgIHJldHVybiBkM19tYXBfZXNjYXBlKGtleSkgaW4gdGhpcy5fO1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9yZW1vdmUoa2V5KSB7XG4gICAgcmV0dXJuIChrZXkgPSBkM19tYXBfZXNjYXBlKGtleSkpIGluIHRoaXMuXyAmJiBkZWxldGUgdGhpcy5fW2tleV07XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX2tleXMoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBrZXlzLnB1c2goZDNfbWFwX3VuZXNjYXBlKGtleSkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9zaXplKCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSArK3NpemU7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX2VtcHR5KCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkMy5uZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5lc3QgPSB7fSwga2V5cyA9IFtdLCBzb3J0S2V5cyA9IFtdLCBzb3J0VmFsdWVzLCByb2xsdXA7XG4gICAgZnVuY3Rpb24gbWFwKG1hcFR5cGUsIGFycmF5LCBkZXB0aCkge1xuICAgICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSByZXR1cm4gcm9sbHVwID8gcm9sbHVwLmNhbGwobmVzdCwgYXJyYXkpIDogc29ydFZhbHVlcyA/IGFycmF5LnNvcnQoc29ydFZhbHVlcykgOiBhcnJheTtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGtleSA9IGtleXNbZGVwdGgrK10sIGtleVZhbHVlLCBvYmplY3QsIHNldHRlciwgdmFsdWVzQnlLZXkgPSBuZXcgZDNfTWFwKCksIHZhbHVlcztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleS5nZXQoa2V5VmFsdWUgPSBrZXkob2JqZWN0ID0gYXJyYXlbaV0pKSkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVzQnlLZXkuc2V0KGtleVZhbHVlLCBbIG9iamVjdCBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hcFR5cGUpIHtcbiAgICAgICAgb2JqZWN0ID0gbWFwVHlwZSgpO1xuICAgICAgICBzZXR0ZXIgPSBmdW5jdGlvbihrZXlWYWx1ZSwgdmFsdWVzKSB7XG4gICAgICAgICAgb2JqZWN0LnNldChrZXlWYWx1ZSwgbWFwKG1hcFR5cGUsIHZhbHVlcywgZGVwdGgpKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdCA9IHt9O1xuICAgICAgICBzZXR0ZXIgPSBmdW5jdGlvbihrZXlWYWx1ZSwgdmFsdWVzKSB7XG4gICAgICAgICAgb2JqZWN0W2tleVZhbHVlXSA9IG1hcChtYXBUeXBlLCB2YWx1ZXMsIGRlcHRoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhbHVlc0J5S2V5LmZvckVhY2goc2V0dGVyKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVudHJpZXMobWFwLCBkZXB0aCkge1xuICAgICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSByZXR1cm4gbWFwO1xuICAgICAgdmFyIGFycmF5ID0gW10sIHNvcnRLZXkgPSBzb3J0S2V5c1tkZXB0aCsrXTtcbiAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKGtleSwga2V5TWFwKSB7XG4gICAgICAgIGFycmF5LnB1c2goe1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHZhbHVlczogZW50cmllcyhrZXlNYXAsIGRlcHRoKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvcnRLZXkgPyBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRLZXkoYS5rZXksIGIua2V5KTtcbiAgICAgIH0pIDogYXJyYXk7XG4gICAgfVxuICAgIG5lc3QubWFwID0gZnVuY3Rpb24oYXJyYXksIG1hcFR5cGUpIHtcbiAgICAgIHJldHVybiBtYXAobWFwVHlwZSwgYXJyYXksIDApO1xuICAgIH07XG4gICAgbmVzdC5lbnRyaWVzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgIHJldHVybiBlbnRyaWVzKG1hcChkMy5tYXAsIGFycmF5LCAwKSwgMCk7XG4gICAgfTtcbiAgICBuZXN0LmtleSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgIGtleXMucHVzaChkKTtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgbmVzdC5zb3J0S2V5cyA9IGZ1bmN0aW9uKG9yZGVyKSB7XG4gICAgICBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7XG4gICAgICByZXR1cm4gbmVzdDtcbiAgICB9O1xuICAgIG5lc3Quc29ydFZhbHVlcyA9IGZ1bmN0aW9uKG9yZGVyKSB7XG4gICAgICBzb3J0VmFsdWVzID0gb3JkZXI7XG4gICAgICByZXR1cm4gbmVzdDtcbiAgICB9O1xuICAgIG5lc3Qucm9sbHVwID0gZnVuY3Rpb24oZikge1xuICAgICAgcm9sbHVwID0gZjtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgcmV0dXJuIG5lc3Q7XG4gIH07XG4gIGQzLnNldCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHNldCA9IG5ldyBkM19TZXQoKTtcbiAgICBpZiAoYXJyYXkpIGZvciAodmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoOyBpIDwgbjsgKytpKSBzZXQuYWRkKGFycmF5W2ldKTtcbiAgICByZXR1cm4gc2V0O1xuICB9O1xuICBmdW5jdGlvbiBkM19TZXQoKSB7XG4gICAgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBkM19jbGFzcyhkM19TZXQsIHtcbiAgICBoYXM6IGQzX21hcF9oYXMsXG4gICAgYWRkOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHRoaXMuX1tkM19tYXBfZXNjYXBlKGtleSArPSBcIlwiKV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9LFxuICAgIHJlbW92ZTogZDNfbWFwX3JlbW92ZSxcbiAgICB2YWx1ZXM6IGQzX21hcF9rZXlzLFxuICAgIHNpemU6IGQzX21hcF9zaXplLFxuICAgIGVtcHR5OiBkM19tYXBfZW1wdHksXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oZikge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgZi5jYWxsKHRoaXMsIGQzX21hcF91bmVzY2FwZShrZXkpKTtcbiAgICB9XG4gIH0pO1xuICBkMy5iZWhhdmlvciA9IHt9O1xuICBkMy5yZWJpbmQgPSBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIHZhciBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1ldGhvZDtcbiAgICB3aGlsZSAoKytpIDwgbikgdGFyZ2V0W21ldGhvZCA9IGFyZ3VtZW50c1tpXV0gPSBkM19yZWJpbmQodGFyZ2V0LCBzb3VyY2UsIHNvdXJjZVttZXRob2RdKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICBmdW5jdGlvbiBkM19yZWJpbmQodGFyZ2V0LCBzb3VyY2UsIG1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseShzb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHNvdXJjZSA/IHRhcmdldCA6IHZhbHVlO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdmVuZG9yU3ltYm9sKG9iamVjdCwgbmFtZSkge1xuICAgIGlmIChuYW1lIGluIG9iamVjdCkgcmV0dXJuIG5hbWU7XG4gICAgbmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gZDNfdmVuZG9yUHJlZml4ZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgcHJlZml4TmFtZSA9IGQzX3ZlbmRvclByZWZpeGVzW2ldICsgbmFtZTtcbiAgICAgIGlmIChwcmVmaXhOYW1lIGluIG9iamVjdCkgcmV0dXJuIHByZWZpeE5hbWU7XG4gICAgfVxuICB9XG4gIHZhciBkM192ZW5kb3JQcmVmaXhlcyA9IFsgXCJ3ZWJraXRcIiwgXCJtc1wiLCBcIm1velwiLCBcIk1velwiLCBcIm9cIiwgXCJPXCIgXTtcbiAgZnVuY3Rpb24gZDNfbm9vcCgpIHt9XG4gIGQzLmRpc3BhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gbmV3IGQzX2Rpc3BhdGNoKCksIGkgPSAtMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRpc3BhdGNoW2FyZ3VtZW50c1tpXV0gPSBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoO1xuICB9O1xuICBmdW5jdGlvbiBkM19kaXNwYXRjaCgpIHt9XG4gIGQzX2Rpc3BhdGNoLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGkgPSB0eXBlLmluZGV4T2YoXCIuXCIpLCBuYW1lID0gXCJcIjtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBuYW1lID0gdHlwZS5zbGljZShpICsgMSk7XG4gICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCBpKTtcbiAgICB9XG4gICAgaWYgKHR5cGUpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHRoaXNbdHlwZV0ub24obmFtZSkgOiB0aGlzW3R5cGVdLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIGZvciAodHlwZSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHR5cGUpKSB0aGlzW3R5cGVdLm9uKG5hbWUsIG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBbXSwgbGlzdGVuZXJCeU5hbWUgPSBuZXcgZDNfTWFwKCk7XG4gICAgZnVuY3Rpb24gZXZlbnQoKSB7XG4gICAgICB2YXIgeiA9IGxpc3RlbmVycywgaSA9IC0xLCBuID0gei5sZW5ndGgsIGw7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGwgPSB6W2ldLm9uKSBsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2g7XG4gICAgfVxuICAgIGV2ZW50Lm9uID0gZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsID0gbGlzdGVuZXJCeU5hbWUuZ2V0KG5hbWUpLCBpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gbCAmJiBsLm9uO1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgbC5vbiA9IG51bGw7XG4gICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgwLCBpID0gbGlzdGVuZXJzLmluZGV4T2YobCkpLmNvbmNhdChsaXN0ZW5lcnMuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgbGlzdGVuZXJCeU5hbWUucmVtb3ZlKG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3RlbmVyKSBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lckJ5TmFtZS5zZXQobmFtZSwge1xuICAgICAgICBvbjogbGlzdGVuZXJcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaDtcbiAgICB9O1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBkMy5ldmVudCA9IG51bGw7XG4gIGZ1bmN0aW9uIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKSB7XG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19ldmVudFNvdXJjZSgpIHtcbiAgICB2YXIgZSA9IGQzLmV2ZW50LCBzO1xuICAgIHdoaWxlIChzID0gZS5zb3VyY2VFdmVudCkgZSA9IHM7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZXZlbnREaXNwYXRjaCh0YXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBuZXcgZDNfZGlzcGF0Y2goKSwgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkaXNwYXRjaFthcmd1bWVudHNbaV1dID0gZDNfZGlzcGF0Y2hfZXZlbnQoZGlzcGF0Y2gpO1xuICAgIGRpc3BhdGNoLm9mID0gZnVuY3Rpb24odGhpeiwgYXJndW1lbnR6KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZTEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZTAgPSBlMS5zb3VyY2VFdmVudCA9IGQzLmV2ZW50O1xuICAgICAgICAgIGUxLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICBkMy5ldmVudCA9IGUxO1xuICAgICAgICAgIGRpc3BhdGNoW2UxLnR5cGVdLmFwcGx5KHRoaXosIGFyZ3VtZW50eik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZDMuZXZlbnQgPSBlMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBkaXNwYXRjaDtcbiAgfVxuICBkMy5yZXF1b3RlID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoZDNfcmVxdW90ZV9yZSwgXCJcXFxcJCZcIik7XG4gIH07XG4gIHZhciBkM19yZXF1b3RlX3JlID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuICB2YXIgZDNfc3ViY2xhc3MgPSB7fS5fX3Byb3RvX18gPyBmdW5jdGlvbihvYmplY3QsIHByb3RvdHlwZSkge1xuICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gIH0gOiBmdW5jdGlvbihvYmplY3QsIHByb3RvdHlwZSkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHByb3RvdHlwZSkgb2JqZWN0W3Byb3BlcnR5XSA9IHByb3RvdHlwZVtwcm9wZXJ0eV07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbihncm91cHMpIHtcbiAgICBkM19zdWJjbGFzcyhncm91cHMsIGQzX3NlbGVjdGlvblByb3RvdHlwZSk7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuICB2YXIgZDNfc2VsZWN0ID0gZnVuY3Rpb24ocywgbikge1xuICAgIHJldHVybiBuLnF1ZXJ5U2VsZWN0b3Iocyk7XG4gIH0sIGQzX3NlbGVjdEFsbCA9IGZ1bmN0aW9uKHMsIG4pIHtcbiAgICByZXR1cm4gbi5xdWVyeVNlbGVjdG9yQWxsKHMpO1xuICB9LCBkM19zZWxlY3RNYXRjaGVyID0gZDNfZG9jdW1lbnRFbGVtZW50Lm1hdGNoZXMgfHwgZDNfZG9jdW1lbnRFbGVtZW50W2QzX3ZlbmRvclN5bWJvbChkM19kb2N1bWVudEVsZW1lbnQsIFwibWF0Y2hlc1NlbGVjdG9yXCIpXSwgZDNfc2VsZWN0TWF0Y2hlcyA9IGZ1bmN0aW9uKG4sIHMpIHtcbiAgICByZXR1cm4gZDNfc2VsZWN0TWF0Y2hlci5jYWxsKG4sIHMpO1xuICB9O1xuICBpZiAodHlwZW9mIFNpenpsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZDNfc2VsZWN0ID0gZnVuY3Rpb24ocywgbikge1xuICAgICAgcmV0dXJuIFNpenpsZShzLCBuKVswXSB8fCBudWxsO1xuICAgIH07XG4gICAgZDNfc2VsZWN0QWxsID0gU2l6emxlO1xuICAgIGQzX3NlbGVjdE1hdGNoZXMgPSBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yO1xuICB9XG4gIGQzLnNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25Sb290O1xuICB9O1xuICB2YXIgZDNfc2VsZWN0aW9uUHJvdG90eXBlID0gZDMuc2VsZWN0aW9uLnByb3RvdHlwZSA9IFtdO1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBzdWJub2RlLCBncm91cCwgbm9kZTtcbiAgICBzZWxlY3RvciA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gKGdyb3VwID0gdGhpc1tqXSkucGFyZW50Tm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKHN1Ym5vZGUgPSBzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKTtcbiAgICAgICAgICBpZiAoc3Vibm9kZSAmJiBcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdG9yIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0KHNlbGVjdG9yLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zZWxlY3RBbGwgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIG5vZGU7XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gZDNfYXJyYXkoc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkpO1xuICAgICAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3NlbGVjdG9yQWxsKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiID8gc2VsZWN0b3IgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zZWxlY3RBbGwoc2VsZWN0b3IsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX25zUHJlZml4ID0ge1xuICAgIHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHhodG1sOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcbiAgICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgeG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbiAgfTtcbiAgZDMubnMgPSB7XG4gICAgcHJlZml4OiBkM19uc1ByZWZpeCxcbiAgICBxdWFsaWZ5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIjpcIiksIHByZWZpeCA9IG5hbWU7XG4gICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSk7XG4gICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkM19uc1ByZWZpeC5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge1xuICAgICAgICBzcGFjZTogZDNfbnNQcmVmaXhbcHJlZml4XSxcbiAgICAgICAgbG9jYWw6IG5hbWVcbiAgICAgIH0gOiBuYW1lO1xuICAgIH1cbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgICAgIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWUpO1xuICAgICAgICByZXR1cm4gbmFtZS5sb2NhbCA/IG5vZGUuZ2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCkgOiBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9hdHRyKHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2F0dHIobmFtZSwgdmFsdWUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2F0dHIobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lKTtcbiAgICBmdW5jdGlvbiBhdHRyTnVsbCgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyTnVsbE5TKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckNvbnN0YW50KCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyQ29uc3RhbnROUygpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpOyBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgeCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbmFtZS5sb2NhbCA/IGF0dHJOdWxsTlMgOiBhdHRyTnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uIDogbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2NvbGxhcHNlKHMpIHtcbiAgICByZXR1cm4gcy50cmltKCkucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNsYXNzZWQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCksIG4gPSAobmFtZSA9IGQzX3NlbGVjdGlvbl9jbGFzc2VzKG5hbWUpKS5sZW5ndGgsIGkgPSAtMTtcbiAgICAgICAgaWYgKHZhbHVlID0gbm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCF2YWx1ZS5jb250YWlucyhuYW1lW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFkM19zZWxlY3Rpb25fY2xhc3NlZFJlKG5hbWVbaV0pLnRlc3QodmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhbHVlIGluIG5hbWUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fY2xhc3NlZCh2YWx1ZSwgbmFtZVt2YWx1ZV0pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9jbGFzc2VkKG5hbWUsIHZhbHVlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VkUmUobmFtZSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XnxcXFxccyspXCIgKyBkMy5yZXF1b3RlKG5hbWUpICsgXCIoPzpcXFxccyt8JClcIiwgXCJnXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VzKG5hbWUpIHtcbiAgICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VkKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IGQzX3NlbGVjdGlvbl9jbGFzc2VzKG5hbWUpLm1hcChkM19zZWxlY3Rpb25fY2xhc3NlZE5hbWUpO1xuICAgIHZhciBuID0gbmFtZS5sZW5ndGg7XG4gICAgZnVuY3Rpb24gY2xhc3NlZENvbnN0YW50KCkge1xuICAgICAgdmFyIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBuYW1lW2ldKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSAtMSwgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoKytpIDwgbikgbmFtZVtpXSh0aGlzLCB4KTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xhc3NlZEZ1bmN0aW9uIDogY2xhc3NlZENvbnN0YW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jbGFzc2VkTmFtZShuYW1lKSB7XG4gICAgdmFyIHJlID0gZDNfc2VsZWN0aW9uX2NsYXNzZWRSZShuYW1lKTtcbiAgICByZXR1cm4gZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICAgIGlmIChjID0gbm9kZS5jbGFzc0xpc3QpIHJldHVybiB2YWx1ZSA/IGMuYWRkKG5hbWUpIDogYy5yZW1vdmUobmFtZSk7XG4gICAgICB2YXIgYyA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIjtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoIXJlLnRlc3QoYykpIG5vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZDNfY29sbGFwc2UoYyArIFwiIFwiICsgbmFtZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkM19jb2xsYXBzZShjLnJlcGxhY2UocmUsIFwiIFwiKSkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnN0eWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMykge1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuIDwgMikgdmFsdWUgPSBcIlwiO1xuICAgICAgICBmb3IgKHByaW9yaXR5IGluIG5hbWUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fc3R5bGUocHJpb3JpdHksIG5hbWVbcHJpb3JpdHldLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMikgcmV0dXJuIGQzX3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSgpLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgcHJpb3JpdHkgPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3N0eWxlKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIGZ1bmN0aW9uIHN0eWxlTnVsbCgpIHtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQoKSB7XG4gICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpOyBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgeCwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHN0eWxlTnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVGdW5jdGlvbiA6IHN0eWxlQ29uc3RhbnQ7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRoaXMubm9kZSgpW25hbWVdO1xuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3Byb3BlcnR5KHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3Byb3BlcnR5KG5hbWUsIHZhbHVlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9wcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5TnVsbCgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KCkge1xuICAgICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHggPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07IGVsc2UgdGhpc1tuYW1lXSA9IHg7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gcHJvcGVydHlOdWxsIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBwcm9wZXJ0eUZ1bmN0aW9uIDogcHJvcGVydHlDb25zdGFudDtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2godHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgICB9IDogdmFsdWUgPT0gbnVsbCA/IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgIH0pIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuZWFjaCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgICB9IDogdmFsdWUgPT0gbnVsbCA/IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgfSkgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKG5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiAobmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZSkpLmxvY2FsID8gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5hbWVzcGFjZVVSSSwgbmFtZSk7XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gICAgbmFtZSA9IGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpO1xuICAgIGJlZm9yZSA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvcihiZWZvcmUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShuYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGJlZm9yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICAgIH0pO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25SZW1vdmUpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25SZW1vdmUoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoLCBncm91cCwgbm9kZTtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gbmV3IEFycmF5KG4gPSAoZ3JvdXAgPSB0aGlzWzBdKS5sZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHZhbHVlW2ldID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiaW5kKGdyb3VwLCBncm91cERhdGEpIHtcbiAgICAgIHZhciBpLCBuID0gZ3JvdXAubGVuZ3RoLCBtID0gZ3JvdXBEYXRhLmxlbmd0aCwgbjAgPSBNYXRoLm1pbihuLCBtKSwgdXBkYXRlTm9kZXMgPSBuZXcgQXJyYXkobSksIGVudGVyTm9kZXMgPSBuZXcgQXJyYXkobSksIGV4aXROb2RlcyA9IG5ldyBBcnJheShuKSwgbm9kZSwgbm9kZURhdGE7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciBub2RlQnlLZXlWYWx1ZSA9IG5ldyBkM19NYXAoKSwga2V5VmFsdWVzID0gbmV3IEFycmF5KG4pLCBrZXlWYWx1ZTtcbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG47ICkge1xuICAgICAgICAgIGlmIChub2RlQnlLZXlWYWx1ZS5oYXMoa2V5VmFsdWUgPSBrZXkuY2FsbChub2RlID0gZ3JvdXBbaV0sIG5vZGUuX19kYXRhX18sIGkpKSkge1xuICAgICAgICAgICAgZXhpdE5vZGVzW2ldID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG07ICkge1xuICAgICAgICAgIGlmICghKG5vZGUgPSBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWUgPSBrZXkuY2FsbChncm91cERhdGEsIG5vZGVEYXRhID0gZ3JvdXBEYXRhW2ldLCBpKSkpKSB7XG4gICAgICAgICAgICBlbnRlck5vZGVzW2ldID0gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKG5vZGVEYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVzW2ldID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUuX19kYXRhX18gPSBub2RlRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbjsgKSB7XG4gICAgICAgICAgaWYgKG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZXNbaV0pICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBleGl0Tm9kZXNbaV0gPSBncm91cFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBuMDsgKSB7XG4gICAgICAgICAgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgICAgIG5vZGVEYXRhID0gZ3JvdXBEYXRhW2ldO1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLl9fZGF0YV9fID0gbm9kZURhdGE7XG4gICAgICAgICAgICB1cGRhdGVOb2Rlc1tpXSA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudGVyTm9kZXNbaV0gPSBkM19zZWxlY3Rpb25fZGF0YU5vZGUobm9kZURhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDtpIDwgbTsgKytpKSB7XG4gICAgICAgICAgZW50ZXJOb2Rlc1tpXSA9IGQzX3NlbGVjdGlvbl9kYXRhTm9kZShncm91cERhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoO2kgPCBuOyArK2kpIHtcbiAgICAgICAgICBleGl0Tm9kZXNbaV0gPSBncm91cFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW50ZXJOb2Rlcy51cGRhdGUgPSB1cGRhdGVOb2RlcztcbiAgICAgIGVudGVyTm9kZXMucGFyZW50Tm9kZSA9IHVwZGF0ZU5vZGVzLnBhcmVudE5vZGUgPSBleGl0Tm9kZXMucGFyZW50Tm9kZSA9IGdyb3VwLnBhcmVudE5vZGU7XG4gICAgICBlbnRlci5wdXNoKGVudGVyTm9kZXMpO1xuICAgICAgdXBkYXRlLnB1c2godXBkYXRlTm9kZXMpO1xuICAgICAgZXhpdC5wdXNoKGV4aXROb2Rlcyk7XG4gICAgfVxuICAgIHZhciBlbnRlciA9IGQzX3NlbGVjdGlvbl9lbnRlcihbXSksIHVwZGF0ZSA9IGQzX3NlbGVjdGlvbihbXSksIGV4aXQgPSBkM19zZWxlY3Rpb24oW10pO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYmluZChncm91cCA9IHRoaXNbaV0sIHZhbHVlLmNhbGwoZ3JvdXAsIGdyb3VwLnBhcmVudE5vZGUuX19kYXRhX18sIGkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYmluZChncm91cCA9IHRoaXNbaV0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlLmVudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZW50ZXI7XG4gICAgfTtcbiAgICB1cGRhdGUuZXhpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4aXQ7XG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZGF0YU5vZGUoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBfX2RhdGFfXzogZGF0YVxuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmRhdHVtID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB2YWx1ZSkgOiB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIik7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBncm91cCwgbm9kZTtcbiAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkM19zZWxlY3Rpb25fZmlsdGVyKGZpbHRlcik7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSB0aGlzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gKGdyb3VwID0gdGhpc1tqXSkucGFyZW50Tm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBmaWx0ZXIuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZmlsdGVyKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdE1hdGNoZXModGhpcywgc2VsZWN0b3IpO1xuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBub2RlLm5leHRTaWJsaW5nKSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICBjb21wYXJhdG9yID0gZDNfc2VsZWN0aW9uX3NvcnRDb21wYXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkgdGhpc1tqXS5zb3J0KGNvbXBhcmF0b3IpO1xuICAgIHJldHVybiB0aGlzLm9yZGVyKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zb3J0Q29tcGFyYXRvcihjb21wYXJhdG9yKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSBjb21wYXJhdG9yID0gZDNfYXNjZW5kaW5nO1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAmJiBiID8gY29tcGFyYXRvcihhLl9fZGF0YV9fLCBiLl9fZGF0YV9fKSA6ICFhIC0gIWI7XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaik7XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9lYWNoKGdyb3VwcywgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBjYWxsYmFjayhub2RlLCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ3MgPSBkM19hcnJheShhcmd1bWVudHMpO1xuICAgIGNhbGxiYWNrLmFwcGx5KGFyZ3NbMF0gPSB0aGlzLCBhcmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLm5vZGUoKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSAwO1xuICAgIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgKytuO1xuICAgIH0pO1xuICAgIHJldHVybiBuO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZW50ZXIoc2VsZWN0aW9uKSB7XG4gICAgZDNfc3ViY2xhc3Moc2VsZWN0aW9uLCBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUpO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgdmFyIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZSA9IFtdO1xuICBkMy5zZWxlY3Rpb24uZW50ZXIgPSBkM19zZWxlY3Rpb25fZW50ZXI7XG4gIGQzLnNlbGVjdGlvbi5lbnRlci5wcm90b3R5cGUgPSBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGU7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5hcHBlbmQgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuYXBwZW5kO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuZW1wdHkgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZW1wdHk7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5ub2RlID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLm5vZGU7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5jYWxsID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNhbGw7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5zaXplID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNpemU7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGUsIHVwZ3JvdXAsIGdyb3VwLCBub2RlO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHVwZ3JvdXAgPSAoZ3JvdXAgPSB0aGlzW2pdKS51cGRhdGU7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSBncm91cC5wYXJlbnROb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2godXBncm91cFtpXSA9IHN1Ym5vZGUgPSBzZWxlY3Rvci5jYWxsKGdyb3VwLnBhcmVudE5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKTtcbiAgICAgICAgICBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKG5hbWUsIGJlZm9yZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgYmVmb3JlID0gZDNfc2VsZWN0aW9uX2VudGVySW5zZXJ0QmVmb3JlKHRoaXMpO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25Qcm90b3R5cGUuaW5zZXJ0LmNhbGwodGhpcywgbmFtZSwgYmVmb3JlKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2VudGVySW5zZXJ0QmVmb3JlKGVudGVyKSB7XG4gICAgdmFyIGkwLCBqMDtcbiAgICByZXR1cm4gZnVuY3Rpb24oZCwgaSwgaikge1xuICAgICAgdmFyIGdyb3VwID0gZW50ZXJbal0udXBkYXRlLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlO1xuICAgICAgaWYgKGogIT0gajApIGowID0gaiwgaTAgPSAwO1xuICAgICAgaWYgKGkgPj0gaTApIGkwID0gaSArIDE7XG4gICAgICB3aGlsZSAoIShub2RlID0gZ3JvdXBbaTBdKSAmJiArK2kwIDwgbikgO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfVxuICBkMy5zZWxlY3QgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGdyb3VwID0gWyB0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIiA/IGQzX3NlbGVjdChub2RlLCBkM19kb2N1bWVudCkgOiBub2RlIF07XG4gICAgZ3JvdXAucGFyZW50Tm9kZSA9IGQzX2RvY3VtZW50RWxlbWVudDtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKFsgZ3JvdXAgXSk7XG4gIH07XG4gIGQzLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgdmFyIGdyb3VwID0gZDNfYXJyYXkodHlwZW9mIG5vZGVzID09PSBcInN0cmluZ1wiID8gZDNfc2VsZWN0QWxsKG5vZGVzLCBkM19kb2N1bWVudCkgOiBub2Rlcyk7XG4gICAgZ3JvdXAucGFyZW50Tm9kZSA9IGQzX2RvY3VtZW50RWxlbWVudDtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKFsgZ3JvdXAgXSk7XG4gIH07XG4gIHZhciBkM19zZWxlY3Rpb25Sb290ID0gZDMuc2VsZWN0KGQzX2RvY3VtZW50RWxlbWVudCk7XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuIDwgMikgbGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjYXB0dXJlIGluIHR5cGUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fb24oY2FwdHVyZSwgdHlwZVtjYXB0dXJlXSwgbGlzdGVuZXIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAobiA8IDIpIHJldHVybiAobiA9IHRoaXMubm9kZSgpW1wiX19vblwiICsgdHlwZV0pICYmIG4uXztcbiAgICAgIGNhcHR1cmUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fb24odHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX29uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIG5hbWUgPSBcIl9fb25cIiArIHR5cGUsIGkgPSB0eXBlLmluZGV4T2YoXCIuXCIpLCB3cmFwID0gZDNfc2VsZWN0aW9uX29uTGlzdGVuZXI7XG4gICAgaWYgKGkgPiAwKSB0eXBlID0gdHlwZS5zbGljZSgwLCBpKTtcbiAgICB2YXIgZmlsdGVyID0gZDNfc2VsZWN0aW9uX29uRmlsdGVycy5nZXQodHlwZSk7XG4gICAgaWYgKGZpbHRlcikgdHlwZSA9IGZpbHRlciwgd3JhcCA9IGQzX3NlbGVjdGlvbl9vbkZpbHRlcjtcbiAgICBmdW5jdGlvbiBvblJlbW92ZSgpIHtcbiAgICAgIHZhciBsID0gdGhpc1tuYW1lXTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsLCBsLiQpO1xuICAgICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25BZGQoKSB7XG4gICAgICB2YXIgbCA9IHdyYXAobGlzdGVuZXIsIGQzX2FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgb25SZW1vdmUuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzW25hbWVdID0gbCwgbC4kID0gY2FwdHVyZSk7XG4gICAgICBsLl8gPSBsaXN0ZW5lcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIl5fX29uKFteLl0rKVwiICsgZDMucmVxdW90ZSh0eXBlKSArIFwiJFwiKSwgbWF0Y2g7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKG1hdGNoID0gbmFtZS5tYXRjaChyZSkpIHtcbiAgICAgICAgICB2YXIgbCA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG1hdGNoWzFdLCBsLCBsLiQpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpID8gbGlzdGVuZXIgPyBvbkFkZCA6IG9uUmVtb3ZlIDogbGlzdGVuZXIgPyBkM19ub29wIDogcmVtb3ZlQWxsO1xuICB9XG4gIHZhciBkM19zZWxlY3Rpb25fb25GaWx0ZXJzID0gZDMubWFwKHtcbiAgICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxuICB9KTtcbiAgZDNfc2VsZWN0aW9uX29uRmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoXCJvblwiICsgayBpbiBkM19kb2N1bWVudCkgZDNfc2VsZWN0aW9uX29uRmlsdGVycy5yZW1vdmUoayk7XG4gIH0pO1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcihsaXN0ZW5lciwgYXJndW1lbnR6KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBvID0gZDMuZXZlbnQ7XG4gICAgICBkMy5ldmVudCA9IGU7XG4gICAgICBhcmd1bWVudHpbMF0gPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnR6KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzLmV2ZW50ID0gbztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9vbkZpbHRlcihsaXN0ZW5lciwgYXJndW1lbnR6KSB7XG4gICAgdmFyIGwgPSBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcihsaXN0ZW5lciwgYXJndW1lbnR6KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBpZiAoIXJlbGF0ZWQgfHwgcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICEocmVsYXRlZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0YXJnZXQpICYgOCkpIHtcbiAgICAgICAgbC5jYWxsKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZXZlbnRfZHJhZ1NlbGVjdCA9IFwib25zZWxlY3RzdGFydFwiIGluIGQzX2RvY3VtZW50ID8gbnVsbCA6IGQzX3ZlbmRvclN5bWJvbChkM19kb2N1bWVudEVsZW1lbnQuc3R5bGUsIFwidXNlclNlbGVjdFwiKSwgZDNfZXZlbnRfZHJhZ0lkID0gMDtcbiAgZnVuY3Rpb24gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKCkge1xuICAgIHZhciBuYW1lID0gXCIuZHJhZ3N1cHByZXNzLVwiICsgKytkM19ldmVudF9kcmFnSWQsIGNsaWNrID0gXCJjbGlja1wiICsgbmFtZSwgdyA9IGQzLnNlbGVjdChkM193aW5kb3cpLm9uKFwidG91Y2htb3ZlXCIgKyBuYW1lLCBkM19ldmVudFByZXZlbnREZWZhdWx0KS5vbihcImRyYWdzdGFydFwiICsgbmFtZSwgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCkub24oXCJzZWxlY3RzdGFydFwiICsgbmFtZSwgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCk7XG4gICAgaWYgKGQzX2V2ZW50X2RyYWdTZWxlY3QpIHtcbiAgICAgIHZhciBzdHlsZSA9IGQzX2RvY3VtZW50RWxlbWVudC5zdHlsZSwgc2VsZWN0ID0gc3R5bGVbZDNfZXZlbnRfZHJhZ1NlbGVjdF07XG4gICAgICBzdHlsZVtkM19ldmVudF9kcmFnU2VsZWN0XSA9IFwibm9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oc3VwcHJlc3NDbGljaykge1xuICAgICAgdy5vbihuYW1lLCBudWxsKTtcbiAgICAgIGlmIChkM19ldmVudF9kcmFnU2VsZWN0KSBzdHlsZVtkM19ldmVudF9kcmFnU2VsZWN0XSA9IHNlbGVjdDtcbiAgICAgIGlmIChzdXBwcmVzc0NsaWNrKSB7XG4gICAgICAgIHZhciBvZmYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB3Lm9uKGNsaWNrLCBudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdy5vbihjbGljaywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIG9mZigpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgc2V0VGltZW91dChvZmYsIDApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZDMubW91c2UgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICByZXR1cm4gZDNfbW91c2VQb2ludChjb250YWluZXIsIGQzX2V2ZW50U291cmNlKCkpO1xuICB9O1xuICB2YXIgZDNfbW91c2VfYnVnNDQwODMgPSAvV2ViS2l0Ly50ZXN0KGQzX3dpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSA/IC0xIDogMDtcbiAgZnVuY3Rpb24gZDNfbW91c2VQb2ludChjb250YWluZXIsIGUpIHtcbiAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcykgZSA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdmFyIHN2ZyA9IGNvbnRhaW5lci5vd25lclNWR0VsZW1lbnQgfHwgY29udGFpbmVyO1xuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgaWYgKGQzX21vdXNlX2J1ZzQ0MDgzIDwgMCAmJiAoZDNfd2luZG93LnNjcm9sbFggfHwgZDNfd2luZG93LnNjcm9sbFkpKSB7XG4gICAgICAgIHN2ZyA9IGQzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwic3ZnXCIpLnN0eWxlKHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgIGJvcmRlcjogXCJub25lXCJcbiAgICAgICAgfSwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgIHZhciBjdG0gPSBzdmdbMF1bMF0uZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgIGQzX21vdXNlX2J1ZzQ0MDgzID0gIShjdG0uZiB8fCBjdG0uZSk7XG4gICAgICAgIHN2Zy5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkM19tb3VzZV9idWc0NDA4MykgcG9pbnQueCA9IGUucGFnZVgsIHBvaW50LnkgPSBlLnBhZ2VZOyBlbHNlIHBvaW50LnggPSBlLmNsaWVudFgsIFxuICAgICAgcG9pbnQueSA9IGUuY2xpZW50WTtcbiAgICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKGNvbnRhaW5lci5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgcmV0dXJuIFsgcG9pbnQueCwgcG9pbnQueSBdO1xuICAgIH1cbiAgICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gWyBlLmNsaWVudFggLSByZWN0LmxlZnQgLSBjb250YWluZXIuY2xpZW50TGVmdCwgZS5jbGllbnRZIC0gcmVjdC50b3AgLSBjb250YWluZXIuY2xpZW50VG9wIF07XG4gIH1cbiAgZDMudG91Y2ggPSBmdW5jdGlvbihjb250YWluZXIsIHRvdWNoZXMsIGlkZW50aWZpZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGlkZW50aWZpZXIgPSB0b3VjaGVzLCB0b3VjaGVzID0gZDNfZXZlbnRTb3VyY2UoKS5jaGFuZ2VkVG91Y2hlcztcbiAgICBpZiAodG91Y2hlcykgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzLmxlbmd0aCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodG91Y2ggPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBkM19tb3VzZVBvaW50KGNvbnRhaW5lciwgdG91Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZDMuYmVoYXZpb3IuZHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBldmVudCA9IGQzX2V2ZW50RGlzcGF0Y2goZHJhZywgXCJkcmFnXCIsIFwiZHJhZ3N0YXJ0XCIsIFwiZHJhZ2VuZFwiKSwgb3JpZ2luID0gbnVsbCwgbW91c2Vkb3duID0gZHJhZ3N0YXJ0KGQzX25vb3AsIGQzLm1vdXNlLCBkM19iZWhhdmlvcl9kcmFnTW91c2VTdWJqZWN0LCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNldXBcIiksIHRvdWNoc3RhcnQgPSBkcmFnc3RhcnQoZDNfYmVoYXZpb3JfZHJhZ1RvdWNoSWQsIGQzLnRvdWNoLCBkM19iZWhhdmlvcl9kcmFnVG91Y2hTdWJqZWN0LCBcInRvdWNobW92ZVwiLCBcInRvdWNoZW5kXCIpO1xuICAgIGZ1bmN0aW9uIGRyYWcoKSB7XG4gICAgICB0aGlzLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbW91c2Vkb3duKS5vbihcInRvdWNoc3RhcnQuZHJhZ1wiLCB0b3VjaHN0YXJ0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhZ3N0YXJ0KGlkLCBwb3NpdGlvbiwgc3ViamVjdCwgbW92ZSwgZW5kKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcywgdGFyZ2V0ID0gZDMuZXZlbnQudGFyZ2V0LCBwYXJlbnQgPSB0aGF0LnBhcmVudE5vZGUsIGRpc3BhdGNoID0gZXZlbnQub2YodGhhdCwgYXJndW1lbnRzKSwgZHJhZ2dlZCA9IDAsIGRyYWdJZCA9IGlkKCksIGRyYWdOYW1lID0gXCIuZHJhZ1wiICsgKGRyYWdJZCA9PSBudWxsID8gXCJcIiA6IFwiLVwiICsgZHJhZ0lkKSwgZHJhZ09mZnNldCwgZHJhZ1N1YmplY3QgPSBkMy5zZWxlY3Qoc3ViamVjdCgpKS5vbihtb3ZlICsgZHJhZ05hbWUsIG1vdmVkKS5vbihlbmQgKyBkcmFnTmFtZSwgZW5kZWQpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcygpLCBwb3NpdGlvbjAgPSBwb3NpdGlvbihwYXJlbnQsIGRyYWdJZCk7XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICBkcmFnT2Zmc2V0ID0gb3JpZ2luLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZHJhZ09mZnNldCA9IFsgZHJhZ09mZnNldC54IC0gcG9zaXRpb24wWzBdLCBkcmFnT2Zmc2V0LnkgLSBwb3NpdGlvbjBbMV0gXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmFnT2Zmc2V0ID0gWyAwLCAwIF07XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IFwiZHJhZ3N0YXJ0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbjEgPSBwb3NpdGlvbihwYXJlbnQsIGRyYWdJZCksIGR4LCBkeTtcbiAgICAgICAgICBpZiAoIXBvc2l0aW9uMSkgcmV0dXJuO1xuICAgICAgICAgIGR4ID0gcG9zaXRpb24xWzBdIC0gcG9zaXRpb24wWzBdO1xuICAgICAgICAgIGR5ID0gcG9zaXRpb24xWzFdIC0gcG9zaXRpb24wWzFdO1xuICAgICAgICAgIGRyYWdnZWQgfD0gZHggfCBkeTtcbiAgICAgICAgICBwb3NpdGlvbjAgPSBwb3NpdGlvbjE7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogXCJkcmFnXCIsXG4gICAgICAgICAgICB4OiBwb3NpdGlvbjFbMF0gKyBkcmFnT2Zmc2V0WzBdLFxuICAgICAgICAgICAgeTogcG9zaXRpb24xWzFdICsgZHJhZ09mZnNldFsxXSxcbiAgICAgICAgICAgIGR4OiBkeCxcbiAgICAgICAgICAgIGR5OiBkeVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICAgIGlmICghcG9zaXRpb24ocGFyZW50LCBkcmFnSWQpKSByZXR1cm47XG4gICAgICAgICAgZHJhZ1N1YmplY3Qub24obW92ZSArIGRyYWdOYW1lLCBudWxsKS5vbihlbmQgKyBkcmFnTmFtZSwgbnVsbCk7XG4gICAgICAgICAgZHJhZ1Jlc3RvcmUoZHJhZ2dlZCAmJiBkMy5ldmVudC50YXJnZXQgPT09IHRhcmdldCk7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogXCJkcmFnZW5kXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZHJhZy5vcmlnaW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmlnaW47XG4gICAgICBvcmlnaW4gPSB4O1xuICAgICAgcmV0dXJuIGRyYWc7XG4gICAgfTtcbiAgICByZXR1cm4gZDMucmViaW5kKGRyYWcsIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19iZWhhdmlvcl9kcmFnVG91Y2hJZCgpIHtcbiAgICByZXR1cm4gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbiAgfVxuICBmdW5jdGlvbiBkM19iZWhhdmlvcl9kcmFnVG91Y2hTdWJqZWN0KCkge1xuICAgIHJldHVybiBkMy5ldmVudC50YXJnZXQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfYmVoYXZpb3JfZHJhZ01vdXNlU3ViamVjdCgpIHtcbiAgICByZXR1cm4gZDNfd2luZG93O1xuICB9XG4gIGQzLnRvdWNoZXMgPSBmdW5jdGlvbihjb250YWluZXIsIHRvdWNoZXMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHRvdWNoZXMgPSBkM19ldmVudFNvdXJjZSgpLnRvdWNoZXM7XG4gICAgcmV0dXJuIHRvdWNoZXMgPyBkM19hcnJheSh0b3VjaGVzKS5tYXAoZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIHZhciBwb2ludCA9IGQzX21vdXNlUG9pbnQoY29udGFpbmVyLCB0b3VjaCk7XG4gICAgICBwb2ludC5pZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9KSA6IFtdO1xuICB9O1xuICB2YXIgzrUgPSAxZS02LCDOtTIgPSDOtSAqIM61LCDPgCA9IE1hdGguUEksIM+EID0gMiAqIM+ALCDPhM61ID0gz4QgLSDOtSwgaGFsZs+AID0gz4AgLyAyLCBkM19yYWRpYW5zID0gz4AgLyAxODAsIGQzX2RlZ3JlZXMgPSAxODAgLyDPgDtcbiAgZnVuY3Rpb24gZDNfc2duKHgpIHtcbiAgICByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY3Jvc3MyZChhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChiWzBdIC0gYVswXSkgKiAoY1sxXSAtIGFbMV0pIC0gKGJbMV0gLSBhWzFdKSAqIChjWzBdIC0gYVswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfYWNvcyh4KSB7XG4gICAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IM+AIDogTWF0aC5hY29zKHgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2FzaW4oeCkge1xuICAgIHJldHVybiB4ID4gMSA/IGhhbGbPgCA6IHggPCAtMSA/IC1oYWxmz4AgOiBNYXRoLmFzaW4oeCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2luaCh4KSB7XG4gICAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY29zaCh4KSB7XG4gICAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGFuaCh4KSB7XG4gICAgcmV0dXJuICgoeCA9IE1hdGguZXhwKDIgKiB4KSkgLSAxKSAvICh4ICsgMSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfaGF2ZXJzaW4oeCkge1xuICAgIHJldHVybiAoeCA9IE1hdGguc2luKHggLyAyKSkgKiB4O1xuICB9XG4gIHZhciDPgSA9IE1hdGguU1FSVDIsIM+BMiA9IDIsIM+BNCA9IDQ7XG4gIGQzLmludGVycG9sYXRlWm9vbSA9IGZ1bmN0aW9uKHAwLCBwMSkge1xuICAgIHZhciB1eDAgPSBwMFswXSwgdXkwID0gcDBbMV0sIHcwID0gcDBbMl0sIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXTtcbiAgICB2YXIgZHggPSB1eDEgLSB1eDAsIGR5ID0gdXkxIC0gdXkwLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5LCBkMSA9IE1hdGguc3FydChkMiksIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgz4E0ICogZDIpIC8gKDIgKiB3MCAqIM+BMiAqIGQxKSwgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSDPgTQgKiBkMikgLyAoMiAqIHcxICogz4EyICogZDEpLCByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKSwgZHIgPSByMSAtIHIwLCBTID0gKGRyIHx8IE1hdGgubG9nKHcxIC8gdzApKSAvIM+BO1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKHQpIHtcbiAgICAgIHZhciBzID0gdCAqIFM7XG4gICAgICBpZiAoZHIpIHtcbiAgICAgICAgdmFyIGNvc2hyMCA9IGQzX2Nvc2gocjApLCB1ID0gdzAgLyAoz4EyICogZDEpICogKGNvc2hyMCAqIGQzX3Rhbmgoz4EgKiBzICsgcjApIC0gZDNfc2luaChyMCkpO1xuICAgICAgICByZXR1cm4gWyB1eDAgKyB1ICogZHgsIHV5MCArIHUgKiBkeSwgdzAgKiBjb3NocjAgLyBkM19jb3NoKM+BICogcyArIHIwKSBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsgdXgwICsgdCAqIGR4LCB1eTAgKyB0ICogZHksIHcwICogTWF0aC5leHAoz4EgKiBzKSBdO1xuICAgIH1cbiAgICBpbnRlcnBvbGF0ZS5kdXJhdGlvbiA9IFMgKiAxZTM7XG4gICAgcmV0dXJuIGludGVycG9sYXRlO1xuICB9O1xuICBkMy5iZWhhdmlvci56b29tID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZpZXcgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIGs6IDFcbiAgICB9LCB0cmFuc2xhdGUwLCBjZW50ZXIwLCBjZW50ZXIsIHNpemUgPSBbIDk2MCwgNTAwIF0sIHNjYWxlRXh0ZW50ID0gZDNfYmVoYXZpb3Jfem9vbUluZmluaXR5LCBkdXJhdGlvbiA9IDI1MCwgem9vbWluZyA9IDAsIG1vdXNlZG93biA9IFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vtb3ZlID0gXCJtb3VzZW1vdmUuem9vbVwiLCBtb3VzZXVwID0gXCJtb3VzZXVwLnpvb21cIiwgbW91c2V3aGVlbFRpbWVyLCB0b3VjaHN0YXJ0ID0gXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2h0aW1lLCBldmVudCA9IGQzX2V2ZW50RGlzcGF0Y2goem9vbSwgXCJ6b29tc3RhcnRcIiwgXCJ6b29tXCIsIFwiem9vbWVuZFwiKSwgeDAsIHgxLCB5MCwgeTE7XG4gICAgZnVuY3Rpb24gem9vbShnKSB7XG4gICAgICBnLm9uKG1vdXNlZG93biwgbW91c2Vkb3duZWQpLm9uKGQzX2JlaGF2aW9yX3pvb21XaGVlbCArIFwiLnpvb21cIiwgbW91c2V3aGVlbGVkKS5vbihcImRibGNsaWNrLnpvb21cIiwgZGJsY2xpY2tlZCkub24odG91Y2hzdGFydCwgdG91Y2hzdGFydGVkKTtcbiAgICB9XG4gICAgem9vbS5ldmVudCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpc3BhdGNoID0gZXZlbnQub2YodGhpcywgYXJndW1lbnRzKSwgdmlldzEgPSB2aWV3O1xuICAgICAgICBpZiAoZDNfdHJhbnNpdGlvbkluaGVyaXRJZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZWFjaChcInN0YXJ0Lnpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2aWV3ID0gdGhpcy5fX2NoYXJ0X18gfHwge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICBrOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIH0pLnR3ZWVuKFwiem9vbTp6b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGR4ID0gc2l6ZVswXSwgZHkgPSBzaXplWzFdLCBjeCA9IGNlbnRlcjAgPyBjZW50ZXIwWzBdIDogZHggLyAyLCBjeSA9IGNlbnRlcjAgPyBjZW50ZXIwWzFdIDogZHkgLyAyLCBpID0gZDMuaW50ZXJwb2xhdGVab29tKFsgKGN4IC0gdmlldy54KSAvIHZpZXcuaywgKGN5IC0gdmlldy55KSAvIHZpZXcuaywgZHggLyB2aWV3LmsgXSwgWyAoY3ggLSB2aWV3MS54KSAvIHZpZXcxLmssIChjeSAtIHZpZXcxLnkpIC8gdmlldzEuaywgZHggLyB2aWV3MS5rIF0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBpKHQpLCBrID0gZHggLyBsWzJdO1xuICAgICAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHZpZXcgPSB7XG4gICAgICAgICAgICAgICAgeDogY3ggLSBsWzBdICogayxcbiAgICAgICAgICAgICAgICB5OiBjeSAtIGxbMV0gKiBrLFxuICAgICAgICAgICAgICAgIGs6IGtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkuZWFjaChcImludGVycnVwdC56b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB9KS5lYWNoKFwiZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19jaGFydF9fID0gdmlldztcbiAgICAgICAgICB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHpvb20udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyB2aWV3LngsIHZpZXcueSBdO1xuICAgICAgdmlldyA9IHtcbiAgICAgICAgeDogK19bMF0sXG4gICAgICAgIHk6ICtfWzFdLFxuICAgICAgICBrOiB2aWV3LmtcbiAgICAgIH07XG4gICAgICByZXNjYWxlKCk7XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2aWV3Lms7XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiB2aWV3LngsXG4gICAgICAgIHk6IHZpZXcueSxcbiAgICAgICAgazogK19cbiAgICAgIH07XG4gICAgICByZXNjYWxlKCk7XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uc2NhbGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzY2FsZUV4dGVudDtcbiAgICAgIHNjYWxlRXh0ZW50ID0gXyA9PSBudWxsID8gZDNfYmVoYXZpb3Jfem9vbUluZmluaXR5IDogWyArX1swXSwgK19bMV0gXTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjZW50ZXI7XG4gICAgICBjZW50ZXIgPSBfICYmIFsgK19bMF0sICtfWzFdIF07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0gXyAmJiBbICtfWzBdLCArX1sxXSBdO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZHVyYXRpb247XG4gICAgICBkdXJhdGlvbiA9ICtfO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnggPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MTtcbiAgICAgIHgxID0gejtcbiAgICAgIHgwID0gei5jb3B5KCk7XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBrOiAxXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnkgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkxID0gejtcbiAgICAgIHkwID0gei5jb3B5KCk7XG4gICAgICB2aWV3ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBrOiAxXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsb2NhdGlvbihwKSB7XG4gICAgICByZXR1cm4gWyAocFswXSAtIHZpZXcueCkgLyB2aWV3LmssIChwWzFdIC0gdmlldy55KSAvIHZpZXcuayBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludChsKSB7XG4gICAgICByZXR1cm4gWyBsWzBdICogdmlldy5rICsgdmlldy54LCBsWzFdICogdmlldy5rICsgdmlldy55IF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlVG8ocykge1xuICAgICAgdmlldy5rID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCBzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVRvKHAsIGwpIHtcbiAgICAgIGwgPSBwb2ludChsKTtcbiAgICAgIHZpZXcueCArPSBwWzBdIC0gbFswXTtcbiAgICAgIHZpZXcueSArPSBwWzFdIC0gbFsxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbVRvKHRoYXQsIHAsIGwsIGspIHtcbiAgICAgIHRoYXQuX19jaGFydF9fID0ge1xuICAgICAgICB4OiB2aWV3LngsXG4gICAgICAgIHk6IHZpZXcueSxcbiAgICAgICAgazogdmlldy5rXG4gICAgICB9O1xuICAgICAgc2NhbGVUbyhNYXRoLnBvdygyLCBrKSk7XG4gICAgICB0cmFuc2xhdGVUbyhjZW50ZXIwID0gcCwgbCk7XG4gICAgICB0aGF0ID0gZDMuc2VsZWN0KHRoYXQpO1xuICAgICAgaWYgKGR1cmF0aW9uID4gMCkgdGhhdCA9IHRoYXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgIHRoYXQuY2FsbCh6b29tLmV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIGlmICh4MSkgeDEuZG9tYWluKHgwLnJhbmdlKCkubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuICh4IC0gdmlldy54KSAvIHZpZXcuaztcbiAgICAgIH0pLm1hcCh4MC5pbnZlcnQpKTtcbiAgICAgIGlmICh5MSkgeTEuZG9tYWluKHkwLnJhbmdlKCkubWFwKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuICh5IC0gdmlldy55KSAvIHZpZXcuaztcbiAgICAgIH0pLm1hcCh5MC5pbnZlcnQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpIHtcbiAgICAgIGlmICghem9vbWluZysrKSBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiem9vbXN0YXJ0XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tZWQoZGlzcGF0Y2gpIHtcbiAgICAgIHJlc2NhbGUoKTtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJ6b29tXCIsXG4gICAgICAgIHNjYWxlOiB2aWV3LmssXG4gICAgICAgIHRyYW5zbGF0ZTogWyB2aWV3LngsIHZpZXcueSBdXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem9vbWVuZGVkKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoIS0tem9vbWluZykgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcInpvb21lbmRcIlxuICAgICAgfSk7XG4gICAgICBjZW50ZXIwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91c2Vkb3duZWQoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsIHRhcmdldCA9IGQzLmV2ZW50LnRhcmdldCwgZGlzcGF0Y2ggPSBldmVudC5vZih0aGF0LCBhcmd1bWVudHMpLCBkcmFnZ2VkID0gMCwgc3ViamVjdCA9IGQzLnNlbGVjdChkM193aW5kb3cpLm9uKG1vdXNlbW92ZSwgbW92ZWQpLm9uKG1vdXNldXAsIGVuZGVkKSwgbG9jYXRpb24wID0gbG9jYXRpb24oZDMubW91c2UodGhhdCkpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcygpO1xuICAgICAgZDNfc2VsZWN0aW9uX2ludGVycnVwdC5jYWxsKHRoYXQpO1xuICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgZnVuY3Rpb24gbW92ZWQoKSB7XG4gICAgICAgIGRyYWdnZWQgPSAxO1xuICAgICAgICB0cmFuc2xhdGVUbyhkMy5tb3VzZSh0aGF0KSwgbG9jYXRpb24wKTtcbiAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICBzdWJqZWN0Lm9uKG1vdXNlbW92ZSwgbnVsbCkub24obW91c2V1cCwgbnVsbCk7XG4gICAgICAgIGRyYWdSZXN0b3JlKGRyYWdnZWQgJiYgZDMuZXZlbnQudGFyZ2V0ID09PSB0YXJnZXQpO1xuICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsIGRpc3BhdGNoID0gZXZlbnQub2YodGhhdCwgYXJndW1lbnRzKSwgbG9jYXRpb25zMCA9IHt9LCBkaXN0YW5jZTAgPSAwLCBzY2FsZTAsIHpvb21OYW1lID0gXCIuem9vbS1cIiArIGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXIsIHRvdWNobW92ZSA9IFwidG91Y2htb3ZlXCIgKyB6b29tTmFtZSwgdG91Y2hlbmQgPSBcInRvdWNoZW5kXCIgKyB6b29tTmFtZSwgdGFyZ2V0cyA9IFtdLCBzdWJqZWN0ID0gZDMuc2VsZWN0KHRoYXQpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcygpO1xuICAgICAgc3RhcnRlZCgpO1xuICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgc3ViamVjdC5vbihtb3VzZWRvd24sIG51bGwpLm9uKHRvdWNoc3RhcnQsIHN0YXJ0ZWQpO1xuICAgICAgZnVuY3Rpb24gcmVsb2NhdGUoKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gZDMudG91Y2hlcyh0aGF0KTtcbiAgICAgICAgc2NhbGUwID0gdmlldy5rO1xuICAgICAgICB0b3VjaGVzLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICAgIGlmICh0LmlkZW50aWZpZXIgaW4gbG9jYXRpb25zMCkgbG9jYXRpb25zMFt0LmlkZW50aWZpZXJdID0gbG9jYXRpb24odCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG91Y2hlcztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0ZWQoKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBkMy5ldmVudC50YXJnZXQ7XG4gICAgICAgIGQzLnNlbGVjdCh0YXJnZXQpLm9uKHRvdWNobW92ZSwgbW92ZWQpLm9uKHRvdWNoZW5kLCBlbmRlZCk7XG4gICAgICAgIHRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGNoYW5nZWQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgbG9jYXRpb25zMFtjaGFuZ2VkW2ldLmlkZW50aWZpZXJdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG91Y2hlcyA9IHJlbG9jYXRlKCksIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGlmIChub3cgLSB0b3VjaHRpbWUgPCA1MDApIHtcbiAgICAgICAgICAgIHZhciBwID0gdG91Y2hlc1swXTtcbiAgICAgICAgICAgIHpvb21Ubyh0aGF0LCBwLCBsb2NhdGlvbnMwW3AuaWRlbnRpZmllcl0sIE1hdGguZmxvb3IoTWF0aC5sb2codmlldy5rKSAvIE1hdGguTE4yKSArIDEpO1xuICAgICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3VjaHRpbWUgPSBub3c7XG4gICAgICAgIH0gZWxzZSBpZiAodG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIHAgPSB0b3VjaGVzWzBdLCBxID0gdG91Y2hlc1sxXSwgZHggPSBwWzBdIC0gcVswXSwgZHkgPSBwWzFdIC0gcVsxXTtcbiAgICAgICAgICBkaXN0YW5jZTAgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbW92ZWQoKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gZDMudG91Y2hlcyh0aGF0KSwgcDAsIGwwLCBwMSwgbDE7XG4gICAgICAgIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQuY2FsbCh0aGF0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IG47ICsraSwgbDEgPSBudWxsKSB7XG4gICAgICAgICAgcDEgPSB0b3VjaGVzW2ldO1xuICAgICAgICAgIGlmIChsMSA9IGxvY2F0aW9uczBbcDEuaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGlmIChsMCkgYnJlYWs7XG4gICAgICAgICAgICBwMCA9IHAxLCBsMCA9IGwxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobDEpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UxID0gKGRpc3RhbmNlMSA9IHAxWzBdIC0gcDBbMF0pICogZGlzdGFuY2UxICsgKGRpc3RhbmNlMSA9IHAxWzFdIC0gcDBbMV0pICogZGlzdGFuY2UxLCBzY2FsZTEgPSBkaXN0YW5jZTAgJiYgTWF0aC5zcXJ0KGRpc3RhbmNlMSAvIGRpc3RhbmNlMCk7XG4gICAgICAgICAgcDAgPSBbIChwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDIgXTtcbiAgICAgICAgICBsMCA9IFsgKGwwWzBdICsgbDFbMF0pIC8gMiwgKGwwWzFdICsgbDFbMV0pIC8gMiBdO1xuICAgICAgICAgIHNjYWxlVG8oc2NhbGUxICogc2NhbGUwKTtcbiAgICAgICAgfVxuICAgICAgICB0b3VjaHRpbWUgPSBudWxsO1xuICAgICAgICB0cmFuc2xhdGVUbyhwMCwgbDApO1xuICAgICAgICB6b29tZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC50b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBjaGFuZ2VkID0gZDMuZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjaGFuZ2VkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgZGVsZXRlIGxvY2F0aW9uczBbY2hhbmdlZFtpXS5pZGVudGlmaWVyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaWRlbnRpZmllciBpbiBsb2NhdGlvbnMwKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCByZWxvY2F0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkMy5zZWxlY3RBbGwodGFyZ2V0cykub24oem9vbU5hbWUsIG51bGwpO1xuICAgICAgICBzdWJqZWN0Lm9uKG1vdXNlZG93biwgbW91c2Vkb3duZWQpLm9uKHRvdWNoc3RhcnQsIHRvdWNoc3RhcnRlZCk7XG4gICAgICAgIGRyYWdSZXN0b3JlKCk7XG4gICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdXNld2hlZWxlZCgpIHtcbiAgICAgIHZhciBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAobW91c2V3aGVlbFRpbWVyKSBjbGVhclRpbWVvdXQobW91c2V3aGVlbFRpbWVyKTsgZWxzZSB0cmFuc2xhdGUwID0gbG9jYXRpb24oY2VudGVyMCA9IGNlbnRlciB8fCBkMy5tb3VzZSh0aGlzKSksIFxuICAgICAgZDNfc2VsZWN0aW9uX2ludGVycnVwdC5jYWxsKHRoaXMpLCB6b29tc3RhcnRlZChkaXNwYXRjaCk7XG4gICAgICBtb3VzZXdoZWVsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBtb3VzZXdoZWVsVGltZXIgPSBudWxsO1xuICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgfSwgNTApO1xuICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2NhbGVUbyhNYXRoLnBvdygyLCBkM19iZWhhdmlvcl96b29tRGVsdGEoKSAqIC4wMDIpICogdmlldy5rKTtcbiAgICAgIHRyYW5zbGF0ZVRvKGNlbnRlcjAsIHRyYW5zbGF0ZTApO1xuICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGJsY2xpY2tlZCgpIHtcbiAgICAgIHZhciBwID0gZDMubW91c2UodGhpcyksIGsgPSBNYXRoLmxvZyh2aWV3LmspIC8gTWF0aC5MTjI7XG4gICAgICB6b29tVG8odGhpcywgcCwgbG9jYXRpb24ocCksIGQzLmV2ZW50LnNoaWZ0S2V5ID8gTWF0aC5jZWlsKGspIC0gMSA6IE1hdGguZmxvb3IoaykgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzLnJlYmluZCh6b29tLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgdmFyIGQzX2JlaGF2aW9yX3pvb21JbmZpbml0eSA9IFsgMCwgSW5maW5pdHkgXTtcbiAgdmFyIGQzX2JlaGF2aW9yX3pvb21EZWx0YSwgZDNfYmVoYXZpb3Jfem9vbVdoZWVsID0gXCJvbndoZWVsXCIgaW4gZDNfZG9jdW1lbnQgPyAoZDNfYmVoYXZpb3Jfem9vbURlbHRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIC1kMy5ldmVudC5kZWx0YVkgKiAoZDMuZXZlbnQuZGVsdGFNb2RlID8gMTIwIDogMSk7XG4gIH0sIFwid2hlZWxcIikgOiBcIm9ubW91c2V3aGVlbFwiIGluIGQzX2RvY3VtZW50ID8gKGQzX2JlaGF2aW9yX3pvb21EZWx0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5ldmVudC53aGVlbERlbHRhO1xuICB9LCBcIm1vdXNld2hlZWxcIikgOiAoZDNfYmVoYXZpb3Jfem9vbURlbHRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIC1kMy5ldmVudC5kZXRhaWw7XG4gIH0sIFwiTW96TW91c2VQaXhlbFNjcm9sbFwiKTtcbiAgZDMuY29sb3IgPSBkM19jb2xvcjtcbiAgZnVuY3Rpb24gZDNfY29sb3IoKSB7fVxuICBkM19jb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKSArIFwiXCI7XG4gIH07XG4gIGQzLmhzbCA9IGQzX2hzbDtcbiAgZnVuY3Rpb24gZDNfaHNsKGgsIHMsIGwpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX2hzbCA/IHZvaWQgKHRoaXMuaCA9ICtoLCB0aGlzLnMgPSArcywgdGhpcy5sID0gK2wpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBoIGluc3RhbmNlb2YgZDNfaHNsID8gbmV3IGQzX2hzbChoLmgsIGgucywgaC5sKSA6IGQzX3JnYl9wYXJzZShcIlwiICsgaCwgZDNfcmdiX2hzbCwgZDNfaHNsKSA6IG5ldyBkM19oc2woaCwgcywgbCk7XG4gIH1cbiAgdmFyIGQzX2hzbFByb3RvdHlwZSA9IGQzX2hzbC5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfaHNsUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLnBvdyguNywgYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKTtcbiAgICByZXR1cm4gbmV3IGQzX2hzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sIC8gayk7XG4gIH07XG4gIGQzX2hzbFByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHJldHVybiBuZXcgZDNfaHNsKHRoaXMuaCwgdGhpcy5zLCBrICogdGhpcy5sKTtcbiAgfTtcbiAgZDNfaHNsUHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19oc2xfcmdiKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwpO1xuICB9O1xuICBmdW5jdGlvbiBkM19oc2xfcmdiKGgsIHMsIGwpIHtcbiAgICB2YXIgbTEsIG0yO1xuICAgIGggPSBpc05hTihoKSA/IDAgOiAoaCAlPSAzNjApIDwgMCA/IGggKyAzNjAgOiBoO1xuICAgIHMgPSBpc05hTihzKSA/IDAgOiBzIDwgMCA/IDAgOiBzID4gMSA/IDEgOiBzO1xuICAgIGwgPSBsIDwgMCA/IDAgOiBsID4gMSA/IDEgOiBsO1xuICAgIG0yID0gbCA8PSAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgZnVuY3Rpb24gdihoKSB7XG4gICAgICBpZiAoaCA+IDM2MCkgaCAtPSAzNjA7IGVsc2UgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICAgIGlmIChoIDwgNjApIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggLyA2MDtcbiAgICAgIGlmIChoIDwgMTgwKSByZXR1cm4gbTI7XG4gICAgICBpZiAoaCA8IDI0MCkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjA7XG4gICAgICByZXR1cm4gbTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZ2KGgpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHYoaCkgKiAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGQzX3JnYih2dihoICsgMTIwKSwgdnYoaCksIHZ2KGggLSAxMjApKTtcbiAgfVxuICBkMy5oY2wgPSBkM19oY2w7XG4gIGZ1bmN0aW9uIGQzX2hjbChoLCBjLCBsKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19oY2wgPyB2b2lkICh0aGlzLmggPSAraCwgdGhpcy5jID0gK2MsIHRoaXMubCA9ICtsKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gaCBpbnN0YW5jZW9mIGQzX2hjbCA/IG5ldyBkM19oY2woaC5oLCBoLmMsIGgubCkgOiBoIGluc3RhbmNlb2YgZDNfbGFiID8gZDNfbGFiX2hjbChoLmwsIGguYSwgaC5iKSA6IGQzX2xhYl9oY2woKGggPSBkM19yZ2JfbGFiKChoID0gZDMucmdiKGgpKS5yLCBoLmcsIGguYikpLmwsIGguYSwgaC5iKSA6IG5ldyBkM19oY2woaCwgYywgbCk7XG4gIH1cbiAgdmFyIGQzX2hjbFByb3RvdHlwZSA9IGQzX2hjbC5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfaGNsUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfaGNsKHRoaXMuaCwgdGhpcy5jLCBNYXRoLm1pbigxMDAsIHRoaXMubCArIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpKTtcbiAgfTtcbiAgZDNfaGNsUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2hjbCh0aGlzLmgsIHRoaXMuYywgTWF0aC5tYXgoMCwgdGhpcy5sIC0gZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSkpO1xuICB9O1xuICBkM19oY2xQcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2hjbF9sYWIodGhpcy5oLCB0aGlzLmMsIHRoaXMubCkucmdiKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2hjbF9sYWIoaCwgYywgbCkge1xuICAgIGlmIChpc05hTihoKSkgaCA9IDA7XG4gICAgaWYgKGlzTmFOKGMpKSBjID0gMDtcbiAgICByZXR1cm4gbmV3IGQzX2xhYihsLCBNYXRoLmNvcyhoICo9IGQzX3JhZGlhbnMpICogYywgTWF0aC5zaW4oaCkgKiBjKTtcbiAgfVxuICBkMy5sYWIgPSBkM19sYWI7XG4gIGZ1bmN0aW9uIGQzX2xhYihsLCBhLCBiKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19sYWIgPyB2b2lkICh0aGlzLmwgPSArbCwgdGhpcy5hID0gK2EsIHRoaXMuYiA9ICtiKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gbCBpbnN0YW5jZW9mIGQzX2xhYiA/IG5ldyBkM19sYWIobC5sLCBsLmEsIGwuYikgOiBsIGluc3RhbmNlb2YgZDNfaGNsID8gZDNfaGNsX2xhYihsLmgsIGwuYywgbC5sKSA6IGQzX3JnYl9sYWIoKGwgPSBkM19yZ2IobCkpLnIsIGwuZywgbC5iKSA6IG5ldyBkM19sYWIobCwgYSwgYik7XG4gIH1cbiAgdmFyIGQzX2xhYl9LID0gMTg7XG4gIHZhciBkM19sYWJfWCA9IC45NTA0NywgZDNfbGFiX1kgPSAxLCBkM19sYWJfWiA9IDEuMDg4ODM7XG4gIHZhciBkM19sYWJQcm90b3R5cGUgPSBkM19sYWIucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG4gIGQzX2xhYlByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2xhYihNYXRoLm1pbigxMDAsIHRoaXMubCArIGQzX2xhYl9LICogKGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSkpLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG4gIGQzX2xhYlByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBkM19sYWIoTWF0aC5tYXgoMCwgdGhpcy5sIC0gZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSksIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcbiAgZDNfbGFiUHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19sYWJfcmdiKHRoaXMubCwgdGhpcy5hLCB0aGlzLmIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYWJfcmdiKGwsIGEsIGIpIHtcbiAgICB2YXIgeSA9IChsICsgMTYpIC8gMTE2LCB4ID0geSArIGEgLyA1MDAsIHogPSB5IC0gYiAvIDIwMDtcbiAgICB4ID0gZDNfbGFiX3h5eih4KSAqIGQzX2xhYl9YO1xuICAgIHkgPSBkM19sYWJfeHl6KHkpICogZDNfbGFiX1k7XG4gICAgeiA9IGQzX2xhYl94eXooeikgKiBkM19sYWJfWjtcbiAgICByZXR1cm4gbmV3IGQzX3JnYihkM194eXpfcmdiKDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gLjQ5ODUzMTQgKiB6KSwgZDNfeHl6X3JnYigtLjk2OTI2NiAqIHggKyAxLjg3NjAxMDggKiB5ICsgLjA0MTU1NiAqIHopLCBkM194eXpfcmdiKC4wNTU2NDM0ICogeCAtIC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYWJfaGNsKGwsIGEsIGIpIHtcbiAgICByZXR1cm4gbCA+IDAgPyBuZXcgZDNfaGNsKE1hdGguYXRhbjIoYiwgYSkgKiBkM19kZWdyZWVzLCBNYXRoLnNxcnQoYSAqIGEgKyBiICogYiksIGwpIDogbmV3IGQzX2hjbChOYU4sIE5hTiwgbCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGFiX3h5eih4KSB7XG4gICAgcmV0dXJuIHggPiAuMjA2ODkzMDM0ID8geCAqIHggKiB4IDogKHggLSA0IC8gMjkpIC8gNy43ODcwMzc7XG4gIH1cbiAgZnVuY3Rpb24gZDNfeHl6X2xhYih4KSB7XG4gICAgcmV0dXJuIHggPiAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogNy43ODcwMzcgKiB4ICsgNCAvIDI5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3h5el9yZ2Iocikge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKDI1NSAqIChyIDw9IC4wMDMwNCA/IDEyLjkyICogciA6IDEuMDU1ICogTWF0aC5wb3cociwgMSAvIDIuNCkgLSAuMDU1KSk7XG4gIH1cbiAgZDMucmdiID0gZDNfcmdiO1xuICBmdW5jdGlvbiBkM19yZ2IociwgZywgYikge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfcmdiID8gdm9pZCAodGhpcy5yID0gfn5yLCB0aGlzLmcgPSB+fmcsIHRoaXMuYiA9IH5+YikgOiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHIgaW5zdGFuY2VvZiBkM19yZ2IgPyBuZXcgZDNfcmdiKHIuciwgci5nLCByLmIpIDogZDNfcmdiX3BhcnNlKFwiXCIgKyByLCBkM19yZ2IsIGQzX2hzbF9yZ2IpIDogbmV3IGQzX3JnYihyLCBnLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IGQzX3JnYih2YWx1ZSA+PiAxNiwgdmFsdWUgPj4gOCAmIDI1NSwgdmFsdWUgJiAyNTUpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYlN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBkM19yZ2JOdW1iZXIodmFsdWUpICsgXCJcIjtcbiAgfVxuICB2YXIgZDNfcmdiUHJvdG90eXBlID0gZDNfcmdiLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19yZ2JQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iLCBpID0gMzA7XG4gICAgaWYgKCFyICYmICFnICYmICFiKSByZXR1cm4gbmV3IGQzX3JnYihpLCBpLCBpKTtcbiAgICBpZiAociAmJiByIDwgaSkgciA9IGk7XG4gICAgaWYgKGcgJiYgZyA8IGkpIGcgPSBpO1xuICAgIGlmIChiICYmIGIgPCBpKSBiID0gaTtcbiAgICByZXR1cm4gbmV3IGQzX3JnYihNYXRoLm1pbigyNTUsIHIgLyBrKSwgTWF0aC5taW4oMjU1LCBnIC8gayksIE1hdGgubWluKDI1NSwgYiAvIGspKTtcbiAgfTtcbiAgZDNfcmdiUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgcmV0dXJuIG5ldyBkM19yZ2IoayAqIHRoaXMuciwgayAqIHRoaXMuZywgayAqIHRoaXMuYik7XG4gIH07XG4gIGQzX3JnYlByb3RvdHlwZS5oc2wgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfcmdiX2hzbCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgfTtcbiAgZDNfcmdiUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgZDNfcmdiX2hleCh0aGlzLnIpICsgZDNfcmdiX2hleCh0aGlzLmcpICsgZDNfcmdiX2hleCh0aGlzLmIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19yZ2JfaGV4KHYpIHtcbiAgICByZXR1cm4gdiA8IDE2ID8gXCIwXCIgKyBNYXRoLm1heCgwLCB2KS50b1N0cmluZygxNikgOiBNYXRoLm1pbigyNTUsIHYpLnRvU3RyaW5nKDE2KTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfcGFyc2UoZm9ybWF0LCByZ2IsIGhzbCkge1xuICAgIHZhciByID0gMCwgZyA9IDAsIGIgPSAwLCBtMSwgbTIsIGNvbG9yO1xuICAgIG0xID0gLyhbYS16XSspXFwoKC4qKVxcKS9pLmV4ZWMoZm9ybWF0KTtcbiAgICBpZiAobTEpIHtcbiAgICAgIG0yID0gbTFbMl0uc3BsaXQoXCIsXCIpO1xuICAgICAgc3dpdGNoIChtMVsxXSkge1xuICAgICAgIGNhc2UgXCJoc2xcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBoc2wocGFyc2VGbG9hdChtMlswXSksIHBhcnNlRmxvYXQobTJbMV0pIC8gMTAwLCBwYXJzZUZsb2F0KG0yWzJdKSAvIDEwMCk7XG4gICAgICAgIH1cblxuICAgICAgIGNhc2UgXCJyZ2JcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiByZ2IoZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzBdKSwgZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzFdKSwgZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzJdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbG9yID0gZDNfcmdiX25hbWVzLmdldChmb3JtYXQpKSByZXR1cm4gcmdiKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgIGlmIChmb3JtYXQgIT0gbnVsbCAmJiBmb3JtYXQuY2hhckF0KDApID09PSBcIiNcIiAmJiAhaXNOYU4oY29sb3IgPSBwYXJzZUludChmb3JtYXQuc2xpY2UoMSksIDE2KSkpIHtcbiAgICAgIGlmIChmb3JtYXQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHIgPSAoY29sb3IgJiAzODQwKSA+PiA0O1xuICAgICAgICByID0gciA+PiA0IHwgcjtcbiAgICAgICAgZyA9IGNvbG9yICYgMjQwO1xuICAgICAgICBnID0gZyA+PiA0IHwgZztcbiAgICAgICAgYiA9IGNvbG9yICYgMTU7XG4gICAgICAgIGIgPSBiIDw8IDQgfCBiO1xuICAgICAgfSBlbHNlIGlmIChmb3JtYXQubGVuZ3RoID09PSA3KSB7XG4gICAgICAgIHIgPSAoY29sb3IgJiAxNjcxMTY4MCkgPj4gMTY7XG4gICAgICAgIGcgPSAoY29sb3IgJiA2NTI4MCkgPj4gODtcbiAgICAgICAgYiA9IGNvbG9yICYgMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiKHIsIGcsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9oc2wociwgZywgYikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyIC89IDI1NSwgZyAvPSAyNTUsIGIgLz0gMjU1KSwgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIGQgPSBtYXggLSBtaW4sIGgsIHMsIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gICAgaWYgKGQpIHtcbiAgICAgIHMgPSBsIDwgLjUgPyBkIC8gKG1heCArIG1pbikgOiBkIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgaWYgKHIgPT0gbWF4KSBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGVsc2UgaWYgKGcgPT0gbWF4KSBoID0gKGIgLSByKSAvIGQgKyAyOyBlbHNlIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICBoICo9IDYwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gTmFOO1xuICAgICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZDNfaHNsKGgsIHMsIGwpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9sYWIociwgZywgYikge1xuICAgIHIgPSBkM19yZ2JfeHl6KHIpO1xuICAgIGcgPSBkM19yZ2JfeHl6KGcpO1xuICAgIGIgPSBkM19yZ2JfeHl6KGIpO1xuICAgIHZhciB4ID0gZDNfeHl6X2xhYigoLjQxMjQ1NjQgKiByICsgLjM1NzU3NjEgKiBnICsgLjE4MDQzNzUgKiBiKSAvIGQzX2xhYl9YKSwgeSA9IGQzX3h5el9sYWIoKC4yMTI2NzI5ICogciArIC43MTUxNTIyICogZyArIC4wNzIxNzUgKiBiKSAvIGQzX2xhYl9ZKSwgeiA9IGQzX3h5el9sYWIoKC4wMTkzMzM5ICogciArIC4xMTkxOTIgKiBnICsgLjk1MDMwNDEgKiBiKSAvIGQzX2xhYl9aKTtcbiAgICByZXR1cm4gZDNfbGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiX3h5eihyKSB7XG4gICAgcmV0dXJuIChyIC89IDI1NSkgPD0gLjA0MDQ1ID8gciAvIDEyLjkyIDogTWF0aC5wb3coKHIgKyAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9wYXJzZU51bWJlcihjKSB7XG4gICAgdmFyIGYgPSBwYXJzZUZsb2F0KGMpO1xuICAgIHJldHVybiBjLmNoYXJBdChjLmxlbmd0aCAtIDEpID09PSBcIiVcIiA/IE1hdGgucm91bmQoZiAqIDIuNTUpIDogZjtcbiAgfVxuICB2YXIgZDNfcmdiX25hbWVzID0gZDMubWFwKHtcbiAgICBhbGljZWJsdWU6IDE1NzkyMzgzLFxuICAgIGFudGlxdWV3aGl0ZTogMTY0NDQzNzUsXG4gICAgYXF1YTogNjU1MzUsXG4gICAgYXF1YW1hcmluZTogODM4ODU2NCxcbiAgICBhenVyZTogMTU3OTQxNzUsXG4gICAgYmVpZ2U6IDE2MTE5MjYwLFxuICAgIGJpc3F1ZTogMTY3NzAyNDQsXG4gICAgYmxhY2s6IDAsXG4gICAgYmxhbmNoZWRhbG1vbmQ6IDE2NzcyMDQ1LFxuICAgIGJsdWU6IDI1NSxcbiAgICBibHVldmlvbGV0OiA5MDU1MjAyLFxuICAgIGJyb3duOiAxMDgyNDIzNCxcbiAgICBidXJseXdvb2Q6IDE0NTk2MjMxLFxuICAgIGNhZGV0Ymx1ZTogNjI2NjUyOCxcbiAgICBjaGFydHJldXNlOiA4Mzg4MzUyLFxuICAgIGNob2NvbGF0ZTogMTM3ODk0NzAsXG4gICAgY29yYWw6IDE2NzQ0MjcyLFxuICAgIGNvcm5mbG93ZXJibHVlOiA2NTkxOTgxLFxuICAgIGNvcm5zaWxrOiAxNjc3NTM4OCxcbiAgICBjcmltc29uOiAxNDQyMzEwMCxcbiAgICBjeWFuOiA2NTUzNSxcbiAgICBkYXJrYmx1ZTogMTM5LFxuICAgIGRhcmtjeWFuOiAzNTcyMyxcbiAgICBkYXJrZ29sZGVucm9kOiAxMjA5MjkzOSxcbiAgICBkYXJrZ3JheTogMTExMTkwMTcsXG4gICAgZGFya2dyZWVuOiAyNTYwMCxcbiAgICBkYXJrZ3JleTogMTExMTkwMTcsXG4gICAgZGFya2toYWtpOiAxMjQzMzI1OSxcbiAgICBkYXJrbWFnZW50YTogOTEwOTY0MyxcbiAgICBkYXJrb2xpdmVncmVlbjogNTU5Nzk5OSxcbiAgICBkYXJrb3JhbmdlOiAxNjc0NzUyMCxcbiAgICBkYXJrb3JjaGlkOiAxMDA0MDAxMixcbiAgICBkYXJrcmVkOiA5MTA5NTA0LFxuICAgIGRhcmtzYWxtb246IDE1MzA4NDEwLFxuICAgIGRhcmtzZWFncmVlbjogOTQxOTkxOSxcbiAgICBkYXJrc2xhdGVibHVlOiA0NzM0MzQ3LFxuICAgIGRhcmtzbGF0ZWdyYXk6IDMxMDA0OTUsXG4gICAgZGFya3NsYXRlZ3JleTogMzEwMDQ5NSxcbiAgICBkYXJrdHVycXVvaXNlOiA1Mjk0NSxcbiAgICBkYXJrdmlvbGV0OiA5Njk5NTM5LFxuICAgIGRlZXBwaW5rOiAxNjcxNjk0NyxcbiAgICBkZWVwc2t5Ymx1ZTogNDkxNTEsXG4gICAgZGltZ3JheTogNjkwODI2NSxcbiAgICBkaW1ncmV5OiA2OTA4MjY1LFxuICAgIGRvZGdlcmJsdWU6IDIwMDMxOTksXG4gICAgZmlyZWJyaWNrOiAxMTY3NDE0NixcbiAgICBmbG9yYWx3aGl0ZTogMTY3NzU5MjAsXG4gICAgZm9yZXN0Z3JlZW46IDIyNjM4NDIsXG4gICAgZnVjaHNpYTogMTY3MTE5MzUsXG4gICAgZ2FpbnNib3JvOiAxNDQ3NDQ2MCxcbiAgICBnaG9zdHdoaXRlOiAxNjMxNjY3MSxcbiAgICBnb2xkOiAxNjc2NjcyMCxcbiAgICBnb2xkZW5yb2Q6IDE0MzI5MTIwLFxuICAgIGdyYXk6IDg0MjE1MDQsXG4gICAgZ3JlZW46IDMyNzY4LFxuICAgIGdyZWVueWVsbG93OiAxMTQwMzA1NSxcbiAgICBncmV5OiA4NDIxNTA0LFxuICAgIGhvbmV5ZGV3OiAxNTc5NDE2MCxcbiAgICBob3RwaW5rOiAxNjczODc0MCxcbiAgICBpbmRpYW5yZWQ6IDEzNDU4NTI0LFxuICAgIGluZGlnbzogNDkxNTMzMCxcbiAgICBpdm9yeTogMTY3NzcyMDAsXG4gICAga2hha2k6IDE1Nzg3NjYwLFxuICAgIGxhdmVuZGVyOiAxNTEzMjQxMCxcbiAgICBsYXZlbmRlcmJsdXNoOiAxNjc3MzM2NSxcbiAgICBsYXduZ3JlZW46IDgxOTA5NzYsXG4gICAgbGVtb25jaGlmZm9uOiAxNjc3NTg4NSxcbiAgICBsaWdodGJsdWU6IDExMzkzMjU0LFxuICAgIGxpZ2h0Y29yYWw6IDE1NzYxNTM2LFxuICAgIGxpZ2h0Y3lhbjogMTQ3NDU1OTksXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDE2NDQ4MjEwLFxuICAgIGxpZ2h0Z3JheTogMTM4ODIzMjMsXG4gICAgbGlnaHRncmVlbjogOTQ5ODI1NixcbiAgICBsaWdodGdyZXk6IDEzODgyMzIzLFxuICAgIGxpZ2h0cGluazogMTY3NTg0NjUsXG4gICAgbGlnaHRzYWxtb246IDE2NzUyNzYyLFxuICAgIGxpZ2h0c2VhZ3JlZW46IDIxNDI4OTAsXG4gICAgbGlnaHRza3libHVlOiA4OTAwMzQ2LFxuICAgIGxpZ2h0c2xhdGVncmF5OiA3ODMzNzUzLFxuICAgIGxpZ2h0c2xhdGVncmV5OiA3ODMzNzUzLFxuICAgIGxpZ2h0c3RlZWxibHVlOiAxMTU4NDczNCxcbiAgICBsaWdodHllbGxvdzogMTY3NzcxODQsXG4gICAgbGltZTogNjUyODAsXG4gICAgbGltZWdyZWVuOiAzMzI5MzMwLFxuICAgIGxpbmVuOiAxNjQ0NTY3MCxcbiAgICBtYWdlbnRhOiAxNjcxMTkzNSxcbiAgICBtYXJvb246IDgzODg2MDgsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogNjczNzMyMixcbiAgICBtZWRpdW1ibHVlOiAyMDUsXG4gICAgbWVkaXVtb3JjaGlkOiAxMjIxMTY2NyxcbiAgICBtZWRpdW1wdXJwbGU6IDk2NjI2ODMsXG4gICAgbWVkaXVtc2VhZ3JlZW46IDM5NzgwOTcsXG4gICAgbWVkaXVtc2xhdGVibHVlOiA4MDg3NzkwLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiA2NDE1NCxcbiAgICBtZWRpdW10dXJxdW9pc2U6IDQ3NzIzMDAsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiAxMzA0NzE3MyxcbiAgICBtaWRuaWdodGJsdWU6IDE2NDQ5MTIsXG4gICAgbWludGNyZWFtOiAxNjEyMTg1MCxcbiAgICBtaXN0eXJvc2U6IDE2NzcwMjczLFxuICAgIG1vY2Nhc2luOiAxNjc3MDIyOSxcbiAgICBuYXZham93aGl0ZTogMTY3Njg2ODUsXG4gICAgbmF2eTogMTI4LFxuICAgIG9sZGxhY2U6IDE2NjQzNTU4LFxuICAgIG9saXZlOiA4NDIxMzc2LFxuICAgIG9saXZlZHJhYjogNzA0ODczOSxcbiAgICBvcmFuZ2U6IDE2NzUzOTIwLFxuICAgIG9yYW5nZXJlZDogMTY3MjkzNDQsXG4gICAgb3JjaGlkOiAxNDMxNTczNCxcbiAgICBwYWxlZ29sZGVucm9kOiAxNTY1NzEzMCxcbiAgICBwYWxlZ3JlZW46IDEwMDI1ODgwLFxuICAgIHBhbGV0dXJxdW9pc2U6IDExNTI5OTY2LFxuICAgIHBhbGV2aW9sZXRyZWQ6IDE0MzgxMjAzLFxuICAgIHBhcGF5YXdoaXA6IDE2NzczMDc3LFxuICAgIHBlYWNocHVmZjogMTY3Njc2NzMsXG4gICAgcGVydTogMTM0Njg5OTEsXG4gICAgcGluazogMTY3NjEwMzUsXG4gICAgcGx1bTogMTQ1MjQ2MzcsXG4gICAgcG93ZGVyYmx1ZTogMTE1OTE5MTAsXG4gICAgcHVycGxlOiA4Mzg4NzM2LFxuICAgIHJlZDogMTY3MTE2ODAsXG4gICAgcm9zeWJyb3duOiAxMjM1NzUxOSxcbiAgICByb3lhbGJsdWU6IDQyODY5NDUsXG4gICAgc2FkZGxlYnJvd246IDkxMjcxODcsXG4gICAgc2FsbW9uOiAxNjQxNjg4MixcbiAgICBzYW5keWJyb3duOiAxNjAzMjg2NCxcbiAgICBzZWFncmVlbjogMzA1MDMyNyxcbiAgICBzZWFzaGVsbDogMTY3NzQ2MzgsXG4gICAgc2llbm5hOiAxMDUwNjc5NyxcbiAgICBzaWx2ZXI6IDEyNjMyMjU2LFxuICAgIHNreWJsdWU6IDg5MDAzMzEsXG4gICAgc2xhdGVibHVlOiA2OTcwMDYxLFxuICAgIHNsYXRlZ3JheTogNzM3Mjk0NCxcbiAgICBzbGF0ZWdyZXk6IDczNzI5NDQsXG4gICAgc25vdzogMTY3NzU5MzAsXG4gICAgc3ByaW5nZ3JlZW46IDY1NDA3LFxuICAgIHN0ZWVsYmx1ZTogNDYyMDk4MCxcbiAgICB0YW46IDEzODA4NzgwLFxuICAgIHRlYWw6IDMyODk2LFxuICAgIHRoaXN0bGU6IDE0MjA0ODg4LFxuICAgIHRvbWF0bzogMTY3MzcwOTUsXG4gICAgdHVycXVvaXNlOiA0MjUxODU2LFxuICAgIHZpb2xldDogMTU2MzEwODYsXG4gICAgd2hlYXQ6IDE2MTEzMzMxLFxuICAgIHdoaXRlOiAxNjc3NzIxNSxcbiAgICB3aGl0ZXNtb2tlOiAxNjExOTI4NSxcbiAgICB5ZWxsb3c6IDE2Nzc2OTYwLFxuICAgIHllbGxvd2dyZWVuOiAxMDE0NTA3NFxuICB9KTtcbiAgZDNfcmdiX25hbWVzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGQzX3JnYl9uYW1lcy5zZXQoa2V5LCBkM19yZ2JOdW1iZXIodmFsdWUpKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX2Z1bmN0b3Iodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiID8gdiA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgfVxuICBkMy5mdW5jdG9yID0gZDNfZnVuY3RvcjtcbiAgZnVuY3Rpb24gZDNfaWRlbnRpdHkoZCkge1xuICAgIHJldHVybiBkO1xuICB9XG4gIGQzLnhociA9IGQzX3hoclR5cGUoZDNfaWRlbnRpdHkpO1xuICBmdW5jdGlvbiBkM194aHJUeXBlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgbWltZVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgbWltZVR5cGUgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2sgPSBtaW1lVHlwZSwgXG4gICAgICBtaW1lVHlwZSA9IG51bGw7XG4gICAgICByZXR1cm4gZDNfeGhyKHVybCwgbWltZVR5cGUsIHJlc3BvbnNlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM194aHIodXJsLCBtaW1lVHlwZSwgcmVzcG9uc2UsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IHt9LCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKFwiYmVmb3Jlc2VuZFwiLCBcInByb2dyZXNzXCIsIFwibG9hZFwiLCBcImVycm9yXCIpLCBoZWFkZXJzID0ge30sIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSwgcmVzcG9uc2VUeXBlID0gbnVsbDtcbiAgICBpZiAoZDNfd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiByZXF1ZXN0KSAmJiAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgXCJvbmxvYWRcIiBpbiByZXF1ZXN0ID8gcmVxdWVzdC5vbmxvYWQgPSByZXF1ZXN0Lm9uZXJyb3IgPSByZXNwb25kIDogcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlcXVlc3QucmVhZHlTdGF0ZSA+IDMgJiYgcmVzcG9uZCgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICAgIHZhciBzdGF0dXMgPSByZXF1ZXN0LnN0YXR1cywgcmVzdWx0O1xuICAgICAgaWYgKCFzdGF0dXMgJiYgZDNfeGhySGFzUmVzcG9uc2UocmVxdWVzdCkgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSByZXNwb25zZS5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkaXNwYXRjaC5lcnJvci5jYWxsKHhociwgZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoLmxvYWQuY2FsbCh4aHIsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaC5lcnJvci5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgbyA9IGQzLmV2ZW50O1xuICAgICAgZDMuZXZlbnQgPSBldmVudDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRpc3BhdGNoLnByb2dyZXNzLmNhbGwoeGhyLCByZXF1ZXN0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzLmV2ZW50ID0gbztcbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5oZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgbmFtZSA9IChuYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIGhlYWRlcnNbbmFtZV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkgZGVsZXRlIGhlYWRlcnNbbmFtZV07IGVsc2UgaGVhZGVyc1tuYW1lXSA9IHZhbHVlICsgXCJcIjtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICB4aHIubWltZVR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWltZVR5cGU7XG4gICAgICBtaW1lVHlwZSA9IHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWUgKyBcIlwiO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmVzcG9uc2VUeXBlO1xuICAgICAgcmVzcG9uc2VUeXBlID0gdmFsdWU7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgeGhyLnJlc3BvbnNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3BvbnNlID0gdmFsdWU7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgWyBcImdldFwiLCBcInBvc3RcIiBdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICB4aHJbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geGhyLnNlbmQuYXBwbHkoeGhyLCBbIG1ldGhvZCBdLmNvbmNhdChkM19hcnJheShhcmd1bWVudHMpKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHhoci5zZW5kID0gZnVuY3Rpb24obWV0aG9kLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2sgPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgICAgIHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICBpZiAobWltZVR5cGUgIT0gbnVsbCAmJiAhKFwiYWNjZXB0XCIgaW4gaGVhZGVycykpIGhlYWRlcnNbXCJhY2NlcHRcIl0gPSBtaW1lVHlwZSArIFwiLCovKlwiO1xuICAgICAgaWYgKHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcikgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICBpZiAobWltZVR5cGUgIT0gbnVsbCAmJiByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUpIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZShtaW1lVHlwZSk7XG4gICAgICBpZiAocmVzcG9uc2VUeXBlICE9IG51bGwpIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHhoci5vbihcImVycm9yXCIsIGNhbGxiYWNrKS5vbihcImxvYWRcIiwgZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgICAgZGlzcGF0Y2guYmVmb3Jlc2VuZC5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICByZXF1ZXN0LnNlbmQoZGF0YSA9PSBudWxsID8gbnVsbCA6IGRhdGEpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIGQzLnJlYmluZCh4aHIsIGRpc3BhdGNoLCBcIm9uXCIpO1xuICAgIHJldHVybiBjYWxsYmFjayA9PSBudWxsID8geGhyIDogeGhyLmdldChkM194aHJfZml4Q2FsbGJhY2soY2FsbGJhY2spKTtcbiAgfVxuICBmdW5jdGlvbiBkM194aHJfZml4Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY2FsbGJhY2subGVuZ3RoID09PSAxID8gZnVuY3Rpb24oZXJyb3IsIHJlcXVlc3QpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yID09IG51bGwgPyByZXF1ZXN0IDogbnVsbCk7XG4gICAgfSA6IGNhbGxiYWNrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3hockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICB2YXIgdHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgIHJldHVybiB0eXBlICYmIHR5cGUgIT09IFwidGV4dFwiID8gcmVxdWVzdC5yZXNwb25zZSA6IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9XG4gIGQzLmRzdiA9IGZ1bmN0aW9uKGRlbGltaXRlciwgbWltZVR5cGUpIHtcbiAgICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKCdbXCInICsgZGVsaW1pdGVyICsgXCJcXG5dXCIpLCBkZWxpbWl0ZXJDb2RlID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG4gICAgZnVuY3Rpb24gZHN2KHVybCwgcm93LCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBjYWxsYmFjayA9IHJvdywgcm93ID0gbnVsbDtcbiAgICAgIHZhciB4aHIgPSBkM194aHIodXJsLCBtaW1lVHlwZSwgcm93ID09IG51bGwgPyByZXNwb25zZSA6IHR5cGVkUmVzcG9uc2Uocm93KSwgY2FsbGJhY2spO1xuICAgICAgeGhyLnJvdyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB4aHIucmVzcG9uc2UoKHJvdyA9IF8pID09IG51bGwgPyByZXNwb25zZSA6IHR5cGVkUmVzcG9uc2UoXykpIDogcm93O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICAgIHJldHVybiBkc3YucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlZFJlc3BvbnNlKGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBkc3YucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQsIGYpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZHN2LnBhcnNlID0gZnVuY3Rpb24odGV4dCwgZikge1xuICAgICAgdmFyIG87XG4gICAgICByZXR1cm4gZHN2LnBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgICAgaWYgKG8pIHJldHVybiBvKHJvdywgaSAtIDEpO1xuICAgICAgICB2YXIgYSA9IG5ldyBGdW5jdGlvbihcImRcIiwgXCJyZXR1cm4ge1wiICsgcm93Lm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xuICAgICAgICBvID0gZiA/IGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgICAgIHJldHVybiBmKGEocm93KSwgaSk7XG4gICAgICAgIH0gOiBhO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBkc3YucGFyc2VSb3dzID0gZnVuY3Rpb24odGV4dCwgZikge1xuICAgICAgdmFyIEVPTCA9IHt9LCBFT0YgPSB7fSwgcm93cyA9IFtdLCBOID0gdGV4dC5sZW5ndGgsIEkgPSAwLCBuID0gMCwgdCwgZW9sO1xuICAgICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICAgIGlmIChJID49IE4pIHJldHVybiBFT0Y7XG4gICAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuICAgICAgICB2YXIgaiA9IEk7XG4gICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IDM0KSB7XG4gICAgICAgICAgdmFyIGkgPSBqO1xuICAgICAgICAgIHdoaWxlIChpKysgPCBOKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSAzNCkge1xuICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMzQpIGJyZWFrO1xuICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIEkgPSBpICsgMjtcbiAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgaWYgKGMgPT09IDEzKSB7XG4gICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpICsgMikgPT09IDEwKSArK0k7XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAxMCkge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkpLnJlcGxhY2UoL1wiXCIvZywgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSwgayA9IDE7XG4gICAgICAgICAgaWYgKGMgPT09IDEwKSBlb2wgPSB0cnVlOyBlbHNlIGlmIChjID09PSAxMykge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IDEwKSArK0ksICsraztcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgIT09IGRlbGltaXRlckNvZGUpIGNvbnRpbnVlO1xuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIEkgLSBrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHtcbiAgICAgICAgICBhLnB1c2godCk7XG4gICAgICAgICAgdCA9IHRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgJiYgKGEgPSBmKGEsIG4rKykpID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICByb3dzLnB1c2goYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuICAgIGRzdi5mb3JtYXQgPSBmdW5jdGlvbihyb3dzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3dzWzBdKSkgcmV0dXJuIGRzdi5mb3JtYXRSb3dzKHJvd3MpO1xuICAgICAgdmFyIGZpZWxkU2V0ID0gbmV3IGQzX1NldCgpLCBmaWVsZHMgPSBbXTtcbiAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgZm9yICh2YXIgZmllbGQgaW4gcm93KSB7XG4gICAgICAgICAgaWYgKCFmaWVsZFNldC5oYXMoZmllbGQpKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZFNldC5hZGQoZmllbGQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFsgZmllbGRzLm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpIF0uY29uY2F0KHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gZmllbGRzLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbZmllbGRdKTtcbiAgICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgICAgfSkpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBkc3YuZm9ybWF0Um93cyA9IGZ1bmN0aW9uKHJvd3MpIHtcbiAgICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh0ZXh0KSB7XG4gICAgICByZXR1cm4gcmVGb3JtYXQudGVzdCh0ZXh0KSA/ICdcIicgKyB0ZXh0LnJlcGxhY2UoL1xcXCIvZywgJ1wiXCInKSArICdcIicgOiB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZHN2O1xuICB9O1xuICBkMy5jc3YgPSBkMy5kc3YoXCIsXCIsIFwidGV4dC9jc3ZcIik7XG4gIGQzLnRzdiA9IGQzLmRzdihcIlx0XCIsIFwidGV4dC90YWItc2VwYXJhdGVkLXZhbHVlc1wiKTtcbiAgdmFyIGQzX3RpbWVyX3F1ZXVlSGVhZCwgZDNfdGltZXJfcXVldWVUYWlsLCBkM190aW1lcl9pbnRlcnZhbCwgZDNfdGltZXJfdGltZW91dCwgZDNfdGltZXJfYWN0aXZlLCBkM190aW1lcl9mcmFtZSA9IGQzX3dpbmRvd1tkM192ZW5kb3JTeW1ib2woZDNfd2luZG93LCBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiKV0gfHwgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxNyk7XG4gIH07XG4gIGQzLnRpbWVyID0gZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aGVuKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMikgZGVsYXkgPSAwO1xuICAgIGlmIChuIDwgMykgdGhlbiA9IERhdGUubm93KCk7XG4gICAgdmFyIHRpbWUgPSB0aGVuICsgZGVsYXksIHRpbWVyID0ge1xuICAgICAgYzogY2FsbGJhY2ssXG4gICAgICB0OiB0aW1lLFxuICAgICAgZjogZmFsc2UsXG4gICAgICBuOiBudWxsXG4gICAgfTtcbiAgICBpZiAoZDNfdGltZXJfcXVldWVUYWlsKSBkM190aW1lcl9xdWV1ZVRhaWwubiA9IHRpbWVyOyBlbHNlIGQzX3RpbWVyX3F1ZXVlSGVhZCA9IHRpbWVyO1xuICAgIGQzX3RpbWVyX3F1ZXVlVGFpbCA9IHRpbWVyO1xuICAgIGlmICghZDNfdGltZXJfaW50ZXJ2YWwpIHtcbiAgICAgIGQzX3RpbWVyX3RpbWVvdXQgPSBjbGVhclRpbWVvdXQoZDNfdGltZXJfdGltZW91dCk7XG4gICAgICBkM190aW1lcl9pbnRlcnZhbCA9IDE7XG4gICAgICBkM190aW1lcl9mcmFtZShkM190aW1lcl9zdGVwKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RpbWVyX3N0ZXAoKSB7XG4gICAgdmFyIG5vdyA9IGQzX3RpbWVyX21hcmsoKSwgZGVsYXkgPSBkM190aW1lcl9zd2VlcCgpIC0gbm93O1xuICAgIGlmIChkZWxheSA+IDI0KSB7XG4gICAgICBpZiAoaXNGaW5pdGUoZGVsYXkpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkM190aW1lcl90aW1lb3V0KTtcbiAgICAgICAgZDNfdGltZXJfdGltZW91dCA9IHNldFRpbWVvdXQoZDNfdGltZXJfc3RlcCwgZGVsYXkpO1xuICAgICAgfVxuICAgICAgZDNfdGltZXJfaW50ZXJ2YWwgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBkM190aW1lcl9pbnRlcnZhbCA9IDE7XG4gICAgICBkM190aW1lcl9mcmFtZShkM190aW1lcl9zdGVwKTtcbiAgICB9XG4gIH1cbiAgZDMudGltZXIuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICBkM190aW1lcl9tYXJrKCk7XG4gICAgZDNfdGltZXJfc3dlZXAoKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdGltZXJfbWFyaygpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBkM190aW1lcl9hY3RpdmUgPSBkM190aW1lcl9xdWV1ZUhlYWQ7XG4gICAgd2hpbGUgKGQzX3RpbWVyX2FjdGl2ZSkge1xuICAgICAgaWYgKG5vdyA+PSBkM190aW1lcl9hY3RpdmUudCkgZDNfdGltZXJfYWN0aXZlLmYgPSBkM190aW1lcl9hY3RpdmUuYyhub3cgLSBkM190aW1lcl9hY3RpdmUudCk7XG4gICAgICBkM190aW1lcl9hY3RpdmUgPSBkM190aW1lcl9hY3RpdmUubjtcbiAgICB9XG4gICAgcmV0dXJuIG5vdztcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lcl9zd2VlcCgpIHtcbiAgICB2YXIgdDAsIHQxID0gZDNfdGltZXJfcXVldWVIZWFkLCB0aW1lID0gSW5maW5pdHk7XG4gICAgd2hpbGUgKHQxKSB7XG4gICAgICBpZiAodDEuZikge1xuICAgICAgICB0MSA9IHQwID8gdDAubiA9IHQxLm4gOiBkM190aW1lcl9xdWV1ZUhlYWQgPSB0MS5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHQxLnQgPCB0aW1lKSB0aW1lID0gdDEudDtcbiAgICAgICAgdDEgPSAodDAgPSB0MSkubjtcbiAgICAgIH1cbiAgICB9XG4gICAgZDNfdGltZXJfcXVldWVUYWlsID0gdDA7XG4gICAgcmV0dXJuIHRpbWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZm9ybWF0X3ByZWNpc2lvbih4LCBwKSB7XG4gICAgcmV0dXJuIHAgLSAoeCA/IE1hdGguY2VpbChNYXRoLmxvZyh4KSAvIE1hdGguTE4xMCkgOiAxKTtcbiAgfVxuICBkMy5yb3VuZCA9IGZ1bmN0aW9uKHgsIG4pIHtcbiAgICByZXR1cm4gbiA/IE1hdGgucm91bmQoeCAqIChuID0gTWF0aC5wb3coMTAsIG4pKSkgLyBuIDogTWF0aC5yb3VuZCh4KTtcbiAgfTtcbiAgdmFyIGQzX2Zvcm1hdFByZWZpeGVzID0gWyBcInlcIiwgXCJ6XCIsIFwiYVwiLCBcImZcIiwgXCJwXCIsIFwiblwiLCBcIsK1XCIsIFwibVwiLCBcIlwiLCBcImtcIiwgXCJNXCIsIFwiR1wiLCBcIlRcIiwgXCJQXCIsIFwiRVwiLCBcIlpcIiwgXCJZXCIgXS5tYXAoZDNfZm9ybWF0UHJlZml4KTtcbiAgZDMuZm9ybWF0UHJlZml4ID0gZnVuY3Rpb24odmFsdWUsIHByZWNpc2lvbikge1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlICo9IC0xO1xuICAgICAgaWYgKHByZWNpc2lvbikgdmFsdWUgPSBkMy5yb3VuZCh2YWx1ZSwgZDNfZm9ybWF0X3ByZWNpc2lvbih2YWx1ZSwgcHJlY2lzaW9uKSk7XG4gICAgICBpID0gMSArIE1hdGguZmxvb3IoMWUtMTIgKyBNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMTApO1xuICAgICAgaSA9IE1hdGgubWF4KC0yNCwgTWF0aC5taW4oMjQsIE1hdGguZmxvb3IoKGkgLSAxKSAvIDMpICogMykpO1xuICAgIH1cbiAgICByZXR1cm4gZDNfZm9ybWF0UHJlZml4ZXNbOCArIGkgLyAzXTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZm9ybWF0UHJlZml4KGQsIGkpIHtcbiAgICB2YXIgayA9IE1hdGgucG93KDEwLCBhYnMoOCAtIGkpICogMyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlOiBpID4gOCA/IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgLyBrO1xuICAgICAgfSA6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgKiBrO1xuICAgICAgfSxcbiAgICAgIHN5bWJvbDogZFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfbG9jYWxlX251bWJlckZvcm1hdChsb2NhbGUpIHtcbiAgICB2YXIgbG9jYWxlX2RlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbCwgbG9jYWxlX3Rob3VzYW5kcyA9IGxvY2FsZS50aG91c2FuZHMsIGxvY2FsZV9ncm91cGluZyA9IGxvY2FsZS5ncm91cGluZywgbG9jYWxlX2N1cnJlbmN5ID0gbG9jYWxlLmN1cnJlbmN5LCBmb3JtYXRHcm91cCA9IGxvY2FsZV9ncm91cGluZyAmJiBsb2NhbGVfdGhvdXNhbmRzID8gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCwgdCA9IFtdLCBqID0gMCwgZyA9IGxvY2FsZV9ncm91cGluZ1swXSwgbGVuZ3RoID0gMDtcbiAgICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgICAgZyA9IGxvY2FsZV9ncm91cGluZ1tqID0gKGogKyAxKSAlIGxvY2FsZV9ncm91cGluZy5sZW5ndGhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4obG9jYWxlX3Rob3VzYW5kcyk7XG4gICAgfSA6IGQzX2lkZW50aXR5O1xuICAgIHJldHVybiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBtYXRjaCA9IGQzX2Zvcm1hdF9yZS5leGVjKHNwZWNpZmllciksIGZpbGwgPSBtYXRjaFsxXSB8fCBcIiBcIiwgYWxpZ24gPSBtYXRjaFsyXSB8fCBcIj5cIiwgc2lnbiA9IG1hdGNoWzNdIHx8IFwiLVwiLCBzeW1ib2wgPSBtYXRjaFs0XSB8fCBcIlwiLCB6ZmlsbCA9IG1hdGNoWzVdLCB3aWR0aCA9ICttYXRjaFs2XSwgY29tbWEgPSBtYXRjaFs3XSwgcHJlY2lzaW9uID0gbWF0Y2hbOF0sIHR5cGUgPSBtYXRjaFs5XSwgc2NhbGUgPSAxLCBwcmVmaXggPSBcIlwiLCBzdWZmaXggPSBcIlwiLCBpbnRlZ2VyID0gZmFsc2UsIGV4cG9uZW50ID0gdHJ1ZTtcbiAgICAgIGlmIChwcmVjaXNpb24pIHByZWNpc2lvbiA9ICtwcmVjaXNpb24uc3Vic3RyaW5nKDEpO1xuICAgICAgaWYgKHpmaWxsIHx8IGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikge1xuICAgICAgICB6ZmlsbCA9IGZpbGwgPSBcIjBcIjtcbiAgICAgICAgYWxpZ24gPSBcIj1cIjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgIGNvbW1hID0gdHJ1ZTtcbiAgICAgICAgdHlwZSA9IFwiZ1wiO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIHNjYWxlID0gMTAwO1xuICAgICAgICBzdWZmaXggPSBcIiVcIjtcbiAgICAgICAgdHlwZSA9IFwiZlwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJwXCI6XG4gICAgICAgIHNjYWxlID0gMTAwO1xuICAgICAgICBzdWZmaXggPSBcIiVcIjtcbiAgICAgICAgdHlwZSA9IFwiclwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJiXCI6XG4gICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICBjYXNlIFwieFwiOlxuICAgICAgIGNhc2UgXCJYXCI6XG4gICAgICAgIGlmIChzeW1ib2wgPT09IFwiI1wiKSBwcmVmaXggPSBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIGV4cG9uZW50ID0gZmFsc2U7XG5cbiAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICBpbnRlZ2VyID0gdHJ1ZTtcbiAgICAgICAgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICBzY2FsZSA9IC0xO1xuICAgICAgICB0eXBlID0gXCJyXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN5bWJvbCA9PT0gXCIkXCIpIHByZWZpeCA9IGxvY2FsZV9jdXJyZW5jeVswXSwgc3VmZml4ID0gbG9jYWxlX2N1cnJlbmN5WzFdO1xuICAgICAgaWYgKHR5cGUgPT0gXCJyXCIgJiYgIXByZWNpc2lvbikgdHlwZSA9IFwiZ1wiO1xuICAgICAgaWYgKHByZWNpc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlID09IFwiZ1wiKSBwcmVjaXNpb24gPSBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSk7IGVsc2UgaWYgKHR5cGUgPT0gXCJlXCIgfHwgdHlwZSA9PSBcImZcIikgcHJlY2lzaW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuICAgICAgfVxuICAgICAgdHlwZSA9IGQzX2Zvcm1hdF90eXBlcy5nZXQodHlwZSkgfHwgZDNfZm9ybWF0X3R5cGVEZWZhdWx0O1xuICAgICAgdmFyIHpjb21tYSA9IHpmaWxsICYmIGNvbW1hO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBmdWxsU3VmZml4ID0gc3VmZml4O1xuICAgICAgICBpZiAoaW50ZWdlciAmJiB2YWx1ZSAlIDEpIHJldHVybiBcIlwiO1xuICAgICAgICB2YXIgbmVnYXRpdmUgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/ICh2YWx1ZSA9IC12YWx1ZSwgXCItXCIpIDogc2lnbiA9PT0gXCItXCIgPyBcIlwiIDogc2lnbjtcbiAgICAgICAgaWYgKHNjYWxlIDwgMCkge1xuICAgICAgICAgIHZhciB1bml0ID0gZDMuZm9ybWF0UHJlZml4KHZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgICAgIHZhbHVlID0gdW5pdC5zY2FsZSh2YWx1ZSk7XG4gICAgICAgICAgZnVsbFN1ZmZpeCA9IHVuaXQuc3ltYm9sICsgc3VmZml4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICo9IHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdHlwZSh2YWx1ZSwgcHJlY2lzaW9uKTtcbiAgICAgICAgdmFyIGkgPSB2YWx1ZS5sYXN0SW5kZXhPZihcIi5cIiksIGJlZm9yZSwgYWZ0ZXI7XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgIHZhciBqID0gZXhwb25lbnQgPyB2YWx1ZS5sYXN0SW5kZXhPZihcImVcIikgOiAtMTtcbiAgICAgICAgICBpZiAoaiA8IDApIGJlZm9yZSA9IHZhbHVlLCBhZnRlciA9IFwiXCI7IGVsc2UgYmVmb3JlID0gdmFsdWUuc3Vic3RyaW5nKDAsIGopLCBhZnRlciA9IHZhbHVlLnN1YnN0cmluZyhqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZWZvcmUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgICAgYWZ0ZXIgPSBsb2NhbGVfZGVjaW1hbCArIHZhbHVlLnN1YnN0cmluZyhpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6ZmlsbCAmJiBjb21tYSkgYmVmb3JlID0gZm9ybWF0R3JvdXAoYmVmb3JlLCBJbmZpbml0eSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgYmVmb3JlLmxlbmd0aCArIGFmdGVyLmxlbmd0aCArICh6Y29tbWEgPyAwIDogbmVnYXRpdmUubGVuZ3RoKSwgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KGxlbmd0aCA9IHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG4gICAgICAgIGlmICh6Y29tbWEpIGJlZm9yZSA9IGZvcm1hdEdyb3VwKHBhZGRpbmcgKyBiZWZvcmUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSBhZnRlci5sZW5ndGggOiBJbmZpbml0eSk7XG4gICAgICAgIG5lZ2F0aXZlICs9IHByZWZpeDtcbiAgICAgICAgdmFsdWUgPSBiZWZvcmUgKyBhZnRlcjtcbiAgICAgICAgcmV0dXJuIChhbGlnbiA9PT0gXCI8XCIgPyBuZWdhdGl2ZSArIHZhbHVlICsgcGFkZGluZyA6IGFsaWduID09PSBcIj5cIiA/IHBhZGRpbmcgKyBuZWdhdGl2ZSArIHZhbHVlIDogYWxpZ24gPT09IFwiXlwiID8gcGFkZGluZy5zdWJzdHJpbmcoMCwgbGVuZ3RoID4+PSAxKSArIG5lZ2F0aXZlICsgdmFsdWUgKyBwYWRkaW5nLnN1YnN0cmluZyhsZW5ndGgpIDogbmVnYXRpdmUgKyAoemNvbW1hID8gdmFsdWUgOiBwYWRkaW5nICsgdmFsdWUpKSArIGZ1bGxTdWZmaXg7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX2Zvcm1hdF9yZSA9IC8oPzooW157XSk/KFs8Pj1eXSkpPyhbK1xcLSBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLi0/XFxkKyk/KFthLXolXSk/L2k7XG4gIHZhciBkM19mb3JtYXRfdHlwZXMgPSBkMy5tYXAoe1xuICAgIGI6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDIpO1xuICAgIH0sXG4gICAgYzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geC50b1N0cmluZyg4KTtcbiAgICB9LFxuICAgIHg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDE2KTtcbiAgICB9LFxuICAgIFg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG4gICAgZzogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuIHgudG9QcmVjaXNpb24ocCk7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4geC50b0V4cG9uZW50aWFsKHApO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChwKTtcbiAgICB9LFxuICAgIHI6IGZ1bmN0aW9uKHgsIHApIHtcbiAgICAgIHJldHVybiAoeCA9IGQzLnJvdW5kKHgsIGQzX2Zvcm1hdF9wcmVjaXNpb24oeCwgcCkpKS50b0ZpeGVkKE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBkM19mb3JtYXRfcHJlY2lzaW9uKHggKiAoMSArIDFlLTE1KSwgcCkpKSk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gZDNfZm9ybWF0X3R5cGVEZWZhdWx0KHgpIHtcbiAgICByZXR1cm4geCArIFwiXCI7XG4gIH1cbiAgdmFyIGQzX3RpbWUgPSBkMy50aW1lID0ge30sIGQzX2RhdGUgPSBEYXRlO1xuICBmdW5jdGlvbiBkM19kYXRlX3V0YygpIHtcbiAgICB0aGlzLl8gPSBuZXcgRGF0ZShhcmd1bWVudHMubGVuZ3RoID4gMSA/IERhdGUuVVRDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF0pO1xuICB9XG4gIGQzX2RhdGVfdXRjLnByb3RvdHlwZSA9IHtcbiAgICBnZXREYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDRGF0ZSgpO1xuICAgIH0sXG4gICAgZ2V0RGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDRGF5KCk7XG4gICAgfSxcbiAgICBnZXRGdWxsWWVhcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgfSxcbiAgICBnZXRIb3VyczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ0hvdXJzKCk7XG4gICAgfSxcbiAgICBnZXRNaWxsaXNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICB9LFxuICAgIGdldE1pbnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENNaW51dGVzKCk7XG4gICAgfSxcbiAgICBnZXRNb250aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ01vbnRoKCk7XG4gICAgfSxcbiAgICBnZXRTZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDU2Vjb25kcygpO1xuICAgIH0sXG4gICAgZ2V0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFRpbWUoKTtcbiAgICB9LFxuICAgIGdldFRpbWV6b25lT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLnZhbHVlT2YoKTtcbiAgICB9LFxuICAgIHNldERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDRGF0ZS5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXREYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDRGF5LmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldEZ1bGxZZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ0Z1bGxZZWFyLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldEhvdXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ0hvdXJzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldE1pbGxpc2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENNaWxsaXNlY29uZHMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0TWludXRlczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENNaW51dGVzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldE1vbnRoOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ01vbnRoLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldFNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDU2Vjb25kcy5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFRpbWUuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGQzX3RpbWVfcHJvdG90eXBlID0gRGF0ZS5wcm90b3R5cGU7XG4gIGZ1bmN0aW9uIGQzX3RpbWVfaW50ZXJ2YWwobG9jYWwsIHN0ZXAsIG51bWJlcikge1xuICAgIGZ1bmN0aW9uIHJvdW5kKGRhdGUpIHtcbiAgICAgIHZhciBkMCA9IGxvY2FsKGRhdGUpLCBkMSA9IG9mZnNldChkMCwgMSk7XG4gICAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VpbChkYXRlKSB7XG4gICAgICBzdGVwKGRhdGUgPSBsb2NhbChuZXcgZDNfZGF0ZShkYXRlIC0gMSkpLCAxKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvZmZzZXQoZGF0ZSwgaykge1xuICAgICAgc3RlcChkYXRlID0gbmV3IGQzX2RhdGUoK2RhdGUpLCBrKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5nZSh0MCwgdDEsIGR0KSB7XG4gICAgICB2YXIgdGltZSA9IGNlaWwodDApLCB0aW1lcyA9IFtdO1xuICAgICAgaWYgKGR0ID4gMSkge1xuICAgICAgICB3aGlsZSAodGltZSA8IHQxKSB7XG4gICAgICAgICAgaWYgKCEobnVtYmVyKHRpbWUpICUgZHQpKSB0aW1lcy5wdXNoKG5ldyBEYXRlKCt0aW1lKSk7XG4gICAgICAgICAgc3RlcCh0aW1lLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHRpbWUgPCB0MSkgdGltZXMucHVzaChuZXcgRGF0ZSgrdGltZSkpLCBzdGVwKHRpbWUsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpbWVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5nZV91dGModDAsIHQxLCBkdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICB2YXIgdXRjID0gbmV3IGQzX2RhdGVfdXRjKCk7XG4gICAgICAgIHV0Yy5fID0gdDA7XG4gICAgICAgIHJldHVybiByYW5nZSh1dGMsIHQxLCBkdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9jYWwuZmxvb3IgPSBsb2NhbDtcbiAgICBsb2NhbC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvY2FsLmNlaWwgPSBjZWlsO1xuICAgIGxvY2FsLm9mZnNldCA9IG9mZnNldDtcbiAgICBsb2NhbC5yYW5nZSA9IHJhbmdlO1xuICAgIHZhciB1dGMgPSBsb2NhbC51dGMgPSBkM190aW1lX2ludGVydmFsX3V0Yyhsb2NhbCk7XG4gICAgdXRjLmZsb29yID0gdXRjO1xuICAgIHV0Yy5yb3VuZCA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKHJvdW5kKTtcbiAgICB1dGMuY2VpbCA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKGNlaWwpO1xuICAgIHV0Yy5vZmZzZXQgPSBkM190aW1lX2ludGVydmFsX3V0YyhvZmZzZXQpO1xuICAgIHV0Yy5yYW5nZSA9IHJhbmdlX3V0YztcbiAgICByZXR1cm4gbG9jYWw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9pbnRlcnZhbF91dGMobWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUsIGspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQzX2RhdGUgPSBkM19kYXRlX3V0YztcbiAgICAgICAgdmFyIHV0YyA9IG5ldyBkM19kYXRlX3V0YygpO1xuICAgICAgICB1dGMuXyA9IGRhdGU7XG4gICAgICAgIHJldHVybiBtZXRob2QodXRjLCBrKS5fO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkM190aW1lLnllYXIgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlID0gZDNfdGltZS5kYXkoZGF0ZSk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfSk7XG4gIGQzX3RpbWUueWVhcnMgPSBkM190aW1lLnllYXIucmFuZ2U7XG4gIGQzX3RpbWUueWVhcnMudXRjID0gZDNfdGltZS55ZWFyLnV0Yy5yYW5nZTtcbiAgZDNfdGltZS5kYXkgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgZGF5ID0gbmV3IGQzX2RhdGUoMmUzLCAwKTtcbiAgICBkYXkuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICByZXR1cm4gZGF5O1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbiAgfSk7XG4gIGQzX3RpbWUuZGF5cyA9IGQzX3RpbWUuZGF5LnJhbmdlO1xuICBkM190aW1lLmRheXMudXRjID0gZDNfdGltZS5kYXkudXRjLnJhbmdlO1xuICBkM190aW1lLmRheU9mWWVhciA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgeWVhciA9IGQzX3RpbWUueWVhcihkYXRlKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZSAtIHllYXIgLSAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC0geWVhci5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA4NjRlNSk7XG4gIH07XG4gIFsgXCJzdW5kYXlcIiwgXCJtb25kYXlcIiwgXCJ0dWVzZGF5XCIsIFwid2VkbmVzZGF5XCIsIFwidGh1cnNkYXlcIiwgXCJmcmlkYXlcIiwgXCJzYXR1cmRheVwiIF0uZm9yRWFjaChmdW5jdGlvbihkYXksIGkpIHtcbiAgICBpID0gNyAtIGk7XG4gICAgdmFyIGludGVydmFsID0gZDNfdGltZVtkYXldID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICAoZGF0ZSA9IGQzX3RpbWUuZGF5KGRhdGUpKS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyBpKSAlIDcpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBNYXRoLmZsb29yKG9mZnNldCkgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZGF5ID0gZDNfdGltZS55ZWFyKGRhdGUpLmdldERheSgpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGQzX3RpbWUuZGF5T2ZZZWFyKGRhdGUpICsgKGRheSArIGkpICUgNykgLyA3KSAtIChkYXkgIT09IGkpO1xuICAgIH0pO1xuICAgIGQzX3RpbWVbZGF5ICsgXCJzXCJdID0gaW50ZXJ2YWwucmFuZ2U7XG4gICAgZDNfdGltZVtkYXkgKyBcInNcIl0udXRjID0gaW50ZXJ2YWwudXRjLnJhbmdlO1xuICAgIGQzX3RpbWVbZGF5ICsgXCJPZlllYXJcIl0gPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZGF5ID0gZDNfdGltZS55ZWFyKGRhdGUpLmdldERheSgpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGQzX3RpbWUuZGF5T2ZZZWFyKGRhdGUpICsgKGRheSArIGkpICUgNykgLyA3KTtcbiAgICB9O1xuICB9KTtcbiAgZDNfdGltZS53ZWVrID0gZDNfdGltZS5zdW5kYXk7XG4gIGQzX3RpbWUud2Vla3MgPSBkM190aW1lLnN1bmRheS5yYW5nZTtcbiAgZDNfdGltZS53ZWVrcy51dGMgPSBkM190aW1lLnN1bmRheS51dGMucmFuZ2U7XG4gIGQzX3RpbWUud2Vla09mWWVhciA9IGQzX3RpbWUuc3VuZGF5T2ZZZWFyO1xuICBmdW5jdGlvbiBkM19sb2NhbGVfdGltZUZvcm1hdChsb2NhbGUpIHtcbiAgICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLCBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLCBsb2NhbGVfdGltZSA9IGxvY2FsZS50aW1lLCBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLCBsb2NhbGVfZGF5cyA9IGxvY2FsZS5kYXlzLCBsb2NhbGVfc2hvcnREYXlzID0gbG9jYWxlLnNob3J0RGF5cywgbG9jYWxlX21vbnRocyA9IGxvY2FsZS5tb250aHMsIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcbiAgICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdCh0ZW1wbGF0ZSkge1xuICAgICAgdmFyIG4gPSB0ZW1wbGF0ZS5sZW5ndGg7XG4gICAgICBmdW5jdGlvbiBmb3JtYXQoZGF0ZSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gW10sIGkgPSAtMSwgaiA9IDAsIGMsIHAsIGY7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaCh0ZW1wbGF0ZS5zbGljZShqLCBpKSk7XG4gICAgICAgICAgICBpZiAoKHAgPSBkM190aW1lX2Zvcm1hdFBhZHNbYyA9IHRlbXBsYXRlLmNoYXJBdCgrK2kpXSkgIT0gbnVsbCkgYyA9IHRlbXBsYXRlLmNoYXJBdCgrK2kpO1xuICAgICAgICAgICAgaWYgKGYgPSBkM190aW1lX2Zvcm1hdHNbY10pIGMgPSBmKGRhdGUsIHAgPT0gbnVsbCA/IGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIiA6IHApO1xuICAgICAgICAgICAgc3RyaW5nLnB1c2goYyk7XG4gICAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmluZy5wdXNoKHRlbXBsYXRlLnNsaWNlKGosIGkpKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgZm9ybWF0LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHZhciBkID0ge1xuICAgICAgICAgIHk6IDE5MDAsXG4gICAgICAgICAgbTogMCxcbiAgICAgICAgICBkOiAxLFxuICAgICAgICAgIEg6IDAsXG4gICAgICAgICAgTTogMCxcbiAgICAgICAgICBTOiAwLFxuICAgICAgICAgIEw6IDAsXG4gICAgICAgICAgWjogbnVsbFxuICAgICAgICB9LCBpID0gZDNfdGltZV9wYXJzZShkLCB0ZW1wbGF0ZSwgc3RyaW5nLCAwKTtcbiAgICAgICAgaWYgKGkgIT0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xuICAgICAgICB2YXIgbG9jYWxaID0gZC5aICE9IG51bGwgJiYgZDNfZGF0ZSAhPT0gZDNfZGF0ZV91dGMsIGRhdGUgPSBuZXcgKGxvY2FsWiA/IGQzX2RhdGVfdXRjIDogZDNfZGF0ZSkoKTtcbiAgICAgICAgaWYgKFwialwiIGluIGQpIGRhdGUuc2V0RnVsbFllYXIoZC55LCAwLCBkLmopOyBlbHNlIGlmIChcIndcIiBpbiBkICYmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpKSB7XG4gICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkLnksIDAsIDEpO1xuICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoZC55LCAwLCBcIldcIiBpbiBkID8gKGQudyArIDYpICUgNyArIGQuVyAqIDcgLSAoZGF0ZS5nZXREYXkoKSArIDUpICUgNyA6IGQudyArIGQuVSAqIDcgLSAoZGF0ZS5nZXREYXkoKSArIDYpICUgNyk7XG4gICAgICAgIH0gZWxzZSBkYXRlLnNldEZ1bGxZZWFyKGQueSwgZC5tLCBkLmQpO1xuICAgICAgICBkYXRlLnNldEhvdXJzKGQuSCArIChkLlogLyAxMDAgfCAwKSwgZC5NICsgZC5aICUgMTAwLCBkLlMsIGQuTCk7XG4gICAgICAgIHJldHVybiBsb2NhbFogPyBkYXRlLl8gOiBkYXRlO1xuICAgICAgfTtcbiAgICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZShkYXRlLCB0ZW1wbGF0ZSwgc3RyaW5nLCBqKSB7XG4gICAgICB2YXIgYywgcCwgdCwgaSA9IDAsIG4gPSB0ZW1wbGF0ZS5sZW5ndGgsIG0gPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgICAgYyA9IHRlbXBsYXRlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgICAgdCA9IHRlbXBsYXRlLmNoYXJBdChpKyspO1xuICAgICAgICAgIHAgPSBkM190aW1lX3BhcnNlcnNbdCBpbiBkM190aW1lX2Zvcm1hdFBhZHMgPyB0ZW1wbGF0ZS5jaGFyQXQoaSsrKSA6IHRdO1xuICAgICAgICAgIGlmICghcCB8fCAoaiA9IHAoZGF0ZSwgc3RyaW5nLCBqKSkgPCAwKSByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gajtcbiAgICB9XG4gICAgZDNfdGltZV9mb3JtYXQudXRjID0gZnVuY3Rpb24odGVtcGxhdGUpIHtcbiAgICAgIHZhciBsb2NhbCA9IGQzX3RpbWVfZm9ybWF0KHRlbXBsYXRlKTtcbiAgICAgIGZ1bmN0aW9uIGZvcm1hdChkYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICAgIHZhciB1dGMgPSBuZXcgZDNfZGF0ZSgpO1xuICAgICAgICAgIHV0Yy5fID0gZGF0ZTtcbiAgICAgICAgICByZXR1cm4gbG9jYWwodXRjKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9ybWF0LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICAgIHZhciBkYXRlID0gbG9jYWwucGFyc2Uoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZSAmJiBkYXRlLl87XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3JtYXQudG9TdHJpbmcgPSBsb2NhbC50b1N0cmluZztcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfTtcbiAgICBkM190aW1lX2Zvcm1hdC5tdWx0aSA9IGQzX3RpbWVfZm9ybWF0LnV0Yy5tdWx0aSA9IGQzX3RpbWVfZm9ybWF0TXVsdGk7XG4gICAgdmFyIGQzX3RpbWVfcGVyaW9kTG9va3VwID0gZDMubWFwKCksIGQzX3RpbWVfZGF5UmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9kYXlzKSwgZDNfdGltZV9kYXlMb29rdXAgPSBkM190aW1lX2Zvcm1hdExvb2t1cChsb2NhbGVfZGF5cyksIGQzX3RpbWVfZGF5QWJicmV2UmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9zaG9ydERheXMpLCBkM190aW1lX2RheUFiYnJldkxvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydERheXMpLCBkM190aW1lX21vbnRoUmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9tb250aHMpLCBkM190aW1lX21vbnRoTG9va3VwID0gZDNfdGltZV9mb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksIGQzX3RpbWVfbW9udGhBYmJyZXZSZSA9IGQzX3RpbWVfZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSwgZDNfdGltZV9tb250aEFiYnJldkxvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydE1vbnRocyk7XG4gICAgbG9jYWxlX3BlcmlvZHMuZm9yRWFjaChmdW5jdGlvbihwLCBpKSB7XG4gICAgICBkM190aW1lX3BlcmlvZExvb2t1cC5zZXQocC50b0xvd2VyQ2FzZSgpLCBpKTtcbiAgICB9KTtcbiAgICB2YXIgZDNfdGltZV9mb3JtYXRzID0ge1xuICAgICAgYTogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX3Nob3J0RGF5c1tkLmdldERheSgpXTtcbiAgICAgIH0sXG4gICAgICBBOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfZGF5c1tkLmdldERheSgpXTtcbiAgICAgIH0sXG4gICAgICBiOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgICAgIH0sXG4gICAgICBCOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgICB9LFxuICAgICAgYzogZDNfdGltZV9mb3JtYXQobG9jYWxlX2RhdGVUaW1lKSxcbiAgICAgIGQ6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBlOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldERhdGUoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgSDogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBJOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gICAgICB9LFxuICAgICAgajogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoMSArIGQzX3RpbWUuZGF5T2ZZZWFyKGQpLCBwLCAzKTtcbiAgICAgIH0sXG4gICAgICBMOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1pbGxpc2Vjb25kcygpLCBwLCAzKTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBNOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1pbnV0ZXMoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgcDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgICAgIH0sXG4gICAgICBTOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgVTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZDNfdGltZS5zdW5kYXlPZlllYXIoZCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0RGF5KCk7XG4gICAgICB9LFxuICAgICAgVzogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZDNfdGltZS5tb25kYXlPZlllYXIoZCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIHg6IGQzX3RpbWVfZm9ybWF0KGxvY2FsZV9kYXRlKSxcbiAgICAgIFg6IGQzX3RpbWVfZm9ybWF0KGxvY2FsZV90aW1lKSxcbiAgICAgIHk6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG4gICAgICB9LFxuICAgICAgWTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRGdWxsWWVhcigpICUgMWU0LCBwLCA0KTtcbiAgICAgIH0sXG4gICAgICBaOiBkM190aW1lX3pvbmUsXG4gICAgICBcIiVcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIiVcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkM190aW1lX3BhcnNlcnMgPSB7XG4gICAgICBhOiBkM190aW1lX3BhcnNlV2Vla2RheUFiYnJldixcbiAgICAgIEE6IGQzX3RpbWVfcGFyc2VXZWVrZGF5LFxuICAgICAgYjogZDNfdGltZV9wYXJzZU1vbnRoQWJicmV2LFxuICAgICAgQjogZDNfdGltZV9wYXJzZU1vbnRoLFxuICAgICAgYzogZDNfdGltZV9wYXJzZUxvY2FsZUZ1bGwsXG4gICAgICBkOiBkM190aW1lX3BhcnNlRGF5LFxuICAgICAgZTogZDNfdGltZV9wYXJzZURheSxcbiAgICAgIEg6IGQzX3RpbWVfcGFyc2VIb3VyMjQsXG4gICAgICBJOiBkM190aW1lX3BhcnNlSG91cjI0LFxuICAgICAgajogZDNfdGltZV9wYXJzZURheU9mWWVhcixcbiAgICAgIEw6IGQzX3RpbWVfcGFyc2VNaWxsaXNlY29uZHMsXG4gICAgICBtOiBkM190aW1lX3BhcnNlTW9udGhOdW1iZXIsXG4gICAgICBNOiBkM190aW1lX3BhcnNlTWludXRlcyxcbiAgICAgIHA6IGQzX3RpbWVfcGFyc2VBbVBtLFxuICAgICAgUzogZDNfdGltZV9wYXJzZVNlY29uZHMsXG4gICAgICBVOiBkM190aW1lX3BhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICAgIHc6IGQzX3RpbWVfcGFyc2VXZWVrZGF5TnVtYmVyLFxuICAgICAgVzogZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJNb25kYXksXG4gICAgICB4OiBkM190aW1lX3BhcnNlTG9jYWxlRGF0ZSxcbiAgICAgIFg6IGQzX3RpbWVfcGFyc2VMb2NhbGVUaW1lLFxuICAgICAgeTogZDNfdGltZV9wYXJzZVllYXIsXG4gICAgICBZOiBkM190aW1lX3BhcnNlRnVsbFllYXIsXG4gICAgICBaOiBkM190aW1lX3BhcnNlWm9uZSxcbiAgICAgIFwiJVwiOiBkM190aW1lX3BhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5QWJicmV2KGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9kYXlBYmJyZXZSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX2RheUFiYnJldlJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUudyA9IGQzX3RpbWVfZGF5QWJicmV2TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9kYXlSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUudyA9IGQzX3RpbWVfZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNb250aEFiYnJldihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIGQzX3RpbWVfbW9udGhBYmJyZXZSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX21vbnRoQWJicmV2UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZGF0ZS5tID0gZDNfdGltZV9tb250aEFiYnJldkxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTW9udGgoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICBkM190aW1lX21vbnRoUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuID0gZDNfdGltZV9tb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUubSA9IGQzX3RpbWVfbW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUxvY2FsZUZ1bGwoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9wYXJzZShkYXRlLCBkM190aW1lX2Zvcm1hdHMuYy50b1N0cmluZygpLCBzdHJpbmcsIGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTG9jYWxlRGF0ZShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3BhcnNlKGRhdGUsIGQzX3RpbWVfZm9ybWF0cy54LnRvU3RyaW5nKCksIHN0cmluZywgaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VMb2NhbGVUaW1lKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfcGFyc2UoZGF0ZSwgZDNfdGltZV9mb3JtYXRzLlgudG9TdHJpbmcoKSwgc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUFtUG0oZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfcGVyaW9kTG9va3VwLmdldChzdHJpbmcuc2xpY2UoaSwgaSArPSAyKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIHJldHVybiBuID09IG51bGwgPyAtMSA6IChkYXRlLnAgPSBuLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0O1xuICB9XG4gIHZhciBkM190aW1lX2Zvcm1hdFBhZHMgPSB7XG4gICAgXCItXCI6IFwiXCIsXG4gICAgXzogXCIgXCIsXG4gICAgXCIwXCI6IFwiMFwiXG4gIH0sIGQzX3RpbWVfbnVtYmVyUmUgPSAvXlxccypcXGQrLywgZDNfdGltZV9wZXJjZW50UmUgPSAvXiUvO1xuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdFBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIiwgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRSZShuYW1lcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKGQzLnJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdExvb2t1cChuYW1lcykge1xuICAgIHZhciBtYXAgPSBuZXcgZDNfTWFwKCksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgbWFwLnNldChuYW1lc1tpXS50b0xvd2VyQ2FzZSgpLCBpKTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5TnVtYmVyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGRhdGUuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJNb25kYXkoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlRnVsbFllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICAgIHJldHVybiBuID8gKGRhdGUueSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUueSA9IGQzX3RpbWVfZXhwYW5kWWVhcigrblswXSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlWm9uZShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gL15bKy1dXFxkezR9JC8udGVzdChzdHJpbmcgPSBzdHJpbmcuc2xpY2UoaSwgaSArIDUpKSA/IChkYXRlLlogPSAtc3RyaW5nLCBcbiAgICBpICsgNSkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2V4cGFuZFllYXIoZCkge1xuICAgIHJldHVybiBkICsgKGQgPiA2OCA/IDE5MDAgOiAyZTMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNb250aE51bWJlcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlRGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VEYXlPZlllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICAgIHJldHVybiBuID8gKGRhdGUuaiA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUhvdXIyNChkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTWludXRlcyhkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5NID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlU2Vjb25kcyhkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5TID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTWlsbGlzZWNvbmRzKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfem9uZShkKSB7XG4gICAgdmFyIHogPSBkLmdldFRpbWV6b25lT2Zmc2V0KCksIHpzID0geiA+IDAgPyBcIi1cIiA6IFwiK1wiLCB6aCA9IGFicyh6KSAvIDYwIHwgMCwgem0gPSBhYnMoeikgJSA2MDtcbiAgICByZXR1cm4genMgKyBkM190aW1lX2Zvcm1hdFBhZCh6aCwgXCIwXCIsIDIpICsgZDNfdGltZV9mb3JtYXRQYWQoem0sIFwiMFwiLCAyKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTGl0ZXJhbFBlcmNlbnQoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9wZXJjZW50UmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfcGVyY2VudFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyBpICsgblswXS5sZW5ndGggOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdE11bHRpKGZvcm1hdHMpIHtcbiAgICB2YXIgbiA9IGZvcm1hdHMubGVuZ3RoLCBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IG4pIGZvcm1hdHNbaV1bMF0gPSB0aGlzKGZvcm1hdHNbaV1bMF0pO1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgaSA9IDAsIGYgPSBmb3JtYXRzW2ldO1xuICAgICAgd2hpbGUgKCFmWzFdKGRhdGUpKSBmID0gZm9ybWF0c1srK2ldO1xuICAgICAgcmV0dXJuIGZbMF0oZGF0ZSk7XG4gICAgfTtcbiAgfVxuICBkMy5sb2NhbGUgPSBmdW5jdGlvbihsb2NhbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyRm9ybWF0OiBkM19sb2NhbGVfbnVtYmVyRm9ybWF0KGxvY2FsZSksXG4gICAgICB0aW1lRm9ybWF0OiBkM19sb2NhbGVfdGltZUZvcm1hdChsb2NhbGUpXG4gICAgfTtcbiAgfTtcbiAgdmFyIGQzX2xvY2FsZV9lblVTID0gZDMubG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbIDMgXSxcbiAgICBjdXJyZW5jeTogWyBcIiRcIiwgXCJcIiBdLFxuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlbS8lZC8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbIFwiQU1cIiwgXCJQTVwiIF0sXG4gICAgZGF5czogWyBcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIgXSxcbiAgICBzaG9ydERheXM6IFsgXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiBdLFxuICAgIG1vbnRoczogWyBcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCIgXSxcbiAgICBzaG9ydE1vbnRoczogWyBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiIF1cbiAgfSk7XG4gIGQzLmZvcm1hdCA9IGQzX2xvY2FsZV9lblVTLm51bWJlckZvcm1hdDtcbiAgZDMuZ2VvID0ge307XG4gIGZ1bmN0aW9uIGQzX2FkZGVyKCkge31cbiAgZDNfYWRkZXIucHJvdG90eXBlID0ge1xuICAgIHM6IDAsXG4gICAgdDogMCxcbiAgICBhZGQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgIGQzX2FkZGVyU3VtKHksIHRoaXMudCwgZDNfYWRkZXJUZW1wKTtcbiAgICAgIGQzX2FkZGVyU3VtKGQzX2FkZGVyVGVtcC5zLCB0aGlzLnMsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMucykgdGhpcy50ICs9IGQzX2FkZGVyVGVtcC50OyBlbHNlIHRoaXMucyA9IGQzX2FkZGVyVGVtcC50O1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zID0gdGhpcy50ID0gMDtcbiAgICB9LFxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucztcbiAgICB9XG4gIH07XG4gIHZhciBkM19hZGRlclRlbXAgPSBuZXcgZDNfYWRkZXIoKTtcbiAgZnVuY3Rpb24gZDNfYWRkZXJTdW0oYSwgYiwgbykge1xuICAgIHZhciB4ID0gby5zID0gYSArIGIsIGJ2ID0geCAtIGEsIGF2ID0geCAtIGJ2O1xuICAgIG8udCA9IGEgLSBhdiArIChiIC0gYnYpO1xuICB9XG4gIGQzLmdlby5zdHJlYW0gPSBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgaWYgKG9iamVjdCAmJiBkM19nZW9fc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KG9iamVjdCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGdlb21ldHJ5LCBsaXN0ZW5lcikge1xuICAgIGlmIChnZW9tZXRyeSAmJiBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgICBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIHZhciBkM19nZW9fc3RyZWFtT2JqZWN0VHlwZSA9IHtcbiAgICBGZWF0dXJlOiBmdW5jdGlvbihmZWF0dXJlLCBsaXN0ZW5lcikge1xuICAgICAgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG4gIHZhciBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICAgIFNwaGVyZTogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIuc3BoZXJlKCk7XG4gICAgfSxcbiAgICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0LmNvb3JkaW5hdGVzO1xuICAgICAgbGlzdGVuZXIucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgfSxcbiAgICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgfSxcbiAgICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICBkM19nZW9fc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIGxpc3RlbmVyLCAwKTtcbiAgICB9LFxuICAgIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLCAwKTtcbiAgICB9LFxuICAgIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cmllc1tpXSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3N0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIGxpc3RlbmVyLCBjbG9zZWQpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgIHdoaWxlICgrK2kgPCBuKSBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xuICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgbGlzdGVuZXIpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIsIDEpO1xuICAgIGxpc3RlbmVyLnBvbHlnb25FbmQoKTtcbiAgfVxuICBkMy5nZW8uYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19hcmVhU3VtID0gMDtcbiAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgZDNfZ2VvX2FyZWEpO1xuICAgIHJldHVybiBkM19nZW9fYXJlYVN1bTtcbiAgfTtcbiAgdmFyIGQzX2dlb19hcmVhU3VtLCBkM19nZW9fYXJlYVJpbmdTdW0gPSBuZXcgZDNfYWRkZXIoKTtcbiAgdmFyIGQzX2dlb19hcmVhID0ge1xuICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fYXJlYVN1bSArPSA0ICogz4A7XG4gICAgfSxcbiAgICBwb2ludDogZDNfbm9vcCxcbiAgICBsaW5lU3RhcnQ6IGQzX25vb3AsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2FyZWFSaW5nU3VtLnJlc2V0KCk7XG4gICAgICBkM19nZW9fYXJlYS5saW5lU3RhcnQgPSBkM19nZW9fYXJlYVJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZWEgPSAyICogZDNfZ2VvX2FyZWFSaW5nU3VtO1xuICAgICAgZDNfZ2VvX2FyZWFTdW0gKz0gYXJlYSA8IDAgPyA0ICogz4AgKyBhcmVhIDogYXJlYTtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVTdGFydCA9IGQzX2dlb19hcmVhLmxpbmVFbmQgPSBkM19nZW9fYXJlYS5wb2ludCA9IGQzX25vb3A7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fYXJlYVJpbmdTdGFydCgpIHtcbiAgICB2YXIgzrswMCwgz4YwMCwgzrswLCBjb3PPhjAsIHNpbs+GMDtcbiAgICBkM19nZW9fYXJlYS5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgZDNfZ2VvX2FyZWEucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICDOuzAgPSAozrswMCA9IM67KSAqIGQzX3JhZGlhbnMsIGNvc8+GMCA9IE1hdGguY29zKM+GID0gKM+GMDAgPSDPhikgKiBkM19yYWRpYW5zIC8gMiArIM+AIC8gNCksIFxuICAgICAgc2luz4YwID0gTWF0aC5zaW4oz4YpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIM+GID0gz4YgKiBkM19yYWRpYW5zIC8gMiArIM+AIC8gNDtcbiAgICAgIHZhciBkzrsgPSDOuyAtIM67MCwgc2TOuyA9IGTOuyA+PSAwID8gMSA6IC0xLCBhZM67ID0gc2TOuyAqIGTOuywgY29zz4YgPSBNYXRoLmNvcyjPhiksIHNpbs+GID0gTWF0aC5zaW4oz4YpLCBrID0gc2luz4YwICogc2luz4YsIHUgPSBjb3PPhjAgKiBjb3PPhiArIGsgKiBNYXRoLmNvcyhhZM67KSwgdiA9IGsgKiBzZM67ICogTWF0aC5zaW4oYWTOuyk7XG4gICAgICBkM19nZW9fYXJlYVJpbmdTdW0uYWRkKE1hdGguYXRhbjIodiwgdSkpO1xuICAgICAgzrswID0gzrssIGNvc8+GMCA9IGNvc8+GLCBzaW7PhjAgPSBzaW7PhjtcbiAgICB9XG4gICAgZDNfZ2VvX2FyZWEubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KM67MDAsIM+GMDApO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgICB2YXIgzrsgPSBzcGhlcmljYWxbMF0sIM+GID0gc3BoZXJpY2FsWzFdLCBjb3PPhiA9IE1hdGguY29zKM+GKTtcbiAgICByZXR1cm4gWyBjb3PPhiAqIE1hdGguY29zKM67KSwgY29zz4YgKiBNYXRoLnNpbijOuyksIE1hdGguc2luKM+GKSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5Eb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKGEsIGIpIHtcbiAgICByZXR1cm4gWyBhWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbkFkZChhLCBiKSB7XG4gICAgYVswXSArPSBiWzBdO1xuICAgIGFbMV0gKz0gYlsxXTtcbiAgICBhWzJdICs9IGJbMl07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKHZlY3Rvciwgaykge1xuICAgIHJldHVybiBbIHZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGsgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGQpIHtcbiAgICB2YXIgbCA9IE1hdGguc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICAgIGRbMF0gLz0gbDtcbiAgICBkWzFdIC89IGw7XG4gICAgZFsyXSAvPSBsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19zcGhlcmljYWwoY2FydGVzaWFuKSB7XG4gICAgcmV0dXJuIFsgTWF0aC5hdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGQzX2FzaW4oY2FydGVzaWFuWzJdKSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19zcGhlcmljYWxFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgPCDOtSAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgzrU7XG4gIH1cbiAgZDMuZ2VvLmJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciDOuzAsIM+GMCwgzrsxLCDPhjEsIM67XywgzrtfXywgz4ZfXywgcDAsIGTOu1N1bSwgcmFuZ2VzLCByYW5nZTtcbiAgICB2YXIgYm91bmQgPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBib3VuZC5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgICAgYm91bmQubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICBib3VuZC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgZM67U3VtID0gMDtcbiAgICAgICAgZDNfZ2VvX2FyZWEucG9seWdvblN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzX2dlb19hcmVhLnBvbHlnb25FbmQoKTtcbiAgICAgICAgYm91bmQucG9pbnQgPSBwb2ludDtcbiAgICAgICAgYm91bmQubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBib3VuZC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgaWYgKGQzX2dlb19hcmVhUmluZ1N1bSA8IDApIM67MCA9IC0ozrsxID0gMTgwKSwgz4YwID0gLSjPhjEgPSA5MCk7IGVsc2UgaWYgKGTOu1N1bSA+IM61KSDPhjEgPSA5MDsgZWxzZSBpZiAoZM67U3VtIDwgLc61KSDPhjAgPSAtOTA7XG4gICAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvaW50KM67LCDPhikge1xuICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UgPSBbIM67MCA9IM67LCDOuzEgPSDOuyBdKTtcbiAgICAgIGlmICjPhiA8IM+GMCkgz4YwID0gz4Y7XG4gICAgICBpZiAoz4YgPiDPhjEpIM+GMSA9IM+GO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQozrssIM+GKSB7XG4gICAgICB2YXIgcCA9IGQzX2dlb19jYXJ0ZXNpYW4oWyDOuyAqIGQzX3JhZGlhbnMsIM+GICogZDNfcmFkaWFucyBdKTtcbiAgICAgIGlmIChwMCkge1xuICAgICAgICB2YXIgbm9ybWFsID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKHAwLCBwKSwgZXF1YXRvcmlhbCA9IFsgbm9ybWFsWzFdLCAtbm9ybWFsWzBdLCAwIF0sIGluZmxlY3Rpb24gPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MoZXF1YXRvcmlhbCwgbm9ybWFsKTtcbiAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShpbmZsZWN0aW9uKTtcbiAgICAgICAgaW5mbGVjdGlvbiA9IGQzX2dlb19zcGhlcmljYWwoaW5mbGVjdGlvbik7XG4gICAgICAgIHZhciBkzrsgPSDOuyAtIM67XywgcyA9IGTOuyA+IDAgPyAxIDogLTEsIM67aSA9IGluZmxlY3Rpb25bMF0gKiBkM19kZWdyZWVzICogcywgYW50aW1lcmlkaWFuID0gYWJzKGTOuykgPiAxODA7XG4gICAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiAocyAqIM67XyA8IM67aSAmJiDOu2kgPCBzICogzrspKSB7XG4gICAgICAgICAgdmFyIM+GaSA9IGluZmxlY3Rpb25bMV0gKiBkM19kZWdyZWVzO1xuICAgICAgICAgIGlmICjPhmkgPiDPhjEpIM+GMSA9IM+GaTtcbiAgICAgICAgfSBlbHNlIGlmICjOu2kgPSAozrtpICsgMzYwKSAlIDM2MCAtIDE4MCwgYW50aW1lcmlkaWFuIF4gKHMgKiDOu18gPCDOu2kgJiYgzrtpIDwgcyAqIM67KSkge1xuICAgICAgICAgIHZhciDPhmkgPSAtaW5mbGVjdGlvblsxXSAqIGQzX2RlZ3JlZXM7XG4gICAgICAgICAgaWYgKM+GaSA8IM+GMCkgz4YwID0gz4ZpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICjPhiA8IM+GMCkgz4YwID0gz4Y7XG4gICAgICAgICAgaWYgKM+GID4gz4YxKSDPhjEgPSDPhjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW50aW1lcmlkaWFuKSB7XG4gICAgICAgICAgaWYgKM67IDwgzrtfKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUozrswLCDOuykgPiBhbmdsZSjOuzAsIM67MSkpIM67MSA9IM67O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUozrssIM67MSkgPiBhbmdsZSjOuzAsIM67MSkpIM67MCA9IM67O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAozrsxID49IM67MCkge1xuICAgICAgICAgICAgaWYgKM67IDwgzrswKSDOuzAgPSDOuztcbiAgICAgICAgICAgIGlmICjOuyA+IM67MSkgzrsxID0gzrs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICjOuyA+IM67Xykge1xuICAgICAgICAgICAgICBpZiAoYW5nbGUozrswLCDOuykgPiBhbmdsZSjOuzAsIM67MSkpIM67MSA9IM67O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGFuZ2xlKM67LCDOuzEpID4gYW5nbGUozrswLCDOuzEpKSDOuzAgPSDOuztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50KM67LCDPhik7XG4gICAgICB9XG4gICAgICBwMCA9IHAsIM67XyA9IM67O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBib3VuZC5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIGJvdW5kLnBvaW50ID0gcG9pbnQ7XG4gICAgICBwMCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpbmdQb2ludCjOuywgz4YpIHtcbiAgICAgIGlmIChwMCkge1xuICAgICAgICB2YXIgZM67ID0gzrsgLSDOu187XG4gICAgICAgIGTOu1N1bSArPSBhYnMoZM67KSA+IDE4MCA/IGTOuyArIChkzrsgPiAwID8gMzYwIDogLTM2MCkgOiBkzrs7XG4gICAgICB9IGVsc2UgzrtfXyA9IM67LCDPhl9fID0gz4Y7XG4gICAgICBkM19nZW9fYXJlYS5wb2ludCjOuywgz4YpO1xuICAgICAgbGluZVBvaW50KM67LCDPhik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVTdGFydCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcmluZ1BvaW50KM67X18sIM+GX18pO1xuICAgICAgZDNfZ2VvX2FyZWEubGluZUVuZCgpO1xuICAgICAgaWYgKGFicyhkzrtTdW0pID4gzrUpIM67MCA9IC0ozrsxID0gMTgwKTtcbiAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIHAwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW5nbGUozrswLCDOuzEpIHtcbiAgICAgIHJldHVybiAozrsxIC09IM67MCkgPCAwID8gzrsxICsgMzYwIDogzrsxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlUmFuZ2VzKGEsIGIpIHtcbiAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2l0aGluUmFuZ2UoeCwgcmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZVswXSA8PSByYW5nZVsxXSA/IHJhbmdlWzBdIDw9IHggJiYgeCA8PSByYW5nZVsxXSA6IHggPCByYW5nZVswXSB8fCByYW5nZVsxXSA8IHg7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICDPhjEgPSDOuzEgPSAtKM67MCA9IM+GMCA9IEluZmluaXR5KTtcbiAgICAgIHJhbmdlcyA9IFtdO1xuICAgICAgZDMuZ2VvLnN0cmVhbShmZWF0dXJlLCBib3VuZCk7XG4gICAgICB2YXIgbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBpZiAobikge1xuICAgICAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGEgPSByYW5nZXNbMF0sIGIsIG1lcmdlZCA9IFsgYSBdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgYiA9IHJhbmdlc1tpXTtcbiAgICAgICAgICBpZiAod2l0aGluUmFuZ2UoYlswXSwgYSkgfHwgd2l0aGluUmFuZ2UoYlsxXSwgYSkpIHtcbiAgICAgICAgICAgIGlmIChhbmdsZShhWzBdLCBiWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzFdID0gYlsxXTtcbiAgICAgICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzBdID0gYlswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goYSA9IGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVzdCA9IC1JbmZpbml0eSwgZM67O1xuICAgICAgICBmb3IgKHZhciBuID0gbWVyZ2VkLmxlbmd0aCAtIDEsIGkgPSAwLCBhID0gbWVyZ2VkW25dLCBiOyBpIDw9IG47IGEgPSBiLCArK2kpIHtcbiAgICAgICAgICBiID0gbWVyZ2VkW2ldO1xuICAgICAgICAgIGlmICgoZM67ID0gYW5nbGUoYVsxXSwgYlswXSkpID4gYmVzdCkgYmVzdCA9IGTOuywgzrswID0gYlswXSwgzrsxID0gYVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmFuZ2VzID0gcmFuZ2UgPSBudWxsO1xuICAgICAgcmV0dXJuIM67MCA9PT0gSW5maW5pdHkgfHwgz4YwID09PSBJbmZpbml0eSA/IFsgWyBOYU4sIE5hTiBdLCBbIE5hTiwgTmFOIF0gXSA6IFsgWyDOuzAsIM+GMCBdLCBbIM67MSwgz4YxIF0gXTtcbiAgICB9O1xuICB9KCk7XG4gIGQzLmdlby5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19jZW50cm9pZFcwID0gZDNfZ2VvX2NlbnRyb2lkVzEgPSBkM19nZW9fY2VudHJvaWRYMCA9IGQzX2dlb19jZW50cm9pZFkwID0gZDNfZ2VvX2NlbnRyb2lkWjAgPSBkM19nZW9fY2VudHJvaWRYMSA9IGQzX2dlb19jZW50cm9pZFkxID0gZDNfZ2VvX2NlbnRyb2lkWjEgPSBkM19nZW9fY2VudHJvaWRYMiA9IGQzX2dlb19jZW50cm9pZFkyID0gZDNfZ2VvX2NlbnRyb2lkWjIgPSAwO1xuICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBkM19nZW9fY2VudHJvaWQpO1xuICAgIHZhciB4ID0gZDNfZ2VvX2NlbnRyb2lkWDIsIHkgPSBkM19nZW9fY2VudHJvaWRZMiwgeiA9IGQzX2dlb19jZW50cm9pZFoyLCBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgIGlmIChtIDwgzrUyKSB7XG4gICAgICB4ID0gZDNfZ2VvX2NlbnRyb2lkWDEsIHkgPSBkM19nZW9fY2VudHJvaWRZMSwgeiA9IGQzX2dlb19jZW50cm9pZFoxO1xuICAgICAgaWYgKGQzX2dlb19jZW50cm9pZFcxIDwgzrUpIHggPSBkM19nZW9fY2VudHJvaWRYMCwgeSA9IGQzX2dlb19jZW50cm9pZFkwLCB6ID0gZDNfZ2VvX2NlbnRyb2lkWjA7XG4gICAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgICAgaWYgKG0gPCDOtTIpIHJldHVybiBbIE5hTiwgTmFOIF07XG4gICAgfVxuICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSwgeCkgKiBkM19kZWdyZWVzLCBkM19hc2luKHogLyBNYXRoLnNxcnQobSkpICogZDNfZGVncmVlcyBdO1xuICB9O1xuICB2YXIgZDNfZ2VvX2NlbnRyb2lkVzAsIGQzX2dlb19jZW50cm9pZFcxLCBkM19nZW9fY2VudHJvaWRYMCwgZDNfZ2VvX2NlbnRyb2lkWTAsIGQzX2dlb19jZW50cm9pZFowLCBkM19nZW9fY2VudHJvaWRYMSwgZDNfZ2VvX2NlbnRyb2lkWTEsIGQzX2dlb19jZW50cm9pZFoxLCBkM19nZW9fY2VudHJvaWRYMiwgZDNfZ2VvX2NlbnRyb2lkWTIsIGQzX2dlb19jZW50cm9pZFoyO1xuICB2YXIgZDNfZ2VvX2NlbnRyb2lkID0ge1xuICAgIHNwaGVyZTogZDNfbm9vcCxcbiAgICBwb2ludDogZDNfZ2VvX2NlbnRyb2lkUG9pbnQsXG4gICAgbGluZVN0YXJ0OiBkM19nZW9fY2VudHJvaWRMaW5lU3RhcnQsXG4gICAgbGluZUVuZDogZDNfZ2VvX2NlbnRyb2lkTGluZUVuZCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19jZW50cm9pZFJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19jZW50cm9pZExpbmVTdGFydDtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFBvaW50KM67LCDPhikge1xuICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyk7XG4gICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooY29zz4YgKiBNYXRoLmNvcyjOuyksIGNvc8+GICogTWF0aC5zaW4ozrspLCBNYXRoLnNpbijPhikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgsIHksIHopIHtcbiAgICArK2QzX2dlb19jZW50cm9pZFcwO1xuICAgIGQzX2dlb19jZW50cm9pZFgwICs9ICh4IC0gZDNfZ2VvX2NlbnRyb2lkWDApIC8gZDNfZ2VvX2NlbnRyb2lkVzA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWTAgKz0gKHkgLSBkM19nZW9fY2VudHJvaWRZMCkgLyBkM19nZW9fY2VudHJvaWRXMDtcbiAgICBkM19nZW9fY2VudHJvaWRaMCArPSAoeiAtIGQzX2dlb19jZW50cm9pZFowKSAvIGQzX2dlb19jZW50cm9pZFcwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZExpbmVTdGFydCgpIHtcbiAgICB2YXIgeDAsIHkwLCB6MDtcbiAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKTtcbiAgICAgIHgwID0gY29zz4YgKiBNYXRoLmNvcyjOuyk7XG4gICAgICB5MCA9IGNvc8+GICogTWF0aC5zaW4ozrspO1xuICAgICAgejAgPSBNYXRoLnNpbijPhik7XG4gICAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4MCwgeTAsIHowKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCjOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKSwgeCA9IGNvc8+GICogTWF0aC5jb3MozrspLCB5ID0gY29zz4YgKiBNYXRoLnNpbijOuyksIHogPSBNYXRoLnNpbijPhiksIHcgPSBNYXRoLmF0YW4yKE1hdGguc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkVzEgKz0gdztcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRMaW5lRW5kKCkge1xuICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGQzX2dlb19jZW50cm9pZFBvaW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgICB2YXIgzrswMCwgz4YwMCwgeDAsIHkwLCB6MDtcbiAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67MDAgPSDOuywgz4YwMCA9IM+GO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpO1xuICAgICAgeDAgPSBjb3PPhiAqIE1hdGguY29zKM67KTtcbiAgICAgIHkwID0gY29zz4YgKiBNYXRoLnNpbijOuyk7XG4gICAgICB6MCA9IE1hdGguc2luKM+GKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH07XG4gICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRQb2ludCjOuzAwLCDPhjAwKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5saW5lRW5kID0gZDNfZ2VvX2NlbnRyb2lkTGluZUVuZDtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGQzX2dlb19jZW50cm9pZFBvaW50O1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpLCB4ID0gY29zz4YgKiBNYXRoLmNvcyjOuyksIHkgPSBjb3PPhiAqIE1hdGguc2luKM67KSwgeiA9IE1hdGguc2luKM+GKSwgY3ggPSB5MCAqIHogLSB6MCAqIHksIGN5ID0gejAgKiB4IC0geDAgKiB6LCBjeiA9IHgwICogeSAtIHkwICogeCwgbSA9IE1hdGguc3FydChjeCAqIGN4ICsgY3kgKiBjeSArIGN6ICogY3opLCB1ID0geDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6LCB2ID0gbSAmJiAtZDNfYWNvcyh1KSAvIG0sIHcgPSBNYXRoLmF0YW4yKG0sIHUpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDIgKz0gdiAqIGN4O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTIgKz0gdiAqIGN5O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjIgKz0gdiAqIGN6O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkVzEgKz0gdztcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY29tcG9zZShhLCBiKSB7XG4gICAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgICByZXR1cm4geCA9IGEoeCwgeSksIGIoeFswXSwgeFsxXSk7XG4gICAgfVxuICAgIGlmIChhLmludmVydCAmJiBiLmludmVydCkgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4geCA9IGIuaW52ZXJ0KHgsIHkpLCB4ICYmIGEuaW52ZXJ0KHhbMF0sIHhbMV0pO1xuICAgIH07XG4gICAgcmV0dXJuIGNvbXBvc2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGNvbXBhcmUsIGNsaXBTdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIHN1YmplY3QgPSBbXSwgY2xpcCA9IFtdO1xuICAgIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgICAgaWYgKChuID0gc2VnbWVudC5sZW5ndGggLSAxKSA8PSAwKSByZXR1cm47XG4gICAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl07XG4gICAgICBpZiAoZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBsaXN0ZW5lci5wb2ludCgocDAgPSBzZWdtZW50W2ldKVswXSwgcDBbMV0pO1xuICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gbmV3IGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwMCwgc2VnbWVudCwgbnVsbCwgdHJ1ZSksIGIgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAwLCBudWxsLCBhLCBmYWxzZSk7XG4gICAgICBhLm8gPSBiO1xuICAgICAgc3ViamVjdC5wdXNoKGEpO1xuICAgICAgY2xpcC5wdXNoKGIpO1xuICAgICAgYSA9IG5ldyBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKTtcbiAgICAgIGIgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAxLCBudWxsLCBhLCB0cnVlKTtcbiAgICAgIGEubyA9IGI7XG4gICAgICBzdWJqZWN0LnB1c2goYSk7XG4gICAgICBjbGlwLnB1c2goYik7XG4gICAgfSk7XG4gICAgY2xpcC5zb3J0KGNvbXBhcmUpO1xuICAgIGQzX2dlb19jbGlwUG9seWdvbkxpbmtDaXJjdWxhcihzdWJqZWN0KTtcbiAgICBkM19nZW9fY2xpcFBvbHlnb25MaW5rQ2lyY3VsYXIoY2xpcCk7XG4gICAgaWYgKCFzdWJqZWN0Lmxlbmd0aCkgcmV0dXJuO1xuICAgIGZvciAodmFyIGkgPSAwLCBlbnRyeSA9IGNsaXBTdGFydEluc2lkZSwgbiA9IGNsaXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBjbGlwW2ldLmUgPSBlbnRyeSA9ICFlbnRyeTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSwgcG9pbnRzLCBwb2ludDtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBzdGFydCwgaXNTdWJqZWN0ID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChjdXJyZW50LnYpIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KSByZXR1cm47XG4gICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgIGRvIHtcbiAgICAgICAgY3VycmVudC52ID0gY3VycmVudC5vLnYgPSB0cnVlO1xuICAgICAgICBpZiAoY3VycmVudC5lKSB7XG4gICAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5uLngsIDEsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgICBwb2ludHMgPSBjdXJyZW50LnAuejtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50LnAueCwgLTEsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xuICAgICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XG4gICAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBQb2x5Z29uTGlua0NpcmN1bGFyKGFycmF5KSB7XG4gICAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgICB2YXIgbiwgaSA9IDAsIGEgPSBhcnJheVswXSwgYjtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgICAgYi5wID0gYTtcbiAgICAgIGEgPSBiO1xuICAgIH1cbiAgICBhLm4gPSBiID0gYXJyYXlbMF07XG4gICAgYi5wID0gYTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocG9pbnQsIHBvaW50cywgb3RoZXIsIGVudHJ5KSB7XG4gICAgdGhpcy54ID0gcG9pbnQ7XG4gICAgdGhpcy56ID0gcG9pbnRzO1xuICAgIHRoaXMubyA9IG90aGVyO1xuICAgIHRoaXMuZSA9IGVudHJ5O1xuICAgIHRoaXMudiA9IGZhbHNlO1xuICAgIHRoaXMubiA9IHRoaXMucCA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXAocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIGNsaXBTdGFydCkge1xuICAgIHJldHVybiBmdW5jdGlvbihyb3RhdGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGluZSA9IGNsaXBMaW5lKGxpc3RlbmVyKSwgcm90YXRlZENsaXBTdGFydCA9IHJvdGF0ZS5pbnZlcnQoY2xpcFN0YXJ0WzBdLCBjbGlwU3RhcnRbMV0pO1xuICAgICAgdmFyIGNsaXAgPSB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50UmluZztcbiAgICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgICBjbGlwLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgY2xpcC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgY2xpcC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgICBzZWdtZW50cyA9IGQzLm1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgICB2YXIgY2xpcFN0YXJ0SW5zaWRlID0gZDNfZ2VvX3BvaW50SW5Qb2x5Z29uKHJvdGF0ZWRDbGlwU3RhcnQsIHBvbHlnb24pO1xuICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGQzX2dlb19jbGlwU29ydCwgY2xpcFN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgbGlzdGVuZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xpcFN0YXJ0SW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdGVuZXIucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2x5Z29uRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBwb2ludCjOuywgz4YpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKM67LCDPhik7XG4gICAgICAgIGlmIChwb2ludFZpc2libGUozrsgPSBwb2ludFswXSwgz4YgPSBwb2ludFsxXSkpIGxpc3RlbmVyLnBvaW50KM67LCDPhik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb2ludExpbmUozrssIM+GKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZSjOuywgz4YpO1xuICAgICAgICBsaW5lLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludExpbmU7XG4gICAgICAgIGxpbmUubGluZVN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgdmFyIHNlZ21lbnRzO1xuICAgICAgdmFyIGJ1ZmZlciA9IGQzX2dlb19jbGlwQnVmZmVyTGlzdGVuZXIoKSwgcmluZ0xpc3RlbmVyID0gY2xpcExpbmUoYnVmZmVyKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZSwgcG9seWdvbiwgcmluZztcbiAgICAgIGZ1bmN0aW9uIHBvaW50UmluZyjOuywgz4YpIHtcbiAgICAgICAgcmluZy5wdXNoKFsgzrssIM+GIF0pO1xuICAgICAgICB2YXIgcG9pbnQgPSByb3RhdGUozrssIM+GKTtcbiAgICAgICAgcmluZ0xpc3RlbmVyLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICAgIHJpbmdMaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgcmluZyA9IFtdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgICAgcG9pbnRSaW5nKHJpbmdbMF1bMF0sIHJpbmdbMF1bMV0pO1xuICAgICAgICByaW5nTGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICB2YXIgY2xlYW4gPSByaW5nTGlzdGVuZXIuY2xlYW4oKSwgcmluZ1NlZ21lbnRzID0gYnVmZmVyLmJ1ZmZlcigpLCBzZWdtZW50LCBuID0gcmluZ1NlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgcmluZy5wb3AoKTtcbiAgICAgICAgcG9seWdvbi5wdXNoKHJpbmcpO1xuICAgICAgICByaW5nID0gbnVsbDtcbiAgICAgICAgaWYgKCFuKSByZXR1cm47XG4gICAgICAgIGlmIChjbGVhbiAmIDEpIHtcbiAgICAgICAgICBzZWdtZW50ID0gcmluZ1NlZ21lbnRzWzBdO1xuICAgICAgICAgIHZhciBuID0gc2VnbWVudC5sZW5ndGggLSAxLCBpID0gLTEsIHBvaW50O1xuICAgICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IHNlZ21lbnRbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDEgJiYgY2xlYW4gJiAyKSByaW5nU2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMucG9wKCkuY29uY2F0KHJpbmdTZWdtZW50cy5zaGlmdCgpKSk7XG4gICAgICAgIHNlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLmZpbHRlcihkM19nZW9fY2xpcFNlZ21lbnRMZW5ndGgxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xpcDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwU2VnbWVudExlbmd0aDEoc2VnbWVudCkge1xuICAgIHJldHVybiBzZWdtZW50Lmxlbmd0aCA+IDE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBCdWZmZXJMaXN0ZW5lcigpIHtcbiAgICB2YXIgbGluZXMgPSBbXSwgbGluZTtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGluZXMucHVzaChsaW5lID0gW10pO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgICAgbGluZS5wdXNoKFsgzrssIM+GIF0pO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgICBidWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gbGluZXM7XG4gICAgICAgIGxpbmVzID0gW107XG4gICAgICAgIGxpbmUgPSBudWxsO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgfSxcbiAgICAgIHJlam9pbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSBsaW5lcy5wdXNoKGxpbmVzLnBvcCgpLmNvbmNhdChsaW5lcy5zaGlmdCgpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFNvcnQoYSwgYikge1xuICAgIHJldHVybiAoKGEgPSBhLngpWzBdIDwgMCA/IGFbMV0gLSBoYWxmz4AgLSDOtSA6IGhhbGbPgCAtIGFbMV0pIC0gKChiID0gYi54KVswXSA8IDAgPyBiWzFdIC0gaGFsZs+AIC0gzrUgOiBoYWxmz4AgLSBiWzFdKTtcbiAgfVxuICB2YXIgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW4gPSBkM19nZW9fY2xpcChkM190cnVlLCBkM19nZW9fY2xpcEFudGltZXJpZGlhbkxpbmUsIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUsIFsgLc+ALCAtz4AgLyAyIF0pO1xuICBmdW5jdGlvbiBkM19nZW9fY2xpcEFudGltZXJpZGlhbkxpbmUobGlzdGVuZXIpIHtcbiAgICB2YXIgzrswID0gTmFOLCDPhjAgPSBOYU4sIHPOuzAgPSBOYU4sIGNsZWFuO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbijOuzEsIM+GMSkge1xuICAgICAgICB2YXIgc867MSA9IM67MSA+IDAgPyDPgCA6IC3PgCwgZM67ID0gYWJzKM67MSAtIM67MCk7XG4gICAgICAgIGlmIChhYnMoZM67IC0gz4ApIDwgzrUpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludCjOuzAsIM+GMCA9ICjPhjAgKyDPhjEpIC8gMiA+IDAgPyBoYWxmz4AgOiAtaGFsZs+AKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrswLCDPhjApO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrsxLCDPhjApO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KM67MSwgz4YwKTtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc867MCAhPT0gc867MSAmJiBkzrsgPj0gz4ApIHtcbiAgICAgICAgICBpZiAoYWJzKM67MCAtIHPOuzApIDwgzrUpIM67MCAtPSBzzrswICogzrU7XG4gICAgICAgICAgaWYgKGFicyjOuzEgLSBzzrsxKSA8IM61KSDOuzEgLT0gc867MSAqIM61O1xuICAgICAgICAgIM+GMCA9IGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KM67MCwgz4YwLCDOuzEsIM+GMSk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MCwgz4YwKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MSwgz4YwKTtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIucG9pbnQozrswID0gzrsxLCDPhjAgPSDPhjEpO1xuICAgICAgICBzzrswID0gc867MTtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICDOuzAgPSDPhjAgPSBOYU47XG4gICAgICB9LFxuICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMiAtIGNsZWFuO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QozrswLCDPhjAsIM67MSwgz4YxKSB7XG4gICAgdmFyIGNvc8+GMCwgY29zz4YxLCBzaW7OuzBfzrsxID0gTWF0aC5zaW4ozrswIC0gzrsxKTtcbiAgICByZXR1cm4gYWJzKHNpbs67MF/OuzEpID4gzrUgPyBNYXRoLmF0YW4oKE1hdGguc2luKM+GMCkgKiAoY29zz4YxID0gTWF0aC5jb3Moz4YxKSkgKiBNYXRoLnNpbijOuzEpIC0gTWF0aC5zaW4oz4YxKSAqIChjb3PPhjAgPSBNYXRoLmNvcyjPhjApKSAqIE1hdGguc2luKM67MCkpIC8gKGNvc8+GMCAqIGNvc8+GMSAqIHNpbs67MF/OuzEpKSA6ICjPhjAgKyDPhjEpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIGxpc3RlbmVyKSB7XG4gICAgdmFyIM+GO1xuICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgIM+GID0gZGlyZWN0aW9uICogaGFsZs+AO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgwLCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCjPgCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoz4AsIDApO1xuICAgICAgbGlzdGVuZXIucG9pbnQoz4AsIC3Phik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgwLCAtz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCAtz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCAwKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC3PgCwgz4YpO1xuICAgIH0gZWxzZSBpZiAoYWJzKGZyb21bMF0gLSB0b1swXSkgPiDOtSkge1xuICAgICAgdmFyIHMgPSBmcm9tWzBdIDwgdG9bMF0gPyDPgCA6IC3PgDtcbiAgICAgIM+GID0gZGlyZWN0aW9uICogcyAvIDI7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtcywgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoMCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQocywgz4YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ZW5lci5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcG9pbnRJblBvbHlnb24ocG9pbnQsIHBvbHlnb24pIHtcbiAgICB2YXIgbWVyaWRpYW4gPSBwb2ludFswXSwgcGFyYWxsZWwgPSBwb2ludFsxXSwgbWVyaWRpYW5Ob3JtYWwgPSBbIE1hdGguc2luKG1lcmlkaWFuKSwgLU1hdGguY29zKG1lcmlkaWFuKSwgMCBdLCBwb2xhckFuZ2xlID0gMCwgd2luZGluZyA9IDA7XG4gICAgZDNfZ2VvX2FyZWFSaW5nU3VtLnJlc2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBtID0gcmluZy5sZW5ndGg7XG4gICAgICBpZiAoIW0pIGNvbnRpbnVlO1xuICAgICAgdmFyIHBvaW50MCA9IHJpbmdbMF0sIM67MCA9IHBvaW50MFswXSwgz4YwID0gcG9pbnQwWzFdIC8gMiArIM+AIC8gNCwgc2luz4YwID0gTWF0aC5zaW4oz4YwKSwgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgaiA9IDE7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoaiA9PT0gbSkgaiA9IDA7XG4gICAgICAgIHBvaW50ID0gcmluZ1tqXTtcbiAgICAgICAgdmFyIM67ID0gcG9pbnRbMF0sIM+GID0gcG9pbnRbMV0gLyAyICsgz4AgLyA0LCBzaW7PhiA9IE1hdGguc2luKM+GKSwgY29zz4YgPSBNYXRoLmNvcyjPhiksIGTOuyA9IM67IC0gzrswLCBzZM67ID0gZM67ID49IDAgPyAxIDogLTEsIGFkzrsgPSBzZM67ICogZM67LCBhbnRpbWVyaWRpYW4gPSBhZM67ID4gz4AsIGsgPSBzaW7PhjAgKiBzaW7PhjtcbiAgICAgICAgZDNfZ2VvX2FyZWFSaW5nU3VtLmFkZChNYXRoLmF0YW4yKGsgKiBzZM67ICogTWF0aC5zaW4oYWTOuyksIGNvc8+GMCAqIGNvc8+GICsgayAqIE1hdGguY29zKGFkzrspKSk7XG4gICAgICAgIHBvbGFyQW5nbGUgKz0gYW50aW1lcmlkaWFuID8gZM67ICsgc2TOuyAqIM+EIDogZM67O1xuICAgICAgICBpZiAoYW50aW1lcmlkaWFuIF4gzrswID49IG1lcmlkaWFuIF4gzrsgPj0gbWVyaWRpYW4pIHtcbiAgICAgICAgICB2YXIgYXJjID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKGQzX2dlb19jYXJ0ZXNpYW4ocG9pbnQwKSwgZDNfZ2VvX2NhcnRlc2lhbihwb2ludCkpO1xuICAgICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoYXJjKTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKG1lcmlkaWFuTm9ybWFsLCBhcmMpO1xuICAgICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICB2YXIgz4ZhcmMgPSAoYW50aW1lcmlkaWFuIF4gZM67ID49IDAgPyAtMSA6IDEpICogZDNfYXNpbihpbnRlcnNlY3Rpb25bMl0pO1xuICAgICAgICAgIGlmIChwYXJhbGxlbCA+IM+GYXJjIHx8IHBhcmFsbGVsID09PSDPhmFyYyAmJiAoYXJjWzBdIHx8IGFyY1sxXSkpIHtcbiAgICAgICAgICAgIHdpbmRpbmcgKz0gYW50aW1lcmlkaWFuIF4gZM67ID49IDAgPyAxIDogLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaisrKSBicmVhaztcbiAgICAgICAgzrswID0gzrssIHNpbs+GMCA9IHNpbs+GLCBjb3PPhjAgPSBjb3PPhiwgcG9pbnQwID0gcG9pbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAocG9sYXJBbmdsZSA8IC3OtSB8fCBwb2xhckFuZ2xlIDwgzrUgJiYgZDNfZ2VvX2FyZWFSaW5nU3VtIDwgMCkgXiB3aW5kaW5nICYgMTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcENpcmNsZShyYWRpdXMpIHtcbiAgICB2YXIgY3IgPSBNYXRoLmNvcyhyYWRpdXMpLCBzbWFsbFJhZGl1cyA9IGNyID4gMCwgbm90SGVtaXNwaGVyZSA9IGFicyhjcikgPiDOtSwgaW50ZXJwb2xhdGUgPSBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUocmFkaXVzLCA2ICogZDNfcmFkaWFucyk7XG4gICAgcmV0dXJuIGQzX2dlb19jbGlwKHZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc21hbGxSYWRpdXMgPyBbIDAsIC1yYWRpdXMgXSA6IFsgLc+ALCByYWRpdXMgLSDPgCBdKTtcbiAgICBmdW5jdGlvbiB2aXNpYmxlKM67LCDPhikge1xuICAgICAgcmV0dXJuIE1hdGguY29zKM67KSAqIE1hdGguY29zKM+GKSA+IGNyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwTGluZShsaXN0ZW5lcikge1xuICAgICAgdmFyIHBvaW50MCwgYzAsIHYwLCB2MDAsIGNsZWFuO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2MDAgPSB2MCA9IGZhbHNlO1xuICAgICAgICAgIGNsZWFuID0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgICAgIHZhciBwb2ludDEgPSBbIM67LCDPhiBdLCBwb2ludDIsIHYgPSB2aXNpYmxlKM67LCDPhiksIGMgPSBzbWFsbFJhZGl1cyA/IHYgPyAwIDogY29kZSjOuywgz4YpIDogdiA/IGNvZGUozrsgKyAozrsgPCAwID8gz4AgOiAtz4ApLCDPhikgOiAwO1xuICAgICAgICAgIGlmICghcG9pbnQwICYmICh2MDAgPSB2MCA9IHYpKSBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICBpZiAoZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHBvaW50MCwgcG9pbnQyKSB8fCBkM19nZW9fc3BoZXJpY2FsRXF1YWwocG9pbnQxLCBwb2ludDIpKSB7XG4gICAgICAgICAgICAgIHBvaW50MVswXSArPSDOtTtcbiAgICAgICAgICAgICAgcG9pbnQxWzFdICs9IM61O1xuICAgICAgICAgICAgICB2ID0gdmlzaWJsZShwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnQwID0gcG9pbnQyO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm90SGVtaXNwaGVyZSAmJiBwb2ludDAgJiYgc21hbGxSYWRpdXMgXiB2KSB7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIGlmICghKGMgJiBjMCkgJiYgKHQgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDAsIHRydWUpKSkge1xuICAgICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICAgIGlmIChzbWFsbFJhZGl1cykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHYgJiYgKCFwb2ludDAgfHwgIWQzX2dlb19zcGhlcmljYWxFcXVhbChwb2ludDAsIHBvaW50MSkpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2ludChwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh2MCkgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIHBvaW50MCA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gY2xlYW4gfCAodjAwICYmIHYwKSA8PCAxO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYiwgdHdvKSB7XG4gICAgICB2YXIgcGEgPSBkM19nZW9fY2FydGVzaWFuKGEpLCBwYiA9IGQzX2dlb19jYXJ0ZXNpYW4oYik7XG4gICAgICB2YXIgbjEgPSBbIDEsIDAsIDAgXSwgbjIgPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MocGEsIHBiKSwgbjJuMiA9IGQzX2dlb19jYXJ0ZXNpYW5Eb3QobjIsIG4yKSwgbjFuMiA9IG4yWzBdLCBkZXRlcm1pbmFudCA9IG4ybjIgLSBuMW4yICogbjFuMjtcbiAgICAgIGlmICghZGV0ZXJtaW5hbnQpIHJldHVybiAhdHdvICYmIGE7XG4gICAgICB2YXIgYzEgPSBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCwgYzIgPSAtY3IgKiBuMW4yIC8gZGV0ZXJtaW5hbnQsIG4xeG4yID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKG4xLCBuMiksIEEgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUobjEsIGMxKSwgQiA9IGQzX2dlb19jYXJ0ZXNpYW5TY2FsZShuMiwgYzIpO1xuICAgICAgZDNfZ2VvX2NhcnRlc2lhbkFkZChBLCBCKTtcbiAgICAgIHZhciB1ID0gbjF4bjIsIHcgPSBkM19nZW9fY2FydGVzaWFuRG90KEEsIHUpLCB1dSA9IGQzX2dlb19jYXJ0ZXNpYW5Eb3QodSwgdSksIHQyID0gdyAqIHcgLSB1dSAqIChkM19nZW9fY2FydGVzaWFuRG90KEEsIEEpIC0gMSk7XG4gICAgICBpZiAodDIgPCAwKSByZXR1cm47XG4gICAgICB2YXIgdCA9IE1hdGguc3FydCh0MiksIHEgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUodSwgKC13IC0gdCkgLyB1dSk7XG4gICAgICBkM19nZW9fY2FydGVzaWFuQWRkKHEsIEEpO1xuICAgICAgcSA9IGQzX2dlb19zcGhlcmljYWwocSk7XG4gICAgICBpZiAoIXR3bykgcmV0dXJuIHE7XG4gICAgICB2YXIgzrswID0gYVswXSwgzrsxID0gYlswXSwgz4YwID0gYVsxXSwgz4YxID0gYlsxXSwgejtcbiAgICAgIGlmICjOuzEgPCDOuzApIHogPSDOuzAsIM67MCA9IM67MSwgzrsxID0gejtcbiAgICAgIHZhciDOtM67ID0gzrsxIC0gzrswLCBwb2xhciA9IGFicyjOtM67IC0gz4ApIDwgzrUsIG1lcmlkaWFuID0gcG9sYXIgfHwgzrTOuyA8IM61O1xuICAgICAgaWYgKCFwb2xhciAmJiDPhjEgPCDPhjApIHogPSDPhjAsIM+GMCA9IM+GMSwgz4YxID0gejtcbiAgICAgIGlmIChtZXJpZGlhbiA/IHBvbGFyID8gz4YwICsgz4YxID4gMCBeIHFbMV0gPCAoYWJzKHFbMF0gLSDOuzApIDwgzrUgPyDPhjAgOiDPhjEpIDogz4YwIDw9IHFbMV0gJiYgcVsxXSA8PSDPhjEgOiDOtM67ID4gz4AgXiAozrswIDw9IHFbMF0gJiYgcVswXSA8PSDOuzEpKSB7XG4gICAgICAgIHZhciBxMSA9IGQzX2dlb19jYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgKyB0KSAvIHV1KTtcbiAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbkFkZChxMSwgQSk7XG4gICAgICAgIHJldHVybiBbIHEsIGQzX2dlb19zcGhlcmljYWwocTEpIF07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvZGUozrssIM+GKSB7XG4gICAgICB2YXIgciA9IHNtYWxsUmFkaXVzID8gcmFkaXVzIDogz4AgLSByYWRpdXMsIGNvZGUgPSAwO1xuICAgICAgaWYgKM67IDwgLXIpIGNvZGUgfD0gMTsgZWxzZSBpZiAozrsgPiByKSBjb2RlIHw9IDI7XG4gICAgICBpZiAoz4YgPCAtcikgY29kZSB8PSA0OyBlbHNlIGlmICjPhiA+IHIpIGNvZGUgfD0gODtcbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX2NsaXBMaW5lKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBhID0gbGluZS5hLCBiID0gbGluZS5iLCBheCA9IGEueCwgYXkgPSBhLnksIGJ4ID0gYi54LCBieSA9IGIueSwgdDAgPSAwLCB0MSA9IDEsIGR4ID0gYnggLSBheCwgZHkgPSBieSAtIGF5LCByO1xuICAgICAgciA9IHgwIC0gYXg7XG4gICAgICBpZiAoIWR4ICYmIHIgPiAwKSByZXR1cm47XG4gICAgICByIC89IGR4O1xuICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICAgICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgICAgfVxuICAgICAgciA9IHgxIC0gYXg7XG4gICAgICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XG4gICAgICByIC89IGR4O1xuICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICAgICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgICAgfVxuICAgICAgciA9IHkwIC0gYXk7XG4gICAgICBpZiAoIWR5ICYmIHIgPiAwKSByZXR1cm47XG4gICAgICByIC89IGR5O1xuICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICAgICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgICAgfVxuICAgICAgciA9IHkxIC0gYXk7XG4gICAgICBpZiAoIWR5ICYmIHIgPCAwKSByZXR1cm47XG4gICAgICByIC89IGR5O1xuICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICAgICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgICAgfVxuICAgICAgaWYgKHQwID4gMCkgbGluZS5hID0ge1xuICAgICAgICB4OiBheCArIHQwICogZHgsXG4gICAgICAgIHk6IGF5ICsgdDAgKiBkeVxuICAgICAgfTtcbiAgICAgIGlmICh0MSA8IDEpIGxpbmUuYiA9IHtcbiAgICAgICAgeDogYXggKyB0MSAqIGR4LFxuICAgICAgICB5OiBheSArIHQxICogZHlcbiAgICAgIH07XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19nZW9fY2xpcEV4dGVudE1BWCA9IDFlOTtcbiAgZDMuZ2VvLmNsaXBFeHRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeDAsIHkwLCB4MSwgeTEsIHN0cmVhbSwgY2xpcCwgY2xpcEV4dGVudCA9IHtcbiAgICAgIHN0cmVhbTogZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS52YWxpZCA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0gPSBjbGlwKG91dHB1dCk7XG4gICAgICAgIHN0cmVhbS52YWxpZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgZXh0ZW50OiBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgWyB4MCwgeTAgXSwgWyB4MSwgeTEgXSBdO1xuICAgICAgICBjbGlwID0gZDNfZ2VvX2NsaXBFeHRlbnQoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSk7XG4gICAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS52YWxpZCA9IGZhbHNlLCBzdHJlYW0gPSBudWxsO1xuICAgICAgICByZXR1cm4gY2xpcEV4dGVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBjbGlwRXh0ZW50LmV4dGVudChbIFsgMCwgMCBdLCBbIDk2MCwgNTAwIF0gXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwRXh0ZW50KHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdGVuZXJfID0gbGlzdGVuZXIsIGJ1ZmZlckxpc3RlbmVyID0gZDNfZ2VvX2NsaXBCdWZmZXJMaXN0ZW5lcigpLCBjbGlwTGluZSA9IGQzX2dlb21fY2xpcExpbmUoeDAsIHkwLCB4MSwgeTEpLCBzZWdtZW50cywgcG9seWdvbiwgcmluZztcbiAgICAgIHZhciBjbGlwID0ge1xuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxpc3RlbmVyID0gYnVmZmVyTGlzdGVuZXI7XG4gICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICAgICAgY2xlYW4gPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyXztcbiAgICAgICAgICBzZWdtZW50cyA9IGQzLm1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgICB2YXIgY2xpcFN0YXJ0SW5zaWRlID0gaW5zaWRlUG9seWdvbihbIHgwLCB5MSBdKSwgaW5zaWRlID0gY2xlYW4gJiYgY2xpcFN0YXJ0SW5zaWRlLCB2aXNpYmxlID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChpbnNpZGUgfHwgdmlzaWJsZSkge1xuICAgICAgICAgICAgbGlzdGVuZXIucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAgIGQzX2dlb19jbGlwUG9seWdvbihzZWdtZW50cywgY29tcGFyZSwgY2xpcFN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXIucG9seWdvbkVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSByaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIGluc2lkZVBvbHlnb24ocCkge1xuICAgICAgICB2YXIgd24gPSAwLCBuID0gcG9seWdvbi5sZW5ndGgsIHkgPSBwWzFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAxLCB2ID0gcG9seWdvbltpXSwgbSA9IHYubGVuZ3RoLCBhID0gdlswXSwgYjsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgYiA9IHZbal07XG4gICAgICAgICAgICBpZiAoYVsxXSA8PSB5KSB7XG4gICAgICAgICAgICAgIGlmIChiWzFdID4geSAmJiBkM19jcm9zczJkKGEsIGIsIHApID4gMCkgKyt3bjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChiWzFdIDw9IHkgJiYgZDNfY3Jvc3MyZChhLCBiLCBwKSA8IDApIC0td247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHduICE9PSAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGEgPSAwLCBhMSA9IDA7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwgfHwgKGEgPSBjb3JuZXIoZnJvbSwgZGlyZWN0aW9uKSkgIT09IChhMSA9IGNvcm5lcih0bywgZGlyZWN0aW9uKSkgfHwgY29tcGFyZVBvaW50cyhmcm9tLCB0bykgPCAwIF4gZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KGEgPT09IDAgfHwgYSA9PT0gMyA/IHgwIDogeDEsIGEgPiAxID8geTEgOiB5MCk7XG4gICAgICAgICAgfSB3aGlsZSAoKGEgPSAoYSArIGRpcmVjdGlvbiArIDQpICUgNCkgIT09IGExKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb2ludFZpc2libGUoeCwgeSkge1xuICAgICAgICByZXR1cm4geDAgPD0geCAmJiB4IDw9IHgxICYmIHkwIDw9IHkgJiYgeSA8PSB5MTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgaWYgKHBvaW50VmlzaWJsZSh4LCB5KSkgbGlzdGVuZXIucG9pbnQoeCwgeSk7XG4gICAgICB9XG4gICAgICB2YXIgeF9fLCB5X18sIHZfXywgeF8sIHlfLCB2XywgZmlyc3QsIGNsZWFuO1xuICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgICBpZiAocG9seWdvbikgcG9seWdvbi5wdXNoKHJpbmcgPSBbXSk7XG4gICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdl8gPSBmYWxzZTtcbiAgICAgICAgeF8gPSB5XyA9IE5hTjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICAgIGxpbmVQb2ludCh4X18sIHlfXyk7XG4gICAgICAgICAgaWYgKHZfXyAmJiB2XykgYnVmZmVyTGlzdGVuZXIucmVqb2luKCk7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChidWZmZXJMaXN0ZW5lci5idWZmZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICBpZiAodl8pIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVQb2ludCh4LCB5KSB7XG4gICAgICAgIHggPSBNYXRoLm1heCgtZDNfZ2VvX2NsaXBFeHRlbnRNQVgsIE1hdGgubWluKGQzX2dlb19jbGlwRXh0ZW50TUFYLCB4KSk7XG4gICAgICAgIHkgPSBNYXRoLm1heCgtZDNfZ2VvX2NsaXBFeHRlbnRNQVgsIE1hdGgubWluKGQzX2dlb19jbGlwRXh0ZW50TUFYLCB5KSk7XG4gICAgICAgIHZhciB2ID0gcG9pbnRWaXNpYmxlKHgsIHkpO1xuICAgICAgICBpZiAocG9seWdvbikgcmluZy5wdXNoKFsgeCwgeSBdKTtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgeF9fID0geCwgeV9fID0geSwgdl9fID0gdjtcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodiAmJiB2XykgbGlzdGVuZXIucG9pbnQoeCwgeSk7IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGwgPSB7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICB4OiB4XyxcbiAgICAgICAgICAgICAgICB5OiB5X1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY2xpcExpbmUobCkpIHtcbiAgICAgICAgICAgICAgaWYgKCF2Xykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KGwuYS54LCBsLmEueSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQobC5iLngsIGwuYi55KTtcbiAgICAgICAgICAgICAgaWYgKCF2KSBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4XyA9IHgsIHlfID0geSwgdl8gPSB2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjb3JuZXIocCwgZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gYWJzKHBbMF0gLSB4MCkgPCDOtSA/IGRpcmVjdGlvbiA+IDAgPyAwIDogMyA6IGFicyhwWzBdIC0geDEpIDwgzrUgPyBkaXJlY3Rpb24gPiAwID8gMiA6IDEgOiBhYnMocFsxXSAtIHkwKSA8IM61ID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwIDogZGlyZWN0aW9uID4gMCA/IDMgOiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb21wYXJlUG9pbnRzKGEueCwgYi54KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZVBvaW50cyhhLCBiKSB7XG4gICAgICB2YXIgY2EgPSBjb3JuZXIoYSwgMSksIGNiID0gY29ybmVyKGIsIDEpO1xuICAgICAgcmV0dXJuIGNhICE9PSBjYiA/IGNhIC0gY2IgOiBjYSA9PT0gMCA/IGJbMV0gLSBhWzFdIDogY2EgPT09IDEgPyBhWzBdIC0gYlswXSA6IGNhID09PSAyID8gYVsxXSAtIGJbMV0gOiBiWzBdIC0gYVswXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljKHByb2plY3RBdCkge1xuICAgIHZhciDPhjAgPSAwLCDPhjEgPSDPgCAvIDMsIG0gPSBkM19nZW9fcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSwgcCA9IG0oz4YwLCDPhjEpO1xuICAgIHAucGFyYWxsZWxzID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyDPhjAgLyDPgCAqIDE4MCwgz4YxIC8gz4AgKiAxODAgXTtcbiAgICAgIHJldHVybiBtKM+GMCA9IF9bMF0gKiDPgCAvIDE4MCwgz4YxID0gX1sxXSAqIM+AIC8gMTgwKTtcbiAgICB9O1xuICAgIHJldHVybiBwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jb25pY0VxdWFsQXJlYSjPhjAsIM+GMSkge1xuICAgIHZhciBzaW7PhjAgPSBNYXRoLnNpbijPhjApLCBuID0gKHNpbs+GMCArIE1hdGguc2luKM+GMSkpIC8gMiwgQyA9IDEgKyBzaW7PhjAgKiAoMiAqIG4gLSBzaW7PhjApLCDPgTAgPSBNYXRoLnNxcnQoQykgLyBuO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQozrssIM+GKSB7XG4gICAgICB2YXIgz4EgPSBNYXRoLnNxcnQoQyAtIDIgKiBuICogTWF0aC5zaW4oz4YpKSAvIG47XG4gICAgICByZXR1cm4gWyDPgSAqIE1hdGguc2luKM67ICo9IG4pLCDPgTAgLSDPgSAqIE1hdGguY29zKM67KSBdO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgTBfeSA9IM+BMCAtIHk7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHgsIM+BMF95KSAvIG4sIGQzX2FzaW4oKEMgLSAoeCAqIHggKyDPgTBfeSAqIM+BMF95KSAqIG4gKiBuKSAvICgyICogbikpIF07XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuICAoZDMuZ2VvLmNvbmljRXF1YWxBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19jb25pYyhkM19nZW9fY29uaWNFcXVhbEFyZWEpO1xuICB9KS5yYXcgPSBkM19nZW9fY29uaWNFcXVhbEFyZWE7XG4gIGQzLmdlby5hbGJlcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuZ2VvLmNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsgOTYsIDAgXSkuY2VudGVyKFsgLS42LCAzOC43IF0pLnBhcmFsbGVscyhbIDI5LjUsIDQ1LjUgXSkuc2NhbGUoMTA3MCk7XG4gIH07XG4gIGQzLmdlby5hbGJlcnNVc2EgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbG93ZXI0OCA9IGQzLmdlby5hbGJlcnMoKTtcbiAgICB2YXIgYWxhc2thID0gZDMuZ2VvLmNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsgMTU0LCAwIF0pLmNlbnRlcihbIC0yLCA1OC41IF0pLnBhcmFsbGVscyhbIDU1LCA2NSBdKTtcbiAgICB2YXIgaGF3YWlpID0gZDMuZ2VvLmNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsgMTU3LCAwIF0pLmNlbnRlcihbIC0zLCAxOS45IF0pLnBhcmFsbGVscyhbIDgsIDE4IF0pO1xuICAgIHZhciBwb2ludCwgcG9pbnRTdHJlYW0gPSB7XG4gICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBwb2ludCA9IFsgeCwgeSBdO1xuICAgICAgfVxuICAgIH0sIGxvd2VyNDhQb2ludCwgYWxhc2thUG9pbnQsIGhhd2FpaVBvaW50O1xuICAgIGZ1bmN0aW9uIGFsYmVyc1VzYShjb29yZGluYXRlcykge1xuICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgcG9pbnQgPSBudWxsO1xuICAgICAgKGxvd2VyNDhQb2ludCh4LCB5KSwgcG9pbnQpIHx8IChhbGFza2FQb2ludCh4LCB5KSwgcG9pbnQpIHx8IGhhd2FpaVBvaW50KHgsIHkpO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBhbGJlcnNVc2EuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB0ID0gbG93ZXI0OC50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgIHJldHVybiAoeSA+PSAuMTIgJiYgeSA8IC4yMzQgJiYgeCA+PSAtLjQyNSAmJiB4IDwgLS4yMTQgPyBhbGFza2EgOiB5ID49IC4xNjYgJiYgeSA8IC4yMzQgJiYgeCA+PSAtLjIxNCAmJiB4IDwgLS4xMTUgPyBoYXdhaWkgOiBsb3dlcjQ4KS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgdmFyIGxvd2VyNDhTdHJlYW0gPSBsb3dlcjQ4LnN0cmVhbShzdHJlYW0pLCBhbGFza2FTdHJlYW0gPSBhbGFza2Euc3RyZWFtKHN0cmVhbSksIGhhd2FpaVN0cmVhbSA9IGhhd2FpaS5zdHJlYW0oc3RyZWFtKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICB9LFxuICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0uc3BoZXJlKCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLnNwaGVyZSgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5zcGhlcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGFsYmVyc1VzYS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnByZWNpc2lvbigpO1xuICAgICAgbG93ZXI0OC5wcmVjaXNpb24oXyk7XG4gICAgICBhbGFza2EucHJlY2lzaW9uKF8pO1xuICAgICAgaGF3YWlpLnByZWNpc2lvbihfKTtcbiAgICAgIHJldHVybiBhbGJlcnNVc2E7XG4gICAgfTtcbiAgICBhbGJlcnNVc2Euc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnNjYWxlKCk7XG4gICAgICBsb3dlcjQ4LnNjYWxlKF8pO1xuICAgICAgYWxhc2thLnNjYWxlKF8gKiAuMzUpO1xuICAgICAgaGF3YWlpLnNjYWxlKF8pO1xuICAgICAgcmV0dXJuIGFsYmVyc1VzYS50cmFuc2xhdGUobG93ZXI0OC50cmFuc2xhdGUoKSk7XG4gICAgfTtcbiAgICBhbGJlcnNVc2EudHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC50cmFuc2xhdGUoKTtcbiAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgIGxvd2VyNDhQb2ludCA9IGxvd2VyNDgudHJhbnNsYXRlKF8pLmNsaXBFeHRlbnQoWyBbIHggLSAuNDU1ICogaywgeSAtIC4yMzggKiBrIF0sIFsgeCArIC40NTUgKiBrLCB5ICsgLjIzOCAqIGsgXSBdKS5zdHJlYW0ocG9pbnRTdHJlYW0pLnBvaW50O1xuICAgICAgYWxhc2thUG9pbnQgPSBhbGFza2EudHJhbnNsYXRlKFsgeCAtIC4zMDcgKiBrLCB5ICsgLjIwMSAqIGsgXSkuY2xpcEV4dGVudChbIFsgeCAtIC40MjUgKiBrICsgzrUsIHkgKyAuMTIgKiBrICsgzrUgXSwgWyB4IC0gLjIxNCAqIGsgLSDOtSwgeSArIC4yMzQgKiBrIC0gzrUgXSBdKS5zdHJlYW0ocG9pbnRTdHJlYW0pLnBvaW50O1xuICAgICAgaGF3YWlpUG9pbnQgPSBoYXdhaWkudHJhbnNsYXRlKFsgeCAtIC4yMDUgKiBrLCB5ICsgLjIxMiAqIGsgXSkuY2xpcEV4dGVudChbIFsgeCAtIC4yMTQgKiBrICsgzrUsIHkgKyAuMTY2ICogayArIM61IF0sIFsgeCAtIC4xMTUgKiBrIC0gzrUsIHkgKyAuMjM0ICogayAtIM61IF0gXSkuc3RyZWFtKHBvaW50U3RyZWFtKS5wb2ludDtcbiAgICAgIHJldHVybiBhbGJlcnNVc2E7XG4gICAgfTtcbiAgICByZXR1cm4gYWxiZXJzVXNhLnNjYWxlKDEwNzApO1xuICB9O1xuICB2YXIgZDNfZ2VvX3BhdGhBcmVhU3VtLCBkM19nZW9fcGF0aEFyZWFQb2x5Z29uLCBkM19nZW9fcGF0aEFyZWEgPSB7XG4gICAgcG9pbnQ6IGQzX25vb3AsXG4gICAgbGluZVN0YXJ0OiBkM19ub29wLFxuICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVBvbHlnb24gPSAwO1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhLmxpbmVTdGFydCA9IGQzX2dlb19wYXRoQXJlYVJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhLmxpbmVTdGFydCA9IGQzX2dlb19wYXRoQXJlYS5saW5lRW5kID0gZDNfZ2VvX3BhdGhBcmVhLnBvaW50ID0gZDNfbm9vcDtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVN1bSArPSBhYnMoZDNfZ2VvX3BhdGhBcmVhUG9seWdvbiAvIDIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhBcmVhUmluZ1N0YXJ0KCkge1xuICAgIHZhciB4MDAsIHkwMCwgeDAsIHkwO1xuICAgIGQzX2dlb19wYXRoQXJlYS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYS5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5O1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVBvbHlnb24gKz0geTAgKiB4IC0geDAgKiB5O1xuICAgICAgeDAgPSB4LCB5MCA9IHk7XG4gICAgfVxuICAgIGQzX2dlb19wYXRoQXJlYS5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0UG9pbnQoeDAwLCB5MDApO1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX2dlb19wYXRoQm91bmRzWDAsIGQzX2dlb19wYXRoQm91bmRzWTAsIGQzX2dlb19wYXRoQm91bmRzWDEsIGQzX2dlb19wYXRoQm91bmRzWTE7XG4gIHZhciBkM19nZW9fcGF0aEJvdW5kcyA9IHtcbiAgICBwb2ludDogZDNfZ2VvX3BhdGhCb3VuZHNQb2ludCxcbiAgICBsaW5lU3RhcnQ6IGQzX25vb3AsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGQzX25vb3AsXG4gICAgcG9seWdvbkVuZDogZDNfbm9vcFxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fcGF0aEJvdW5kc1BvaW50KHgsIHkpIHtcbiAgICBpZiAoeCA8IGQzX2dlb19wYXRoQm91bmRzWDApIGQzX2dlb19wYXRoQm91bmRzWDAgPSB4O1xuICAgIGlmICh4ID4gZDNfZ2VvX3BhdGhCb3VuZHNYMSkgZDNfZ2VvX3BhdGhCb3VuZHNYMSA9IHg7XG4gICAgaWYgKHkgPCBkM19nZW9fcGF0aEJvdW5kc1kwKSBkM19nZW9fcGF0aEJvdW5kc1kwID0geTtcbiAgICBpZiAoeSA+IGQzX2dlb19wYXRoQm91bmRzWTEpIGQzX2dlb19wYXRoQm91bmRzWTEgPSB5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQnVmZmVyKCkge1xuICAgIHZhciBwb2ludENpcmNsZSA9IGQzX2dlb19wYXRoQnVmZmVyQ2lyY2xlKDQuNSksIGJ1ZmZlciA9IFtdO1xuICAgIHZhciBzdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmVTdGFydDtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kUG9seWdvbjtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIH0sXG4gICAgICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgICAgICBwb2ludENpcmNsZSA9IGQzX2dlb19wYXRoQnVmZmVyQ2lyY2xlKF8pO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGJ1ZmZlci5qb2luKFwiXCIpO1xuICAgICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSwgcG9pbnRDaXJjbGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmVTdGFydCh4LCB5KSB7XG4gICAgICBidWZmZXIucHVzaChcIk1cIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmUoeCwgeSkge1xuICAgICAgYnVmZmVyLnB1c2goXCJMXCIsIHgsIFwiLFwiLCB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kUG9seWdvbigpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aEJ1ZmZlckNpcmNsZShyYWRpdXMpIHtcbiAgICByZXR1cm4gXCJtMCxcIiArIHJhZGl1cyArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgLTIgKiByYWRpdXMgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIDIgKiByYWRpdXMgKyBcInpcIjtcbiAgfVxuICB2YXIgZDNfZ2VvX3BhdGhDZW50cm9pZCA9IHtcbiAgICBwb2ludDogZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50LFxuICAgIGxpbmVTdGFydDogZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVTdGFydCxcbiAgICBsaW5lRW5kOiBkM19nZW9fcGF0aENlbnRyb2lkTGluZUVuZCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lU3RhcnQgPSBkM19nZW9fcGF0aENlbnRyb2lkUmluZ1N0YXJ0O1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lU3RhcnQgPSBkM19nZW9fcGF0aENlbnRyb2lkTGluZVN0YXJ0O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lRW5kID0gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVFbmQ7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeCwgeSkge1xuICAgIGQzX2dlb19jZW50cm9pZFgwICs9IHg7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWTAgKz0geTtcbiAgICArK2QzX2dlb19jZW50cm9pZFowO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gICAgdmFyIHgwLCB5MDtcbiAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQoeCwgeSkge1xuICAgICAgdmFyIGR4ID0geCAtIHgwLCBkeSA9IHkgLSB5MCwgeiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMSArPSB6ICogKHgwICsgeCkgLyAyO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTEgKz0geiAqICh5MCArIHkpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoxICs9IHo7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkTGluZUVuZCgpIHtcbiAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gICAgdmFyIHgwMCwgeTAwLCB4MCwgeTA7XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KHgsIHkpIHtcbiAgICAgIHZhciBkeCA9IHggLSB4MCwgZHkgPSB5IC0geTAsIHogPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMSArPSB6O1xuICAgICAgeiA9IHkwICogeCAtIHgwICogeTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgyICs9IHogKiAoeDAgKyB4KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkyICs9IHogKiAoeTAgKyB5KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoyICs9IHogKiAzO1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbiAgICB9XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0UG9pbnQoeDAwLCB5MDApO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDb250ZXh0KGNvbnRleHQpIHtcbiAgICB2YXIgcG9pbnRSYWRpdXMgPSA0LjU7XG4gICAgdmFyIHN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZVN0YXJ0O1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCA9IGxpbmVFbmRQb2x5Z29uO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgfSxcbiAgICAgIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgICAgIHBvaW50UmFkaXVzID0gXztcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICByZXN1bHQ6IGQzX25vb3BcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHggKyBwb2ludFJhZGl1cywgeSk7XG4gICAgICBjb250ZXh0LmFyYyh4LCB5LCBwb2ludFJhZGl1cywgMCwgz4QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmVTdGFydCh4LCB5KSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lKHgsIHkpIHtcbiAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmRQb2x5Z29uKCkge1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcmVzYW1wbGUocHJvamVjdCkge1xuICAgIHZhciDOtDIgPSAuNSwgY29zTWluRGlzdGFuY2UgPSBNYXRoLmNvcygzMCAqIGQzX3JhZGlhbnMpLCBtYXhEZXB0aCA9IDE2O1xuICAgIGZ1bmN0aW9uIHJlc2FtcGxlKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIChtYXhEZXB0aCA/IHJlc2FtcGxlUmVjdXJzaXZlIDogcmVzYW1wbGVOb25lKShzdHJlYW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZU5vbmUoc3RyZWFtKSB7XG4gICAgICByZXR1cm4gZDNfZ2VvX3RyYW5zZm9ybVBvaW50KHN0cmVhbSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlUmVjdXJzaXZlKHN0cmVhbSkge1xuICAgICAgdmFyIM67MDAsIM+GMDAsIHgwMCwgeTAwLCBhMDAsIGIwMCwgYzAwLCDOuzAsIHgwLCB5MCwgYTAsIGIwLCBjMDtcbiAgICAgIHZhciByZXNhbXBsZSA9IHtcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgcmVzYW1wbGUubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgIHJlc2FtcGxlLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgeDAgPSBOYU47XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lUG9pbnQozrssIM+GKSB7XG4gICAgICAgIHZhciBjID0gZDNfZ2VvX2NhcnRlc2lhbihbIM67LCDPhiBdKSwgcCA9IHByb2plY3QozrssIM+GKTtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCDOuzAsIGEwLCBiMCwgYzAsIHgwID0gcFswXSwgeTAgPSBwWzFdLCDOuzAgPSDOuywgYTAgPSBjWzBdLCBiMCA9IGNbMV0sIGMwID0gY1syXSwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4MCwgeTApO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgcmVzYW1wbGUucG9pbnQgPSBwb2ludDtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gcmluZ1BvaW50O1xuICAgICAgICByZXNhbXBsZS5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdQb2ludCjOuywgz4YpIHtcbiAgICAgICAgbGluZVBvaW50KM67MDAgPSDOuywgz4YwMCA9IM+GKSwgeDAwID0geDAsIHkwMCA9IHkwLCBhMDAgPSBhMCwgYjAwID0gYjAsIGMwMCA9IGMwO1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgzrswMCwgYTAwLCBiMDAsIGMwMCwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIHJlc2FtcGxlLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBsaW5lRW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzYW1wbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MSwgeTEsIM67MSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSkge1xuICAgICAgdmFyIGR4ID0geDEgLSB4MCwgZHkgPSB5MSAtIHkwLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgaWYgKGQyID4gNCAqIM60MiAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhciBhID0gYTAgKyBhMSwgYiA9IGIwICsgYjEsIGMgPSBjMCArIGMxLCBtID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYyksIM+GMiA9IE1hdGguYXNpbihjIC89IG0pLCDOuzIgPSBhYnMoYWJzKGMpIC0gMSkgPCDOtSB8fCBhYnMozrswIC0gzrsxKSA8IM61ID8gKM67MCArIM67MSkgLyAyIDogTWF0aC5hdGFuMihiLCBhKSwgcCA9IHByb2plY3QozrsyLCDPhjIpLCB4MiA9IHBbMF0sIHkyID0gcFsxXSwgZHgyID0geDIgLSB4MCwgZHkyID0geTIgLSB5MCwgZHogPSBkeSAqIGR4MiAtIGR4ICogZHkyO1xuICAgICAgICBpZiAoZHogKiBkeiAvIGQyID4gzrQyIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIC41KSA+IC4zIHx8IGEwICogYTEgKyBiMCAqIGIxICsgYzAgKiBjMSA8IGNvc01pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCDOuzAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgzrsyLCBhIC89IG0sIGIgLz0gbSwgYywgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgICAgc3RyZWFtLnBvaW50KHgyLCB5Mik7XG4gICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDIsIHkyLCDOuzIsIGEsIGIsIGMsIHgxLCB5MSwgzrsxLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXNhbXBsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBNYXRoLnNxcnQozrQyKTtcbiAgICAgIG1heERlcHRoID0gKM60MiA9IF8gKiBfKSA+IDAgJiYgMTY7XG4gICAgICByZXR1cm4gcmVzYW1wbGU7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzYW1wbGU7XG4gIH1cbiAgZDMuZ2VvLnBhdGggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcG9pbnRSYWRpdXMgPSA0LjUsIHByb2plY3Rpb24sIGNvbnRleHQsIHByb2plY3RTdHJlYW0sIGNvbnRleHRTdHJlYW0sIGNhY2hlU3RyZWFtO1xuICAgIGZ1bmN0aW9uIHBhdGgob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrcG9pbnRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICghY2FjaGVTdHJlYW0gfHwgIWNhY2hlU3RyZWFtLnZhbGlkKSBjYWNoZVN0cmVhbSA9IHByb2plY3RTdHJlYW0oY29udGV4dFN0cmVhbSk7XG4gICAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBjYWNoZVN0cmVhbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGV4dFN0cmVhbS5yZXN1bHQoKTtcbiAgICB9XG4gICAgcGF0aC5hcmVhID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWFTdW0gPSAwO1xuICAgICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIHByb2plY3RTdHJlYW0oZDNfZ2VvX3BhdGhBcmVhKSk7XG4gICAgICByZXR1cm4gZDNfZ2VvX3BhdGhBcmVhU3VtO1xuICAgIH07XG4gICAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDAgPSBkM19nZW9fY2VudHJvaWRZMCA9IGQzX2dlb19jZW50cm9pZFowID0gZDNfZ2VvX2NlbnRyb2lkWDEgPSBkM19nZW9fY2VudHJvaWRZMSA9IGQzX2dlb19jZW50cm9pZFoxID0gZDNfZ2VvX2NlbnRyb2lkWDIgPSBkM19nZW9fY2VudHJvaWRZMiA9IGQzX2dlb19jZW50cm9pZFoyID0gMDtcbiAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBwcm9qZWN0U3RyZWFtKGQzX2dlb19wYXRoQ2VudHJvaWQpKTtcbiAgICAgIHJldHVybiBkM19nZW9fY2VudHJvaWRaMiA/IFsgZDNfZ2VvX2NlbnRyb2lkWDIgLyBkM19nZW9fY2VudHJvaWRaMiwgZDNfZ2VvX2NlbnRyb2lkWTIgLyBkM19nZW9fY2VudHJvaWRaMiBdIDogZDNfZ2VvX2NlbnRyb2lkWjEgPyBbIGQzX2dlb19jZW50cm9pZFgxIC8gZDNfZ2VvX2NlbnRyb2lkWjEsIGQzX2dlb19jZW50cm9pZFkxIC8gZDNfZ2VvX2NlbnRyb2lkWjEgXSA6IGQzX2dlb19jZW50cm9pZFowID8gWyBkM19nZW9fY2VudHJvaWRYMCAvIGQzX2dlb19jZW50cm9pZFowLCBkM19nZW9fY2VudHJvaWRZMCAvIGQzX2dlb19jZW50cm9pZFowIF0gOiBbIE5hTiwgTmFOIF07XG4gICAgfTtcbiAgICBwYXRoLmJvdW5kcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgZDNfZ2VvX3BhdGhCb3VuZHNYMSA9IGQzX2dlb19wYXRoQm91bmRzWTEgPSAtKGQzX2dlb19wYXRoQm91bmRzWDAgPSBkM19nZW9fcGF0aEJvdW5kc1kwID0gSW5maW5pdHkpO1xuICAgICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIHByb2plY3RTdHJlYW0oZDNfZ2VvX3BhdGhCb3VuZHMpKTtcbiAgICAgIHJldHVybiBbIFsgZDNfZ2VvX3BhdGhCb3VuZHNYMCwgZDNfZ2VvX3BhdGhCb3VuZHNZMCBdLCBbIGQzX2dlb19wYXRoQm91bmRzWDEsIGQzX2dlb19wYXRoQm91bmRzWTEgXSBdO1xuICAgIH07XG4gICAgcGF0aC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgIHByb2plY3RTdHJlYW0gPSAocHJvamVjdGlvbiA9IF8pID8gXy5zdHJlYW0gfHwgZDNfZ2VvX3BhdGhQcm9qZWN0U3RyZWFtKF8pIDogZDNfaWRlbnRpdHk7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHBhdGguY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgICBjb250ZXh0U3RyZWFtID0gKGNvbnRleHQgPSBfKSA9PSBudWxsID8gbmV3IGQzX2dlb19wYXRoQnVmZmVyKCkgOiBuZXcgZDNfZ2VvX3BhdGhDb250ZXh0KF8pO1xuICAgICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKHBvaW50UmFkaXVzKTtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcGF0aC5wb2ludFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBvaW50UmFkaXVzO1xuICAgICAgcG9pbnRSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IChjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtfKSwgK18pO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5wcm9qZWN0aW9uKGQzLmdlby5hbGJlcnNVc2EoKSkuY29udGV4dChudWxsKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhQcm9qZWN0U3RyZWFtKHByb2plY3QpIHtcbiAgICB2YXIgcmVzYW1wbGUgPSBkM19nZW9fcmVzYW1wbGUoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHByb2plY3QoWyB4ICogZDNfZGVncmVlcywgeSAqIGQzX2RlZ3JlZXMgXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uUmFkaWFucyhyZXNhbXBsZShzdHJlYW0pKTtcbiAgICB9O1xuICB9XG4gIGQzLmdlby50cmFuc2Zvcm0gPSBmdW5jdGlvbihtZXRob2RzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmVhbTogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgZDNfZ2VvX3RyYW5zZm9ybShzdHJlYW0pO1xuICAgICAgICBmb3IgKHZhciBrIGluIG1ldGhvZHMpIHRyYW5zZm9ybVtrXSA9IG1ldGhvZHNba107XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3RyYW5zZm9ybShzdHJlYW0pIHtcbiAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgfVxuICBkM19nZW9fdHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdGhpcy5zdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgfSxcbiAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0uc3BoZXJlKCk7XG4gICAgfSxcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9LFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3RyYW5zZm9ybVBvaW50KHN0cmVhbSwgcG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnNwaGVyZSgpO1xuICAgICAgfSxcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkMy5nZW8ucHJvamVjdGlvbiA9IGQzX2dlb19wcm9qZWN0aW9uO1xuICBkMy5nZW8ucHJvamVjdGlvbk11dGF0b3IgPSBkM19nZW9fcHJvamVjdGlvbk11dGF0b3I7XG4gIGZ1bmN0aW9uIGQzX2dlb19wcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHByb2plY3Q7XG4gICAgfSkoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSB7XG4gICAgdmFyIHByb2plY3QsIHJvdGF0ZSwgcHJvamVjdFJvdGF0ZSwgcHJvamVjdFJlc2FtcGxlID0gZDNfZ2VvX3Jlc2FtcGxlKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgcmV0dXJuIFsgeFswXSAqIGsgKyDOtHgsIM60eSAtIHhbMV0gKiBrIF07XG4gICAgfSksIGsgPSAxNTAsIHggPSA0ODAsIHkgPSAyNTAsIM67ID0gMCwgz4YgPSAwLCDOtM67ID0gMCwgzrTPhiA9IDAsIM60zrMgPSAwLCDOtHgsIM60eSwgcHJlY2xpcCA9IGQzX2dlb19jbGlwQW50aW1lcmlkaWFuLCBwb3N0Y2xpcCA9IGQzX2lkZW50aXR5LCBjbGlwQW5nbGUgPSBudWxsLCBjbGlwRXh0ZW50ID0gbnVsbCwgc3RyZWFtO1xuICAgIGZ1bmN0aW9uIHByb2plY3Rpb24ocG9pbnQpIHtcbiAgICAgIHBvaW50ID0gcHJvamVjdFJvdGF0ZShwb2ludFswXSAqIGQzX3JhZGlhbnMsIHBvaW50WzFdICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gWyBwb2ludFswXSAqIGsgKyDOtHgsIM60eSAtIHBvaW50WzFdICogayBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZlcnQocG9pbnQpIHtcbiAgICAgIHBvaW50ID0gcHJvamVjdFJvdGF0ZS5pbnZlcnQoKHBvaW50WzBdIC0gzrR4KSAvIGssICjOtHkgLSBwb2ludFsxXSkgLyBrKTtcbiAgICAgIHJldHVybiBwb2ludCAmJiBbIHBvaW50WzBdICogZDNfZGVncmVlcywgcG9pbnRbMV0gKiBkM19kZWdyZWVzIF07XG4gICAgfVxuICAgIHByb2plY3Rpb24uc3RyZWFtID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbSA9IGQzX2dlb19wcm9qZWN0aW9uUmFkaWFucyhwcmVjbGlwKHJvdGF0ZSwgcHJvamVjdFJlc2FtcGxlKHBvc3RjbGlwKG91dHB1dCkpKSk7XG4gICAgICBzdHJlYW0udmFsaWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uY2xpcEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEFuZ2xlO1xuICAgICAgcHJlY2xpcCA9IF8gPT0gbnVsbCA/IChjbGlwQW5nbGUgPSBfLCBkM19nZW9fY2xpcEFudGltZXJpZGlhbikgOiBkM19nZW9fY2xpcENpcmNsZSgoY2xpcEFuZ2xlID0gK18pICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gaW52YWxpZGF0ZSgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEV4dGVudDtcbiAgICAgIGNsaXBFeHRlbnQgPSBfO1xuICAgICAgcG9zdGNsaXAgPSBfID8gZDNfZ2VvX2NsaXBFeHRlbnQoX1swXVswXSwgX1swXVsxXSwgX1sxXVswXSwgX1sxXVsxXSkgOiBkM19pZGVudGl0eTtcbiAgICAgIHJldHVybiBpbnZhbGlkYXRlKCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaztcbiAgICAgIGsgPSArXztcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIHgsIHkgXTtcbiAgICAgIHggPSArX1swXTtcbiAgICAgIHkgPSArX1sxXTtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIM67ICogZDNfZGVncmVlcywgz4YgKiBkM19kZWdyZWVzIF07XG4gICAgICDOuyA9IF9bMF0gJSAzNjAgKiBkM19yYWRpYW5zO1xuICAgICAgz4YgPSBfWzFdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIM60zrsgKiBkM19kZWdyZWVzLCDOtM+GICogZDNfZGVncmVlcywgzrTOsyAqIGQzX2RlZ3JlZXMgXTtcbiAgICAgIM60zrsgPSBfWzBdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIM60z4YgPSBfWzFdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIM60zrMgPSBfLmxlbmd0aCA+IDIgPyBfWzJdICUgMzYwICogZDNfcmFkaWFucyA6IDA7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIGQzLnJlYmluZChwcm9qZWN0aW9uLCBwcm9qZWN0UmVzYW1wbGUsIFwicHJlY2lzaW9uXCIpO1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgcHJvamVjdFJvdGF0ZSA9IGQzX2dlb19jb21wb3NlKHJvdGF0ZSA9IGQzX2dlb19yb3RhdGlvbijOtM67LCDOtM+GLCDOtM6zKSwgcHJvamVjdCk7XG4gICAgICB2YXIgY2VudGVyID0gcHJvamVjdCjOuywgz4YpO1xuICAgICAgzrR4ID0geCAtIGNlbnRlclswXSAqIGs7XG4gICAgICDOtHkgPSB5ICsgY2VudGVyWzFdICogaztcbiAgICAgIHJldHVybiBpbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZSwgc3RyZWFtID0gbnVsbDtcbiAgICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBwcm9qZWN0ID0gcHJvamVjdEF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBwcm9qZWN0aW9uLmludmVydCA9IHByb2plY3QuaW52ZXJ0ICYmIGludmVydDtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3Byb2plY3Rpb25SYWRpYW5zKHN0cmVhbSkge1xuICAgIHJldHVybiBkM19nZW9fdHJhbnNmb3JtUG9pbnQoc3RyZWFtLCBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBzdHJlYW0ucG9pbnQoeCAqIGQzX3JhZGlhbnMsIHkgKiBkM19yYWRpYW5zKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyKM67LCDPhikge1xuICAgIHJldHVybiBbIM67LCDPhiBdO1xuICB9XG4gIChkMy5nZW8uZXF1aXJlY3Rhbmd1bGFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19lcXVpcmVjdGFuZ3VsYXIpO1xuICB9KS5yYXcgPSBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyLmludmVydCA9IGQzX2dlb19lcXVpcmVjdGFuZ3VsYXI7XG4gIGQzLmdlby5yb3RhdGlvbiA9IGZ1bmN0aW9uKHJvdGF0ZSkge1xuICAgIHJvdGF0ZSA9IGQzX2dlb19yb3RhdGlvbihyb3RhdGVbMF0gJSAzNjAgKiBkM19yYWRpYW5zLCByb3RhdGVbMV0gKiBkM19yYWRpYW5zLCByb3RhdGUubGVuZ3RoID4gMiA/IHJvdGF0ZVsyXSAqIGQzX3JhZGlhbnMgOiAwKTtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKGNvb3JkaW5hdGVzKSB7XG4gICAgICBjb29yZGluYXRlcyA9IHJvdGF0ZShjb29yZGluYXRlc1swXSAqIGQzX3JhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gICAgfVxuICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gcm90YXRlLmludmVydChjb29yZGluYXRlc1swXSAqIGQzX3JhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2lkZW50aXR5Um90YXRpb24ozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgzrsgPiDPgCA/IM67IC0gz4QgOiDOuyA8IC3PgCA/IM67ICsgz4QgOiDOuywgz4YgXTtcbiAgfVxuICBkM19nZW9faWRlbnRpdHlSb3RhdGlvbi5pbnZlcnQgPSBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyO1xuICBmdW5jdGlvbiBkM19nZW9fcm90YXRpb24ozrTOuywgzrTPhiwgzrTOsykge1xuICAgIHJldHVybiDOtM67ID8gzrTPhiB8fCDOtM6zID8gZDNfZ2VvX2NvbXBvc2UoZDNfZ2VvX3JvdGF0aW9uzrsozrTOuyksIGQzX2dlb19yb3RhdGlvbs+GzrMozrTPhiwgzrTOsykpIDogZDNfZ2VvX3JvdGF0aW9uzrsozrTOuykgOiDOtM+GIHx8IM60zrMgPyBkM19nZW9fcm90YXRpb27Phs6zKM60z4YsIM60zrMpIDogZDNfZ2VvX2lkZW50aXR5Um90YXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2ZvcndhcmRSb3RhdGlvbs67KM60zrspIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICByZXR1cm4gzrsgKz0gzrTOuywgWyDOuyA+IM+AID8gzrsgLSDPhCA6IM67IDwgLc+AID8gzrsgKyDPhCA6IM67LCDPhiBdO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3JvdGF0aW9uzrsozrTOuykge1xuICAgIHZhciByb3RhdGlvbiA9IGQzX2dlb19mb3J3YXJkUm90YXRpb27OuyjOtM67KTtcbiAgICByb3RhdGlvbi5pbnZlcnQgPSBkM19nZW9fZm9yd2FyZFJvdGF0aW9uzrsoLc60zrspO1xuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcm90YXRpb27Phs6zKM60z4YsIM60zrMpIHtcbiAgICB2YXIgY29zzrTPhiA9IE1hdGguY29zKM60z4YpLCBzaW7OtM+GID0gTWF0aC5zaW4ozrTPhiksIGNvc860zrMgPSBNYXRoLmNvcyjOtM6zKSwgc2luzrTOsyA9IE1hdGguc2luKM60zrMpO1xuICAgIGZ1bmN0aW9uIHJvdGF0aW9uKM67LCDPhikge1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YpLCB4ID0gTWF0aC5jb3MozrspICogY29zz4YsIHkgPSBNYXRoLnNpbijOuykgKiBjb3PPhiwgeiA9IE1hdGguc2luKM+GKSwgayA9IHogKiBjb3POtM+GICsgeCAqIHNpbs60z4Y7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHkgKiBjb3POtM6zIC0gayAqIHNpbs60zrMsIHggKiBjb3POtM+GIC0geiAqIHNpbs60z4YpLCBkM19hc2luKGsgKiBjb3POtM6zICsgeSAqIHNpbs60zrMpIF07XG4gICAgfVxuICAgIHJvdGF0aW9uLmludmVydCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YpLCB4ID0gTWF0aC5jb3MozrspICogY29zz4YsIHkgPSBNYXRoLnNpbijOuykgKiBjb3PPhiwgeiA9IE1hdGguc2luKM+GKSwgayA9IHogKiBjb3POtM6zIC0geSAqIHNpbs60zrM7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHkgKiBjb3POtM6zICsgeiAqIHNpbs60zrMsIHggKiBjb3POtM+GICsgayAqIHNpbs60z4YpLCBkM19hc2luKGsgKiBjb3POtM+GIC0geCAqIHNpbs60z4YpIF07XG4gICAgfTtcbiAgICByZXR1cm4gcm90YXRpb247XG4gIH1cbiAgZDMuZ2VvLmNpcmNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW4gPSBbIDAsIDAgXSwgYW5nbGUsIHByZWNpc2lvbiA9IDYsIGludGVycG9sYXRlO1xuICAgIGZ1bmN0aW9uIGNpcmNsZSgpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0eXBlb2Ygb3JpZ2luID09PSBcImZ1bmN0aW9uXCIgPyBvcmlnaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IG9yaWdpbiwgcm90YXRlID0gZDNfZ2VvX3JvdGF0aW9uKC1jZW50ZXJbMF0gKiBkM19yYWRpYW5zLCAtY2VudGVyWzFdICogZDNfcmFkaWFucywgMCkuaW52ZXJ0LCByaW5nID0gW107XG4gICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCB7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgcmluZy5wdXNoKHggPSByb3RhdGUoeCwgeSkpO1xuICAgICAgICAgIHhbMF0gKj0gZDNfZGVncmVlcywgeFsxXSAqPSBkM19kZWdyZWVzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogWyByaW5nIF1cbiAgICAgIH07XG4gICAgfVxuICAgIGNpcmNsZS5vcmlnaW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmlnaW47XG4gICAgICBvcmlnaW4gPSB4O1xuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9O1xuICAgIGNpcmNsZS5hbmdsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFuZ2xlO1xuICAgICAgaW50ZXJwb2xhdGUgPSBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUoKGFuZ2xlID0gK3gpICogZDNfcmFkaWFucywgcHJlY2lzaW9uICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH07XG4gICAgY2lyY2xlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByZWNpc2lvbjtcbiAgICAgIGludGVycG9sYXRlID0gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKGFuZ2xlICogZDNfcmFkaWFucywgKHByZWNpc2lvbiA9ICtfKSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9O1xuICAgIHJldHVybiBjaXJjbGUuYW5nbGUoOTApO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUocmFkaXVzLCBwcmVjaXNpb24pIHtcbiAgICB2YXIgY3IgPSBNYXRoLmNvcyhyYWRpdXMpLCBzciA9IE1hdGguc2luKHJhZGl1cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZyb20sIHRvLCBkaXJlY3Rpb24sIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgc3RlcCA9IGRpcmVjdGlvbiAqIHByZWNpc2lvbjtcbiAgICAgIGlmIChmcm9tICE9IG51bGwpIHtcbiAgICAgICAgZnJvbSA9IGQzX2dlb19jaXJjbGVBbmdsZShjciwgZnJvbSk7XG4gICAgICAgIHRvID0gZDNfZ2VvX2NpcmNsZUFuZ2xlKGNyLCB0byk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPiAwID8gZnJvbSA8IHRvIDogZnJvbSA+IHRvKSBmcm9tICs9IGRpcmVjdGlvbiAqIM+EO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbSA9IHJhZGl1cyArIGRpcmVjdGlvbiAqIM+EO1xuICAgICAgICB0byA9IHJhZGl1cyAtIC41ICogc3RlcDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHBvaW50LCB0ID0gZnJvbTsgZGlyZWN0aW9uID4gMCA/IHQgPiB0byA6IHQgPCB0bzsgdCAtPSBzdGVwKSB7XG4gICAgICAgIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IGQzX2dlb19zcGhlcmljYWwoWyBjciwgLXNyICogTWF0aC5jb3ModCksIC1zciAqIE1hdGguc2luKHQpIF0pKVswXSwgcG9pbnRbMV0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NpcmNsZUFuZ2xlKGNyLCBwb2ludCkge1xuICAgIHZhciBhID0gZDNfZ2VvX2NhcnRlc2lhbihwb2ludCk7XG4gICAgYVswXSAtPSBjcjtcbiAgICBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGEpO1xuICAgIHZhciBhbmdsZSA9IGQzX2Fjb3MoLWFbMV0pO1xuICAgIHJldHVybiAoKC1hWzJdIDwgMCA/IC1hbmdsZSA6IGFuZ2xlKSArIDIgKiBNYXRoLlBJIC0gzrUpICUgKDIgKiBNYXRoLlBJKTtcbiAgfVxuICBkMy5nZW8uZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIM6UzrsgPSAoYlswXSAtIGFbMF0pICogZDNfcmFkaWFucywgz4YwID0gYVsxXSAqIGQzX3JhZGlhbnMsIM+GMSA9IGJbMV0gKiBkM19yYWRpYW5zLCBzaW7OlM67ID0gTWF0aC5zaW4ozpTOuyksIGNvc86UzrsgPSBNYXRoLmNvcyjOlM67KSwgc2luz4YwID0gTWF0aC5zaW4oz4YwKSwgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgc2luz4YxID0gTWF0aC5zaW4oz4YxKSwgY29zz4YxID0gTWF0aC5jb3Moz4YxKSwgdDtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihNYXRoLnNxcnQoKHQgPSBjb3PPhjEgKiBzaW7OlM67KSAqIHQgKyAodCA9IGNvc8+GMCAqIHNpbs+GMSAtIHNpbs+GMCAqIGNvc8+GMSAqIGNvc86UzrspICogdCksIHNpbs+GMCAqIHNpbs+GMSArIGNvc8+GMCAqIGNvc8+GMSAqIGNvc86UzrspO1xuICB9O1xuICBkMy5nZW8uZ3JhdGljdWxlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHgxLCB4MCwgWDEsIFgwLCB5MSwgeTAsIFkxLCBZMCwgZHggPSAxMCwgZHkgPSBkeCwgRFggPSA5MCwgRFkgPSAzNjAsIHgsIHksIFgsIFksIHByZWNpc2lvbiA9IDIuNTtcbiAgICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLFxuICAgICAgICBjb29yZGluYXRlczogbGluZXMoKVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZXMoKSB7XG4gICAgICByZXR1cm4gZDMucmFuZ2UoTWF0aC5jZWlsKFgwIC8gRFgpICogRFgsIFgxLCBEWCkubWFwKFgpLmNvbmNhdChkMy5yYW5nZShNYXRoLmNlaWwoWTAgLyBEWSkgKiBEWSwgWTEsIERZKS5tYXAoWSkpLmNvbmNhdChkMy5yYW5nZShNYXRoLmNlaWwoeDAgLyBkeCkgKiBkeCwgeDEsIGR4KS5maWx0ZXIoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gYWJzKHggJSBEWCkgPiDOtTtcbiAgICAgIH0pLm1hcCh4KSkuY29uY2F0KGQzLnJhbmdlKE1hdGguY2VpbCh5MCAvIGR5KSAqIGR5LCB5MSwgZHkpLmZpbHRlcihmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBhYnMoeSAlIERZKSA+IM61O1xuICAgICAgfSkubWFwKHkpKTtcbiAgICB9XG4gICAgZ3JhdGljdWxlLmxpbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbGluZXMoKS5tYXAoZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm91dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogWyBYKFgwKS5jb25jYXQoWShZMSkuc2xpY2UoMSksIFgoWDEpLnJldmVyc2UoKS5zbGljZSgxKSwgWShZMCkucmV2ZXJzZSgpLnNsaWNlKDEpKSBdXG4gICAgICB9O1xuICAgIH07XG4gICAgZ3JhdGljdWxlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5taW5vckV4dGVudCgpO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZS5tYWpvckV4dGVudChfKS5taW5vckV4dGVudChfKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5tYWpvckV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgWyBYMCwgWTAgXSwgWyBYMSwgWTEgXSBdO1xuICAgICAgWDAgPSArX1swXVswXSwgWDEgPSArX1sxXVswXTtcbiAgICAgIFkwID0gK19bMF1bMV0sIFkxID0gK19bMV1bMV07XG4gICAgICBpZiAoWDAgPiBYMSkgXyA9IFgwLCBYMCA9IFgxLCBYMSA9IF87XG4gICAgICBpZiAoWTAgPiBZMSkgXyA9IFkwLCBZMCA9IFkxLCBZMSA9IF87XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm1pbm9yRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBbIHgwLCB5MCBdLCBbIHgxLCB5MSBdIF07XG4gICAgICB4MCA9ICtfWzBdWzBdLCB4MSA9ICtfWzFdWzBdO1xuICAgICAgeTAgPSArX1swXVsxXSwgeTEgPSArX1sxXVsxXTtcbiAgICAgIGlmICh4MCA+IHgxKSBfID0geDAsIHgwID0geDEsIHgxID0gXztcbiAgICAgIGlmICh5MCA+IHkxKSBfID0geTAsIHkwID0geTEsIHkxID0gXztcbiAgICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgfTtcbiAgICBncmF0aWN1bGUuc3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5taW5vclN0ZXAoKTtcbiAgICAgIHJldHVybiBncmF0aWN1bGUubWFqb3JTdGVwKF8pLm1pbm9yU3RlcChfKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5tYWpvclN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIERYLCBEWSBdO1xuICAgICAgRFggPSArX1swXSwgRFkgPSArX1sxXTtcbiAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWlub3JTdGVwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBkeCwgZHkgXTtcbiAgICAgIGR4ID0gK19bMF0sIGR5ID0gK19bMV07XG4gICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByZWNpc2lvbjtcbiAgICAgIHByZWNpc2lvbiA9ICtfO1xuICAgICAgeCA9IGQzX2dlb19ncmF0aWN1bGVYKHkwLCB5MSwgOTApO1xuICAgICAgeSA9IGQzX2dlb19ncmF0aWN1bGVZKHgwLCB4MSwgcHJlY2lzaW9uKTtcbiAgICAgIFggPSBkM19nZW9fZ3JhdGljdWxlWChZMCwgWTEsIDkwKTtcbiAgICAgIFkgPSBkM19nZW9fZ3JhdGljdWxlWShYMCwgWDEsIHByZWNpc2lvbik7XG4gICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgIH07XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5tYWpvckV4dGVudChbIFsgLTE4MCwgLTkwICsgzrUgXSwgWyAxODAsIDkwIC0gzrUgXSBdKS5taW5vckV4dGVudChbIFsgLTE4MCwgLTgwIC0gzrUgXSwgWyAxODAsIDgwICsgzrUgXSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2dyYXRpY3VsZVgoeTAsIHkxLCBkeSkge1xuICAgIHZhciB5ID0gZDMucmFuZ2UoeTAsIHkxIC0gzrUsIGR5KS5jb25jYXQoeTEpO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geS5tYXAoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gWyB4LCB5IF07XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19ncmF0aWN1bGVZKHgwLCB4MSwgZHgpIHtcbiAgICB2YXIgeCA9IGQzLnJhbmdlKHgwLCB4MSAtIM61LCBkeCkuY29uY2F0KHgxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHgubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIFsgeCwgeSBdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19zb3VyY2UoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfVxuICBmdW5jdGlvbiBkM190YXJnZXQoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfVxuICBkMy5nZW8uZ3JlYXRBcmMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gZDNfc291cmNlLCBzb3VyY2VfLCB0YXJnZXQgPSBkM190YXJnZXQsIHRhcmdldF87XG4gICAgZnVuY3Rpb24gZ3JlYXRBcmMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgc291cmNlXyB8fCBzb3VyY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGFyZ2V0XyB8fCB0YXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSBdXG4gICAgICB9O1xuICAgIH1cbiAgICBncmVhdEFyYy5kaXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzLmdlby5kaXN0YW5jZShzb3VyY2VfIHx8IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0YXJnZXRfIHx8IHRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIGdyZWF0QXJjLnNvdXJjZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IF8sIHNvdXJjZV8gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IF87XG4gICAgICByZXR1cm4gZ3JlYXRBcmM7XG4gICAgfTtcbiAgICBncmVhdEFyYy50YXJnZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBfLCB0YXJnZXRfID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IG51bGwgOiBfO1xuICAgICAgcmV0dXJuIGdyZWF0QXJjO1xuICAgIH07XG4gICAgZ3JlYXRBcmMucHJlY2lzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGdyZWF0QXJjIDogMDtcbiAgICB9O1xuICAgIHJldHVybiBncmVhdEFyYztcbiAgfTtcbiAgZDMuZ2VvLmludGVycG9sYXRlID0gZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2ludGVycG9sYXRlKHNvdXJjZVswXSAqIGQzX3JhZGlhbnMsIHNvdXJjZVsxXSAqIGQzX3JhZGlhbnMsIHRhcmdldFswXSAqIGQzX3JhZGlhbnMsIHRhcmdldFsxXSAqIGQzX3JhZGlhbnMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9faW50ZXJwb2xhdGUoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB2YXIgY3kwID0gTWF0aC5jb3MoeTApLCBzeTAgPSBNYXRoLnNpbih5MCksIGN5MSA9IE1hdGguY29zKHkxKSwgc3kxID0gTWF0aC5zaW4oeTEpLCBreDAgPSBjeTAgKiBNYXRoLmNvcyh4MCksIGt5MCA9IGN5MCAqIE1hdGguc2luKHgwKSwga3gxID0gY3kxICogTWF0aC5jb3MoeDEpLCBreTEgPSBjeTEgKiBNYXRoLnNpbih4MSksIGQgPSAyICogTWF0aC5hc2luKE1hdGguc3FydChkM19oYXZlcnNpbih5MSAtIHkwKSArIGN5MCAqIGN5MSAqIGQzX2hhdmVyc2luKHgxIC0geDApKSksIGsgPSAxIC8gTWF0aC5zaW4oZCk7XG4gICAgdmFyIGludGVycG9sYXRlID0gZCA/IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBCID0gTWF0aC5zaW4odCAqPSBkKSAqIGssIEEgPSBNYXRoLnNpbihkIC0gdCkgKiBrLCB4ID0gQSAqIGt4MCArIEIgKiBreDEsIHkgPSBBICoga3kwICsgQiAqIGt5MSwgeiA9IEEgKiBzeTAgKyBCICogc3kxO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5LCB4KSAqIGQzX2RlZ3JlZXMsIE1hdGguYXRhbjIoeiwgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKSAqIGQzX2RlZ3JlZXMgXTtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gWyB4MCAqIGQzX2RlZ3JlZXMsIHkwICogZDNfZGVncmVlcyBdO1xuICAgIH07XG4gICAgaW50ZXJwb2xhdGUuZGlzdGFuY2UgPSBkO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgfVxuICBkMy5nZW8ubGVuZ3RoID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZDNfZ2VvX2xlbmd0aFN1bSA9IDA7XG4gICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIGQzX2dlb19sZW5ndGgpO1xuICAgIHJldHVybiBkM19nZW9fbGVuZ3RoU3VtO1xuICB9O1xuICB2YXIgZDNfZ2VvX2xlbmd0aFN1bTtcbiAgdmFyIGQzX2dlb19sZW5ndGggPSB7XG4gICAgc3BoZXJlOiBkM19ub29wLFxuICAgIHBvaW50OiBkM19ub29wLFxuICAgIGxpbmVTdGFydDogZDNfZ2VvX2xlbmd0aExpbmVTdGFydCxcbiAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgIHBvbHlnb25TdGFydDogZDNfbm9vcCxcbiAgICBwb2x5Z29uRW5kOiBkM19ub29wXG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19sZW5ndGhMaW5lU3RhcnQoKSB7XG4gICAgdmFyIM67MCwgc2luz4YwLCBjb3PPhjA7XG4gICAgZDNfZ2VvX2xlbmd0aC5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgzrswID0gzrsgKiBkM19yYWRpYW5zLCBzaW7PhjAgPSBNYXRoLnNpbijPhiAqPSBkM19yYWRpYW5zKSwgY29zz4YwID0gTWF0aC5jb3Moz4YpO1xuICAgICAgZDNfZ2VvX2xlbmd0aC5wb2ludCA9IG5leHRQb2ludDtcbiAgICB9O1xuICAgIGQzX2dlb19sZW5ndGgubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2xlbmd0aC5wb2ludCA9IGQzX2dlb19sZW5ndGgubGluZUVuZCA9IGQzX25vb3A7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQozrssIM+GKSB7XG4gICAgICB2YXIgc2luz4YgPSBNYXRoLnNpbijPhiAqPSBkM19yYWRpYW5zKSwgY29zz4YgPSBNYXRoLmNvcyjPhiksIHQgPSBhYnMoKM67ICo9IGQzX3JhZGlhbnMpIC0gzrswKSwgY29zzpTOuyA9IE1hdGguY29zKHQpO1xuICAgICAgZDNfZ2VvX2xlbmd0aFN1bSArPSBNYXRoLmF0YW4yKE1hdGguc3FydCgodCA9IGNvc8+GICogTWF0aC5zaW4odCkpICogdCArICh0ID0gY29zz4YwICogc2luz4YgLSBzaW7PhjAgKiBjb3PPhiAqIGNvc86UzrspICogdCksIHNpbs+GMCAqIHNpbs+GICsgY29zz4YwICogY29zz4YgKiBjb3POlM67KTtcbiAgICAgIM67MCA9IM67LCBzaW7PhjAgPSBzaW7PhiwgY29zz4YwID0gY29zz4Y7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19hemltdXRoYWwoc2NhbGUsIGFuZ2xlKSB7XG4gICAgZnVuY3Rpb24gYXppbXV0aGFsKM67LCDPhikge1xuICAgICAgdmFyIGNvc867ID0gTWF0aC5jb3MozrspLCBjb3PPhiA9IE1hdGguY29zKM+GKSwgayA9IHNjYWxlKGNvc867ICogY29zz4YpO1xuICAgICAgcmV0dXJuIFsgayAqIGNvc8+GICogTWF0aC5zaW4ozrspLCBrICogTWF0aC5zaW4oz4YpIF07XG4gICAgfVxuICAgIGF6aW11dGhhbC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSksIGMgPSBhbmdsZSjPgSksIHNpbmMgPSBNYXRoLnNpbihjKSwgY29zYyA9IE1hdGguY29zKGMpO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4ICogc2luYywgz4EgKiBjb3NjKSwgTWF0aC5hc2luKM+BICYmIHkgKiBzaW5jIC8gz4EpIF07XG4gICAgfTtcbiAgICByZXR1cm4gYXppbXV0aGFsO1xuICB9XG4gIHZhciBkM19nZW9fYXppbXV0aGFsRXF1YWxBcmVhID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbihjb3POu2Nvc8+GKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgyIC8gKDEgKyBjb3POu2Nvc8+GKSk7XG4gIH0sIGZ1bmN0aW9uKM+BKSB7XG4gICAgcmV0dXJuIDIgKiBNYXRoLmFzaW4oz4EgLyAyKTtcbiAgfSk7XG4gIChkMy5nZW8uYXppbXV0aGFsRXF1YWxBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19hemltdXRoYWxFcXVhbEFyZWEpO1xuICB9KS5yYXcgPSBkM19nZW9fYXppbXV0aGFsRXF1YWxBcmVhO1xuICB2YXIgZDNfZ2VvX2F6aW11dGhhbEVxdWlkaXN0YW50ID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbihjb3POu2Nvc8+GKSB7XG4gICAgdmFyIGMgPSBNYXRoLmFjb3MoY29zzrtjb3PPhik7XG4gICAgcmV0dXJuIGMgJiYgYyAvIE1hdGguc2luKGMpO1xuICB9LCBkM19pZGVudGl0eSk7XG4gIChkMy5nZW8uYXppbXV0aGFsRXF1aWRpc3RhbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX2F6aW11dGhhbEVxdWlkaXN0YW50KTtcbiAgfSkucmF3ID0gZDNfZ2VvX2F6aW11dGhhbEVxdWlkaXN0YW50O1xuICBmdW5jdGlvbiBkM19nZW9fY29uaWNDb25mb3JtYWwoz4YwLCDPhjEpIHtcbiAgICB2YXIgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgdCA9IGZ1bmN0aW9uKM+GKSB7XG4gICAgICByZXR1cm4gTWF0aC50YW4oz4AgLyA0ICsgz4YgLyAyKTtcbiAgICB9LCBuID0gz4YwID09PSDPhjEgPyBNYXRoLnNpbijPhjApIDogTWF0aC5sb2coY29zz4YwIC8gTWF0aC5jb3Moz4YxKSkgLyBNYXRoLmxvZyh0KM+GMSkgLyB0KM+GMCkpLCBGID0gY29zz4YwICogTWF0aC5wb3codCjPhjApLCBuKSAvIG47XG4gICAgaWYgKCFuKSByZXR1cm4gZDNfZ2VvX21lcmNhdG9yO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQozrssIM+GKSB7XG4gICAgICBpZiAoRiA+IDApIHtcbiAgICAgICAgaWYgKM+GIDwgLWhhbGbPgCArIM61KSDPhiA9IC1oYWxmz4AgKyDOtTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICjPhiA+IGhhbGbPgCAtIM61KSDPhiA9IGhhbGbPgCAtIM61O1xuICAgICAgfVxuICAgICAgdmFyIM+BID0gRiAvIE1hdGgucG93KHQoz4YpLCBuKTtcbiAgICAgIHJldHVybiBbIM+BICogTWF0aC5zaW4obiAqIM67KSwgRiAtIM+BICogTWF0aC5jb3MobiAqIM67KSBdO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgTBfeSA9IEYgLSB5LCDPgSA9IGQzX3NnbihuKSAqIE1hdGguc3FydCh4ICogeCArIM+BMF95ICogz4EwX3kpO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4LCDPgTBfeSkgLyBuLCAyICogTWF0aC5hdGFuKE1hdGgucG93KEYgLyDPgSwgMSAvIG4pKSAtIGhhbGbPgCBdO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH1cbiAgKGQzLmdlby5jb25pY0NvbmZvcm1hbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fY29uaWMoZDNfZ2VvX2NvbmljQ29uZm9ybWFsKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2NvbmljQ29uZm9ybWFsO1xuICBmdW5jdGlvbiBkM19nZW9fY29uaWNFcXVpZGlzdGFudCjPhjAsIM+GMSkge1xuICAgIHZhciBjb3PPhjAgPSBNYXRoLmNvcyjPhjApLCBuID0gz4YwID09PSDPhjEgPyBNYXRoLnNpbijPhjApIDogKGNvc8+GMCAtIE1hdGguY29zKM+GMSkpIC8gKM+GMSAtIM+GMCksIEcgPSBjb3PPhjAgLyBuICsgz4YwO1xuICAgIGlmIChhYnMobikgPCDOtSkgcmV0dXJuIGQzX2dlb19lcXVpcmVjdGFuZ3VsYXI7XG4gICAgZnVuY3Rpb24gZm9yd2FyZCjOuywgz4YpIHtcbiAgICAgIHZhciDPgSA9IEcgLSDPhjtcbiAgICAgIHJldHVybiBbIM+BICogTWF0aC5zaW4obiAqIM67KSwgRyAtIM+BICogTWF0aC5jb3MobiAqIM67KSBdO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgTBfeSA9IEcgLSB5O1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4LCDPgTBfeSkgLyBuLCBHIC0gZDNfc2duKG4pICogTWF0aC5zcXJ0KHggKiB4ICsgz4EwX3kgKiDPgTBfeSkgXTtcbiAgICB9O1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG4gIChkMy5nZW8uY29uaWNFcXVpZGlzdGFudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fY29uaWMoZDNfZ2VvX2NvbmljRXF1aWRpc3RhbnQpO1xuICB9KS5yYXcgPSBkM19nZW9fY29uaWNFcXVpZGlzdGFudDtcbiAgdmFyIGQzX2dlb19nbm9tb25pYyA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHJldHVybiAxIC8gY29zzrtjb3PPhjtcbiAgfSwgTWF0aC5hdGFuKTtcbiAgKGQzLmdlby5nbm9tb25pYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fZ25vbW9uaWMpO1xuICB9KS5yYXcgPSBkM19nZW9fZ25vbW9uaWM7XG4gIGZ1bmN0aW9uIGQzX2dlb19tZXJjYXRvcijOuywgz4YpIHtcbiAgICByZXR1cm4gWyDOuywgTWF0aC5sb2coTWF0aC50YW4oz4AgLyA0ICsgz4YgLyAyKSkgXTtcbiAgfVxuICBkM19nZW9fbWVyY2F0b3IuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbIHgsIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoeSkpIC0gaGFsZs+AIF07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19tZXJjYXRvclByb2plY3Rpb24ocHJvamVjdCkge1xuICAgIHZhciBtID0gZDNfZ2VvX3Byb2plY3Rpb24ocHJvamVjdCksIHNjYWxlID0gbS5zY2FsZSwgdHJhbnNsYXRlID0gbS50cmFuc2xhdGUsIGNsaXBFeHRlbnQgPSBtLmNsaXBFeHRlbnQsIGNsaXBBdXRvO1xuICAgIG0uc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gc2NhbGUuYXBwbHkobSwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB2ID09PSBtID8gY2xpcEF1dG8gPyBtLmNsaXBFeHRlbnQobnVsbCkgOiBtIDogdjtcbiAgICB9O1xuICAgIG0udHJhbnNsYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHRyYW5zbGF0ZS5hcHBseShtLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHYgPT09IG0gPyBjbGlwQXV0byA/IG0uY2xpcEV4dGVudChudWxsKSA6IG0gOiB2O1xuICAgIH07XG4gICAgbS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgdmFyIHYgPSBjbGlwRXh0ZW50LmFwcGx5KG0sIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodiA9PT0gbSkge1xuICAgICAgICBpZiAoY2xpcEF1dG8gPSBfID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgayA9IM+AICogc2NhbGUoKSwgdCA9IHRyYW5zbGF0ZSgpO1xuICAgICAgICAgIGNsaXBFeHRlbnQoWyBbIHRbMF0gLSBrLCB0WzFdIC0gayBdLCBbIHRbMF0gKyBrLCB0WzFdICsgayBdIF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNsaXBBdXRvKSB7XG4gICAgICAgIHYgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgICByZXR1cm4gbS5jbGlwRXh0ZW50KG51bGwpO1xuICB9XG4gIChkMy5nZW8ubWVyY2F0b3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX21lcmNhdG9yUHJvamVjdGlvbihkM19nZW9fbWVyY2F0b3IpO1xuICB9KS5yYXcgPSBkM19nZW9fbWVyY2F0b3I7XG4gIHZhciBkM19nZW9fb3J0aG9ncmFwaGljID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gMTtcbiAgfSwgTWF0aC5hc2luKTtcbiAgKGQzLmdlby5vcnRob2dyYXBoaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX29ydGhvZ3JhcGhpYyk7XG4gIH0pLnJhdyA9IGQzX2dlb19vcnRob2dyYXBoaWM7XG4gIHZhciBkM19nZW9fc3RlcmVvZ3JhcGhpYyA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHJldHVybiAxIC8gKDEgKyBjb3POu2Nvc8+GKTtcbiAgfSwgZnVuY3Rpb24oz4EpIHtcbiAgICByZXR1cm4gMiAqIE1hdGguYXRhbijPgSk7XG4gIH0pO1xuICAoZDMuZ2VvLnN0ZXJlb2dyYXBoaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX3N0ZXJlb2dyYXBoaWMpO1xuICB9KS5yYXcgPSBkM19nZW9fc3RlcmVvZ3JhcGhpYztcbiAgZnVuY3Rpb24gZDNfZ2VvX3RyYW5zdmVyc2VNZXJjYXRvcijOuywgz4YpIHtcbiAgICByZXR1cm4gWyBNYXRoLmxvZyhNYXRoLnRhbijPgCAvIDQgKyDPhiAvIDIpKSwgLc67IF07XG4gIH1cbiAgZDNfZ2VvX3RyYW5zdmVyc2VNZXJjYXRvci5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFsgLXksIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoeCkpIC0gaGFsZs+AIF07XG4gIH07XG4gIChkMy5nZW8udHJhbnN2ZXJzZU1lcmNhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb2plY3Rpb24gPSBkM19nZW9fbWVyY2F0b3JQcm9qZWN0aW9uKGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3IpLCBjZW50ZXIgPSBwcm9qZWN0aW9uLmNlbnRlciwgcm90YXRlID0gcHJvamVjdGlvbi5yb3RhdGU7XG4gICAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gXyA/IGNlbnRlcihbIC1fWzFdLCBfWzBdIF0pIDogKF8gPSBjZW50ZXIoKSwgWyBfWzFdLCAtX1swXSBdKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIF8gPyByb3RhdGUoWyBfWzBdLCBfWzFdLCBfLmxlbmd0aCA+IDIgPyBfWzJdICsgOTAgOiA5MCBdKSA6IChfID0gcm90YXRlKCksIFxuICAgICAgWyBfWzBdLCBfWzFdLCBfWzJdIC0gOTAgXSk7XG4gICAgfTtcbiAgICByZXR1cm4gcm90YXRlKFsgMCwgMCwgOTAgXSk7XG4gIH0pLnJhdyA9IGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3I7XG4gIGQzLmdlb20gPSB7fTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2ludFgoZCkge1xuICAgIHJldHVybiBkWzBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9pbnRZKGQpIHtcbiAgICByZXR1cm4gZFsxXTtcbiAgfVxuICBkMy5nZW9tLmh1bGwgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGh1bGwodmVydGljZXMpO1xuICAgIGZ1bmN0aW9uIGh1bGwoZGF0YSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMykgcmV0dXJuIFtdO1xuICAgICAgdmFyIGZ4ID0gZDNfZnVuY3Rvcih4KSwgZnkgPSBkM19mdW5jdG9yKHkpLCBpLCBuID0gZGF0YS5sZW5ndGgsIHBvaW50cyA9IFtdLCBmbGlwcGVkUG9pbnRzID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFsgK2Z4LmNhbGwodGhpcywgZGF0YVtpXSwgaSksICtmeS5jYWxsKHRoaXMsIGRhdGFbaV0sIGkpLCBpIF0pO1xuICAgICAgfVxuICAgICAgcG9pbnRzLnNvcnQoZDNfZ2VvbV9odWxsT3JkZXIpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZmxpcHBlZFBvaW50cy5wdXNoKFsgcG9pbnRzW2ldWzBdLCAtcG9pbnRzW2ldWzFdIF0pO1xuICAgICAgdmFyIHVwcGVyID0gZDNfZ2VvbV9odWxsVXBwZXIocG9pbnRzKSwgbG93ZXIgPSBkM19nZW9tX2h1bGxVcHBlcihmbGlwcGVkUG9pbnRzKTtcbiAgICAgIHZhciBza2lwTGVmdCA9IGxvd2VyWzBdID09PSB1cHBlclswXSwgc2tpcFJpZ2h0ID0gbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0gPT09IHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCBwb2x5Z29uID0gW107XG4gICAgICBmb3IgKGkgPSB1cHBlci5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgcG9seWdvbi5wdXNoKGRhdGFbcG9pbnRzW3VwcGVyW2ldXVsyXV0pO1xuICAgICAgZm9yIChpID0gK3NraXBMZWZ0OyBpIDwgbG93ZXIubGVuZ3RoIC0gc2tpcFJpZ2h0OyArK2kpIHBvbHlnb24ucHVzaChkYXRhW3BvaW50c1tsb3dlcltpXV1bMl1dKTtcbiAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgIH1cbiAgICBodWxsLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gXywgaHVsbCkgOiB4O1xuICAgIH07XG4gICAgaHVsbC55ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IF8sIGh1bGwpIDogeTtcbiAgICB9O1xuICAgIHJldHVybiBodWxsO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX2h1bGxVcHBlcihwb2ludHMpIHtcbiAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGgsIGh1bGwgPSBbIDAsIDEgXSwgaHMgPSAyO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgbjsgaSsrKSB7XG4gICAgICB3aGlsZSAoaHMgPiAxICYmIGQzX2Nyb3NzMmQocG9pbnRzW2h1bGxbaHMgLSAyXV0sIHBvaW50c1todWxsW2hzIC0gMV1dLCBwb2ludHNbaV0pIDw9IDApIC0taHM7XG4gICAgICBodWxsW2hzKytdID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIGh1bGwuc2xpY2UoMCwgaHMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21faHVsbE9yZGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV07XG4gIH1cbiAgZDMuZ2VvbS5wb2x5Z29uID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBkM19zdWJjbGFzcyhjb29yZGluYXRlcywgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gIH07XG4gIHZhciBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUgPSBkMy5nZW9tLnBvbHlnb24ucHJvdG90eXBlID0gW107XG4gIGQzX2dlb21fcG9seWdvblByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoLCBhLCBiID0gdGhpc1tuIC0gMV0sIGFyZWEgPSAwO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSB0aGlzW2ldO1xuICAgICAgYXJlYSArPSBhWzFdICogYlswXSAtIGFbMF0gKiBiWzFdO1xuICAgIH1cbiAgICByZXR1cm4gYXJlYSAqIC41O1xuICB9O1xuICBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUuY2VudHJvaWQgPSBmdW5jdGlvbihrKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoLCB4ID0gMCwgeSA9IDAsIGEsIGIgPSB0aGlzW24gLSAxXSwgYztcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIGsgPSAtMSAvICg2ICogdGhpcy5hcmVhKCkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSB0aGlzW2ldO1xuICAgICAgYyA9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG4gICAgICB4ICs9IChhWzBdICsgYlswXSkgKiBjO1xuICAgICAgeSArPSAoYVsxXSArIGJbMV0pICogYztcbiAgICB9XG4gICAgcmV0dXJuIFsgeCAqIGssIHkgKiBrIF07XG4gIH07XG4gIGQzX2dlb21fcG9seWdvblByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24oc3ViamVjdCkge1xuICAgIHZhciBpbnB1dCwgY2xvc2VkID0gZDNfZ2VvbV9wb2x5Z29uQ2xvc2VkKHN1YmplY3QpLCBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCAtIGQzX2dlb21fcG9seWdvbkNsb3NlZCh0aGlzKSwgaiwgbSwgYSA9IHRoaXNbbiAtIDFdLCBiLCBjLCBkO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpbnB1dCA9IHN1YmplY3Quc2xpY2UoKTtcbiAgICAgIHN1YmplY3QubGVuZ3RoID0gMDtcbiAgICAgIGIgPSB0aGlzW2ldO1xuICAgICAgYyA9IGlucHV0WyhtID0gaW5wdXQubGVuZ3RoIC0gY2xvc2VkKSAtIDFdO1xuICAgICAgaiA9IC0xO1xuICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgZCA9IGlucHV0W2pdO1xuICAgICAgICBpZiAoZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKGQsIGEsIGIpKSB7XG4gICAgICAgICAgaWYgKCFkM19nZW9tX3BvbHlnb25JbnNpZGUoYywgYSwgYikpIHtcbiAgICAgICAgICAgIHN1YmplY3QucHVzaChkM19nZW9tX3BvbHlnb25JbnRlcnNlY3QoYywgZCwgYSwgYikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWJqZWN0LnB1c2goZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKGMsIGEsIGIpKSB7XG4gICAgICAgICAgc3ViamVjdC5wdXNoKGQzX2dlb21fcG9seWdvbkludGVyc2VjdChjLCBkLCBhLCBiKSk7XG4gICAgICAgIH1cbiAgICAgICAgYyA9IGQ7XG4gICAgICB9XG4gICAgICBpZiAoY2xvc2VkKSBzdWJqZWN0LnB1c2goc3ViamVjdFswXSk7XG4gICAgICBhID0gYjtcbiAgICB9XG4gICAgcmV0dXJuIHN1YmplY3Q7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9seWdvbkluc2lkZShwLCBhLCBiKSB7XG4gICAgcmV0dXJuIChiWzBdIC0gYVswXSkgKiAocFsxXSAtIGFbMV0pIDwgKGJbMV0gLSBhWzFdKSAqIChwWzBdIC0gYVswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KGMsIGQsIGEsIGIpIHtcbiAgICB2YXIgeDEgPSBjWzBdLCB4MyA9IGFbMF0sIHgyMSA9IGRbMF0gLSB4MSwgeDQzID0gYlswXSAtIHgzLCB5MSA9IGNbMV0sIHkzID0gYVsxXSwgeTIxID0gZFsxXSAtIHkxLCB5NDMgPSBiWzFdIC0geTMsIHVhID0gKHg0MyAqICh5MSAtIHkzKSAtIHk0MyAqICh4MSAtIHgzKSkgLyAoeTQzICogeDIxIC0geDQzICogeTIxKTtcbiAgICByZXR1cm4gWyB4MSArIHVhICogeDIxLCB5MSArIHVhICogeTIxIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2x5Z29uQ2xvc2VkKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIGEgPSBjb29yZGluYXRlc1swXSwgYiA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiAhKGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdKTtcbiAgfVxuICB2YXIgZDNfZ2VvbV92b3Jvbm9pRWRnZXMsIGQzX2dlb21fdm9yb25vaUNlbGxzLCBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLCBkM19nZW9tX3Zvcm9ub2lCZWFjaFBvb2wgPSBbXSwgZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGUsIGQzX2dlb21fdm9yb25vaUNpcmNsZXMsIGQzX2dlb21fdm9yb25vaUNpcmNsZVBvb2wgPSBbXTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQmVhY2goKSB7XG4gICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKHRoaXMpO1xuICAgIHRoaXMuZWRnZSA9IHRoaXMuc2l0ZSA9IHRoaXMuY2lyY2xlID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCZWFjaChzaXRlKSB7XG4gICAgdmFyIGJlYWNoID0gZDNfZ2VvbV92b3Jvbm9pQmVhY2hQb29sLnBvcCgpIHx8IG5ldyBkM19nZW9tX3Zvcm9ub2lCZWFjaCgpO1xuICAgIGJlYWNoLnNpdGUgPSBzaXRlO1xuICAgIHJldHVybiBiZWFjaDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChiZWFjaCkge1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShiZWFjaCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5yZW1vdmUoYmVhY2gpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoUG9vbC5wdXNoKGJlYWNoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUoYmVhY2gpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlbW92ZUJlYWNoKGJlYWNoKSB7XG4gICAgdmFyIGNpcmNsZSA9IGJlYWNoLmNpcmNsZSwgeCA9IGNpcmNsZS54LCB5ID0gY2lyY2xlLmN5LCB2ZXJ0ZXggPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0sIHByZXZpb3VzID0gYmVhY2guUCwgbmV4dCA9IGJlYWNoLk4sIGRpc2FwcGVhcmluZyA9IFsgYmVhY2ggXTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChiZWFjaCk7XG4gICAgdmFyIGxBcmMgPSBwcmV2aW91cztcbiAgICB3aGlsZSAobEFyYy5jaXJjbGUgJiYgYWJzKHggLSBsQXJjLmNpcmNsZS54KSA8IM61ICYmIGFicyh5IC0gbEFyYy5jaXJjbGUuY3kpIDwgzrUpIHtcbiAgICAgIHByZXZpb3VzID0gbEFyYy5QO1xuICAgICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChsQXJjKTtcbiAgICAgIGxBcmMgPSBwcmV2aW91cztcbiAgICB9XG4gICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIHZhciByQXJjID0gbmV4dDtcbiAgICB3aGlsZSAockFyYy5jaXJjbGUgJiYgYWJzKHggLSByQXJjLmNpcmNsZS54KSA8IM61ICYmIGFicyh5IC0gckFyYy5jaXJjbGUuY3kpIDwgzrUpIHtcbiAgICAgIG5leHQgPSByQXJjLk47XG4gICAgICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaURldGFjaEJlYWNoKHJBcmMpO1xuICAgICAgckFyYyA9IG5leHQ7XG4gICAgfVxuICAgIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShyQXJjKTtcbiAgICB2YXIgbkFyY3MgPSBkaXNhcHBlYXJpbmcubGVuZ3RoLCBpQXJjO1xuICAgIGZvciAoaUFyYyA9IDE7IGlBcmMgPCBuQXJjczsgKytpQXJjKSB7XG4gICAgICByQXJjID0gZGlzYXBwZWFyaW5nW2lBcmNdO1xuICAgICAgbEFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjIC0gMV07XG4gICAgICBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKHJBcmMuZWRnZSwgbEFyYy5zaXRlLCByQXJjLnNpdGUsIHZlcnRleCk7XG4gICAgfVxuICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbMF07XG4gICAgckFyYyA9IGRpc2FwcGVhcmluZ1tuQXJjcyAtIDFdO1xuICAgIHJBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobEFyYy5zaXRlLCByQXJjLnNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShyQXJjKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lBZGRCZWFjaChzaXRlKSB7XG4gICAgdmFyIHggPSBzaXRlLngsIGRpcmVjdHJpeCA9IHNpdGUueSwgbEFyYywgckFyYywgZHhsLCBkeHIsIG5vZGUgPSBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLl87XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGR4bCA9IGQzX2dlb21fdm9yb25vaUxlZnRCcmVha1BvaW50KG5vZGUsIGRpcmVjdHJpeCkgLSB4O1xuICAgICAgaWYgKGR4bCA+IM61KSBub2RlID0gbm9kZS5MOyBlbHNlIHtcbiAgICAgICAgZHhyID0geCAtIGQzX2dlb21fdm9yb25vaVJpZ2h0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpO1xuICAgICAgICBpZiAoZHhyID4gzrUpIHtcbiAgICAgICAgICBpZiAoIW5vZGUuUikge1xuICAgICAgICAgICAgbEFyYyA9IG5vZGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUuUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZHhsID4gLc61KSB7XG4gICAgICAgICAgICBsQXJjID0gbm9kZS5QO1xuICAgICAgICAgICAgckFyYyA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChkeHIgPiAtzrUpIHtcbiAgICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgICAgckFyYyA9IG5vZGUuTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbEFyYyA9IHJBcmMgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3QXJjID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQmVhY2goc2l0ZSk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5pbnNlcnQobEFyYywgbmV3QXJjKTtcbiAgICBpZiAoIWxBcmMgJiYgIXJBcmMpIHJldHVybjtcbiAgICBpZiAobEFyYyA9PT0gckFyYykge1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgckFyYyA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUJlYWNoKGxBcmMuc2l0ZSk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLmluc2VydChuZXdBcmMsIHJBcmMpO1xuICAgICAgbmV3QXJjLmVkZ2UgPSByQXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxBcmMuc2l0ZSwgbmV3QXJjLnNpdGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKHJBcmMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXJBcmMpIHtcbiAgICAgIG5ld0FyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShyQXJjKTtcbiAgICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsIGF4ID0gbFNpdGUueCwgYXkgPSBsU2l0ZS55LCBieCA9IHNpdGUueCAtIGF4LCBieSA9IHNpdGUueSAtIGF5LCByU2l0ZSA9IHJBcmMuc2l0ZSwgY3ggPSByU2l0ZS54IC0gYXgsIGN5ID0gclNpdGUueSAtIGF5LCBkID0gMiAqIChieCAqIGN5IC0gYnkgKiBjeCksIGhiID0gYnggKiBieCArIGJ5ICogYnksIGhjID0gY3ggKiBjeCArIGN5ICogY3ksIHZlcnRleCA9IHtcbiAgICAgIHg6IChjeSAqIGhiIC0gYnkgKiBoYykgLyBkICsgYXgsXG4gICAgICB5OiAoYnggKiBoYyAtIGN4ICogaGIpIC8gZCArIGF5XG4gICAgfTtcbiAgICBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKHJBcmMuZWRnZSwgbFNpdGUsIHJTaXRlLCB2ZXJ0ZXgpO1xuICAgIG5ld0FyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsU2l0ZSwgc2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgICByQXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKHNpdGUsIHJTaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUockFyYyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pTGVmdEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgICB2YXIgc2l0ZSA9IGFyYy5zaXRlLCByZm9jeCA9IHNpdGUueCwgcmZvY3kgPSBzaXRlLnksIHBieTIgPSByZm9jeSAtIGRpcmVjdHJpeDtcbiAgICBpZiAoIXBieTIpIHJldHVybiByZm9jeDtcbiAgICB2YXIgbEFyYyA9IGFyYy5QO1xuICAgIGlmICghbEFyYykgcmV0dXJuIC1JbmZpbml0eTtcbiAgICBzaXRlID0gbEFyYy5zaXRlO1xuICAgIHZhciBsZm9jeCA9IHNpdGUueCwgbGZvY3kgPSBzaXRlLnksIHBsYnkyID0gbGZvY3kgLSBkaXJlY3RyaXg7XG4gICAgaWYgKCFwbGJ5MikgcmV0dXJuIGxmb2N4O1xuICAgIHZhciBobCA9IGxmb2N4IC0gcmZvY3gsIGFieTIgPSAxIC8gcGJ5MiAtIDEgLyBwbGJ5MiwgYiA9IGhsIC8gcGxieTI7XG4gICAgaWYgKGFieTIpIHJldHVybiAoLWIgKyBNYXRoLnNxcnQoYiAqIGIgLSAyICogYWJ5MiAqIChobCAqIGhsIC8gKC0yICogcGxieTIpIC0gbGZvY3kgKyBwbGJ5MiAvIDIgKyByZm9jeSAtIHBieTIgLyAyKSkpIC8gYWJ5MiArIHJmb2N4O1xuICAgIHJldHVybiAocmZvY3ggKyBsZm9jeCkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJpZ2h0QnJlYWtQb2ludChhcmMsIGRpcmVjdHJpeCkge1xuICAgIHZhciByQXJjID0gYXJjLk47XG4gICAgaWYgKHJBcmMpIHJldHVybiBkM19nZW9tX3Zvcm9ub2lMZWZ0QnJlYWtQb2ludChyQXJjLCBkaXJlY3RyaXgpO1xuICAgIHZhciBzaXRlID0gYXJjLnNpdGU7XG4gICAgcmV0dXJuIHNpdGUueSA9PT0gZGlyZWN0cml4ID8gc2l0ZS54IDogSW5maW5pdHk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2VsbChzaXRlKSB7XG4gICAgdGhpcy5zaXRlID0gc2l0ZTtcbiAgICB0aGlzLmVkZ2VzID0gW107XG4gIH1cbiAgZDNfZ2VvbV92b3Jvbm9pQ2VsbC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYWxmRWRnZXMgPSB0aGlzLmVkZ2VzLCBpSGFsZkVkZ2UgPSBoYWxmRWRnZXMubGVuZ3RoLCBlZGdlO1xuICAgIHdoaWxlIChpSGFsZkVkZ2UtLSkge1xuICAgICAgZWRnZSA9IGhhbGZFZGdlc1tpSGFsZkVkZ2VdLmVkZ2U7XG4gICAgICBpZiAoIWVkZ2UuYiB8fCAhZWRnZS5hKSBoYWxmRWRnZXMuc3BsaWNlKGlIYWxmRWRnZSwgMSk7XG4gICAgfVxuICAgIGhhbGZFZGdlcy5zb3J0KGQzX2dlb21fdm9yb25vaUhhbGZFZGdlT3JkZXIpO1xuICAgIHJldHVybiBoYWxmRWRnZXMubGVuZ3RoO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDbG9zZUNlbGxzKGV4dGVudCkge1xuICAgIHZhciB4MCA9IGV4dGVudFswXVswXSwgeDEgPSBleHRlbnRbMV1bMF0sIHkwID0gZXh0ZW50WzBdWzFdLCB5MSA9IGV4dGVudFsxXVsxXSwgeDIsIHkyLCB4MywgeTMsIGNlbGxzID0gZDNfZ2VvbV92b3Jvbm9pQ2VsbHMsIGlDZWxsID0gY2VsbHMubGVuZ3RoLCBjZWxsLCBpSGFsZkVkZ2UsIGhhbGZFZGdlcywgbkhhbGZFZGdlcywgc3RhcnQsIGVuZDtcbiAgICB3aGlsZSAoaUNlbGwtLSkge1xuICAgICAgY2VsbCA9IGNlbGxzW2lDZWxsXTtcbiAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5wcmVwYXJlKCkpIGNvbnRpbnVlO1xuICAgICAgaGFsZkVkZ2VzID0gY2VsbC5lZGdlcztcbiAgICAgIG5IYWxmRWRnZXMgPSBoYWxmRWRnZXMubGVuZ3RoO1xuICAgICAgaUhhbGZFZGdlID0gMDtcbiAgICAgIHdoaWxlIChpSGFsZkVkZ2UgPCBuSGFsZkVkZ2VzKSB7XG4gICAgICAgIGVuZCA9IGhhbGZFZGdlc1tpSGFsZkVkZ2VdLmVuZCgpLCB4MyA9IGVuZC54LCB5MyA9IGVuZC55O1xuICAgICAgICBzdGFydCA9IGhhbGZFZGdlc1srK2lIYWxmRWRnZSAlIG5IYWxmRWRnZXNdLnN0YXJ0KCksIHgyID0gc3RhcnQueCwgeTIgPSBzdGFydC55O1xuICAgICAgICBpZiAoYWJzKHgzIC0geDIpID4gzrUgfHwgYWJzKHkzIC0geTIpID4gzrUpIHtcbiAgICAgICAgICBoYWxmRWRnZXMuc3BsaWNlKGlIYWxmRWRnZSwgMCwgbmV3IGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGQzX2dlb21fdm9yb25vaUNyZWF0ZUJvcmRlckVkZ2UoY2VsbC5zaXRlLCBlbmQsIGFicyh4MyAtIHgwKSA8IM61ICYmIHkxIC0geTMgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IHgwLFxuICAgICAgICAgICAgeTogYWJzKHgyIC0geDApIDwgzrUgPyB5MiA6IHkxXG4gICAgICAgICAgfSA6IGFicyh5MyAtIHkxKSA8IM61ICYmIHgxIC0geDMgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IGFicyh5MiAtIHkxKSA8IM61ID8geDIgOiB4MSxcbiAgICAgICAgICAgIHk6IHkxXG4gICAgICAgICAgfSA6IGFicyh4MyAtIHgxKSA8IM61ICYmIHkzIC0geTAgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgICAgeTogYWJzKHgyIC0geDEpIDwgzrUgPyB5MiA6IHkwXG4gICAgICAgICAgfSA6IGFicyh5MyAtIHkwKSA8IM61ICYmIHgzIC0geDAgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IGFicyh5MiAtIHkwKSA8IM61ID8geDIgOiB4MCxcbiAgICAgICAgICAgIHk6IHkwXG4gICAgICAgICAgfSA6IG51bGwpLCBjZWxsLnNpdGUsIG51bGwpKTtcbiAgICAgICAgICArK25IYWxmRWRnZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2VPcmRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGIuYW5nbGUgLSBhLmFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNpcmNsZSgpIHtcbiAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUodGhpcyk7XG4gICAgdGhpcy54ID0gdGhpcy55ID0gdGhpcy5hcmMgPSB0aGlzLnNpdGUgPSB0aGlzLmN5ID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUoYXJjKSB7XG4gICAgdmFyIGxBcmMgPSBhcmMuUCwgckFyYyA9IGFyYy5OO1xuICAgIGlmICghbEFyYyB8fCAhckFyYykgcmV0dXJuO1xuICAgIHZhciBsU2l0ZSA9IGxBcmMuc2l0ZSwgY1NpdGUgPSBhcmMuc2l0ZSwgclNpdGUgPSByQXJjLnNpdGU7XG4gICAgaWYgKGxTaXRlID09PSByU2l0ZSkgcmV0dXJuO1xuICAgIHZhciBieCA9IGNTaXRlLngsIGJ5ID0gY1NpdGUueSwgYXggPSBsU2l0ZS54IC0gYngsIGF5ID0gbFNpdGUueSAtIGJ5LCBjeCA9IHJTaXRlLnggLSBieCwgY3kgPSByU2l0ZS55IC0gYnk7XG4gICAgdmFyIGQgPSAyICogKGF4ICogY3kgLSBheSAqIGN4KTtcbiAgICBpZiAoZCA+PSAtzrUyKSByZXR1cm47XG4gICAgdmFyIGhhID0gYXggKiBheCArIGF5ICogYXksIGhjID0gY3ggKiBjeCArIGN5ICogY3ksIHggPSAoY3kgKiBoYSAtIGF5ICogaGMpIC8gZCwgeSA9IChheCAqIGhjIC0gY3ggKiBoYSkgLyBkLCBjeSA9IHkgKyBieTtcbiAgICB2YXIgY2lyY2xlID0gZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlUG9vbC5wb3AoKSB8fCBuZXcgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlKCk7XG4gICAgY2lyY2xlLmFyYyA9IGFyYztcbiAgICBjaXJjbGUuc2l0ZSA9IGNTaXRlO1xuICAgIGNpcmNsZS54ID0geCArIGJ4O1xuICAgIGNpcmNsZS55ID0gY3kgKyBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgY2lyY2xlLmN5ID0gY3k7XG4gICAgYXJjLmNpcmNsZSA9IGNpcmNsZTtcbiAgICB2YXIgYmVmb3JlID0gbnVsbCwgbm9kZSA9IGQzX2dlb21fdm9yb25vaUNpcmNsZXMuXztcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaWYgKGNpcmNsZS55IDwgbm9kZS55IHx8IGNpcmNsZS55ID09PSBub2RlLnkgJiYgY2lyY2xlLnggPD0gbm9kZS54KSB7XG4gICAgICAgIGlmIChub2RlLkwpIG5vZGUgPSBub2RlLkw7IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSA9IG5vZGUuUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGUuUikgbm9kZSA9IG5vZGUuUjsgZWxzZSB7XG4gICAgICAgICAgYmVmb3JlID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLmluc2VydChiZWZvcmUsIGNpcmNsZSk7XG4gICAgaWYgKCFiZWZvcmUpIGQzX2dlb21fdm9yb25vaUZpcnN0Q2lyY2xlID0gY2lyY2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShhcmMpIHtcbiAgICB2YXIgY2lyY2xlID0gYXJjLmNpcmNsZTtcbiAgICBpZiAoY2lyY2xlKSB7XG4gICAgICBpZiAoIWNpcmNsZS5QKSBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZSA9IGNpcmNsZS5OO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcy5yZW1vdmUoY2lyY2xlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUNpcmNsZVBvb2wucHVzaChjaXJjbGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKGNpcmNsZSk7XG4gICAgICBhcmMuY2lyY2xlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2xpcEVkZ2VzKGV4dGVudCkge1xuICAgIHZhciBlZGdlcyA9IGQzX2dlb21fdm9yb25vaUVkZ2VzLCBjbGlwID0gZDNfZ2VvbV9jbGlwTGluZShleHRlbnRbMF1bMF0sIGV4dGVudFswXVsxXSwgZXh0ZW50WzFdWzBdLCBleHRlbnRbMV1bMV0pLCBpID0gZWRnZXMubGVuZ3RoLCBlO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGUgPSBlZGdlc1tpXTtcbiAgICAgIGlmICghZDNfZ2VvbV92b3Jvbm9pQ29ubmVjdEVkZ2UoZSwgZXh0ZW50KSB8fCAhY2xpcChlKSB8fCBhYnMoZS5hLnggLSBlLmIueCkgPCDOtSAmJiBhYnMoZS5hLnkgLSBlLmIueSkgPCDOtSkge1xuICAgICAgICBlLmEgPSBlLmIgPSBudWxsO1xuICAgICAgICBlZGdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNvbm5lY3RFZGdlKGVkZ2UsIGV4dGVudCkge1xuICAgIHZhciB2YiA9IGVkZ2UuYjtcbiAgICBpZiAodmIpIHJldHVybiB0cnVlO1xuICAgIHZhciB2YSA9IGVkZ2UuYSwgeDAgPSBleHRlbnRbMF1bMF0sIHgxID0gZXh0ZW50WzFdWzBdLCB5MCA9IGV4dGVudFswXVsxXSwgeTEgPSBleHRlbnRbMV1bMV0sIGxTaXRlID0gZWRnZS5sLCByU2l0ZSA9IGVkZ2UuciwgbHggPSBsU2l0ZS54LCBseSA9IGxTaXRlLnksIHJ4ID0gclNpdGUueCwgcnkgPSByU2l0ZS55LCBmeCA9IChseCArIHJ4KSAvIDIsIGZ5ID0gKGx5ICsgcnkpIC8gMiwgZm0sIGZiO1xuICAgIGlmIChyeSA9PT0gbHkpIHtcbiAgICAgIGlmIChmeCA8IHgwIHx8IGZ4ID49IHgxKSByZXR1cm47XG4gICAgICBpZiAobHggPiByeCkge1xuICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MFxuICAgICAgICB9OyBlbHNlIGlmICh2YS55ID49IHkxKSByZXR1cm47XG4gICAgICAgIHZiID0ge1xuICAgICAgICAgIHg6IGZ4LFxuICAgICAgICAgIHk6IHkxXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MVxuICAgICAgICB9OyBlbHNlIGlmICh2YS55IDwgeTApIHJldHVybjtcbiAgICAgICAgdmIgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm0gPSAobHggLSByeCkgLyAocnkgLSBseSk7XG4gICAgICBmYiA9IGZ5IC0gZm0gKiBmeDtcbiAgICAgIGlmIChmbSA8IC0xIHx8IGZtID4gMSkge1xuICAgICAgICBpZiAobHggPiByeCkge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogKHkwIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MFxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnkgPj0geTEpIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6ICh5MSAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTFcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogKHkxIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MVxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnkgPCB5MCkgcmV0dXJuO1xuICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgeDogKHkwIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChseSA8IHJ5KSB7XG4gICAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgICB4OiB4MCxcbiAgICAgICAgICAgIHk6IGZtICogeDAgKyBmYlxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnggPj0geDEpIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgICAgeTogZm0gKiB4MSArIGZiXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgICAgeTogZm0gKiB4MSArIGZiXG4gICAgICAgICAgfTsgZWxzZSBpZiAodmEueCA8IHgwKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiB4MCxcbiAgICAgICAgICAgIHk6IGZtICogeDAgKyBmYlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWRnZS5hID0gdmE7XG4gICAgZWRnZS5iID0gdmI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pRWRnZShsU2l0ZSwgclNpdGUpIHtcbiAgICB0aGlzLmwgPSBsU2l0ZTtcbiAgICB0aGlzLnIgPSByU2l0ZTtcbiAgICB0aGlzLmEgPSB0aGlzLmIgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobFNpdGUsIHJTaXRlLCB2YSwgdmIpIHtcbiAgICB2YXIgZWRnZSA9IG5ldyBkM19nZW9tX3Zvcm9ub2lFZGdlKGxTaXRlLCByU2l0ZSk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRWRnZXMucHVzaChlZGdlKTtcbiAgICBpZiAodmEpIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQoZWRnZSwgbFNpdGUsIHJTaXRlLCB2YSk7XG4gICAgaWYgKHZiKSBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKGVkZ2UsIHJTaXRlLCBsU2l0ZSwgdmIpO1xuICAgIGQzX2dlb21fdm9yb25vaUNlbGxzW2xTaXRlLmldLmVkZ2VzLnB1c2gobmV3IGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGVkZ2UsIGxTaXRlLCByU2l0ZSkpO1xuICAgIGQzX2dlb21fdm9yb25vaUNlbGxzW3JTaXRlLmldLmVkZ2VzLnB1c2gobmV3IGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGVkZ2UsIHJTaXRlLCBsU2l0ZSkpO1xuICAgIHJldHVybiBlZGdlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNyZWF0ZUJvcmRlckVkZ2UobFNpdGUsIHZhLCB2Yikge1xuICAgIHZhciBlZGdlID0gbmV3IGQzX2dlb21fdm9yb25vaUVkZ2UobFNpdGUsIG51bGwpO1xuICAgIGVkZ2UuYSA9IHZhO1xuICAgIGVkZ2UuYiA9IHZiO1xuICAgIGQzX2dlb21fdm9yb25vaUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgcmV0dXJuIGVkZ2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChlZGdlLCBsU2l0ZSwgclNpdGUsIHZlcnRleCkge1xuICAgIGlmICghZWRnZS5hICYmICFlZGdlLmIpIHtcbiAgICAgIGVkZ2UuYSA9IHZlcnRleDtcbiAgICAgIGVkZ2UubCA9IGxTaXRlO1xuICAgICAgZWRnZS5yID0gclNpdGU7XG4gICAgfSBlbHNlIGlmIChlZGdlLmwgPT09IHJTaXRlKSB7XG4gICAgICBlZGdlLmIgPSB2ZXJ0ZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkZ2UuYSA9IHZlcnRleDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UoZWRnZSwgbFNpdGUsIHJTaXRlKSB7XG4gICAgdmFyIHZhID0gZWRnZS5hLCB2YiA9IGVkZ2UuYjtcbiAgICB0aGlzLmVkZ2UgPSBlZGdlO1xuICAgIHRoaXMuc2l0ZSA9IGxTaXRlO1xuICAgIHRoaXMuYW5nbGUgPSByU2l0ZSA/IE1hdGguYXRhbjIoclNpdGUueSAtIGxTaXRlLnksIHJTaXRlLnggLSBsU2l0ZS54KSA6IGVkZ2UubCA9PT0gbFNpdGUgPyBNYXRoLmF0YW4yKHZiLnggLSB2YS54LCB2YS55IC0gdmIueSkgOiBNYXRoLmF0YW4yKHZhLnggLSB2Yi54LCB2Yi55IC0gdmEueSk7XG4gIH1cbiAgZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UucHJvdG90eXBlID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVkZ2UubCA9PT0gdGhpcy5zaXRlID8gdGhpcy5lZGdlLmEgOiB0aGlzLmVkZ2UuYjtcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlLmwgPT09IHRoaXMuc2l0ZSA/IHRoaXMuZWRnZS5iIDogdGhpcy5lZGdlLmE7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUoKSB7XG4gICAgdGhpcy5fID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUobm9kZSkge1xuICAgIG5vZGUuVSA9IG5vZGUuQyA9IG5vZGUuTCA9IG5vZGUuUiA9IG5vZGUuUCA9IG5vZGUuTiA9IG51bGw7XG4gIH1cbiAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlLnByb3RvdHlwZSA9IHtcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKGFmdGVyLCBub2RlKSB7XG4gICAgICB2YXIgcGFyZW50LCBncmFuZHBhLCB1bmNsZTtcbiAgICAgIGlmIChhZnRlcikge1xuICAgICAgICBub2RlLlAgPSBhZnRlcjtcbiAgICAgICAgbm9kZS5OID0gYWZ0ZXIuTjtcbiAgICAgICAgaWYgKGFmdGVyLk4pIGFmdGVyLk4uUCA9IG5vZGU7XG4gICAgICAgIGFmdGVyLk4gPSBub2RlO1xuICAgICAgICBpZiAoYWZ0ZXIuUikge1xuICAgICAgICAgIGFmdGVyID0gYWZ0ZXIuUjtcbiAgICAgICAgICB3aGlsZSAoYWZ0ZXIuTCkgYWZ0ZXIgPSBhZnRlci5MO1xuICAgICAgICAgIGFmdGVyLkwgPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmdGVyLlIgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IGFmdGVyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl8pIHtcbiAgICAgICAgYWZ0ZXIgPSBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja0ZpcnN0KHRoaXMuXyk7XG4gICAgICAgIG5vZGUuUCA9IG51bGw7XG4gICAgICAgIG5vZGUuTiA9IGFmdGVyO1xuICAgICAgICBhZnRlci5QID0gYWZ0ZXIuTCA9IG5vZGU7XG4gICAgICAgIHBhcmVudCA9IGFmdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5QID0gbm9kZS5OID0gbnVsbDtcbiAgICAgICAgdGhpcy5fID0gbm9kZTtcbiAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUuTCA9IG5vZGUuUiA9IG51bGw7XG4gICAgICBub2RlLlUgPSBwYXJlbnQ7XG4gICAgICBub2RlLkMgPSB0cnVlO1xuICAgICAgYWZ0ZXIgPSBub2RlO1xuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuQykge1xuICAgICAgICBncmFuZHBhID0gcGFyZW50LlU7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IGdyYW5kcGEuTCkge1xuICAgICAgICAgIHVuY2xlID0gZ3JhbmRwYS5SO1xuICAgICAgICAgIGlmICh1bmNsZSAmJiB1bmNsZS5DKSB7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBhZnRlciA9IGdyYW5kcGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhZnRlciA9PT0gcGFyZW50LlIpIHtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIGdyYW5kcGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bmNsZSA9IGdyYW5kcGEuTDtcbiAgICAgICAgICBpZiAodW5jbGUgJiYgdW5jbGUuQykge1xuICAgICAgICAgICAgcGFyZW50LkMgPSB1bmNsZS5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBncmFuZHBhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5MKSB7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgIH1cbiAgICAgIHRoaXMuXy5DID0gZmFsc2U7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLk4pIG5vZGUuTi5QID0gbm9kZS5QO1xuICAgICAgaWYgKG5vZGUuUCkgbm9kZS5QLk4gPSBub2RlLk47XG4gICAgICBub2RlLk4gPSBub2RlLlAgPSBudWxsO1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUuVSwgc2libGluZywgbGVmdCA9IG5vZGUuTCwgcmlnaHQgPSBub2RlLlIsIG5leHQsIHJlZDtcbiAgICAgIGlmICghbGVmdCkgbmV4dCA9IHJpZ2h0OyBlbHNlIGlmICghcmlnaHQpIG5leHQgPSBsZWZ0OyBlbHNlIG5leHQgPSBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja0ZpcnN0KHJpZ2h0KTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5MID09PSBub2RlKSBwYXJlbnQuTCA9IG5leHQ7IGVsc2UgcGFyZW50LlIgPSBuZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICYmIHJpZ2h0KSB7XG4gICAgICAgIHJlZCA9IG5leHQuQztcbiAgICAgICAgbmV4dC5DID0gbm9kZS5DO1xuICAgICAgICBuZXh0LkwgPSBsZWZ0O1xuICAgICAgICBsZWZ0LlUgPSBuZXh0O1xuICAgICAgICBpZiAobmV4dCAhPT0gcmlnaHQpIHtcbiAgICAgICAgICBwYXJlbnQgPSBuZXh0LlU7XG4gICAgICAgICAgbmV4dC5VID0gbm9kZS5VO1xuICAgICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICAgICAgcGFyZW50LkwgPSBub2RlO1xuICAgICAgICAgIG5leHQuUiA9IHJpZ2h0O1xuICAgICAgICAgIHJpZ2h0LlUgPSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQuVSA9IHBhcmVudDtcbiAgICAgICAgICBwYXJlbnQgPSBuZXh0O1xuICAgICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZCA9IG5vZGUuQztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSkgbm9kZS5VID0gcGFyZW50O1xuICAgICAgaWYgKHJlZCkgcmV0dXJuO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5DKSB7XG4gICAgICAgIG5vZGUuQyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLl8pIGJyZWFrO1xuICAgICAgICBpZiAobm9kZSA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgaWYgKHNpYmxpbmcuQykge1xuICAgICAgICAgICAgc2libGluZy5DID0gZmFsc2U7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpYmxpbmcuTCAmJiBzaWJsaW5nLkwuQyB8fCBzaWJsaW5nLlIgJiYgc2libGluZy5SLkMpIHtcbiAgICAgICAgICAgIGlmICghc2libGluZy5SIHx8ICFzaWJsaW5nLlIuQykge1xuICAgICAgICAgICAgICBzaWJsaW5nLkwuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHNpYmxpbmcpO1xuICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSBwYXJlbnQuQztcbiAgICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuXztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgaWYgKHNpYmxpbmcuQykge1xuICAgICAgICAgICAgc2libGluZy5DID0gZmFsc2U7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMgfHwgc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICBpZiAoIXNpYmxpbmcuTCB8fCAhc2libGluZy5MLkMpIHtcbiAgICAgICAgICAgICAgc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHNpYmxpbmcpO1xuICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSBwYXJlbnQuQztcbiAgICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LlU7XG4gICAgICB9IHdoaWxlICghbm9kZS5DKTtcbiAgICAgIGlmIChub2RlKSBub2RlLkMgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0cmVlLCBub2RlKSB7XG4gICAgdmFyIHAgPSBub2RlLCBxID0gbm9kZS5SLCBwYXJlbnQgPSBwLlU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5MID09PSBwKSBwYXJlbnQuTCA9IHE7IGVsc2UgcGFyZW50LlIgPSBxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlLl8gPSBxO1xuICAgIH1cbiAgICBxLlUgPSBwYXJlbnQ7XG4gICAgcC5VID0gcTtcbiAgICBwLlIgPSBxLkw7XG4gICAgaWYgKHAuUikgcC5SLlUgPSBwO1xuICAgIHEuTCA9IHA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0cmVlLCBub2RlKSB7XG4gICAgdmFyIHAgPSBub2RlLCBxID0gbm9kZS5MLCBwYXJlbnQgPSBwLlU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5MID09PSBwKSBwYXJlbnQuTCA9IHE7IGVsc2UgcGFyZW50LlIgPSBxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlLl8gPSBxO1xuICAgIH1cbiAgICBxLlUgPSBwYXJlbnQ7XG4gICAgcC5VID0gcTtcbiAgICBwLkwgPSBxLlI7XG4gICAgaWYgKHAuTCkgcC5MLlUgPSBwO1xuICAgIHEuUiA9IHA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tGaXJzdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuTCkgbm9kZSA9IG5vZGUuTDtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2koc2l0ZXMsIGJib3gpIHtcbiAgICB2YXIgc2l0ZSA9IHNpdGVzLnNvcnQoZDNfZ2VvbV92b3Jvbm9pVmVydGV4T3JkZXIpLnBvcCgpLCB4MCwgeTAsIGNpcmNsZTtcbiAgICBkM19nZW9tX3Zvcm9ub2lFZGdlcyA9IFtdO1xuICAgIGQzX2dlb21fdm9yb25vaUNlbGxzID0gbmV3IEFycmF5KHNpdGVzLmxlbmd0aCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcyA9IG5ldyBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzID0gbmV3IGQzX2dlb21fdm9yb25vaVJlZEJsYWNrVHJlZSgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjaXJjbGUgPSBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZTtcbiAgICAgIGlmIChzaXRlICYmICghY2lyY2xlIHx8IHNpdGUueSA8IGNpcmNsZS55IHx8IHNpdGUueSA9PT0gY2lyY2xlLnkgJiYgc2l0ZS54IDwgY2lyY2xlLngpKSB7XG4gICAgICAgIGlmIChzaXRlLnggIT09IHgwIHx8IHNpdGUueSAhPT0geTApIHtcbiAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lDZWxsc1tzaXRlLmldID0gbmV3IGQzX2dlb21fdm9yb25vaUNlbGwoc2l0ZSk7XG4gICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pQWRkQmVhY2goc2l0ZSk7XG4gICAgICAgICAgeDAgPSBzaXRlLngsIHkwID0gc2l0ZS55O1xuICAgICAgICB9XG4gICAgICAgIHNpdGUgPSBzaXRlcy5wb3AoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2lyY2xlKSB7XG4gICAgICAgIGQzX2dlb21fdm9yb25vaVJlbW92ZUJlYWNoKGNpcmNsZS5hcmMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiYm94KSBkM19nZW9tX3Zvcm9ub2lDbGlwRWRnZXMoYmJveCksIGQzX2dlb21fdm9yb25vaUNsb3NlQ2VsbHMoYmJveCk7XG4gICAgdmFyIGRpYWdyYW0gPSB7XG4gICAgICBjZWxsczogZDNfZ2VvbV92b3Jvbm9pQ2VsbHMsXG4gICAgICBlZGdlczogZDNfZ2VvbV92b3Jvbm9pRWRnZXNcbiAgICB9O1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMgPSBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzID0gZDNfZ2VvbV92b3Jvbm9pRWRnZXMgPSBkM19nZW9tX3Zvcm9ub2lDZWxscyA9IG51bGw7XG4gICAgcmV0dXJuIGRpYWdyYW07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pVmVydGV4T3JkZXIoYSwgYikge1xuICAgIHJldHVybiBiLnkgLSBhLnkgfHwgYi54IC0gYS54O1xuICB9XG4gIGQzLmdlb20udm9yb25vaSA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WSwgZnggPSB4LCBmeSA9IHksIGNsaXBFeHRlbnQgPSBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50O1xuICAgIGlmIChwb2ludHMpIHJldHVybiB2b3Jvbm9pKHBvaW50cyk7XG4gICAgZnVuY3Rpb24gdm9yb25vaShkYXRhKSB7XG4gICAgICB2YXIgcG9seWdvbnMgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpLCB4MCA9IGNsaXBFeHRlbnRbMF1bMF0sIHkwID0gY2xpcEV4dGVudFswXVsxXSwgeDEgPSBjbGlwRXh0ZW50WzFdWzBdLCB5MSA9IGNsaXBFeHRlbnRbMV1bMV07XG4gICAgICBkM19nZW9tX3Zvcm9ub2koc2l0ZXMoZGF0YSksIGNsaXBFeHRlbnQpLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaSkge1xuICAgICAgICB2YXIgZWRnZXMgPSBjZWxsLmVkZ2VzLCBzaXRlID0gY2VsbC5zaXRlLCBwb2x5Z29uID0gcG9seWdvbnNbaV0gPSBlZGdlcy5sZW5ndGggPyBlZGdlcy5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciBzID0gZS5zdGFydCgpO1xuICAgICAgICAgIHJldHVybiBbIHMueCwgcy55IF07XG4gICAgICAgIH0pIDogc2l0ZS54ID49IHgwICYmIHNpdGUueCA8PSB4MSAmJiBzaXRlLnkgPj0geTAgJiYgc2l0ZS55IDw9IHkxID8gWyBbIHgwLCB5MSBdLCBbIHgxLCB5MSBdLCBbIHgxLCB5MCBdLCBbIHgwLCB5MCBdIF0gOiBbXTtcbiAgICAgICAgcG9seWdvbi5wb2ludCA9IGRhdGFbaV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwb2x5Z29ucztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2l0ZXMoZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKGZ4KGQsIGkpIC8gzrUpICogzrUsXG4gICAgICAgICAgeTogTWF0aC5yb3VuZChmeShkLCBpKSAvIM61KSAqIM61LFxuICAgICAgICAgIGk6IGlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2b3Jvbm9pLmxpbmtzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGQzX2dlb21fdm9yb25vaShzaXRlcyhkYXRhKSkuZWRnZXMuZmlsdGVyKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UubCAmJiBlZGdlLnI7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oZWRnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogZGF0YVtlZGdlLmwuaV0sXG4gICAgICAgICAgdGFyZ2V0OiBkYXRhW2VkZ2Uuci5pXVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2b3Jvbm9pLnRyaWFuZ2xlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciB0cmlhbmdsZXMgPSBbXTtcbiAgICAgIGQzX2dlb21fdm9yb25vaShzaXRlcyhkYXRhKSkuY2VsbHMuZm9yRWFjaChmdW5jdGlvbihjZWxsLCBpKSB7XG4gICAgICAgIHZhciBzaXRlID0gY2VsbC5zaXRlLCBlZGdlcyA9IGNlbGwuZWRnZXMuc29ydChkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZU9yZGVyKSwgaiA9IC0xLCBtID0gZWRnZXMubGVuZ3RoLCBlMCwgczAsIGUxID0gZWRnZXNbbSAtIDFdLmVkZ2UsIHMxID0gZTEubCA9PT0gc2l0ZSA/IGUxLnIgOiBlMS5sO1xuICAgICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICAgIGUwID0gZTE7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICBlMSA9IGVkZ2VzW2pdLmVkZ2U7XG4gICAgICAgICAgczEgPSBlMS5sID09PSBzaXRlID8gZTEuciA6IGUxLmw7XG4gICAgICAgICAgaWYgKGkgPCBzMC5pICYmIGkgPCBzMS5pICYmIGQzX2dlb21fdm9yb25vaVRyaWFuZ2xlQXJlYShzaXRlLCBzMCwgczEpIDwgMCkge1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goWyBkYXRhW2ldLCBkYXRhW3MwLmldLCBkYXRhW3MxLmldIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJpYW5nbGVzO1xuICAgIH07XG4gICAgdm9yb25vaS54ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZnggPSBkM19mdW5jdG9yKHggPSBfKSwgdm9yb25vaSkgOiB4O1xuICAgIH07XG4gICAgdm9yb25vaS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZnkgPSBkM19mdW5jdG9yKHkgPSBfKSwgdm9yb25vaSkgOiB5O1xuICAgIH07XG4gICAgdm9yb25vaS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEV4dGVudCA9PT0gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA/IG51bGwgOiBjbGlwRXh0ZW50O1xuICAgICAgY2xpcEV4dGVudCA9IF8gPT0gbnVsbCA/IGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQgOiBfO1xuICAgICAgcmV0dXJuIHZvcm9ub2k7XG4gICAgfTtcbiAgICB2b3Jvbm9pLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwRXh0ZW50ID09PSBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50ID8gbnVsbCA6IGNsaXBFeHRlbnQgJiYgY2xpcEV4dGVudFsxXTtcbiAgICAgIHJldHVybiB2b3Jvbm9pLmNsaXBFeHRlbnQoXyAmJiBbIFsgMCwgMCBdLCBfIF0pO1xuICAgIH07XG4gICAgcmV0dXJuIHZvcm9ub2k7XG4gIH07XG4gIHZhciBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50ID0gWyBbIC0xZTYsIC0xZTYgXSwgWyAxZTYsIDFlNiBdIF07XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVRyaWFuZ2xlQXJlYShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhLnggLSBjLngpICogKGIueSAtIGEueSkgLSAoYS54IC0gYi54KSAqIChjLnkgLSBhLnkpO1xuICB9XG4gIGQzLmdlb20uZGVsYXVuYXkgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIHJldHVybiBkMy5nZW9tLnZvcm9ub2koKS50cmlhbmdsZXModmVydGljZXMpO1xuICB9O1xuICBkMy5nZW9tLnF1YWR0cmVlID0gZnVuY3Rpb24ocG9pbnRzLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WSwgY29tcGF0O1xuICAgIGlmIChjb21wYXQgPSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB4ID0gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFg7XG4gICAgICB5ID0gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFk7XG4gICAgICBpZiAoY29tcGF0ID09PSAzKSB7XG4gICAgICAgIHkyID0geTE7XG4gICAgICAgIHgyID0geDE7XG4gICAgICAgIHkxID0geDEgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHF1YWR0cmVlKHBvaW50cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1YWR0cmVlKGRhdGEpIHtcbiAgICAgIHZhciBkLCBmeCA9IGQzX2Z1bmN0b3IoeCksIGZ5ID0gZDNfZnVuY3Rvcih5KSwgeHMsIHlzLCBpLCBuLCB4MV8sIHkxXywgeDJfLCB5Ml87XG4gICAgICBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICB4MV8gPSB4MSwgeTFfID0geTEsIHgyXyA9IHgyLCB5Ml8gPSB5MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyXyA9IHkyXyA9IC0oeDFfID0geTFfID0gSW5maW5pdHkpO1xuICAgICAgICB4cyA9IFtdLCB5cyA9IFtdO1xuICAgICAgICBuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChjb21wYXQpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBkID0gZGF0YVtpXTtcbiAgICAgICAgICBpZiAoZC54IDwgeDFfKSB4MV8gPSBkLng7XG4gICAgICAgICAgaWYgKGQueSA8IHkxXykgeTFfID0gZC55O1xuICAgICAgICAgIGlmIChkLnggPiB4Ml8pIHgyXyA9IGQueDtcbiAgICAgICAgICBpZiAoZC55ID4geTJfKSB5Ml8gPSBkLnk7XG4gICAgICAgICAgeHMucHVzaChkLngpO1xuICAgICAgICAgIHlzLnB1c2goZC55KTtcbiAgICAgICAgfSBlbHNlIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICB2YXIgeF8gPSArZngoZCA9IGRhdGFbaV0sIGkpLCB5XyA9ICtmeShkLCBpKTtcbiAgICAgICAgICBpZiAoeF8gPCB4MV8pIHgxXyA9IHhfO1xuICAgICAgICAgIGlmICh5XyA8IHkxXykgeTFfID0geV87XG4gICAgICAgICAgaWYgKHhfID4geDJfKSB4Ml8gPSB4XztcbiAgICAgICAgICBpZiAoeV8gPiB5Ml8pIHkyXyA9IHlfO1xuICAgICAgICAgIHhzLnB1c2goeF8pO1xuICAgICAgICAgIHlzLnB1c2goeV8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZHggPSB4Ml8gLSB4MV8sIGR5ID0geTJfIC0geTFfO1xuICAgICAgaWYgKGR4ID4gZHkpIHkyXyA9IHkxXyArIGR4OyBlbHNlIHgyXyA9IHgxXyArIGR5O1xuICAgICAgZnVuY3Rpb24gaW5zZXJ0KG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuO1xuICAgICAgICBpZiAobi5sZWFmKSB7XG4gICAgICAgICAgdmFyIG54ID0gbi54LCBueSA9IG4ueTtcbiAgICAgICAgICBpZiAobnggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGFicyhueCAtIHgpICsgYWJzKG55IC0geSkgPCAuMDEpIHtcbiAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG5Qb2ludCA9IG4ucG9pbnQ7XG4gICAgICAgICAgICAgIG4ueCA9IG4ueSA9IG4ucG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICBpbnNlcnRDaGlsZChuLCBuUG9pbnQsIG54LCBueSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgICBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4ueCA9IHgsIG4ueSA9IHksIG4ucG9pbnQgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHZhciB4bSA9ICh4MSArIHgyKSAqIC41LCB5bSA9ICh5MSArIHkyKSAqIC41LCByaWdodCA9IHggPj0geG0sIGJlbG93ID0geSA+PSB5bSwgaSA9IGJlbG93IDw8IDEgfCByaWdodDtcbiAgICAgICAgbi5sZWFmID0gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5vZGVzW2ldIHx8IChuLm5vZGVzW2ldID0gZDNfZ2VvbV9xdWFkdHJlZU5vZGUoKSk7XG4gICAgICAgIGlmIChyaWdodCkgeDEgPSB4bTsgZWxzZSB4MiA9IHhtO1xuICAgICAgICBpZiAoYmVsb3cpIHkxID0geW07IGVsc2UgeTIgPSB5bTtcbiAgICAgICAgaW5zZXJ0KG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgIH1cbiAgICAgIHZhciByb290ID0gZDNfZ2VvbV9xdWFkdHJlZU5vZGUoKTtcbiAgICAgIHJvb3QuYWRkID0gZnVuY3Rpb24oZCkge1xuICAgICAgICBpbnNlcnQocm9vdCwgZCwgK2Z4KGQsICsraSksICtmeShkLCBpKSwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgIH07XG4gICAgICByb290LnZpc2l0ID0gZnVuY3Rpb24oZikge1xuICAgICAgICBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgcm9vdCwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgIH07XG4gICAgICByb290LmZpbmQgPSBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gZDNfZ2VvbV9xdWFkdHJlZUZpbmQocm9vdCwgcG9pbnRbMF0sIHBvaW50WzFdLCB4MV8sIHkxXywgeDJfLCB5Ml8pO1xuICAgICAgfTtcbiAgICAgIGkgPSAtMTtcbiAgICAgIGlmICh4MSA9PSBudWxsKSB7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaW5zZXJ0KHJvb3QsIGRhdGFbaV0sIHhzW2ldLCB5c1tpXSwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgICAgfVxuICAgICAgICAtLWk7XG4gICAgICB9IGVsc2UgZGF0YS5mb3JFYWNoKHJvb3QuYWRkKTtcbiAgICAgIHhzID0geXMgPSBkYXRhID0gZCA9IG51bGw7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgcXVhZHRyZWUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSBfLCBxdWFkdHJlZSkgOiB4O1xuICAgIH07XG4gICAgcXVhZHRyZWUueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBfLCBxdWFkdHJlZSkgOiB5O1xuICAgIH07XG4gICAgcXVhZHRyZWUuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDEgPT0gbnVsbCA/IG51bGwgOiBbIFsgeDEsIHkxIF0sIFsgeDIsIHkyIF0gXTtcbiAgICAgIGlmIChfID09IG51bGwpIHgxID0geTEgPSB4MiA9IHkyID0gbnVsbDsgZWxzZSB4MSA9ICtfWzBdWzBdLCB5MSA9ICtfWzBdWzFdLCB4MiA9ICtfWzFdWzBdLCBcbiAgICAgIHkyID0gK19bMV1bMV07XG4gICAgICByZXR1cm4gcXVhZHRyZWU7XG4gICAgfTtcbiAgICBxdWFkdHJlZS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDEgPT0gbnVsbCA/IG51bGwgOiBbIHgyIC0geDEsIHkyIC0geTEgXTtcbiAgICAgIGlmIChfID09IG51bGwpIHgxID0geTEgPSB4MiA9IHkyID0gbnVsbDsgZWxzZSB4MSA9IHkxID0gMCwgeDIgPSArX1swXSwgeTIgPSArX1sxXTtcbiAgICAgIHJldHVybiBxdWFkdHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBxdWFkdHJlZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFgoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFkoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZU5vZGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlYWY6IHRydWUsXG4gICAgICBub2RlczogW10sXG4gICAgICBwb2ludDogbnVsbCxcbiAgICAgIHg6IG51bGwsXG4gICAgICB5OiBudWxsXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgbm9kZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBpZiAoIWYobm9kZSwgeDEsIHkxLCB4MiwgeTIpKSB7XG4gICAgICB2YXIgc3ggPSAoeDEgKyB4MikgKiAuNSwgc3kgPSAoeTEgKyB5MikgKiAuNSwgY2hpbGRyZW4gPSBub2RlLm5vZGVzO1xuICAgICAgaWYgKGNoaWxkcmVuWzBdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bMF0sIHgxLCB5MSwgc3gsIHN5KTtcbiAgICAgIGlmIChjaGlsZHJlblsxXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzFdLCBzeCwgeTEsIHgyLCBzeSk7XG4gICAgICBpZiAoY2hpbGRyZW5bMl0pIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBjaGlsZHJlblsyXSwgeDEsIHN5LCBzeCwgeTIpO1xuICAgICAgaWYgKGNoaWxkcmVuWzNdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bM10sIHN4LCBzeSwgeDIsIHkyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZUZpbmQocm9vdCwgeCwgeSwgeDAsIHkwLCB4MywgeTMpIHtcbiAgICB2YXIgbWluRGlzdGFuY2UyID0gSW5maW5pdHksIGNsb3Nlc3RQb2ludDtcbiAgICAoZnVuY3Rpb24gZmluZChub2RlLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgaWYgKHgxID4geDMgfHwgeTEgPiB5MyB8fCB4MiA8IHgwIHx8IHkyIDwgeTApIHJldHVybjtcbiAgICAgIGlmIChwb2ludCA9IG5vZGUucG9pbnQpIHtcbiAgICAgICAgdmFyIHBvaW50LCBkeCA9IHggLSBwb2ludFswXSwgZHkgPSB5IC0gcG9pbnRbMV0sIGRpc3RhbmNlMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBpZiAoZGlzdGFuY2UyIDwgbWluRGlzdGFuY2UyKSB7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlMiA9IGRpc3RhbmNlMik7XG4gICAgICAgICAgeDAgPSB4IC0gZGlzdGFuY2UsIHkwID0geSAtIGRpc3RhbmNlO1xuICAgICAgICAgIHgzID0geCArIGRpc3RhbmNlLCB5MyA9IHkgKyBkaXN0YW5jZTtcbiAgICAgICAgICBjbG9zZXN0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5ub2RlcywgeG0gPSAoeDEgKyB4MikgKiAuNSwgeW0gPSAoeTEgKyB5MikgKiAuNSwgcmlnaHQgPSB4ID49IHhtLCBiZWxvdyA9IHkgPj0geW07XG4gICAgICBmb3IgKHZhciBpID0gYmVsb3cgPDwgMSB8IHJpZ2h0LCBqID0gaSArIDQ7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgaWYgKG5vZGUgPSBjaGlsZHJlbltpICYgM10pIHN3aXRjaCAoaSAmIDMpIHtcbiAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBmaW5kKG5vZGUsIHgxLCB5MSwgeG0sIHltKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGZpbmQobm9kZSwgeG0sIHkxLCB4MiwgeW0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZmluZChub2RlLCB4MSwgeW0sIHhtLCB5Mik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmaW5kKG5vZGUsIHhtLCB5bSwgeDIsIHkyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKHJvb3QsIHgwLCB5MCwgeDMsIHkzKTtcbiAgICByZXR1cm4gY2xvc2VzdFBvaW50O1xuICB9XG4gIGQzLmludGVycG9sYXRlUmdiID0gZDNfaW50ZXJwb2xhdGVSZ2I7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlUmdiKGEsIGIpIHtcbiAgICBhID0gZDMucmdiKGEpO1xuICAgIGIgPSBkMy5yZ2IoYik7XG4gICAgdmFyIGFyID0gYS5yLCBhZyA9IGEuZywgYWIgPSBhLmIsIGJyID0gYi5yIC0gYXIsIGJnID0gYi5nIC0gYWcsIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBcIiNcIiArIGQzX3JnYl9oZXgoTWF0aC5yb3VuZChhciArIGJyICogdCkpICsgZDNfcmdiX2hleChNYXRoLnJvdW5kKGFnICsgYmcgKiB0KSkgKyBkM19yZ2JfaGV4KE1hdGgucm91bmQoYWIgKyBiYiAqIHQpKTtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlT2JqZWN0ID0gZDNfaW50ZXJwb2xhdGVPYmplY3Q7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlT2JqZWN0KGEsIGIpIHtcbiAgICB2YXIgaSA9IHt9LCBjID0ge30sIGs7XG4gICAgZm9yIChrIGluIGEpIHtcbiAgICAgIGlmIChrIGluIGIpIHtcbiAgICAgICAgaVtrXSA9IGQzX2ludGVycG9sYXRlKGFba10sIGJba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY1trXSA9IGFba107XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayBpbiBiKSB7XG4gICAgICBpZiAoIShrIGluIGEpKSB7XG4gICAgICAgIGNba10gPSBiW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgZm9yIChrIGluIGkpIGNba10gPSBpW2tdKHQpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZU51bWJlciA9IGQzX2ludGVycG9sYXRlTnVtYmVyO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZU51bWJlcihhLCBiKSB7XG4gICAgYSA9ICthLCBiID0gK2I7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVTdHJpbmcgPSBkM19pbnRlcnBvbGF0ZVN0cmluZztcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVTdHJpbmcoYSwgYikge1xuICAgIHZhciBiaSA9IGQzX2ludGVycG9sYXRlX251bWJlckEubGFzdEluZGV4ID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQi5sYXN0SW5kZXggPSAwLCBhbSwgYm0sIGJzLCBpID0gLTEsIHMgPSBbXSwgcSA9IFtdO1xuICAgIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuICAgIHdoaWxlICgoYW0gPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJBLmV4ZWMoYSkpICYmIChibSA9IGQzX2ludGVycG9sYXRlX251bWJlckIuZXhlYyhiKSkpIHtcbiAgICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkge1xuICAgICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IGVsc2Ugc1srK2ldID0gYnM7XG4gICAgICB9XG4gICAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHtcbiAgICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IGVsc2Ugc1srK2ldID0gYm07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzWysraV0gPSBudWxsO1xuICAgICAgICBxLnB1c2goe1xuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIoYW0sIGJtKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJpID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQi5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIHJldHVybiBzLmxlbmd0aCA8IDIgPyBxWzBdID8gKGIgPSBxWzBdLngsIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBiKHQpICsgXCJcIjtcbiAgICB9KSA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH0pO1xuICB9XG4gIHZhciBkM19pbnRlcnBvbGF0ZV9udW1iZXJBID0gL1stK10/KD86XFxkK1xcLj9cXGQqfFxcLj9cXGQrKSg/OltlRV1bLStdP1xcZCspPy9nLCBkM19pbnRlcnBvbGF0ZV9udW1iZXJCID0gbmV3IFJlZ0V4cChkM19pbnRlcnBvbGF0ZV9udW1iZXJBLnNvdXJjZSwgXCJnXCIpO1xuICBkMy5pbnRlcnBvbGF0ZSA9IGQzX2ludGVycG9sYXRlO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgdmFyIGkgPSBkMy5pbnRlcnBvbGF0b3JzLmxlbmd0aCwgZjtcbiAgICB3aGlsZSAoLS1pID49IDAgJiYgIShmID0gZDMuaW50ZXJwb2xhdG9yc1tpXShhLCBiKSkpIDtcbiAgICByZXR1cm4gZjtcbiAgfVxuICBkMy5pbnRlcnBvbGF0b3JzID0gWyBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgYjtcbiAgICByZXR1cm4gKHQgPT09IFwic3RyaW5nXCIgPyBkM19yZ2JfbmFtZXMuaGFzKGIpIHx8IC9eKCN8cmdiXFwofGhzbFxcKCkvLnRlc3QoYikgPyBkM19pbnRlcnBvbGF0ZVJnYiA6IGQzX2ludGVycG9sYXRlU3RyaW5nIDogYiBpbnN0YW5jZW9mIGQzX2NvbG9yID8gZDNfaW50ZXJwb2xhdGVSZ2IgOiBBcnJheS5pc0FycmF5KGIpID8gZDNfaW50ZXJwb2xhdGVBcnJheSA6IHQgPT09IFwib2JqZWN0XCIgJiYgaXNOYU4oYikgPyBkM19pbnRlcnBvbGF0ZU9iamVjdCA6IGQzX2ludGVycG9sYXRlTnVtYmVyKShhLCBiKTtcbiAgfSBdO1xuICBkMy5pbnRlcnBvbGF0ZUFycmF5ID0gZDNfaW50ZXJwb2xhdGVBcnJheTtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVBcnJheShhLCBiKSB7XG4gICAgdmFyIHggPSBbXSwgYyA9IFtdLCBuYSA9IGEubGVuZ3RoLCBuYiA9IGIubGVuZ3RoLCBuMCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCksIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG4wOyArK2kpIHgucHVzaChkM19pbnRlcnBvbGF0ZShhW2ldLCBiW2ldKSk7XG4gICAgZm9yICg7aSA8IG5hOyArK2kpIGNbaV0gPSBhW2ldO1xuICAgIGZvciAoO2kgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IG4wOyArK2kpIGNbaV0gPSB4W2ldKHQpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZWFzZV9kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2lkZW50aXR5O1xuICB9O1xuICB2YXIgZDNfZWFzZSA9IGQzLm1hcCh7XG4gICAgbGluZWFyOiBkM19lYXNlX2RlZmF1bHQsXG4gICAgcG9seTogZDNfZWFzZV9wb2x5LFxuICAgIHF1YWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfcXVhZDtcbiAgICB9LFxuICAgIGN1YmljOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX2N1YmljO1xuICAgIH0sXG4gICAgc2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX3NpbjtcbiAgICB9LFxuICAgIGV4cDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9leHA7XG4gICAgfSxcbiAgICBjaXJjbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfY2lyY2xlO1xuICAgIH0sXG4gICAgZWxhc3RpYzogZDNfZWFzZV9lbGFzdGljLFxuICAgIGJhY2s6IGQzX2Vhc2VfYmFjayxcbiAgICBib3VuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfYm91bmNlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBkM19lYXNlX21vZGUgPSBkMy5tYXAoe1xuICAgIFwiaW5cIjogZDNfaWRlbnRpdHksXG4gICAgb3V0OiBkM19lYXNlX3JldmVyc2UsXG4gICAgXCJpbi1vdXRcIjogZDNfZWFzZV9yZWZsZWN0LFxuICAgIFwib3V0LWluXCI6IGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX3JlZmxlY3QoZDNfZWFzZV9yZXZlcnNlKGYpKTtcbiAgICB9XG4gIH0pO1xuICBkMy5lYXNlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gbmFtZS5pbmRleE9mKFwiLVwiKSwgdCA9IGkgPj0gMCA/IG5hbWUuc2xpY2UoMCwgaSkgOiBuYW1lLCBtID0gaSA+PSAwID8gbmFtZS5zbGljZShpICsgMSkgOiBcImluXCI7XG4gICAgdCA9IGQzX2Vhc2UuZ2V0KHQpIHx8IGQzX2Vhc2VfZGVmYXVsdDtcbiAgICBtID0gZDNfZWFzZV9tb2RlLmdldChtKSB8fCBkM19pZGVudGl0eTtcbiAgICByZXR1cm4gZDNfZWFzZV9jbGFtcChtKHQuYXBwbHkobnVsbCwgZDNfYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfY2xhbXAoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdCA8PSAwID8gMCA6IHQgPj0gMSA/IDEgOiBmKHQpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9yZXZlcnNlKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIDEgLSBmKDEgLSB0KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfcmVmbGVjdChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAuNSAqICh0IDwgLjUgPyBmKDIgKiB0KSA6IDIgLSBmKDIgLSAyICogdCkpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9xdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9jdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2N1YmljSW5PdXQodCkge1xuICAgIGlmICh0IDw9IDApIHJldHVybiAwO1xuICAgIGlmICh0ID49IDEpIHJldHVybiAxO1xuICAgIHZhciB0MiA9IHQgKiB0LCB0MyA9IHQyICogdDtcbiAgICByZXR1cm4gNCAqICh0IDwgLjUgPyB0MyA6IDMgKiAodCAtIHQyKSArIHQzIC0gLjc1KTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3BvbHkoZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3codCwgZSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3Npbih0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZs+AKTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2V4cCh0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9jaXJjbGUodCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9lbGFzdGljKGEsIHApIHtcbiAgICB2YXIgcztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHAgPSAuNDU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHMgPSBwIC8gz4QgKiBNYXRoLmFzaW4oMSAvIGEpOyBlbHNlIGEgPSAxLCBzID0gcCAvIDQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAxICsgYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIM+EIC8gcCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2JhY2socykge1xuICAgIGlmICghcykgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9ib3VuY2UodCkge1xuICAgIHJldHVybiB0IDwgMSAvIDIuNzUgPyA3LjU2MjUgKiB0ICogdCA6IHQgPCAyIC8gMi43NSA/IDcuNTYyNSAqICh0IC09IDEuNSAvIDIuNzUpICogdCArIC43NSA6IHQgPCAyLjUgLyAyLjc1ID8gNy41NjI1ICogKHQgLT0gMi4yNSAvIDIuNzUpICogdCArIC45Mzc1IDogNy41NjI1ICogKHQgLT0gMi42MjUgLyAyLjc1KSAqIHQgKyAuOTg0Mzc1O1xuICB9XG4gIGQzLmludGVycG9sYXRlSGNsID0gZDNfaW50ZXJwb2xhdGVIY2w7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlSGNsKGEsIGIpIHtcbiAgICBhID0gZDMuaGNsKGEpO1xuICAgIGIgPSBkMy5oY2woYik7XG4gICAgdmFyIGFoID0gYS5oLCBhYyA9IGEuYywgYWwgPSBhLmwsIGJoID0gYi5oIC0gYWgsIGJjID0gYi5jIC0gYWMsIGJsID0gYi5sIC0gYWw7XG4gICAgaWYgKGlzTmFOKGJjKSkgYmMgPSAwLCBhYyA9IGlzTmFOKGFjKSA/IGIuYyA6IGFjO1xuICAgIGlmIChpc05hTihiaCkpIGJoID0gMCwgYWggPSBpc05hTihhaCkgPyBiLmggOiBhaDsgZWxzZSBpZiAoYmggPiAxODApIGJoIC09IDM2MDsgZWxzZSBpZiAoYmggPCAtMTgwKSBiaCArPSAzNjA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19oY2xfbGFiKGFoICsgYmggKiB0LCBhYyArIGJjICogdCwgYWwgKyBibCAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlSHNsID0gZDNfaW50ZXJwb2xhdGVIc2w7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlSHNsKGEsIGIpIHtcbiAgICBhID0gZDMuaHNsKGEpO1xuICAgIGIgPSBkMy5oc2woYik7XG4gICAgdmFyIGFoID0gYS5oLCBhcyA9IGEucywgYWwgPSBhLmwsIGJoID0gYi5oIC0gYWgsIGJzID0gYi5zIC0gYXMsIGJsID0gYi5sIC0gYWw7XG4gICAgaWYgKGlzTmFOKGJzKSkgYnMgPSAwLCBhcyA9IGlzTmFOKGFzKSA/IGIucyA6IGFzO1xuICAgIGlmIChpc05hTihiaCkpIGJoID0gMCwgYWggPSBpc05hTihhaCkgPyBiLmggOiBhaDsgZWxzZSBpZiAoYmggPiAxODApIGJoIC09IDM2MDsgZWxzZSBpZiAoYmggPCAtMTgwKSBiaCArPSAzNjA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19oc2xfcmdiKGFoICsgYmggKiB0LCBhcyArIGJzICogdCwgYWwgKyBibCAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlTGFiID0gZDNfaW50ZXJwb2xhdGVMYWI7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlTGFiKGEsIGIpIHtcbiAgICBhID0gZDMubGFiKGEpO1xuICAgIGIgPSBkMy5sYWIoYik7XG4gICAgdmFyIGFsID0gYS5sLCBhYSA9IGEuYSwgYWIgPSBhLmIsIGJsID0gYi5sIC0gYWwsIGJhID0gYi5hIC0gYWEsIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBkM19sYWJfcmdiKGFsICsgYmwgKiB0LCBhYSArIGJhICogdCwgYWIgKyBiYiAqIHQpICsgXCJcIjtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlUm91bmQgPSBkM19pbnRlcnBvbGF0ZVJvdW5kO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVJvdW5kKGEsIGIpIHtcbiAgICBiIC09IGE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKyBiICogdCk7XG4gICAgfTtcbiAgfVxuICBkMy50cmFuc2Zvcm0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZyA9IGQzX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhkMy5ucy5wcmVmaXguc3ZnLCBcImdcIik7XG4gICAgcmV0dXJuIChkMy50cmFuc2Zvcm0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmcgIT0gbnVsbCkge1xuICAgICAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBzdHJpbmcpO1xuICAgICAgICB2YXIgdCA9IGcudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZDNfdHJhbnNmb3JtKHQgPyB0Lm1hdHJpeCA6IGQzX3RyYW5zZm9ybUlkZW50aXR5KTtcbiAgICB9KShzdHJpbmcpO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2Zvcm0obSkge1xuICAgIHZhciByMCA9IFsgbS5hLCBtLmIgXSwgcjEgPSBbIG0uYywgbS5kIF0sIGt4ID0gZDNfdHJhbnNmb3JtTm9ybWFsaXplKHIwKSwga3ogPSBkM190cmFuc2Zvcm1Eb3QocjAsIHIxKSwga3kgPSBkM190cmFuc2Zvcm1Ob3JtYWxpemUoZDNfdHJhbnNmb3JtQ29tYmluZShyMSwgcjAsIC1reikpIHx8IDA7XG4gICAgaWYgKHIwWzBdICogcjFbMV0gPCByMVswXSAqIHIwWzFdKSB7XG4gICAgICByMFswXSAqPSAtMTtcbiAgICAgIHIwWzFdICo9IC0xO1xuICAgICAga3ggKj0gLTE7XG4gICAgICBreiAqPSAtMTtcbiAgICB9XG4gICAgdGhpcy5yb3RhdGUgPSAoa3ggPyBNYXRoLmF0YW4yKHIwWzFdLCByMFswXSkgOiBNYXRoLmF0YW4yKC1yMVswXSwgcjFbMV0pKSAqIGQzX2RlZ3JlZXM7XG4gICAgdGhpcy50cmFuc2xhdGUgPSBbIG0uZSwgbS5mIF07XG4gICAgdGhpcy5zY2FsZSA9IFsga3gsIGt5IF07XG4gICAgdGhpcy5za2V3ID0ga3kgPyBNYXRoLmF0YW4yKGt6LCBreSkgKiBkM19kZWdyZWVzIDogMDtcbiAgfVxuICBkM190cmFuc2Zvcm0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy50cmFuc2xhdGUgKyBcIilyb3RhdGUoXCIgKyB0aGlzLnJvdGF0ZSArIFwiKXNrZXdYKFwiICsgdGhpcy5za2V3ICsgXCIpc2NhbGUoXCIgKyB0aGlzLnNjYWxlICsgXCIpXCI7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybURvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJhbnNmb3JtTm9ybWFsaXplKGEpIHtcbiAgICB2YXIgayA9IE1hdGguc3FydChkM190cmFuc2Zvcm1Eb3QoYSwgYSkpO1xuICAgIGlmIChrKSB7XG4gICAgICBhWzBdIC89IGs7XG4gICAgICBhWzFdIC89IGs7XG4gICAgfVxuICAgIHJldHVybiBrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybUNvbWJpbmUoYSwgYiwgaykge1xuICAgIGFbMF0gKz0gayAqIGJbMF07XG4gICAgYVsxXSArPSBrICogYlsxXTtcbiAgICByZXR1cm4gYTtcbiAgfVxuICB2YXIgZDNfdHJhbnNmb3JtSWRlbnRpdHkgPSB7XG4gICAgYTogMSxcbiAgICBiOiAwLFxuICAgIGM6IDAsXG4gICAgZDogMSxcbiAgICBlOiAwLFxuICAgIGY6IDBcbiAgfTtcbiAgZDMuaW50ZXJwb2xhdGVUcmFuc2Zvcm0gPSBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybTtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm0oYSwgYikge1xuICAgIHZhciBzID0gW10sIHEgPSBbXSwgbiwgQSA9IGQzLnRyYW5zZm9ybShhKSwgQiA9IGQzLnRyYW5zZm9ybShiKSwgdGEgPSBBLnRyYW5zbGF0ZSwgdGIgPSBCLnRyYW5zbGF0ZSwgcmEgPSBBLnJvdGF0ZSwgcmIgPSBCLnJvdGF0ZSwgd2EgPSBBLnNrZXcsIHdiID0gQi5za2V3LCBrYSA9IEEuc2NhbGUsIGtiID0gQi5zY2FsZTtcbiAgICBpZiAodGFbMF0gIT0gdGJbMF0gfHwgdGFbMV0gIT0gdGJbMV0pIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IDEsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHRhWzBdLCB0YlswXSlcbiAgICAgIH0sIHtcbiAgICAgICAgaTogMyxcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIodGFbMV0sIHRiWzFdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YlswXSB8fCB0YlsxXSkge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgdGIgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMucHVzaChcIlwiKTtcbiAgICB9XG4gICAgaWYgKHJhICE9IHJiKSB7XG4gICAgICBpZiAocmEgLSByYiA+IDE4MCkgcmIgKz0gMzYwOyBlbHNlIGlmIChyYiAtIHJhID4gMTgwKSByYSArPSAzNjA7XG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBzLnB1c2gocy5wb3AoKSArIFwicm90YXRlKFwiLCBudWxsLCBcIilcIikgLSAyLFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcihyYSwgcmIpXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJiKSB7XG4gICAgICBzLnB1c2gocy5wb3AoKSArIFwicm90YXRlKFwiICsgcmIgKyBcIilcIik7XG4gICAgfVxuICAgIGlmICh3YSAhPSB3Yikge1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogcy5wdXNoKHMucG9wKCkgKyBcInNrZXdYKFwiLCBudWxsLCBcIilcIikgLSAyLFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcih3YSwgd2IpXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHdiKSB7XG4gICAgICBzLnB1c2gocy5wb3AoKSArIFwic2tld1goXCIgKyB3YiArIFwiKVwiKTtcbiAgICB9XG4gICAgaWYgKGthWzBdICE9IGtiWzBdIHx8IGthWzFdICE9IGtiWzFdKSB7XG4gICAgICBuID0gcy5wdXNoKHMucG9wKCkgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogbiAtIDQsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKGthWzBdLCBrYlswXSlcbiAgICAgIH0sIHtcbiAgICAgICAgaTogbiAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKGthWzFdLCBrYlsxXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoa2JbMF0gIT0gMSB8fCBrYlsxXSAhPSAxKSB7XG4gICAgICBzLnB1c2gocy5wb3AoKSArIFwic2NhbGUoXCIgKyBrYiArIFwiKVwiKTtcbiAgICB9XG4gICAgbiA9IHEubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBvO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM191bmludGVycG9sYXRlTnVtYmVyKGEsIGIpIHtcbiAgICBiID0gKGIgLT0gYSA9ICthKSB8fCAxIC8gYjtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuICh4IC0gYSkgLyBiO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdW5pbnRlcnBvbGF0ZUNsYW1wKGEsIGIpIHtcbiAgICBiID0gKGIgLT0gYSA9ICthKSB8fCAxIC8gYjtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gYSkgLyBiKSk7XG4gICAgfTtcbiAgfVxuICBkMy5sYXlvdXQgPSB7fTtcbiAgZDMubGF5b3V0LmJ1bmRsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihsaW5rcykge1xuICAgICAgdmFyIHBhdGhzID0gW10sIGkgPSAtMSwgbiA9IGxpbmtzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBwYXRocy5wdXNoKGQzX2xheW91dF9idW5kbGVQYXRoKGxpbmtzW2ldKSk7XG4gICAgICByZXR1cm4gcGF0aHM7XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2J1bmRsZVBhdGgobGluaykge1xuICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlLCBlbmQgPSBsaW5rLnRhcmdldCwgbGNhID0gZDNfbGF5b3V0X2J1bmRsZUxlYXN0Q29tbW9uQW5jZXN0b3Ioc3RhcnQsIGVuZCksIHBvaW50cyA9IFsgc3RhcnQgXTtcbiAgICB3aGlsZSAoc3RhcnQgIT09IGxjYSkge1xuICAgICAgc3RhcnQgPSBzdGFydC5wYXJlbnQ7XG4gICAgICBwb2ludHMucHVzaChzdGFydCk7XG4gICAgfVxuICAgIHZhciBrID0gcG9pbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoZW5kICE9PSBsY2EpIHtcbiAgICAgIHBvaW50cy5zcGxpY2UoaywgMCwgZW5kKTtcbiAgICAgIGVuZCA9IGVuZC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2J1bmRsZUFuY2VzdG9ycyhub2RlKSB7XG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdLCBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgIHJldHVybiBhbmNlc3RvcnM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2J1bmRsZUxlYXN0Q29tbW9uQW5jZXN0b3IoYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gYTtcbiAgICB2YXIgYU5vZGVzID0gZDNfbGF5b3V0X2J1bmRsZUFuY2VzdG9ycyhhKSwgYk5vZGVzID0gZDNfbGF5b3V0X2J1bmRsZUFuY2VzdG9ycyhiKSwgYU5vZGUgPSBhTm9kZXMucG9wKCksIGJOb2RlID0gYk5vZGVzLnBvcCgpLCBzaGFyZWROb2RlID0gbnVsbDtcbiAgICB3aGlsZSAoYU5vZGUgPT09IGJOb2RlKSB7XG4gICAgICBzaGFyZWROb2RlID0gYU5vZGU7XG4gICAgICBhTm9kZSA9IGFOb2Rlcy5wb3AoKTtcbiAgICAgIGJOb2RlID0gYk5vZGVzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcmVkTm9kZTtcbiAgfVxuICBkMy5sYXlvdXQuY2hvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hvcmQgPSB7fSwgY2hvcmRzLCBncm91cHMsIG1hdHJpeCwgbiwgcGFkZGluZyA9IDAsIHNvcnRHcm91cHMsIHNvcnRTdWJncm91cHMsIHNvcnRDaG9yZHM7XG4gICAgZnVuY3Rpb24gcmVsYXlvdXQoKSB7XG4gICAgICB2YXIgc3ViZ3JvdXBzID0ge30sIGdyb3VwU3VtcyA9IFtdLCBncm91cEluZGV4ID0gZDMucmFuZ2UobiksIHN1Ymdyb3VwSW5kZXggPSBbXSwgaywgeCwgeDAsIGksIGo7XG4gICAgICBjaG9yZHMgPSBbXTtcbiAgICAgIGdyb3VwcyA9IFtdO1xuICAgICAgayA9IDAsIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIHggPSAwLCBqID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgICAgeCArPSBtYXRyaXhbaV1bal07XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBTdW1zLnB1c2goeCk7XG4gICAgICAgIHN1Ymdyb3VwSW5kZXgucHVzaChkMy5yYW5nZShuKSk7XG4gICAgICAgIGsgKz0geDtcbiAgICAgIH1cbiAgICAgIGlmIChzb3J0R3JvdXBzKSB7XG4gICAgICAgIGdyb3VwSW5kZXguc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIHNvcnRHcm91cHMoZ3JvdXBTdW1zW2FdLCBncm91cFN1bXNbYl0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3J0U3ViZ3JvdXBzKSB7XG4gICAgICAgIHN1Ymdyb3VwSW5kZXguZm9yRWFjaChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0U3ViZ3JvdXBzKG1hdHJpeFtpXVthXSwgbWF0cml4W2ldW2JdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBrID0gKM+EIC0gcGFkZGluZyAqIG4pIC8gaztcbiAgICAgIHggPSAwLCBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICB4MCA9IHgsIGogPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgICB2YXIgZGkgPSBncm91cEluZGV4W2ldLCBkaiA9IHN1Ymdyb3VwSW5kZXhbZGldW2pdLCB2ID0gbWF0cml4W2RpXVtkal0sIGEwID0geCwgYTEgPSB4ICs9IHYgKiBrO1xuICAgICAgICAgIHN1Ymdyb3Vwc1tkaSArIFwiLVwiICsgZGpdID0ge1xuICAgICAgICAgICAgaW5kZXg6IGRpLFxuICAgICAgICAgICAgc3ViaW5kZXg6IGRqLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgICAgICBlbmRBbmdsZTogYTEsXG4gICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBzW2RpXSA9IHtcbiAgICAgICAgICBpbmRleDogZGksXG4gICAgICAgICAgc3RhcnRBbmdsZTogeDAsXG4gICAgICAgICAgZW5kQW5nbGU6IHgsXG4gICAgICAgICAgdmFsdWU6ICh4IC0geDApIC8ga1xuICAgICAgICB9O1xuICAgICAgICB4ICs9IHBhZGRpbmc7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBqID0gaSAtIDE7XG4gICAgICAgIHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHN1Ymdyb3Vwc1tpICsgXCItXCIgKyBqXSwgdGFyZ2V0ID0gc3ViZ3JvdXBzW2ogKyBcIi1cIiArIGldO1xuICAgICAgICAgIGlmIChzb3VyY2UudmFsdWUgfHwgdGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICBjaG9yZHMucHVzaChzb3VyY2UudmFsdWUgPCB0YXJnZXQudmFsdWUgPyB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGFyZ2V0LFxuICAgICAgICAgICAgICB0YXJnZXQ6IHNvdXJjZVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzb3J0Q2hvcmRzKSByZXNvcnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb3J0KCkge1xuICAgICAgY2hvcmRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gc29ydENob3JkcygoYS5zb3VyY2UudmFsdWUgKyBhLnRhcmdldC52YWx1ZSkgLyAyLCAoYi5zb3VyY2UudmFsdWUgKyBiLnRhcmdldC52YWx1ZSkgLyAyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjaG9yZC5tYXRyaXggPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYXRyaXg7XG4gICAgICBuID0gKG1hdHJpeCA9IHgpICYmIG1hdHJpeC5sZW5ndGg7XG4gICAgICBjaG9yZHMgPSBncm91cHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZGRpbmc7XG4gICAgICBwYWRkaW5nID0geDtcbiAgICAgIGNob3JkcyA9IGdyb3VwcyA9IG51bGw7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zb3J0R3JvdXBzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydEdyb3VwcztcbiAgICAgIHNvcnRHcm91cHMgPSB4O1xuICAgICAgY2hvcmRzID0gZ3JvdXBzID0gbnVsbDtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvcnRTdWJncm91cHMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0U3ViZ3JvdXBzO1xuICAgICAgc29ydFN1Ymdyb3VwcyA9IHg7XG4gICAgICBjaG9yZHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc29ydENob3JkcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnRDaG9yZHM7XG4gICAgICBzb3J0Q2hvcmRzID0geDtcbiAgICAgIGlmIChjaG9yZHMpIHJlc29ydCgpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuY2hvcmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWNob3JkcykgcmVsYXlvdXQoKTtcbiAgICAgIHJldHVybiBjaG9yZHM7XG4gICAgfTtcbiAgICBjaG9yZC5ncm91cHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghZ3JvdXBzKSByZWxheW91dCgpO1xuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9O1xuICAgIHJldHVybiBjaG9yZDtcbiAgfTtcbiAgZDMubGF5b3V0LmZvcmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZvcmNlID0ge30sIGV2ZW50ID0gZDMuZGlzcGF0Y2goXCJzdGFydFwiLCBcInRpY2tcIiwgXCJlbmRcIiksIHNpemUgPSBbIDEsIDEgXSwgZHJhZywgYWxwaGEsIGZyaWN0aW9uID0gLjksIGxpbmtEaXN0YW5jZSA9IGQzX2xheW91dF9mb3JjZUxpbmtEaXN0YW5jZSwgbGlua1N0cmVuZ3RoID0gZDNfbGF5b3V0X2ZvcmNlTGlua1N0cmVuZ3RoLCBjaGFyZ2UgPSAtMzAsIGNoYXJnZURpc3RhbmNlMiA9IGQzX2xheW91dF9mb3JjZUNoYXJnZURpc3RhbmNlMiwgZ3Jhdml0eSA9IC4xLCB0aGV0YTIgPSAuNjQsIG5vZGVzID0gW10sIGxpbmtzID0gW10sIGRpc3RhbmNlcywgc3RyZW5ndGhzLCBjaGFyZ2VzO1xuICAgIGZ1bmN0aW9uIHJlcHVsc2Uobm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHF1YWQsIHgxLCBfLCB4Mikge1xuICAgICAgICBpZiAocXVhZC5wb2ludCAhPT0gbm9kZSkge1xuICAgICAgICAgIHZhciBkeCA9IHF1YWQuY3ggLSBub2RlLngsIGR5ID0gcXVhZC5jeSAtIG5vZGUueSwgZHcgPSB4MiAtIHgxLCBkbiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICAgIGlmIChkdyAqIGR3IC8gdGhldGEyIDwgZG4pIHtcbiAgICAgICAgICAgIGlmIChkbiA8IGNoYXJnZURpc3RhbmNlMikge1xuICAgICAgICAgICAgICB2YXIgayA9IHF1YWQuY2hhcmdlIC8gZG47XG4gICAgICAgICAgICAgIG5vZGUucHggLT0gZHggKiBrO1xuICAgICAgICAgICAgICBub2RlLnB5IC09IGR5ICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocXVhZC5wb2ludCAmJiBkbiAmJiBkbiA8IGNoYXJnZURpc3RhbmNlMikge1xuICAgICAgICAgICAgdmFyIGsgPSBxdWFkLnBvaW50Q2hhcmdlIC8gZG47XG4gICAgICAgICAgICBub2RlLnB4IC09IGR4ICogaztcbiAgICAgICAgICAgIG5vZGUucHkgLT0gZHkgKiBrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXF1YWQuY2hhcmdlO1xuICAgICAgfTtcbiAgICB9XG4gICAgZm9yY2UudGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKChhbHBoYSAqPSAuOTkpIDwgLjAwNSkge1xuICAgICAgICBldmVudC5lbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZW5kXCIsXG4gICAgICAgICAgYWxwaGE6IGFscGhhID0gMFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgbiA9IG5vZGVzLmxlbmd0aCwgbSA9IGxpbmtzLmxlbmd0aCwgcSwgaSwgbywgcywgdCwgbCwgaywgeCwgeTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgbyA9IGxpbmtzW2ldO1xuICAgICAgICBzID0gby5zb3VyY2U7XG4gICAgICAgIHQgPSBvLnRhcmdldDtcbiAgICAgICAgeCA9IHQueCAtIHMueDtcbiAgICAgICAgeSA9IHQueSAtIHMueTtcbiAgICAgICAgaWYgKGwgPSB4ICogeCArIHkgKiB5KSB7XG4gICAgICAgICAgbCA9IGFscGhhICogc3RyZW5ndGhzW2ldICogKChsID0gTWF0aC5zcXJ0KGwpKSAtIGRpc3RhbmNlc1tpXSkgLyBsO1xuICAgICAgICAgIHggKj0gbDtcbiAgICAgICAgICB5ICo9IGw7XG4gICAgICAgICAgdC54IC09IHggKiAoayA9IHMud2VpZ2h0IC8gKHQud2VpZ2h0ICsgcy53ZWlnaHQpKTtcbiAgICAgICAgICB0LnkgLT0geSAqIGs7XG4gICAgICAgICAgcy54ICs9IHggKiAoayA9IDEgLSBrKTtcbiAgICAgICAgICBzLnkgKz0geSAqIGs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrID0gYWxwaGEgKiBncmF2aXR5KSB7XG4gICAgICAgIHggPSBzaXplWzBdIC8gMjtcbiAgICAgICAgeSA9IHNpemVbMV0gLyAyO1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIGlmIChrKSB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIG8gPSBub2Rlc1tpXTtcbiAgICAgICAgICBvLnggKz0gKHggLSBvLngpICogaztcbiAgICAgICAgICBvLnkgKz0gKHkgLSBvLnkpICogaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoYXJnZSkge1xuICAgICAgICBkM19sYXlvdXRfZm9yY2VBY2N1bXVsYXRlKHEgPSBkMy5nZW9tLnF1YWR0cmVlKG5vZGVzKSwgYWxwaGEsIGNoYXJnZXMpO1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaWYgKCEobyA9IG5vZGVzW2ldKS5maXhlZCkge1xuICAgICAgICAgICAgcS52aXNpdChyZXB1bHNlKG8pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIG8gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG8uZml4ZWQpIHtcbiAgICAgICAgICBvLnggPSBvLnB4O1xuICAgICAgICAgIG8ueSA9IG8ucHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgby54IC09IChvLnB4IC0gKG8ucHggPSBvLngpKSAqIGZyaWN0aW9uO1xuICAgICAgICAgIG8ueSAtPSAoby5weSAtIChvLnB5ID0gby55KSkgKiBmcmljdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnQudGljayh7XG4gICAgICAgIHR5cGU6IFwidGlja1wiLFxuICAgICAgICBhbHBoYTogYWxwaGFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yY2Uubm9kZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlcztcbiAgICAgIG5vZGVzID0geDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmxpbmtzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua3M7XG4gICAgICBsaW5rcyA9IHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UubGlua0Rpc3RhbmNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua0Rpc3RhbmNlO1xuICAgICAgbGlua0Rpc3RhbmNlID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmRpc3RhbmNlID0gZm9yY2UubGlua0Rpc3RhbmNlO1xuICAgIGZvcmNlLmxpbmtTdHJlbmd0aCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmtTdHJlbmd0aDtcbiAgICAgIGxpbmtTdHJlbmd0aCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5mcmljdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZyaWN0aW9uO1xuICAgICAgZnJpY3Rpb24gPSAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmNoYXJnZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNoYXJnZTtcbiAgICAgIGNoYXJnZSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5jaGFyZ2VEaXN0YW5jZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIE1hdGguc3FydChjaGFyZ2VEaXN0YW5jZTIpO1xuICAgICAgY2hhcmdlRGlzdGFuY2UyID0geCAqIHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5ncmF2aXR5ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3Jhdml0eTtcbiAgICAgIGdyYXZpdHkgPSAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLnRoZXRhID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gTWF0aC5zcXJ0KHRoZXRhMik7XG4gICAgICB0aGV0YTIgPSB4ICogeDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmFscGhhID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYWxwaGE7XG4gICAgICB4ID0gK3g7XG4gICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgaWYgKHggPiAwKSBhbHBoYSA9IHg7IGVsc2UgYWxwaGEgPSAwO1xuICAgICAgfSBlbHNlIGlmICh4ID4gMCkge1xuICAgICAgICBldmVudC5zdGFydCh7XG4gICAgICAgICAgdHlwZTogXCJzdGFydFwiLFxuICAgICAgICAgIGFscGhhOiBhbHBoYSA9IHhcbiAgICAgICAgfSk7XG4gICAgICAgIGQzLnRpbWVyKGZvcmNlLnRpY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2Uuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBtID0gbGlua3MubGVuZ3RoLCB3ID0gc2l6ZVswXSwgaCA9IHNpemVbMV0sIG5laWdoYm9ycywgbztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgKG8gPSBub2Rlc1tpXSkuaW5kZXggPSBpO1xuICAgICAgICBvLndlaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIG8gPSBsaW5rc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnNvdXJjZSA9PSBcIm51bWJlclwiKSBvLnNvdXJjZSA9IG5vZGVzW28uc291cmNlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLnRhcmdldCA9PSBcIm51bWJlclwiKSBvLnRhcmdldCA9IG5vZGVzW28udGFyZ2V0XTtcbiAgICAgICAgKytvLnNvdXJjZS53ZWlnaHQ7XG4gICAgICAgICsrby50YXJnZXQud2VpZ2h0O1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBvID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChpc05hTihvLngpKSBvLnggPSBwb3NpdGlvbihcInhcIiwgdyk7XG4gICAgICAgIGlmIChpc05hTihvLnkpKSBvLnkgPSBwb3NpdGlvbihcInlcIiwgaCk7XG4gICAgICAgIGlmIChpc05hTihvLnB4KSkgby5weCA9IG8ueDtcbiAgICAgICAgaWYgKGlzTmFOKG8ucHkpKSBvLnB5ID0gby55O1xuICAgICAgfVxuICAgICAgZGlzdGFuY2VzID0gW107XG4gICAgICBpZiAodHlwZW9mIGxpbmtEaXN0YW5jZSA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBkaXN0YW5jZXNbaV0gPSArbGlua0Rpc3RhbmNlLmNhbGwodGhpcywgbGlua3NbaV0sIGkpOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIGRpc3RhbmNlc1tpXSA9IGxpbmtEaXN0YW5jZTtcbiAgICAgIHN0cmVuZ3RocyA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rU3RyZW5ndGggPT09IFwiZnVuY3Rpb25cIikgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc3RyZW5ndGhzW2ldID0gK2xpbmtTdHJlbmd0aC5jYWxsKHRoaXMsIGxpbmtzW2ldLCBpKTsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBzdHJlbmd0aHNbaV0gPSBsaW5rU3RyZW5ndGg7XG4gICAgICBjaGFyZ2VzID0gW107XG4gICAgICBpZiAodHlwZW9mIGNoYXJnZSA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGFyZ2VzW2ldID0gK2NoYXJnZS5jYWxsKHRoaXMsIG5vZGVzW2ldLCBpKTsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGFyZ2VzW2ldID0gY2hhcmdlO1xuICAgICAgZnVuY3Rpb24gcG9zaXRpb24oZGltZW5zaW9uLCBzaXplKSB7XG4gICAgICAgIGlmICghbmVpZ2hib3JzKSB7XG4gICAgICAgICAgbmVpZ2hib3JzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgIG5laWdoYm9yc1tqXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGxpbmtzW2pdO1xuICAgICAgICAgICAgbmVpZ2hib3JzW28uc291cmNlLmluZGV4XS5wdXNoKG8udGFyZ2V0KTtcbiAgICAgICAgICAgIG5laWdoYm9yc1tvLnRhcmdldC5pbmRleF0ucHVzaChvLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gbmVpZ2hib3JzW2ldLCBqID0gLTEsIG0gPSBjYW5kaWRhdGVzLmxlbmd0aCwgeDtcbiAgICAgICAgd2hpbGUgKCsraiA8IG0pIGlmICghaXNOYU4oeCA9IGNhbmRpZGF0ZXNbal1bZGltZW5zaW9uXSkpIHJldHVybiB4O1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIHNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yY2UucmVzdW1lKCk7XG4gICAgfTtcbiAgICBmb3JjZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmb3JjZS5hbHBoYSguMSk7XG4gICAgfTtcbiAgICBmb3JjZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9yY2UuYWxwaGEoMCk7XG4gICAgfTtcbiAgICBmb3JjZS5kcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWRyYWcpIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCkub3JpZ2luKGQzX2lkZW50aXR5KS5vbihcImRyYWdzdGFydC5mb3JjZVwiLCBkM19sYXlvdXRfZm9yY2VEcmFnc3RhcnQpLm9uKFwiZHJhZy5mb3JjZVwiLCBkcmFnbW92ZSkub24oXCJkcmFnZW5kLmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZURyYWdlbmQpO1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZHJhZztcbiAgICAgIHRoaXMub24oXCJtb3VzZW92ZXIuZm9yY2VcIiwgZDNfbGF5b3V0X2ZvcmNlTW91c2VvdmVyKS5vbihcIm1vdXNlb3V0LmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZU1vdXNlb3V0KS5jYWxsKGRyYWcpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZHJhZ21vdmUoZCkge1xuICAgICAgZC5weCA9IGQzLmV2ZW50LngsIGQucHkgPSBkMy5ldmVudC55O1xuICAgICAgZm9yY2UucmVzdW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBkMy5yZWJpbmQoZm9yY2UsIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VEcmFnc3RhcnQoZCkge1xuICAgIGQuZml4ZWQgfD0gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VEcmFnZW5kKGQpIHtcbiAgICBkLmZpeGVkICY9IH42O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZU1vdXNlb3ZlcihkKSB7XG4gICAgZC5maXhlZCB8PSA0O1xuICAgIGQucHggPSBkLngsIGQucHkgPSBkLnk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlTW91c2VvdXQoZCkge1xuICAgIGQuZml4ZWQgJj0gfjQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlQWNjdW11bGF0ZShxdWFkLCBhbHBoYSwgY2hhcmdlcykge1xuICAgIHZhciBjeCA9IDAsIGN5ID0gMDtcbiAgICBxdWFkLmNoYXJnZSA9IDA7XG4gICAgaWYgKCFxdWFkLmxlYWYpIHtcbiAgICAgIHZhciBub2RlcyA9IHF1YWQubm9kZXMsIG4gPSBub2Rlcy5sZW5ndGgsIGkgPSAtMSwgYztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGMgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKGMgPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIGQzX2xheW91dF9mb3JjZUFjY3VtdWxhdGUoYywgYWxwaGEsIGNoYXJnZXMpO1xuICAgICAgICBxdWFkLmNoYXJnZSArPSBjLmNoYXJnZTtcbiAgICAgICAgY3ggKz0gYy5jaGFyZ2UgKiBjLmN4O1xuICAgICAgICBjeSArPSBjLmNoYXJnZSAqIGMuY3k7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWFkLnBvaW50KSB7XG4gICAgICBpZiAoIXF1YWQubGVhZikge1xuICAgICAgICBxdWFkLnBvaW50LnggKz0gTWF0aC5yYW5kb20oKSAtIC41O1xuICAgICAgICBxdWFkLnBvaW50LnkgKz0gTWF0aC5yYW5kb20oKSAtIC41O1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBhbHBoYSAqIGNoYXJnZXNbcXVhZC5wb2ludC5pbmRleF07XG4gICAgICBxdWFkLmNoYXJnZSArPSBxdWFkLnBvaW50Q2hhcmdlID0gaztcbiAgICAgIGN4ICs9IGsgKiBxdWFkLnBvaW50Lng7XG4gICAgICBjeSArPSBrICogcXVhZC5wb2ludC55O1xuICAgIH1cbiAgICBxdWFkLmN4ID0gY3ggLyBxdWFkLmNoYXJnZTtcbiAgICBxdWFkLmN5ID0gY3kgLyBxdWFkLmNoYXJnZTtcbiAgfVxuICB2YXIgZDNfbGF5b3V0X2ZvcmNlTGlua0Rpc3RhbmNlID0gMjAsIGQzX2xheW91dF9mb3JjZUxpbmtTdHJlbmd0aCA9IDEsIGQzX2xheW91dF9mb3JjZUNoYXJnZURpc3RhbmNlMiA9IEluZmluaXR5O1xuICBkMy5sYXlvdXQuaGllcmFyY2h5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvcnQgPSBkM19sYXlvdXRfaGllcmFyY2h5U29ydCwgY2hpbGRyZW4gPSBkM19sYXlvdXRfaGllcmFyY2h5Q2hpbGRyZW4sIHZhbHVlID0gZDNfbGF5b3V0X2hpZXJhcmNoeVZhbHVlO1xuICAgIGZ1bmN0aW9uIGhpZXJhcmNoeShyb290KSB7XG4gICAgICB2YXIgc3RhY2sgPSBbIHJvb3QgXSwgbm9kZXMgPSBbXSwgbm9kZTtcbiAgICAgIHJvb3QuZGVwdGggPSAwO1xuICAgICAgd2hpbGUgKChub2RlID0gc3RhY2sucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKChjaGlsZHMgPSBjaGlsZHJlbi5jYWxsKGhpZXJhcmNoeSwgbm9kZSwgbm9kZS5kZXB0aCkpICYmIChuID0gY2hpbGRzLmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgbiwgY2hpbGRzLCBjaGlsZDtcbiAgICAgICAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goY2hpbGQgPSBjaGlsZHNbbl0pO1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIGNoaWxkLmRlcHRoID0gbm9kZS5kZXB0aCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSkgbm9kZS52YWx1ZSA9IDA7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUpIG5vZGUudmFsdWUgPSArdmFsdWUuY2FsbChoaWVyYXJjaHksIG5vZGUsIG5vZGUuZGVwdGgpIHx8IDA7XG4gICAgICAgICAgZGVsZXRlIG5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcywgcGFyZW50O1xuICAgICAgICBpZiAoc29ydCAmJiAoY2hpbGRzID0gbm9kZS5jaGlsZHJlbikpIGNoaWxkcy5zb3J0KHNvcnQpO1xuICAgICAgICBpZiAodmFsdWUgJiYgKHBhcmVudCA9IG5vZGUucGFyZW50KSkgcGFyZW50LnZhbHVlICs9IG5vZGUudmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgaGllcmFyY2h5LnNvcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0O1xuICAgICAgc29ydCA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LmNoaWxkcmVuID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2hpbGRyZW47XG4gICAgICBjaGlsZHJlbiA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LnZhbHVlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHg7XG4gICAgICByZXR1cm4gaGllcmFyY2h5O1xuICAgIH07XG4gICAgaGllcmFyY2h5LnJldmFsdWUgPSBmdW5jdGlvbihyb290KSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikgbm9kZS52YWx1ZSA9IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIHBhcmVudDtcbiAgICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIG5vZGUudmFsdWUgPSArdmFsdWUuY2FsbChoaWVyYXJjaHksIG5vZGUsIG5vZGUuZGVwdGgpIHx8IDA7XG4gICAgICAgICAgaWYgKHBhcmVudCA9IG5vZGUucGFyZW50KSBwYXJlbnQudmFsdWUgKz0gbm9kZS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICAgIHJldHVybiBoaWVyYXJjaHk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQob2JqZWN0LCBoaWVyYXJjaHkpIHtcbiAgICBkMy5yZWJpbmQob2JqZWN0LCBoaWVyYXJjaHksIFwic29ydFwiLCBcImNoaWxkcmVuXCIsIFwidmFsdWVcIik7XG4gICAgb2JqZWN0Lm5vZGVzID0gb2JqZWN0O1xuICAgIG9iamVjdC5saW5rcyA9IGQzX2xheW91dF9oaWVyYXJjaHlMaW5rcztcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShub2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IFsgbm9kZSBdO1xuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgIGlmICgoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIG4sIGNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoLS1uID49IDApIG5vZGVzLnB1c2goY2hpbGRyZW5bbl0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihub2RlLCBjYWxsYmFjaykge1xuICAgIHZhciBub2RlcyA9IFsgbm9kZSBdLCBub2RlczIgPSBbXTtcbiAgICB3aGlsZSAoKG5vZGUgPSBub2Rlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgbm9kZXMyLnB1c2gobm9kZSk7XG4gICAgICBpZiAoKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4sIGNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzMi5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlDaGlsZHJlbihkKSB7XG4gICAgcmV0dXJuIGQuY2hpbGRyZW47XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVZhbHVlKGQpIHtcbiAgICByZXR1cm4gZC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5U29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlMaW5rcyhub2Rlcykge1xuICAgIHJldHVybiBkMy5tZXJnZShub2Rlcy5tYXAoZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICByZXR1cm4gKHBhcmVudC5jaGlsZHJlbiB8fCBbXSkubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBwYXJlbnQsXG4gICAgICAgICAgdGFyZ2V0OiBjaGlsZFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG4gIGQzLmxheW91dC5wYXJ0aXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLCBzaXplID0gWyAxLCAxIF07XG4gICAgZnVuY3Rpb24gcG9zaXRpb24obm9kZSwgeCwgZHgsIGR5KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgbm9kZS54ID0geDtcbiAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBkeTtcbiAgICAgIG5vZGUuZHggPSBkeDtcbiAgICAgIG5vZGUuZHkgPSBkeTtcbiAgICAgIGlmIChjaGlsZHJlbiAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbiwgYywgZDtcbiAgICAgICAgZHggPSBub2RlLnZhbHVlID8gZHggLyBub2RlLnZhbHVlIDogMDtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBwb3NpdGlvbihjID0gY2hpbGRyZW5baV0sIHgsIGQgPSBjLnZhbHVlICogZHgsIGR5KTtcbiAgICAgICAgICB4ICs9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVwdGgobm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiwgZCA9IDA7XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG47XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBkID0gTWF0aC5tYXgoZCwgZGVwdGgoY2hpbGRyZW5baV0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxICsgZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydGl0aW9uKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgcG9zaXRpb24obm9kZXNbMF0sIDAsIHNpemVbMF0sIHNpemVbMV0gLyBkZXB0aChub2Rlc1swXSkpO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBwYXJ0aXRpb24uc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0geDtcbiAgICAgIHJldHVybiBwYXJ0aXRpb247XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZChwYXJ0aXRpb24sIGhpZXJhcmNoeSk7XG4gIH07XG4gIGQzLmxheW91dC5waWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBOdW1iZXIsIHNvcnQgPSBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUsIHN0YXJ0QW5nbGUgPSAwLCBlbmRBbmdsZSA9IM+ELCBwYWRBbmdsZSA9IDA7XG4gICAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIHZhbHVlcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICt2YWx1ZS5jYWxsKHBpZSwgZCwgaSk7XG4gICAgICB9KSwgYSA9ICsodHlwZW9mIHN0YXJ0QW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHN0YXJ0QW5nbGUpLCBkYSA9ICh0eXBlb2YgZW5kQW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBlbmRBbmdsZSkgLSBhLCBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgKyh0eXBlb2YgcGFkQW5nbGUgPT09IFwiZnVuY3Rpb25cIiA/IHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwYWRBbmdsZSkpLCBwYSA9IHAgKiAoZGEgPCAwID8gLTEgOiAxKSwgayA9IChkYSAtIG4gKiBwYSkgLyBkMy5zdW0odmFsdWVzKSwgaW5kZXggPSBkMy5yYW5nZShuKSwgYXJjcyA9IFtdLCB2O1xuICAgICAgaWYgKHNvcnQgIT0gbnVsbCkgaW5kZXguc29ydChzb3J0ID09PSBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUgPyBmdW5jdGlvbihpLCBqKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbal0gLSB2YWx1ZXNbaV07XG4gICAgICB9IDogZnVuY3Rpb24oaSwgaikge1xuICAgICAgICByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTtcbiAgICAgIH0pO1xuICAgICAgaW5kZXguZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGFyY3NbaV0gPSB7XG4gICAgICAgICAgZGF0YTogZGF0YVtpXSxcbiAgICAgICAgICB2YWx1ZTogdiA9IHZhbHVlc1tpXSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiBhLFxuICAgICAgICAgIGVuZEFuZ2xlOiBhICs9IHYgKiBrICsgcGEsXG4gICAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFyY3M7XG4gICAgfVxuICAgIHBpZS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFsdWUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5zb3J0ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydDtcbiAgICAgIHNvcnQgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhcnRBbmdsZTtcbiAgICAgIHN0YXJ0QW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHBpZS5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZEFuZ2xlO1xuICAgICAgcGFkQW5nbGUgPSBfO1xuICAgICAgcmV0dXJuIHBpZTtcbiAgICB9O1xuICAgIHJldHVybiBwaWU7XG4gIH07XG4gIHZhciBkM19sYXlvdXRfcGllU29ydEJ5VmFsdWUgPSB7fTtcbiAgZDMubGF5b3V0LnN0YWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IGQzX2lkZW50aXR5LCBvcmRlciA9IGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdCwgb2Zmc2V0ID0gZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybywgb3V0ID0gZDNfbGF5b3V0X3N0YWNrT3V0LCB4ID0gZDNfbGF5b3V0X3N0YWNrWCwgeSA9IGQzX2xheW91dF9zdGFja1k7XG4gICAgZnVuY3Rpb24gc3RhY2soZGF0YSwgaW5kZXgpIHtcbiAgICAgIGlmICghKG4gPSBkYXRhLmxlbmd0aCkpIHJldHVybiBkYXRhO1xuICAgICAgdmFyIHNlcmllcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5jYWxsKHN0YWNrLCBkLCBpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvaW50cyA9IHNlcmllcy5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZC5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgIHJldHVybiBbIHguY2FsbChzdGFjaywgdiwgaSksIHkuY2FsbChzdGFjaywgdiwgaSkgXTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBvcmRlcnMgPSBvcmRlci5jYWxsKHN0YWNrLCBwb2ludHMsIGluZGV4KTtcbiAgICAgIHNlcmllcyA9IGQzLnBlcm11dGUoc2VyaWVzLCBvcmRlcnMpO1xuICAgICAgcG9pbnRzID0gZDMucGVybXV0ZShwb2ludHMsIG9yZGVycyk7XG4gICAgICB2YXIgb2Zmc2V0cyA9IG9mZnNldC5jYWxsKHN0YWNrLCBwb2ludHMsIGluZGV4KTtcbiAgICAgIHZhciBtID0gc2VyaWVzWzBdLmxlbmd0aCwgbiwgaSwgaiwgbztcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgb3V0LmNhbGwoc3RhY2ssIHNlcmllc1swXVtqXSwgbyA9IG9mZnNldHNbal0sIHBvaW50c1swXVtqXVsxXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBvdXQuY2FsbChzdGFjaywgc2VyaWVzW2ldW2pdLCBvICs9IHBvaW50c1tpIC0gMV1bal1bMV0sIHBvaW50c1tpXVtqXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBzdGFjay52YWx1ZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZXM7XG4gICAgICB2YWx1ZXMgPSB4O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sub3JkZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmRlcjtcbiAgICAgIG9yZGVyID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBkM19sYXlvdXRfc3RhY2tPcmRlcnMuZ2V0KHgpIHx8IGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdDtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLm9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9mZnNldDtcbiAgICAgIG9mZnNldCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogZDNfbGF5b3V0X3N0YWNrT2Zmc2V0cy5nZXQoeCkgfHwgZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybztcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLnggPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgICAgeCA9IHo7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay55ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICAgIHkgPSB6O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sub3V0ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0O1xuICAgICAgb3V0ID0gejtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrWChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tZKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja091dChkLCB5MCwgeSkge1xuICAgIGQueTAgPSB5MDtcbiAgICBkLnkgPSB5O1xuICB9XG4gIHZhciBkM19sYXlvdXRfc3RhY2tPcmRlcnMgPSBkMy5tYXAoe1xuICAgIFwiaW5zaWRlLW91dFwiOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCBpLCBqLCBtYXggPSBkYXRhLm1hcChkM19sYXlvdXRfc3RhY2tNYXhJbmRleCksIHN1bXMgPSBkYXRhLm1hcChkM19sYXlvdXRfc3RhY2tSZWR1Y2VTdW0pLCBpbmRleCA9IGQzLnJhbmdlKG4pLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gbWF4W2FdIC0gbWF4W2JdO1xuICAgICAgfSksIHRvcCA9IDAsIGJvdHRvbSA9IDAsIHRvcHMgPSBbXSwgYm90dG9tcyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBqID0gaW5kZXhbaV07XG4gICAgICAgIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgICAgICB0b3AgKz0gc3Vtc1tqXTtcbiAgICAgICAgICB0b3BzLnB1c2goaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm90dG9tICs9IHN1bXNbal07XG4gICAgICAgICAgYm90dG9tcy5wdXNoKGopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYm90dG9tcy5yZXZlcnNlKCkuY29uY2F0KHRvcHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKGRhdGEubGVuZ3RoKS5yZXZlcnNlKCk7XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogZDNfbGF5b3V0X3N0YWNrT3JkZXJEZWZhdWx0XG4gIH0pO1xuICB2YXIgZDNfbGF5b3V0X3N0YWNrT2Zmc2V0cyA9IGQzLm1hcCh7XG4gICAgc2lsaG91ZXR0ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgbSA9IGRhdGFbMF0ubGVuZ3RoLCBzdW1zID0gW10sIG1heCA9IDAsIGksIGosIG8sIHkwID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG8gPSAwOyBpIDwgbjsgaSsrKSBvICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGlmIChvID4gbWF4KSBtYXggPSBvO1xuICAgICAgICBzdW1zLnB1c2gobyk7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIHkwW2pdID0gKG1heCAtIHN1bXNbal0pIC8gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5MDtcbiAgICB9LFxuICAgIHdpZ2dsZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgeCA9IGRhdGFbMF0sIG0gPSB4Lmxlbmd0aCwgaSwgaiwgaywgczEsIHMyLCBzMywgZHgsIG8sIG8wLCB5MCA9IFtdO1xuICAgICAgeTBbMF0gPSBvID0gbzAgPSAwO1xuICAgICAgZm9yIChqID0gMTsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKGkgPSAwLCBzMSA9IDA7IGkgPCBuOyArK2kpIHMxICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGZvciAoaSA9IDAsIHMyID0gMCwgZHggPSB4W2pdWzBdIC0geFtqIC0gMV1bMF07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBmb3IgKGsgPSAwLCBzMyA9IChkYXRhW2ldW2pdWzFdIC0gZGF0YVtpXVtqIC0gMV1bMV0pIC8gKDIgKiBkeCk7IGsgPCBpOyArK2spIHtcbiAgICAgICAgICAgIHMzICs9IChkYXRhW2tdW2pdWzFdIC0gZGF0YVtrXVtqIC0gMV1bMV0pIC8gZHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMyICs9IHMzICogZGF0YVtpXVtqXVsxXTtcbiAgICAgICAgfVxuICAgICAgICB5MFtqXSA9IG8gLT0gczEgPyBzMiAvIHMxICogZHggOiAwO1xuICAgICAgICBpZiAobyA8IG8wKSBvMCA9IG87XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB5MFtqXSAtPSBvMDtcbiAgICAgIHJldHVybiB5MDtcbiAgICB9LFxuICAgIGV4cGFuZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgbSA9IGRhdGFbMF0ubGVuZ3RoLCBrID0gMSAvIG4sIGksIGosIG8sIHkwID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIG8gPSAwOyBpIDwgbjsgaSsrKSBvICs9IGRhdGFbaV1bal1bMV07XG4gICAgICAgIGlmIChvKSBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBkYXRhW2ldW2pdWzFdIC89IG87IGVsc2UgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZGF0YVtpXVtqXVsxXSA9IGs7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB5MFtqXSA9IDA7XG4gICAgICByZXR1cm4geTA7XG4gICAgfSxcbiAgICB6ZXJvOiBkM19sYXlvdXRfc3RhY2tPZmZzZXRaZXJvXG4gIH0pO1xuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tPcmRlckRlZmF1bHQoZGF0YSkge1xuICAgIHJldHVybiBkMy5yYW5nZShkYXRhLmxlbmd0aCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVybyhkYXRhKSB7XG4gICAgdmFyIGogPSAtMSwgbSA9IGRhdGFbMF0ubGVuZ3RoLCB5MCA9IFtdO1xuICAgIHdoaWxlICgrK2ogPCBtKSB5MFtqXSA9IDA7XG4gICAgcmV0dXJuIHkwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja01heEluZGV4KGFycmF5KSB7XG4gICAgdmFyIGkgPSAxLCBqID0gMCwgdiA9IGFycmF5WzBdWzFdLCBrLCBuID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAoO2kgPCBuOyArK2kpIHtcbiAgICAgIGlmICgoayA9IGFycmF5W2ldWzFdKSA+IHYpIHtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIHYgPSBrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gajtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tSZWR1Y2VTdW0oZCkge1xuICAgIHJldHVybiBkLnJlZHVjZShkM19sYXlvdXRfc3RhY2tTdW0sIDApO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja1N1bShwLCBkKSB7XG4gICAgcmV0dXJuIHAgKyBkWzFdO1xuICB9XG4gIGQzLmxheW91dC5oaXN0b2dyYW0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnJlcXVlbmN5ID0gdHJ1ZSwgdmFsdWVyID0gTnVtYmVyLCByYW5nZXIgPSBkM19sYXlvdXRfaGlzdG9ncmFtUmFuZ2UsIGJpbm5lciA9IGQzX2xheW91dF9oaXN0b2dyYW1CaW5TdHVyZ2VzO1xuICAgIGZ1bmN0aW9uIGhpc3RvZ3JhbShkYXRhLCBpKSB7XG4gICAgICB2YXIgYmlucyA9IFtdLCB2YWx1ZXMgPSBkYXRhLm1hcCh2YWx1ZXIsIHRoaXMpLCByYW5nZSA9IHJhbmdlci5jYWxsKHRoaXMsIHZhbHVlcywgaSksIHRocmVzaG9sZHMgPSBiaW5uZXIuY2FsbCh0aGlzLCByYW5nZSwgdmFsdWVzLCBpKSwgYmluLCBpID0gLTEsIG4gPSB2YWx1ZXMubGVuZ3RoLCBtID0gdGhyZXNob2xkcy5sZW5ndGggLSAxLCBrID0gZnJlcXVlbmN5ID8gMSA6IDEgLyBuLCB4O1xuICAgICAgd2hpbGUgKCsraSA8IG0pIHtcbiAgICAgICAgYmluID0gYmluc1tpXSA9IFtdO1xuICAgICAgICBiaW4uZHggPSB0aHJlc2hvbGRzW2kgKyAxXSAtIChiaW4ueCA9IHRocmVzaG9sZHNbaV0pO1xuICAgICAgICBiaW4ueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAobSA+IDApIHtcbiAgICAgICAgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIHggPSB2YWx1ZXNbaV07XG4gICAgICAgICAgaWYgKHggPj0gcmFuZ2VbMF0gJiYgeCA8PSByYW5nZVsxXSkge1xuICAgICAgICAgICAgYmluID0gYmluc1tkMy5iaXNlY3QodGhyZXNob2xkcywgeCwgMSwgbSkgLSAxXTtcbiAgICAgICAgICAgIGJpbi55ICs9IGs7XG4gICAgICAgICAgICBiaW4ucHVzaChkYXRhW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5zO1xuICAgIH1cbiAgICBoaXN0b2dyYW0udmFsdWUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZXI7XG4gICAgICB2YWx1ZXIgPSB4O1xuICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9O1xuICAgIGhpc3RvZ3JhbS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlcjtcbiAgICAgIHJhbmdlciA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgaGlzdG9ncmFtLmJpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiaW5uZXI7XG4gICAgICBiaW5uZXIgPSB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiA/IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBkM19sYXlvdXRfaGlzdG9ncmFtQmluRml4ZWQocmFuZ2UsIHgpO1xuICAgICAgfSA6IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgaGlzdG9ncmFtLmZyZXF1ZW5jeSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZyZXF1ZW5jeTtcbiAgICAgIGZyZXF1ZW5jeSA9ICEheDtcbiAgICAgIHJldHVybiBoaXN0b2dyYW07XG4gICAgfTtcbiAgICByZXR1cm4gaGlzdG9ncmFtO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfaGlzdG9ncmFtQmluU3R1cmdlcyhyYW5nZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaXN0b2dyYW1CaW5GaXhlZChyYW5nZSwgTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIgKyAxKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpbkZpeGVkKHJhbmdlLCBuKSB7XG4gICAgdmFyIHggPSAtMSwgYiA9ICtyYW5nZVswXSwgbSA9IChyYW5nZVsxXSAtIGIpIC8gbiwgZiA9IFtdO1xuICAgIHdoaWxlICgrK3ggPD0gbikgZlt4XSA9IG0gKiB4ICsgYjtcbiAgICByZXR1cm4gZjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGlzdG9ncmFtUmFuZ2UodmFsdWVzKSB7XG4gICAgcmV0dXJuIFsgZDMubWluKHZhbHVlcyksIGQzLm1heCh2YWx1ZXMpIF07XG4gIH1cbiAgZDMubGF5b3V0LnBhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLnNvcnQoZDNfbGF5b3V0X3BhY2tTb3J0KSwgcGFkZGluZyA9IDAsIHNpemUgPSBbIDEsIDEgXSwgcmFkaXVzO1xuICAgIGZ1bmN0aW9uIHBhY2soZCwgaSkge1xuICAgICAgdmFyIG5vZGVzID0gaGllcmFyY2h5LmNhbGwodGhpcywgZCwgaSksIHJvb3QgPSBub2Rlc1swXSwgdyA9IHNpemVbMF0sIGggPSBzaXplWzFdLCByID0gcmFkaXVzID09IG51bGwgPyBNYXRoLnNxcnQgOiB0eXBlb2YgcmFkaXVzID09PSBcImZ1bmN0aW9uXCIgPyByYWRpdXMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJhZGl1cztcbiAgICAgIH07XG4gICAgICByb290LnggPSByb290LnkgPSAwO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24oZCkge1xuICAgICAgICBkLnIgPSArcihkLnZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZDNfbGF5b3V0X3BhY2tTaWJsaW5ncyk7XG4gICAgICBpZiAocGFkZGluZykge1xuICAgICAgICB2YXIgZHIgPSBwYWRkaW5nICogKHJhZGl1cyA/IDEgOiBNYXRoLm1heCgyICogcm9vdC5yIC8gdywgMiAqIHJvb3QuciAvIGgpKSAvIDI7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBkLnIgKz0gZHI7XG4gICAgICAgIH0pO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBkM19sYXlvdXRfcGFja1NpYmxpbmdzKTtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGQuciAtPSBkcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkM19sYXlvdXRfcGFja1RyYW5zZm9ybShyb290LCB3IC8gMiwgaCAvIDIsIHJhZGl1cyA/IDEgOiAxIC8gTWF0aC5tYXgoMiAqIHJvb3QuciAvIHcsIDIgKiByb290LnIgLyBoKSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHBhY2suc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0gXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcGFjay5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYWRpdXM7XG4gICAgICByYWRpdXMgPSBfID09IG51bGwgfHwgdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiArXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcGFjay5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkZGluZztcbiAgICAgIHBhZGRpbmcgPSArXztcbiAgICAgIHJldHVybiBwYWNrO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQocGFjaywgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYS52YWx1ZSAtIGIudmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tJbnNlcnQoYSwgYikge1xuICAgIHZhciBjID0gYS5fcGFja19uZXh0O1xuICAgIGEuX3BhY2tfbmV4dCA9IGI7XG4gICAgYi5fcGFja19wcmV2ID0gYTtcbiAgICBiLl9wYWNrX25leHQgPSBjO1xuICAgIGMuX3BhY2tfcHJldiA9IGI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tTcGxpY2UoYSwgYikge1xuICAgIGEuX3BhY2tfbmV4dCA9IGI7XG4gICAgYi5fcGFja19wcmV2ID0gYTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoYSwgYikge1xuICAgIHZhciBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnksIGRyID0gYS5yICsgYi5yO1xuICAgIHJldHVybiAuOTk5ICogZHIgKiBkciA+IGR4ICogZHggKyBkeSAqIGR5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrU2libGluZ3Mobm9kZSkge1xuICAgIGlmICghKG5vZGVzID0gbm9kZS5jaGlsZHJlbikgfHwgIShuID0gbm9kZXMubGVuZ3RoKSkgcmV0dXJuO1xuICAgIHZhciBub2RlcywgeE1pbiA9IEluZmluaXR5LCB4TWF4ID0gLUluZmluaXR5LCB5TWluID0gSW5maW5pdHksIHlNYXggPSAtSW5maW5pdHksIGEsIGIsIGMsIGksIGosIGssIG47XG4gICAgZnVuY3Rpb24gYm91bmQobm9kZSkge1xuICAgICAgeE1pbiA9IE1hdGgubWluKG5vZGUueCAtIG5vZGUuciwgeE1pbik7XG4gICAgICB4TWF4ID0gTWF0aC5tYXgobm9kZS54ICsgbm9kZS5yLCB4TWF4KTtcbiAgICAgIHlNaW4gPSBNYXRoLm1pbihub2RlLnkgLSBub2RlLnIsIHlNaW4pO1xuICAgICAgeU1heCA9IE1hdGgubWF4KG5vZGUueSArIG5vZGUuciwgeU1heCk7XG4gICAgfVxuICAgIG5vZGVzLmZvckVhY2goZDNfbGF5b3V0X3BhY2tMaW5rKTtcbiAgICBhID0gbm9kZXNbMF07XG4gICAgYS54ID0gLWEucjtcbiAgICBhLnkgPSAwO1xuICAgIGJvdW5kKGEpO1xuICAgIGlmIChuID4gMSkge1xuICAgICAgYiA9IG5vZGVzWzFdO1xuICAgICAgYi54ID0gYi5yO1xuICAgICAgYi55ID0gMDtcbiAgICAgIGJvdW5kKGIpO1xuICAgICAgaWYgKG4gPiAyKSB7XG4gICAgICAgIGMgPSBub2Rlc1syXTtcbiAgICAgICAgZDNfbGF5b3V0X3BhY2tQbGFjZShhLCBiLCBjKTtcbiAgICAgICAgYm91bmQoYyk7XG4gICAgICAgIGQzX2xheW91dF9wYWNrSW5zZXJ0KGEsIGMpO1xuICAgICAgICBhLl9wYWNrX3ByZXYgPSBjO1xuICAgICAgICBkM19sYXlvdXRfcGFja0luc2VydChjLCBiKTtcbiAgICAgICAgYiA9IGEuX3BhY2tfbmV4dDtcbiAgICAgICAgZm9yIChpID0gMzsgaSA8IG47IGkrKykge1xuICAgICAgICAgIGQzX2xheW91dF9wYWNrUGxhY2UoYSwgYiwgYyA9IG5vZGVzW2ldKTtcbiAgICAgICAgICB2YXIgaXNlY3QgPSAwLCBzMSA9IDEsIHMyID0gMTtcbiAgICAgICAgICBmb3IgKGogPSBiLl9wYWNrX25leHQ7IGogIT09IGI7IGogPSBqLl9wYWNrX25leHQsIHMxKyspIHtcbiAgICAgICAgICAgIGlmIChkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoaiwgYykpIHtcbiAgICAgICAgICAgICAgaXNlY3QgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzZWN0ID09IDEpIHtcbiAgICAgICAgICAgIGZvciAoayA9IGEuX3BhY2tfcHJldjsgayAhPT0gai5fcGFja19wcmV2OyBrID0gay5fcGFja19wcmV2LCBzMisrKSB7XG4gICAgICAgICAgICAgIGlmIChkM19sYXlvdXRfcGFja0ludGVyc2VjdHMoaywgYykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNlY3QpIHtcbiAgICAgICAgICAgIGlmIChzMSA8IHMyIHx8IHMxID09IHMyICYmIGIuciA8IGEucikgZDNfbGF5b3V0X3BhY2tTcGxpY2UoYSwgYiA9IGopOyBlbHNlIGQzX2xheW91dF9wYWNrU3BsaWNlKGEgPSBrLCBiKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDNfbGF5b3V0X3BhY2tJbnNlcnQoYSwgYyk7XG4gICAgICAgICAgICBiID0gYztcbiAgICAgICAgICAgIGJvdW5kKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY3ggPSAoeE1pbiArIHhNYXgpIC8gMiwgY3kgPSAoeU1pbiArIHlNYXgpIC8gMiwgY3IgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGMgPSBub2Rlc1tpXTtcbiAgICAgIGMueCAtPSBjeDtcbiAgICAgIGMueSAtPSBjeTtcbiAgICAgIGNyID0gTWF0aC5tYXgoY3IsIGMuciArIE1hdGguc3FydChjLnggKiBjLnggKyBjLnkgKiBjLnkpKTtcbiAgICB9XG4gICAgbm9kZS5yID0gY3I7XG4gICAgbm9kZXMuZm9yRWFjaChkM19sYXlvdXRfcGFja1VubGluayk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tMaW5rKG5vZGUpIHtcbiAgICBub2RlLl9wYWNrX25leHQgPSBub2RlLl9wYWNrX3ByZXYgPSBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrVW5saW5rKG5vZGUpIHtcbiAgICBkZWxldGUgbm9kZS5fcGFja19uZXh0O1xuICAgIGRlbGV0ZSBub2RlLl9wYWNrX3ByZXY7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tUcmFuc2Zvcm0obm9kZSwgeCwgeSwgaykge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgbm9kZS54ID0geCArPSBrICogbm9kZS54O1xuICAgIG5vZGUueSA9IHkgKz0gayAqIG5vZGUueTtcbiAgICBub2RlLnIgKj0gaztcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfbGF5b3V0X3BhY2tUcmFuc2Zvcm0oY2hpbGRyZW5baV0sIHgsIHksIGspO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1BsYWNlKGEsIGIsIGMpIHtcbiAgICB2YXIgZGIgPSBhLnIgKyBjLnIsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgICBpZiAoZGIgJiYgKGR4IHx8IGR5KSkge1xuICAgICAgdmFyIGRhID0gYi5yICsgYy5yLCBkYyA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgZGEgKj0gZGE7XG4gICAgICBkYiAqPSBkYjtcbiAgICAgIHZhciB4ID0gLjUgKyAoZGIgLSBkYSkgLyAoMiAqIGRjKSwgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCAyICogZGEgKiAoZGIgKyBkYykgLSAoZGIgLT0gZGMpICogZGIgLSBkYSAqIGRhKSkgLyAoMiAqIGRjKTtcbiAgICAgIGMueCA9IGEueCArIHggKiBkeCArIHkgKiBkeTtcbiAgICAgIGMueSA9IGEueSArIHggKiBkeSAtIHkgKiBkeDtcbiAgICB9IGVsc2Uge1xuICAgICAgYy54ID0gYS54ICsgZGI7XG4gICAgICBjLnkgPSBhLnk7XG4gICAgfVxuICB9XG4gIGQzLmxheW91dC50cmVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKS5zb3J0KG51bGwpLnZhbHVlKG51bGwpLCBzZXBhcmF0aW9uID0gZDNfbGF5b3V0X3RyZWVTZXBhcmF0aW9uLCBzaXplID0gWyAxLCAxIF0sIG5vZGVTaXplID0gbnVsbDtcbiAgICBmdW5jdGlvbiB0cmVlKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpLCByb290MCA9IG5vZGVzWzBdLCByb290MSA9IHdyYXBUcmVlKHJvb3QwKTtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QxLCBmaXJzdFdhbGspLCByb290MS5wYXJlbnQubSA9IC1yb290MS56O1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QxLCBzZWNvbmRXYWxrKTtcbiAgICAgIGlmIChub2RlU2l6ZSkgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QwLCBzaXplTm9kZSk7IGVsc2Uge1xuICAgICAgICB2YXIgbGVmdCA9IHJvb3QwLCByaWdodCA9IHJvb3QwLCBib3R0b20gPSByb290MDtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QwLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUueCA8IGxlZnQueCkgbGVmdCA9IG5vZGU7XG4gICAgICAgICAgaWYgKG5vZGUueCA+IHJpZ2h0LngpIHJpZ2h0ID0gbm9kZTtcbiAgICAgICAgICBpZiAobm9kZS5kZXB0aCA+IGJvdHRvbS5kZXB0aCkgYm90dG9tID0gbm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0eCA9IHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMiAtIGxlZnQueCwga3ggPSBzaXplWzBdIC8gKHJpZ2h0LnggKyBzZXBhcmF0aW9uKHJpZ2h0LCBsZWZ0KSAvIDIgKyB0eCksIGt5ID0gc2l6ZVsxXSAvIChib3R0b20uZGVwdGggfHwgMSk7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290MCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIG5vZGUueCA9IChub2RlLnggKyB0eCkgKiBreDtcbiAgICAgICAgICBub2RlLnkgPSBub2RlLmRlcHRoICoga3k7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cmFwVHJlZShyb290MCkge1xuICAgICAgdmFyIHJvb3QxID0ge1xuICAgICAgICBBOiBudWxsLFxuICAgICAgICBjaGlsZHJlbjogWyByb290MCBdXG4gICAgICB9LCBxdWV1ZSA9IFsgcm9vdDEgXSwgbm9kZTE7XG4gICAgICB3aGlsZSAoKG5vZGUxID0gcXVldWUucG9wKCkpICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGRyZW4gPSBub2RlMS5jaGlsZHJlbiwgY2hpbGQsIGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgcXVldWUucHVzaCgoY2hpbGRyZW5baV0gPSBjaGlsZCA9IHtcbiAgICAgICAgICAgIF86IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgcGFyZW50OiBub2RlMSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAoY2hpbGQgPSBjaGlsZHJlbltpXS5jaGlsZHJlbikgJiYgY2hpbGQuc2xpY2UoKSB8fCBbXSxcbiAgICAgICAgICAgIEE6IG51bGwsXG4gICAgICAgICAgICBhOiBudWxsLFxuICAgICAgICAgICAgejogMCxcbiAgICAgICAgICAgIG06IDAsXG4gICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgIHQ6IG51bGwsXG4gICAgICAgICAgICBpOiBpXG4gICAgICAgICAgfSkuYSA9IGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvb3QxLmNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaXJzdFdhbGsodikge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbiwgc2libGluZ3MgPSB2LnBhcmVudC5jaGlsZHJlbiwgdyA9IHYuaSA/IHNpYmxpbmdzW3YuaSAtIDFdIDogbnVsbDtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgZDNfbGF5b3V0X3RyZWVTaGlmdCh2KTtcbiAgICAgICAgdmFyIG1pZHBvaW50ID0gKGNoaWxkcmVuWzBdLnogKyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS56KSAvIDI7XG4gICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICAgICAgdi5tID0gdi56IC0gbWlkcG9pbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdi56ID0gbWlkcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodykge1xuICAgICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICAgIH1cbiAgICAgIHYucGFyZW50LkEgPSBhcHBvcnRpb24odiwgdywgdi5wYXJlbnQuQSB8fCBzaWJsaW5nc1swXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlY29uZFdhbGsodikge1xuICAgICAgdi5fLnggPSB2LnogKyB2LnBhcmVudC5tO1xuICAgICAgdi5tICs9IHYucGFyZW50Lm07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcG9ydGlvbih2LCB3LCBhbmNlc3Rvcikge1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgdmFyIHZpcCA9IHYsIHZvcCA9IHYsIHZpbSA9IHcsIHZvbSA9IHZpcC5wYXJlbnQuY2hpbGRyZW5bMF0sIHNpcCA9IHZpcC5tLCBzb3AgPSB2b3AubSwgc2ltID0gdmltLm0sIHNvbSA9IHZvbS5tLCBzaGlmdDtcbiAgICAgICAgd2hpbGUgKHZpbSA9IGQzX2xheW91dF90cmVlUmlnaHQodmltKSwgdmlwID0gZDNfbGF5b3V0X3RyZWVMZWZ0KHZpcCksIHZpbSAmJiB2aXApIHtcbiAgICAgICAgICB2b20gPSBkM19sYXlvdXRfdHJlZUxlZnQodm9tKTtcbiAgICAgICAgICB2b3AgPSBkM19sYXlvdXRfdHJlZVJpZ2h0KHZvcCk7XG4gICAgICAgICAgdm9wLmEgPSB2O1xuICAgICAgICAgIHNoaWZ0ID0gdmltLnogKyBzaW0gLSB2aXAueiAtIHNpcCArIHNlcGFyYXRpb24odmltLl8sIHZpcC5fKTtcbiAgICAgICAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICAgICAgICBkM19sYXlvdXRfdHJlZU1vdmUoZDNfbGF5b3V0X3RyZWVBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICAgICAgc2lwICs9IHNoaWZ0O1xuICAgICAgICAgICAgc29wICs9IHNoaWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaW0gKz0gdmltLm07XG4gICAgICAgICAgc2lwICs9IHZpcC5tO1xuICAgICAgICAgIHNvbSArPSB2b20ubTtcbiAgICAgICAgICBzb3AgKz0gdm9wLm07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpbSAmJiAhZDNfbGF5b3V0X3RyZWVSaWdodCh2b3ApKSB7XG4gICAgICAgICAgdm9wLnQgPSB2aW07XG4gICAgICAgICAgdm9wLm0gKz0gc2ltIC0gc29wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXAgJiYgIWQzX2xheW91dF90cmVlTGVmdCh2b20pKSB7XG4gICAgICAgICAgdm9tLnQgPSB2aXA7XG4gICAgICAgICAgdm9tLm0gKz0gc2lwIC0gc29tO1xuICAgICAgICAgIGFuY2VzdG9yID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFuY2VzdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaXplTm9kZShub2RlKSB7XG4gICAgICBub2RlLnggKj0gc2l6ZVswXTtcbiAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBzaXplWzFdO1xuICAgIH1cbiAgICB0cmVlLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzZXBhcmF0aW9uO1xuICAgICAgc2VwYXJhdGlvbiA9IHg7XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9O1xuICAgIHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gbnVsbCA6IHNpemU7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgPT0gbnVsbCA/IHNpemVOb2RlIDogbnVsbDtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH07XG4gICAgdHJlZS5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gc2l6ZSA6IG51bGw7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgPT0gbnVsbCA/IG51bGwgOiBzaXplTm9kZTtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQodHJlZSwgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVTZXBhcmF0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wYXJlbnQgPT0gYi5wYXJlbnQgPyAxIDogMjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZUxlZnQodikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuWzBdIDogdi50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlUmlnaHQodikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sIG47XG4gICAgcmV0dXJuIChuID0gY2hpbGRyZW4ubGVuZ3RoKSA/IGNoaWxkcmVuW24gLSAxXSA6IHYudDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZU1vdmUod20sIHdwLCBzaGlmdCkge1xuICAgIHZhciBjaGFuZ2UgPSBzaGlmdCAvICh3cC5pIC0gd20uaSk7XG4gICAgd3AuYyAtPSBjaGFuZ2U7XG4gICAgd3AucyArPSBzaGlmdDtcbiAgICB3bS5jICs9IGNoYW5nZTtcbiAgICB3cC56ICs9IHNoaWZ0O1xuICAgIHdwLm0gKz0gc2hpZnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVTaGlmdCh2KSB7XG4gICAgdmFyIHNoaWZ0ID0gMCwgY2hhbmdlID0gMCwgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLCBpID0gY2hpbGRyZW4ubGVuZ3RoLCB3O1xuICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgdyA9IGNoaWxkcmVuW2ldO1xuICAgICAgdy56ICs9IHNoaWZ0O1xuICAgICAgdy5tICs9IHNoaWZ0O1xuICAgICAgc2hpZnQgKz0gdy5zICsgKGNoYW5nZSArPSB3LmMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZUFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpIHtcbiAgICByZXR1cm4gdmltLmEucGFyZW50ID09PSB2LnBhcmVudCA/IHZpbS5hIDogYW5jZXN0b3I7XG4gIH1cbiAgZDMubGF5b3V0LmNsdXN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLnNvcnQobnVsbCkudmFsdWUobnVsbCksIHNlcGFyYXRpb24gPSBkM19sYXlvdXRfdHJlZVNlcGFyYXRpb24sIHNpemUgPSBbIDEsIDEgXSwgbm9kZVNpemUgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjbHVzdGVyKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpLCByb290ID0gbm9kZXNbMF0sIHByZXZpb3VzTm9kZSwgeCA9IDA7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICBub2RlLnggPSBkM19sYXlvdXRfY2x1c3RlclgoY2hpbGRyZW4pO1xuICAgICAgICAgIG5vZGUueSA9IGQzX2xheW91dF9jbHVzdGVyWShjaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS54ID0gcHJldmlvdXNOb2RlID8geCArPSBzZXBhcmF0aW9uKG5vZGUsIHByZXZpb3VzTm9kZSkgOiAwO1xuICAgICAgICAgIG5vZGUueSA9IDA7XG4gICAgICAgICAgcHJldmlvdXNOb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgbGVmdCA9IGQzX2xheW91dF9jbHVzdGVyTGVmdChyb290KSwgcmlnaHQgPSBkM19sYXlvdXRfY2x1c3RlclJpZ2h0KHJvb3QpLCB4MCA9IGxlZnQueCAtIHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMiwgeDEgPSByaWdodC54ICsgc2VwYXJhdGlvbihyaWdodCwgbGVmdCkgLyAyO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgbm9kZVNpemUgPyBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUueCA9IChub2RlLnggLSByb290LngpICogc2l6ZVswXTtcbiAgICAgICAgbm9kZS55ID0gKHJvb3QueSAtIG5vZGUueSkgKiBzaXplWzFdO1xuICAgICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHgwKSAvICh4MSAtIHgwKSAqIHNpemVbMF07XG4gICAgICAgIG5vZGUueSA9ICgxIC0gKHJvb3QueSA/IG5vZGUueSAvIHJvb3QueSA6IDEpKSAqIHNpemVbMV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgY2x1c3Rlci5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2VwYXJhdGlvbjtcbiAgICAgIHNlcGFyYXRpb24gPSB4O1xuICAgICAgcmV0dXJuIGNsdXN0ZXI7XG4gICAgfTtcbiAgICBjbHVzdGVyLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IG51bGwgOiBzaXplO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpID09IG51bGw7XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9O1xuICAgIGNsdXN0ZXIubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IHNpemUgOiBudWxsO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpICE9IG51bGw7XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKGNsdXN0ZXIsIGhpZXJhcmNoeSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyWShjaGlsZHJlbikge1xuICAgIHJldHVybiAxICsgZDMubWF4KGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJYKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbih4LCBjaGlsZCkge1xuICAgICAgcmV0dXJuIHggKyBjaGlsZC54O1xuICAgIH0sIDApIC8gY2hpbGRyZW4ubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyTGVmdChub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID8gZDNfbGF5b3V0X2NsdXN0ZXJMZWZ0KGNoaWxkcmVuWzBdKSA6IG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJSaWdodChub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiwgbjtcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpID8gZDNfbGF5b3V0X2NsdXN0ZXJSaWdodChjaGlsZHJlbltuIC0gMV0pIDogbm9kZTtcbiAgfVxuICBkMy5sYXlvdXQudHJlZW1hcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCksIHJvdW5kID0gTWF0aC5yb3VuZCwgc2l6ZSA9IFsgMSwgMSBdLCBwYWRkaW5nID0gbnVsbCwgcGFkID0gZDNfbGF5b3V0X3RyZWVtYXBQYWROdWxsLCBzdGlja3kgPSBmYWxzZSwgc3RpY2tpZXMsIG1vZGUgPSBcInNxdWFyaWZ5XCIsIHJhdGlvID0gLjUgKiAoMSArIE1hdGguc3FydCg1KSk7XG4gICAgZnVuY3Rpb24gc2NhbGUoY2hpbGRyZW4sIGspIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBjaGlsZHJlbi5sZW5ndGgsIGNoaWxkLCBhcmVhO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYXJlYSA9IChjaGlsZCA9IGNoaWxkcmVuW2ldKS52YWx1ZSAqIChrIDwgMCA/IDAgOiBrKTtcbiAgICAgICAgY2hpbGQuYXJlYSA9IGlzTmFOKGFyZWEpIHx8IGFyZWEgPD0gMCA/IDAgOiBhcmVhO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzcXVhcmlmeShub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmVjdCA9IHBhZChub2RlKSwgcm93ID0gW10sIHJlbWFpbmluZyA9IGNoaWxkcmVuLnNsaWNlKCksIGNoaWxkLCBiZXN0ID0gSW5maW5pdHksIHNjb3JlLCB1ID0gbW9kZSA9PT0gXCJzbGljZVwiID8gcmVjdC5keCA6IG1vZGUgPT09IFwiZGljZVwiID8gcmVjdC5keSA6IG1vZGUgPT09IFwic2xpY2UtZGljZVwiID8gbm9kZS5kZXB0aCAmIDEgPyByZWN0LmR5IDogcmVjdC5keCA6IE1hdGgubWluKHJlY3QuZHgsIHJlY3QuZHkpLCBuO1xuICAgICAgICBzY2FsZShyZW1haW5pbmcsIHJlY3QuZHggKiByZWN0LmR5IC8gbm9kZS52YWx1ZSk7XG4gICAgICAgIHJvdy5hcmVhID0gMDtcbiAgICAgICAgd2hpbGUgKChuID0gcmVtYWluaW5nLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgcm93LnB1c2goY2hpbGQgPSByZW1haW5pbmdbbiAtIDFdKTtcbiAgICAgICAgICByb3cuYXJlYSArPSBjaGlsZC5hcmVhO1xuICAgICAgICAgIGlmIChtb2RlICE9PSBcInNxdWFyaWZ5XCIgfHwgKHNjb3JlID0gd29yc3Qocm93LCB1KSkgPD0gYmVzdCkge1xuICAgICAgICAgICAgcmVtYWluaW5nLnBvcCgpO1xuICAgICAgICAgICAgYmVzdCA9IHNjb3JlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb3cuYXJlYSAtPSByb3cucG9wKCkuYXJlYTtcbiAgICAgICAgICAgIHBvc2l0aW9uKHJvdywgdSwgcmVjdCwgZmFsc2UpO1xuICAgICAgICAgICAgdSA9IE1hdGgubWluKHJlY3QuZHgsIHJlY3QuZHkpO1xuICAgICAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgICAgIGJlc3QgPSBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdy5sZW5ndGgpIHtcbiAgICAgICAgICBwb3NpdGlvbihyb3csIHUsIHJlY3QsIHRydWUpO1xuICAgICAgICAgIHJvdy5sZW5ndGggPSByb3cuYXJlYSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChzcXVhcmlmeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0aWNraWZ5KG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWN0ID0gcGFkKG5vZGUpLCByZW1haW5pbmcgPSBjaGlsZHJlbi5zbGljZSgpLCBjaGlsZCwgcm93ID0gW107XG4gICAgICAgIHNjYWxlKHJlbWFpbmluZywgcmVjdC5keCAqIHJlY3QuZHkgLyBub2RlLnZhbHVlKTtcbiAgICAgICAgcm93LmFyZWEgPSAwO1xuICAgICAgICB3aGlsZSAoY2hpbGQgPSByZW1haW5pbmcucG9wKCkpIHtcbiAgICAgICAgICByb3cucHVzaChjaGlsZCk7XG4gICAgICAgICAgcm93LmFyZWEgKz0gY2hpbGQuYXJlYTtcbiAgICAgICAgICBpZiAoY2hpbGQueiAhPSBudWxsKSB7XG4gICAgICAgICAgICBwb3NpdGlvbihyb3csIGNoaWxkLnogPyByZWN0LmR4IDogcmVjdC5keSwgcmVjdCwgIXJlbWFpbmluZy5sZW5ndGgpO1xuICAgICAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChzdGlja2lmeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdvcnN0KHJvdywgdSkge1xuICAgICAgdmFyIHMgPSByb3cuYXJlYSwgciwgcm1heCA9IDAsIHJtaW4gPSBJbmZpbml0eSwgaSA9IC0xLCBuID0gcm93Lmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmICghKHIgPSByb3dbaV0uYXJlYSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAociA8IHJtaW4pIHJtaW4gPSByO1xuICAgICAgICBpZiAociA+IHJtYXgpIHJtYXggPSByO1xuICAgICAgfVxuICAgICAgcyAqPSBzO1xuICAgICAgdSAqPSB1O1xuICAgICAgcmV0dXJuIHMgPyBNYXRoLm1heCh1ICogcm1heCAqIHJhdGlvIC8gcywgcyAvICh1ICogcm1pbiAqIHJhdGlvKSkgOiBJbmZpbml0eTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9zaXRpb24ocm93LCB1LCByZWN0LCBmbHVzaCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHJvdy5sZW5ndGgsIHggPSByZWN0LngsIHkgPSByZWN0LnksIHYgPSB1ID8gcm91bmQocm93LmFyZWEgLyB1KSA6IDAsIG87XG4gICAgICBpZiAodSA9PSByZWN0LmR4KSB7XG4gICAgICAgIGlmIChmbHVzaCB8fCB2ID4gcmVjdC5keSkgdiA9IHJlY3QuZHk7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgbyA9IHJvd1tpXTtcbiAgICAgICAgICBvLnggPSB4O1xuICAgICAgICAgIG8ueSA9IHk7XG4gICAgICAgICAgby5keSA9IHY7XG4gICAgICAgICAgeCArPSBvLmR4ID0gTWF0aC5taW4ocmVjdC54ICsgcmVjdC5keCAtIHgsIHYgPyByb3VuZChvLmFyZWEgLyB2KSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIG8ueiA9IHRydWU7XG4gICAgICAgIG8uZHggKz0gcmVjdC54ICsgcmVjdC5keCAtIHg7XG4gICAgICAgIHJlY3QueSArPSB2O1xuICAgICAgICByZWN0LmR5IC09IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmx1c2ggfHwgdiA+IHJlY3QuZHgpIHYgPSByZWN0LmR4O1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIG8gPSByb3dbaV07XG4gICAgICAgICAgby54ID0geDtcbiAgICAgICAgICBvLnkgPSB5O1xuICAgICAgICAgIG8uZHggPSB2O1xuICAgICAgICAgIHkgKz0gby5keSA9IE1hdGgubWluKHJlY3QueSArIHJlY3QuZHkgLSB5LCB2ID8gcm91bmQoby5hcmVhIC8gdikgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBvLnogPSBmYWxzZTtcbiAgICAgICAgby5keSArPSByZWN0LnkgKyByZWN0LmR5IC0geTtcbiAgICAgICAgcmVjdC54ICs9IHY7XG4gICAgICAgIHJlY3QuZHggLT0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJlZW1hcChkKSB7XG4gICAgICB2YXIgbm9kZXMgPSBzdGlja2llcyB8fCBoaWVyYXJjaHkoZCksIHJvb3QgPSBub2Rlc1swXTtcbiAgICAgIHJvb3QueCA9IDA7XG4gICAgICByb290LnkgPSAwO1xuICAgICAgcm9vdC5keCA9IHNpemVbMF07XG4gICAgICByb290LmR5ID0gc2l6ZVsxXTtcbiAgICAgIGlmIChzdGlja2llcykgaGllcmFyY2h5LnJldmFsdWUocm9vdCk7XG4gICAgICBzY2FsZShbIHJvb3QgXSwgcm9vdC5keCAqIHJvb3QuZHkgLyByb290LnZhbHVlKTtcbiAgICAgIChzdGlja2llcyA/IHN0aWNraWZ5IDogc3F1YXJpZnkpKHJvb3QpO1xuICAgICAgaWYgKHN0aWNreSkgc3RpY2tpZXMgPSBub2RlcztcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdHJlZW1hcC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSB4O1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRkaW5nO1xuICAgICAgZnVuY3Rpb24gcGFkRnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcCA9IHguY2FsbCh0cmVlbWFwLCBub2RlLCBub2RlLmRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHAgPT0gbnVsbCA/IGQzX2xheW91dF90cmVlbWFwUGFkTnVsbChub2RlKSA6IGQzX2xheW91dF90cmVlbWFwUGFkKG5vZGUsIHR5cGVvZiBwID09PSBcIm51bWJlclwiID8gWyBwLCBwLCBwLCBwIF0gOiBwKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhZENvbnN0YW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGQzX2xheW91dF90cmVlbWFwUGFkKG5vZGUsIHgpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGU7XG4gICAgICBwYWQgPSAocGFkZGluZyA9IHgpID09IG51bGwgPyBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwgOiAodHlwZSA9IHR5cGVvZiB4KSA9PT0gXCJmdW5jdGlvblwiID8gcGFkRnVuY3Rpb24gOiB0eXBlID09PSBcIm51bWJlclwiID8gKHggPSBbIHgsIHgsIHgsIHggXSwgXG4gICAgICBwYWRDb25zdGFudCkgOiBwYWRDb25zdGFudDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJvdW5kICE9IE51bWJlcjtcbiAgICAgIHJvdW5kID0geCA/IE1hdGgucm91bmQgOiBOdW1iZXI7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAuc3RpY2t5ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RpY2t5O1xuICAgICAgc3RpY2t5ID0geDtcbiAgICAgIHN0aWNraWVzID0gbnVsbDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5yYXRpbyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhdGlvO1xuICAgICAgcmF0aW8gPSB4O1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLm1vZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtb2RlO1xuICAgICAgbW9kZSA9IHggKyBcIlwiO1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZCh0cmVlbWFwLCBoaWVyYXJjaHkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwobm9kZSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBub2RlLngsXG4gICAgICB5OiBub2RlLnksXG4gICAgICBkeDogbm9kZS5keCxcbiAgICAgIGR5OiBub2RlLmR5XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZW1hcFBhZChub2RlLCBwYWRkaW5nKSB7XG4gICAgdmFyIHggPSBub2RlLnggKyBwYWRkaW5nWzNdLCB5ID0gbm9kZS55ICsgcGFkZGluZ1swXSwgZHggPSBub2RlLmR4IC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sIGR5ID0gbm9kZS5keSAtIHBhZGRpbmdbMF0gLSBwYWRkaW5nWzJdO1xuICAgIGlmIChkeCA8IDApIHtcbiAgICAgIHggKz0gZHggLyAyO1xuICAgICAgZHggPSAwO1xuICAgIH1cbiAgICBpZiAoZHkgPCAwKSB7XG4gICAgICB5ICs9IGR5IC8gMjtcbiAgICAgIGR5ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgZHg6IGR4LFxuICAgICAgZHk6IGR5XG4gICAgfTtcbiAgfVxuICBkMy5yYW5kb20gPSB7XG4gICAgbm9ybWFsOiBmdW5jdGlvbijCtSwgz4MpIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChuIDwgMikgz4MgPSAxO1xuICAgICAgaWYgKG4gPCAxKSDCtSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4LCB5LCByO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgeCA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgICAgICB5ID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgICAgICAgIHIgPSB4ICogeCArIHkgKiB5O1xuICAgICAgICB9IHdoaWxlICghciB8fCByID4gMSk7XG4gICAgICAgIHJldHVybiDCtSArIM+DICogeCAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgbG9nTm9ybWFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYW5kb20gPSBkMy5yYW5kb20ubm9ybWFsLmFwcGx5KGQzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5leHAocmFuZG9tKCkpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGJhdGVzOiBmdW5jdGlvbihtKSB7XG4gICAgICB2YXIgcmFuZG9tID0gZDMucmFuZG9tLmlyd2luSGFsbChtKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRvbSgpIC8gbTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBpcndpbkhhbGw6IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGogPSAwOyBqIDwgbTsgaisrKSBzICs9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGQzLnNjYWxlID0ge307XG4gIGZ1bmN0aW9uIGQzX3NjYWxlRXh0ZW50KGRvbWFpbikge1xuICAgIHZhciBzdGFydCA9IGRvbWFpblswXSwgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHN0YXJ0IDwgc3RvcCA/IFsgc3RhcnQsIHN0b3AgXSA6IFsgc3RvcCwgc3RhcnQgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZVJhbmdlKHNjYWxlKSB7XG4gICAgcmV0dXJuIHNjYWxlLnJhbmdlRXh0ZW50ID8gc2NhbGUucmFuZ2VFeHRlbnQoKSA6IGQzX3NjYWxlRXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2JpbGluZWFyKGRvbWFpbiwgcmFuZ2UsIHVuaW50ZXJwb2xhdGUsIGludGVycG9sYXRlKSB7XG4gICAgdmFyIHUgPSB1bmludGVycG9sYXRlKGRvbWFpblswXSwgZG9tYWluWzFdKSwgaSA9IGludGVycG9sYXRlKHJhbmdlWzBdLCByYW5nZVsxXSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBpKHUoeCkpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbmljZShkb21haW4sIG5pY2UpIHtcbiAgICB2YXIgaTAgPSAwLCBpMSA9IGRvbWFpbi5sZW5ndGggLSAxLCB4MCA9IGRvbWFpbltpMF0sIHgxID0gZG9tYWluW2kxXSwgZHg7XG4gICAgaWYgKHgxIDwgeDApIHtcbiAgICAgIGR4ID0gaTAsIGkwID0gaTEsIGkxID0gZHg7XG4gICAgICBkeCA9IHgwLCB4MCA9IHgxLCB4MSA9IGR4O1xuICAgIH1cbiAgICBkb21haW5baTBdID0gbmljZS5mbG9vcih4MCk7XG4gICAgZG9tYWluW2kxXSA9IG5pY2UuY2VpbCh4MSk7XG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9uaWNlU3RlcChzdGVwKSB7XG4gICAgcmV0dXJuIHN0ZXAgPyB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih4IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh4IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgfVxuICAgIH0gOiBkM19zY2FsZV9uaWNlSWRlbnRpdHk7XG4gIH1cbiAgdmFyIGQzX3NjYWxlX25pY2VJZGVudGl0eSA9IHtcbiAgICBmbG9vcjogZDNfaWRlbnRpdHksXG4gICAgY2VpbDogZDNfaWRlbnRpdHlcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcG9seWxpbmVhcihkb21haW4sIHJhbmdlLCB1bmludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSkge1xuICAgIHZhciB1ID0gW10sIGkgPSBbXSwgaiA9IDAsIGsgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMTtcbiAgICBpZiAoZG9tYWluW2tdIDwgZG9tYWluWzBdKSB7XG4gICAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB3aGlsZSAoKytqIDw9IGspIHtcbiAgICAgIHUucHVzaCh1bmludGVycG9sYXRlKGRvbWFpbltqIC0gMV0sIGRvbWFpbltqXSkpO1xuICAgICAgaS5wdXNoKGludGVycG9sYXRlKHJhbmdlW2ogLSAxXSwgcmFuZ2Vbal0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBqID0gZDMuYmlzZWN0KGRvbWFpbiwgeCwgMSwgaykgLSAxO1xuICAgICAgcmV0dXJuIGlbal0odVtqXSh4KSk7XG4gICAgfTtcbiAgfVxuICBkMy5zY2FsZS5saW5lYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyKFsgMCwgMSBdLCBbIDAsIDEgXSwgZDNfaW50ZXJwb2xhdGUsIGZhbHNlKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlLCBjbGFtcCkge1xuICAgIHZhciBvdXRwdXQsIGlucHV0O1xuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICB2YXIgbGluZWFyID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSA+IDIgPyBkM19zY2FsZV9wb2x5bGluZWFyIDogZDNfc2NhbGVfYmlsaW5lYXIsIHVuaW50ZXJwb2xhdGUgPSBjbGFtcCA/IGQzX3VuaW50ZXJwb2xhdGVDbGFtcCA6IGQzX3VuaW50ZXJwb2xhdGVOdW1iZXI7XG4gICAgICBvdXRwdXQgPSBsaW5lYXIoZG9tYWluLCByYW5nZSwgdW5pbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUpO1xuICAgICAgaW5wdXQgPSBsaW5lYXIocmFuZ2UsIGRvbWFpbiwgdW5pbnRlcnBvbGF0ZSwgZDNfaW50ZXJwb2xhdGUpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gb3V0cHV0KHgpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gaW5wdXQoeSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSB4Lm1hcChOdW1iZXIpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBzY2FsZS5yYW5nZSh4KS5pbnRlcnBvbGF0ZShkM19pbnRlcnBvbGF0ZVJvdW5kKTtcbiAgICB9O1xuICAgIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xhbXA7XG4gICAgICBjbGFtcCA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgICAgIGludGVycG9sYXRlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG0sIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpO1xuICAgIH07XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIGQzX3NjYWxlX2xpbmVhck5pY2UoZG9tYWluLCBtKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlLCBjbGFtcCk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKSB7XG4gICAgcmV0dXJuIGQzLnJlYmluZChzY2FsZSwgbGluZWFyLCBcInJhbmdlXCIsIFwicmFuZ2VSb3VuZFwiLCBcImludGVycG9sYXRlXCIsIFwiY2xhbXBcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyTmljZShkb21haW4sIG0pIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfbmljZShkb21haW4sIGQzX3NjYWxlX25pY2VTdGVwKGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pWzJdKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSkge1xuICAgIGlmIChtID09IG51bGwpIG0gPSAxMDtcbiAgICB2YXIgZXh0ZW50ID0gZDNfc2NhbGVFeHRlbnQoZG9tYWluKSwgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXSwgc3RlcCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHNwYW4gLyBtKSAvIE1hdGguTE4xMCkpLCBlcnIgPSBtIC8gc3BhbiAqIHN0ZXA7XG4gICAgaWYgKGVyciA8PSAuMTUpIHN0ZXAgKj0gMTA7IGVsc2UgaWYgKGVyciA8PSAuMzUpIHN0ZXAgKj0gNTsgZWxzZSBpZiAoZXJyIDw9IC43NSkgc3RlcCAqPSAyO1xuICAgIGV4dGVudFswXSA9IE1hdGguY2VpbChleHRlbnRbMF0gLyBzdGVwKSAqIHN0ZXA7XG4gICAgZXh0ZW50WzFdID0gTWF0aC5mbG9vcihleHRlbnRbMV0gLyBzdGVwKSAqIHN0ZXAgKyBzdGVwICogLjU7XG4gICAgZXh0ZW50WzJdID0gc3RlcDtcbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclRpY2tzKGRvbWFpbiwgbSkge1xuICAgIHJldHVybiBkMy5yYW5nZS5hcHBseShkMywgZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpIHtcbiAgICB2YXIgcmFuZ2UgPSBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKTtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSBkM19mb3JtYXRfcmUuZXhlYyhmb3JtYXQpO1xuICAgICAgbWF0Y2guc2hpZnQoKTtcbiAgICAgIGlmIChtYXRjaFs4XSA9PT0gXCJzXCIpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IGQzLmZvcm1hdFByZWZpeChNYXRoLm1heChhYnMocmFuZ2VbMF0pLCBhYnMocmFuZ2VbMV0pKSk7XG4gICAgICAgIGlmICghbWF0Y2hbN10pIG1hdGNoWzddID0gXCIuXCIgKyBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24ocHJlZml4LnNjYWxlKHJhbmdlWzJdKSk7XG4gICAgICAgIG1hdGNoWzhdID0gXCJmXCI7XG4gICAgICAgIGZvcm1hdCA9IGQzLmZvcm1hdChtYXRjaC5qb2luKFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gZm9ybWF0KHByZWZpeC5zY2FsZShkKSkgKyBwcmVmaXguc3ltYm9sO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCFtYXRjaFs3XSkgbWF0Y2hbN10gPSBcIi5cIiArIGQzX3NjYWxlX2xpbmVhckZvcm1hdFByZWNpc2lvbihtYXRjaFs4XSwgcmFuZ2UpO1xuICAgICAgZm9ybWF0ID0gbWF0Y2guam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0ID0gXCIsLlwiICsgZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHJhbmdlWzJdKSArIFwiZlwiO1xuICAgIH1cbiAgICByZXR1cm4gZDMuZm9ybWF0KGZvcm1hdCk7XG4gIH1cbiAgdmFyIGQzX3NjYWxlX2xpbmVhckZvcm1hdFNpZ25pZmljYW50ID0ge1xuICAgIHM6IDEsXG4gICAgZzogMSxcbiAgICBwOiAxLFxuICAgIHI6IDEsXG4gICAgZTogMVxuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24odmFsdWUpIHtcbiAgICByZXR1cm4gLU1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjEwICsgLjAxKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJGb3JtYXRQcmVjaXNpb24odHlwZSwgcmFuZ2UpIHtcbiAgICB2YXIgcCA9IGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihyYW5nZVsyXSk7XG4gICAgcmV0dXJuIHR5cGUgaW4gZDNfc2NhbGVfbGluZWFyRm9ybWF0U2lnbmlmaWNhbnQgPyBNYXRoLmFicyhwIC0gZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKE1hdGgubWF4KGFicyhyYW5nZVswXSksIGFicyhyYW5nZVsxXSkpKSkgKyArKHR5cGUgIT09IFwiZVwiKSA6IHAgLSAodHlwZSA9PT0gXCIlXCIpICogMjtcbiAgfVxuICBkMy5zY2FsZS5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfbG9nKGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihbIDAsIDEgXSksIDEwLCB0cnVlLCBbIDEsIDEwIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9sb2cobGluZWFyLCBiYXNlLCBwb3NpdGl2ZSwgZG9tYWluKSB7XG4gICAgZnVuY3Rpb24gbG9nKHgpIHtcbiAgICAgIHJldHVybiAocG9zaXRpdmUgPyBNYXRoLmxvZyh4IDwgMCA/IDAgOiB4KSA6IC1NYXRoLmxvZyh4ID4gMCA/IDAgOiAteCkpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvdyh4KSB7XG4gICAgICByZXR1cm4gcG9zaXRpdmUgPyBNYXRoLnBvdyhiYXNlLCB4KSA6IC1NYXRoLnBvdyhiYXNlLCAteCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiBsaW5lYXIobG9nKHgpKTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHBvdyhsaW5lYXIuaW52ZXJ0KHgpKTtcbiAgICB9O1xuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIHBvc2l0aXZlID0geFswXSA+PSAwO1xuICAgICAgbGluZWFyLmRvbWFpbigoZG9tYWluID0geC5tYXAoTnVtYmVyKSkubWFwKGxvZykpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJhc2U7XG4gICAgICBiYXNlID0gK187XG4gICAgICBsaW5lYXIuZG9tYWluKGRvbWFpbi5tYXAobG9nKSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmljZWQgPSBkM19zY2FsZV9uaWNlKGRvbWFpbi5tYXAobG9nKSwgcG9zaXRpdmUgPyBNYXRoIDogZDNfc2NhbGVfbG9nTmljZU5lZ2F0aXZlKTtcbiAgICAgIGxpbmVhci5kb21haW4obmljZWQpO1xuICAgICAgZG9tYWluID0gbmljZWQubWFwKHBvdyk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KGRvbWFpbiksIHRpY2tzID0gW10sIHUgPSBleHRlbnRbMF0sIHYgPSBleHRlbnRbMV0sIGkgPSBNYXRoLmZsb29yKGxvZyh1KSksIGogPSBNYXRoLmNlaWwobG9nKHYpKSwgbiA9IGJhc2UgJSAxID8gMiA6IGJhc2U7XG4gICAgICBpZiAoaXNGaW5pdGUoaiAtIGkpKSB7XG4gICAgICAgIGlmIChwb3NpdGl2ZSkge1xuICAgICAgICAgIGZvciAoO2kgPCBqOyBpKyspIGZvciAodmFyIGsgPSAxOyBrIDwgbjsgaysrKSB0aWNrcy5wdXNoKHBvdyhpKSAqIGspO1xuICAgICAgICAgIHRpY2tzLnB1c2gocG93KGkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWNrcy5wdXNoKHBvdyhpKSk7XG4gICAgICAgICAgZm9yICg7aSsrIDwgajsgKSBmb3IgKHZhciBrID0gbiAtIDE7IGsgPiAwOyBrLS0pIHRpY2tzLnB1c2gocG93KGkpICogayk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgdGlja3NbaV0gPCB1OyBpKyspIHt9XG4gICAgICAgIGZvciAoaiA9IHRpY2tzLmxlbmd0aDsgdGlja3NbaiAtIDFdID4gdjsgai0tKSB7fVxuICAgICAgICB0aWNrcyA9IHRpY2tzLnNsaWNlKGksIGopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG4sIGZvcm1hdCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZDNfc2NhbGVfbG9nRm9ybWF0O1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBmb3JtYXQgPSBkM19zY2FsZV9sb2dGb3JtYXQ7IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT09IFwiZnVuY3Rpb25cIikgZm9ybWF0ID0gZDMuZm9ybWF0KGZvcm1hdCk7XG4gICAgICB2YXIgayA9IE1hdGgubWF4KC4xLCBuIC8gc2NhbGUudGlja3MoKS5sZW5ndGgpLCBmID0gcG9zaXRpdmUgPyAoZSA9IDFlLTEyLCBNYXRoLmNlaWwpIDogKGUgPSAtMWUtMTIsIFxuICAgICAgTWF0aC5mbG9vciksIGU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCAvIHBvdyhmKGxvZyhkKSArIGUpKSA8PSBrID8gZm9ybWF0KGQpIDogXCJcIjtcbiAgICAgIH07XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbG9nKGxpbmVhci5jb3B5KCksIGJhc2UsIHBvc2l0aXZlLCBkb21haW4pO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKTtcbiAgfVxuICB2YXIgZDNfc2NhbGVfbG9nRm9ybWF0ID0gZDMuZm9ybWF0KFwiLjBlXCIpLCBkM19zY2FsZV9sb2dOaWNlTmVnYXRpdmUgPSB7XG4gICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAtTWF0aC5jZWlsKC14KTtcbiAgICB9LFxuICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAtTWF0aC5mbG9vcigteCk7XG4gICAgfVxuICB9O1xuICBkMy5zY2FsZS5wb3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfcG93KGQzLnNjYWxlLmxpbmVhcigpLCAxLCBbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3BvdyhsaW5lYXIsIGV4cG9uZW50LCBkb21haW4pIHtcbiAgICB2YXIgcG93cCA9IGQzX3NjYWxlX3Bvd1BvdyhleHBvbmVudCksIHBvd2IgPSBkM19zY2FsZV9wb3dQb3coMSAvIGV4cG9uZW50KTtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gbGluZWFyKHBvd3AoeCkpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gcG93YihsaW5lYXIuaW52ZXJ0KHgpKTtcbiAgICB9O1xuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGxpbmVhci5kb21haW4oKGRvbWFpbiA9IHgubWFwKE51bWJlcikpLm1hcChwb3dwKSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG0sIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpO1xuICAgIH07XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBzY2FsZS5kb21haW4oZDNfc2NhbGVfbGluZWFyTmljZShkb21haW4sIG0pKTtcbiAgICB9O1xuICAgIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZXhwb25lbnQ7XG4gICAgICBwb3dwID0gZDNfc2NhbGVfcG93UG93KGV4cG9uZW50ID0geCk7XG4gICAgICBwb3diID0gZDNfc2NhbGVfcG93UG93KDEgLyBleHBvbmVudCk7XG4gICAgICBsaW5lYXIuZG9tYWluKGRvbWFpbi5tYXAocG93cCkpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3BvdyhsaW5lYXIuY29weSgpLCBleHBvbmVudCwgZG9tYWluKTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfcG93UG93KGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggPCAwID8gLU1hdGgucG93KC14LCBlKSA6IE1hdGgucG93KHgsIGUpO1xuICAgIH07XG4gIH1cbiAgZDMuc2NhbGUuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5wb3coKS5leHBvbmVudCguNSk7XG4gIH07XG4gIGQzLnNjYWxlLm9yZGluYWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfb3JkaW5hbChbXSwge1xuICAgICAgdDogXCJyYW5nZVwiLFxuICAgICAgYTogWyBbXSBdXG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX29yZGluYWwoZG9tYWluLCByYW5nZXIpIHtcbiAgICB2YXIgaW5kZXgsIHJhbmdlLCByYW5nZUJhbmQ7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIHJhbmdlWygoaW5kZXguZ2V0KHgpIHx8IChyYW5nZXIudCA9PT0gXCJyYW5nZVwiID8gaW5kZXguc2V0KHgsIGRvbWFpbi5wdXNoKHgpKSA6IE5hTikpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwcyhzdGFydCwgc3RlcCkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKGRvbWFpbi5sZW5ndGgpLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ZXAgKiBpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IFtdO1xuICAgICAgaW5kZXggPSBuZXcgZDNfTWFwKCk7XG4gICAgICB2YXIgaSA9IC0xLCBuID0geC5sZW5ndGgsIHhpO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghaW5kZXguaGFzKHhpID0geFtpXSkpIGluZGV4LnNldCh4aSwgZG9tYWluLnB1c2goeGkpKTtcbiAgICAgIHJldHVybiBzY2FsZVtyYW5nZXIudF0uYXBwbHkoc2NhbGUsIHJhbmdlci5hKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByYW5nZUJhbmQgPSAwO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUG9pbnRzID0gZnVuY3Rpb24oeCwgcGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIHZhciBzdGFydCA9IHhbMF0sIHN0b3AgPSB4WzFdLCBzdGVwID0gZG9tYWluLmxlbmd0aCA8IDIgPyAoc3RhcnQgPSAoc3RhcnQgKyBzdG9wKSAvIDIsIFxuICAgICAgMCkgOiAoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gMSArIHBhZGRpbmcpO1xuICAgICAgcmFuZ2UgPSBzdGVwcyhzdGFydCArIHN0ZXAgKiBwYWRkaW5nIC8gMiwgc3RlcCk7XG4gICAgICByYW5nZUJhbmQgPSAwO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlUG9pbnRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUm91bmRQb2ludHMgPSBmdW5jdGlvbih4LCBwYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgdmFyIHN0YXJ0ID0geFswXSwgc3RvcCA9IHhbMV0sIHN0ZXAgPSBkb21haW4ubGVuZ3RoIDwgMiA/IChzdGFydCA9IHN0b3AgPSBNYXRoLnJvdW5kKChzdGFydCArIHN0b3ApIC8gMiksIFxuICAgICAgMCkgOiAoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gMSArIHBhZGRpbmcpIHwgMDtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBNYXRoLnJvdW5kKHN0ZXAgKiBwYWRkaW5nIC8gMiArIChzdG9wIC0gc3RhcnQgLSAoZG9tYWluLmxlbmd0aCAtIDEgKyBwYWRkaW5nKSAqIHN0ZXApIC8gMiksIHN0ZXApO1xuICAgICAgcmFuZ2VCYW5kID0gMDtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVJvdW5kUG9pbnRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlQmFuZHMgPSBmdW5jdGlvbih4LCBwYWRkaW5nLCBvdXRlclBhZGRpbmcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcGFkZGluZyA9IDA7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIG91dGVyUGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICB2YXIgcmV2ZXJzZSA9IHhbMV0gPCB4WzBdLCBzdGFydCA9IHhbcmV2ZXJzZSAtIDBdLCBzdG9wID0geFsxIC0gcmV2ZXJzZV0sIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gcGFkZGluZyArIDIgKiBvdXRlclBhZGRpbmcpO1xuICAgICAgcmFuZ2UgPSBzdGVwcyhzdGFydCArIHN0ZXAgKiBvdXRlclBhZGRpbmcsIHN0ZXApO1xuICAgICAgaWYgKHJldmVyc2UpIHJhbmdlLnJldmVyc2UoKTtcbiAgICAgIHJhbmdlQmFuZCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmcpO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlQmFuZHNcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VSb3VuZEJhbmRzID0gZnVuY3Rpb24oeCwgcGFkZGluZywgb3V0ZXJQYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBvdXRlclBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgdmFyIHJldmVyc2UgPSB4WzFdIDwgeFswXSwgc3RhcnQgPSB4W3JldmVyc2UgLSAwXSwgc3RvcCA9IHhbMSAtIHJldmVyc2VdLCBzdGVwID0gTWF0aC5mbG9vcigoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gcGFkZGluZyArIDIgKiBvdXRlclBhZGRpbmcpKTtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBNYXRoLnJvdW5kKChzdG9wIC0gc3RhcnQgLSAoZG9tYWluLmxlbmd0aCAtIHBhZGRpbmcpICogc3RlcCkgLyAyKSwgc3RlcCk7XG4gICAgICBpZiAocmV2ZXJzZSkgcmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgcmFuZ2VCYW5kID0gTWF0aC5yb3VuZChzdGVwICogKDEgLSBwYWRkaW5nKSk7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VSb3VuZEJhbmRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlQmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmdlQmFuZDtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlRXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVFeHRlbnQocmFuZ2VyLmFbMF0pO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX29yZGluYWwoZG9tYWluLCByYW5nZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICB9XG4gIGQzLnNjYWxlLmNhdGVnb3J5MTAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MTApO1xuICB9O1xuICBkMy5zY2FsZS5jYXRlZ29yeTIwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwKTtcbiAgfTtcbiAgZDMuc2NhbGUuY2F0ZWdvcnkyMGIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MjBiKTtcbiAgfTtcbiAgZDMuc2NhbGUuY2F0ZWdvcnkyMGMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MjBjKTtcbiAgfTtcbiAgdmFyIGQzX2NhdGVnb3J5MTAgPSBbIDIwNjIyNjAsIDE2NzQ0MjA2LCAyOTI0NTg4LCAxNDAzNDcyOCwgOTcyNTg4NSwgOTE5NzEzMSwgMTQ5MDczMzAsIDgzNTU3MTEsIDEyMzY5MTg2LCAxNTU2MTc1IF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIHZhciBkM19jYXRlZ29yeTIwID0gWyAyMDYyMjYwLCAxMTQ1NDQ0MCwgMTY3NDQyMDYsIDE2NzU5NjcyLCAyOTI0NTg4LCAxMDAxODY5OCwgMTQwMzQ3MjgsIDE2NzUwNzQyLCA5NzI1ODg1LCAxMjk1NTg2MSwgOTE5NzEzMSwgMTI4ODUxNDAsIDE0OTA3MzMwLCAxNjIzNDE5NCwgODM1NTcxMSwgMTMwOTI4MDcsIDEyMzY5MTg2LCAxNDQwODU4OSwgMTU1NjE3NSwgMTA0MTA3MjUgXS5tYXAoZDNfcmdiU3RyaW5nKTtcbiAgdmFyIGQzX2NhdGVnb3J5MjBiID0gWyAzNzUwNzc3LCA1Mzk1NjE5LCA3MDQwNzE5LCAxMDI2NDI4NiwgNjUxOTA5NywgOTIxNjU5NCwgMTE5MTUxMTUsIDEzNTU2NjM2LCA5MjAyOTkzLCAxMjQyNjgwOSwgMTUxODY1MTQsIDE1MTkwOTMyLCA4NjY2MTY5LCAxMTM1NjQ5MCwgMTQwNDk2NDMsIDE1MTc3MzcyLCA4MDc3NjgzLCAxMDgzNDMyNCwgMTM1Mjg1MDksIDE0NTg5NjU0IF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIHZhciBkM19jYXRlZ29yeTIwYyA9IFsgMzI0NDczMywgNzA1NzExMCwgMTA0MDY2MjUsIDEzMDMyNDMxLCAxNTA5NTA1MywgMTY2MTY3NjQsIDE2NjI1MjU5LCAxNjYzNDAxOCwgMzI1MzA3NiwgNzY1MjQ3MCwgMTA2MDcwMDMsIDEzMTAxNTA0LCA3Njk1MjgxLCAxMDM5NDMxMiwgMTIzNjkzNzIsIDE0MzQyODkxLCA2NTEzNTA3LCA5ODY4OTUwLCAxMjQzNDg3NywgMTQyNzcwODEgXS5tYXAoZDNfcmdiU3RyaW5nKTtcbiAgZDMuc2NhbGUucXVhbnRpbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpbGUoW10sIFtdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcXVhbnRpbGUoZG9tYWluLCByYW5nZSkge1xuICAgIHZhciB0aHJlc2hvbGRzO1xuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICB2YXIgayA9IDAsIHEgPSByYW5nZS5sZW5ndGg7XG4gICAgICB0aHJlc2hvbGRzID0gW107XG4gICAgICB3aGlsZSAoKytrIDwgcSkgdGhyZXNob2xkc1trIC0gMV0gPSBkMy5xdWFudGlsZShkb21haW4sIGsgLyBxKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgaWYgKCFpc05hTih4ID0gK3gpKSByZXR1cm4gcmFuZ2VbZDMuYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0geC5tYXAoZDNfbnVtYmVyKS5maWx0ZXIoZDNfbnVtZXJpYykuc29ydChkM19hc2NlbmRpbmcpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhyZXNob2xkcztcbiAgICB9O1xuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgcmV0dXJuIHkgPCAwID8gWyBOYU4sIE5hTiBdIDogWyB5ID4gMCA/IHRocmVzaG9sZHNbeSAtIDFdIDogZG9tYWluWzBdLCB5IDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW3ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXSBdO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aWxlKGRvbWFpbiwgcmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfVxuICBkMy5zY2FsZS5xdWFudGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9xdWFudGl6ZSgwLCAxLCBbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3F1YW50aXplKHgwLCB4MSwgcmFuZ2UpIHtcbiAgICB2YXIga3gsIGk7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKGksIE1hdGguZmxvb3Ioa3ggKiAoeCAtIHgwKSkpKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICBreCA9IHJhbmdlLmxlbmd0aCAvICh4MSAtIHgwKTtcbiAgICAgIGkgPSByYW5nZS5sZW5ndGggLSAxO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIHgwLCB4MSBdO1xuICAgICAgeDAgPSAreFswXTtcbiAgICAgIHgxID0gK3hbeC5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgeSA9IHkgPCAwID8gTmFOIDogeSAvIGt4ICsgeDA7XG4gICAgICByZXR1cm4gWyB5LCB5ICsgMSAvIGt4IF07XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpemUoeDAsIHgxLCByYW5nZSk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9XG4gIGQzLnNjYWxlLnRocmVzaG9sZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV90aHJlc2hvbGQoWyAuNSBdLCBbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3RocmVzaG9sZChkb21haW4sIHJhbmdlKSB7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgaWYgKHggPD0geCkgcmV0dXJuIHJhbmdlW2QzLmJpc2VjdChkb21haW4sIHgpXTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0gXztcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IF87XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICB5ID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiBbIGRvbWFpblt5IC0gMV0sIGRvbWFpblt5XSBdO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3RocmVzaG9sZChkb21haW4sIHJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuICBkMy5zY2FsZS5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9pZGVudGl0eShbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2lkZW50aXR5KGRvbWFpbikge1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICAgIHJldHVybiAreDtcbiAgICB9XG4gICAgaWRlbnRpdHkuaW52ZXJ0ID0gaWRlbnRpdHk7XG4gICAgaWRlbnRpdHkuZG9tYWluID0gaWRlbnRpdHkucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSB4Lm1hcChpZGVudGl0eSk7XG4gICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgfTtcbiAgICBpZGVudGl0eS50aWNrcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pO1xuICAgIH07XG4gICAgaWRlbnRpdHkudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG0sIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpO1xuICAgIH07XG4gICAgaWRlbnRpdHkuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2lkZW50aXR5KGRvbWFpbik7XG4gICAgfTtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgZDMuc3ZnID0ge307XG4gIGZ1bmN0aW9uIGQzX3plcm8oKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZDMuc3ZnLmFyYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbm5lclJhZGl1cyA9IGQzX3N2Z19hcmNJbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgPSBkM19zdmdfYXJjT3V0ZXJSYWRpdXMsIGNvcm5lclJhZGl1cyA9IGQzX3plcm8sIHBhZFJhZGl1cyA9IGQzX3N2Z19hcmNBdXRvLCBzdGFydEFuZ2xlID0gZDNfc3ZnX2FyY1N0YXJ0QW5nbGUsIGVuZEFuZ2xlID0gZDNfc3ZnX2FyY0VuZEFuZ2xlLCBwYWRBbmdsZSA9IGQzX3N2Z19hcmNQYWRBbmdsZTtcbiAgICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgICB2YXIgcjAgPSBNYXRoLm1heCgwLCAraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksIHIxID0gTWF0aC5tYXgoMCwgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGbPgCwgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZs+ALCBkYSA9IE1hdGguYWJzKGExIC0gYTApLCBjdyA9IGEwID4gYTEgPyAwIDogMTtcbiAgICAgIGlmIChyMSA8IHIwKSByYyA9IHIxLCByMSA9IHIwLCByMCA9IHJjO1xuICAgICAgaWYgKGRhID49IM+EzrUpIHJldHVybiBjaXJjbGVTZWdtZW50KHIxLCBjdykgKyAocjAgPyBjaXJjbGVTZWdtZW50KHIwLCAxIC0gY3cpIDogXCJcIikgKyBcIlpcIjtcbiAgICAgIHZhciByYywgY3IsIHJwLCBhcCwgcDAgPSAwLCBwMSA9IDAsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgcGF0aCA9IFtdO1xuICAgICAgaWYgKGFwID0gKCtwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDApIC8gMikge1xuICAgICAgICBycCA9IHBhZFJhZGl1cyA9PT0gZDNfc3ZnX2FyY0F1dG8gPyBNYXRoLnNxcnQocjAgKiByMCArIHIxICogcjEpIDogK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoIWN3KSBwMSAqPSAtMTtcbiAgICAgICAgaWYgKHIxKSBwMSA9IGQzX2FzaW4ocnAgLyByMSAqIE1hdGguc2luKGFwKSk7XG4gICAgICAgIGlmIChyMCkgcDAgPSBkM19hc2luKHJwIC8gcjAgKiBNYXRoLnNpbihhcCkpO1xuICAgICAgfVxuICAgICAgaWYgKHIxKSB7XG4gICAgICAgIHgwID0gcjEgKiBNYXRoLmNvcyhhMCArIHAxKTtcbiAgICAgICAgeTAgPSByMSAqIE1hdGguc2luKGEwICsgcDEpO1xuICAgICAgICB4MSA9IHIxICogTWF0aC5jb3MoYTEgLSBwMSk7XG4gICAgICAgIHkxID0gcjEgKiBNYXRoLnNpbihhMSAtIHAxKTtcbiAgICAgICAgdmFyIGwxID0gTWF0aC5hYnMoYTEgLSBhMCAtIDIgKiBwMSkgPD0gz4AgPyAwIDogMTtcbiAgICAgICAgaWYgKHAxICYmIGQzX3N2Z19hcmNTd2VlcCh4MCwgeTAsIHgxLCB5MSkgPT09IGN3IF4gbDEpIHtcbiAgICAgICAgICB2YXIgaDEgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICAgIHgwID0gcjEgKiBNYXRoLmNvcyhoMSk7XG4gICAgICAgICAgeTAgPSByMSAqIE1hdGguc2luKGgxKTtcbiAgICAgICAgICB4MSA9IHkxID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDAgPSB5MCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocjApIHtcbiAgICAgICAgeDIgPSByMCAqIE1hdGguY29zKGExIC0gcDApO1xuICAgICAgICB5MiA9IHIwICogTWF0aC5zaW4oYTEgLSBwMCk7XG4gICAgICAgIHgzID0gcjAgKiBNYXRoLmNvcyhhMCArIHAwKTtcbiAgICAgICAgeTMgPSByMCAqIE1hdGguc2luKGEwICsgcDApO1xuICAgICAgICB2YXIgbDAgPSBNYXRoLmFicyhhMCAtIGExICsgMiAqIHAwKSA8PSDPgCA/IDAgOiAxO1xuICAgICAgICBpZiAocDAgJiYgZDNfc3ZnX2FyY1N3ZWVwKHgyLCB5MiwgeDMsIHkzKSA9PT0gMSAtIGN3IF4gbDApIHtcbiAgICAgICAgICB2YXIgaDAgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICAgIHgyID0gcjAgKiBNYXRoLmNvcyhoMCk7XG4gICAgICAgICAgeTIgPSByMCAqIE1hdGguc2luKGgwKTtcbiAgICAgICAgICB4MyA9IHkzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB5MiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoKHJjID0gTWF0aC5taW4oTWF0aC5hYnMocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSA+IC4wMDEpIHtcbiAgICAgICAgY3IgPSByMCA8IHIxIF4gY3cgPyAwIDogMTtcbiAgICAgICAgdmFyIG9jID0geDMgPT0gbnVsbCA/IFsgeDIsIHkyIF0gOiB4MSA9PSBudWxsID8gWyB4MCwgeTAgXSA6IGQzX2dlb21fcG9seWdvbkludGVyc2VjdChbIHgwLCB5MCBdLCBbIHgzLCB5MyBdLCBbIHgxLCB5MSBdLCBbIHgyLCB5MiBdKSwgYXggPSB4MCAtIG9jWzBdLCBheSA9IHkwIC0gb2NbMV0sIGJ4ID0geDEgLSBvY1swXSwgYnkgPSB5MSAtIG9jWzFdLCBrYyA9IDEgLyBNYXRoLnNpbihNYXRoLmFjb3MoKGF4ICogYnggKyBheSAqIGJ5KSAvIChNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkpICogTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkpIC8gMiksIGxjID0gTWF0aC5zcXJ0KG9jWzBdICogb2NbMF0gKyBvY1sxXSAqIG9jWzFdKTtcbiAgICAgICAgaWYgKHgxICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcmMxID0gTWF0aC5taW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKSwgdDMwID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKHgzID09IG51bGwgPyBbIHgyLCB5MiBdIDogWyB4MywgeTMgXSwgWyB4MCwgeTAgXSwgcjEsIHJjMSwgY3cpLCB0MTIgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoWyB4MSwgeTEgXSwgWyB4MiwgeTIgXSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICAgIGlmIChyYyA9PT0gcmMxKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHQzMFswXSwgXCJBXCIsIHJjMSwgXCIsXCIsIHJjMSwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQzMFsxXSwgXCJBXCIsIHIxLCBcIixcIiwgcjEsIFwiIDAgXCIsIDEgLSBjdyBeIGQzX3N2Z19hcmNTd2VlcCh0MzBbMV1bMF0sIHQzMFsxXVsxXSwgdDEyWzFdWzBdLCB0MTJbMV1bMV0pLCBcIixcIiwgY3csIFwiIFwiLCB0MTJbMV0sIFwiQVwiLCByYzEsIFwiLFwiLCByYzEsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MTJbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHQzMFswXSwgXCJBXCIsIHJjMSwgXCIsXCIsIHJjMSwgXCIgMCAxLFwiLCBjciwgXCIgXCIsIHQxMlswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgucHVzaChcIk1cIiwgeDAsIFwiLFwiLCB5MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHgzICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcmMwID0gTWF0aC5taW4ocmMsIChyMCAtIGxjKSAvIChrYyAtIDEpKSwgdDAzID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKFsgeDAsIHkwIF0sIFsgeDMsIHkzIF0sIHIwLCAtcmMwLCBjdyksIHQyMSA9IGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhbIHgyLCB5MiBdLCB4MSA9PSBudWxsID8gWyB4MCwgeTAgXSA6IFsgeDEsIHkxIF0sIHIwLCAtcmMwLCBjdyk7XG4gICAgICAgICAgaWYgKHJjID09PSByYzApIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIkxcIiwgdDIxWzBdLCBcIkFcIiwgcmMwLCBcIixcIiwgcmMwLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDIxWzFdLCBcIkFcIiwgcjAsIFwiLFwiLCByMCwgXCIgMCBcIiwgY3cgXiBkM19zdmdfYXJjU3dlZXAodDIxWzFdWzBdLCB0MjFbMV1bMV0sIHQwM1sxXVswXSwgdDAzWzFdWzFdKSwgXCIsXCIsIDEgLSBjdywgXCIgXCIsIHQwM1sxXSwgXCJBXCIsIHJjMCwgXCIsXCIsIHJjMCwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQwM1swXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIkxcIiwgdDIxWzBdLCBcIkFcIiwgcmMwLCBcIixcIiwgcmMwLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDAzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB4MiwgXCIsXCIsIHkyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aC5wdXNoKFwiTVwiLCB4MCwgXCIsXCIsIHkwKTtcbiAgICAgICAgaWYgKHgxICE9IG51bGwpIHBhdGgucHVzaChcIkFcIiwgcjEsIFwiLFwiLCByMSwgXCIgMCBcIiwgbDEsIFwiLFwiLCBjdywgXCIgXCIsIHgxLCBcIixcIiwgeTEpO1xuICAgICAgICBwYXRoLnB1c2goXCJMXCIsIHgyLCBcIixcIiwgeTIpO1xuICAgICAgICBpZiAoeDMgIT0gbnVsbCkgcGF0aC5wdXNoKFwiQVwiLCByMCwgXCIsXCIsIHIwLCBcIiAwIFwiLCBsMCwgXCIsXCIsIDEgLSBjdywgXCIgXCIsIHgzLCBcIixcIiwgeTMpO1xuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKFwiWlwiKTtcbiAgICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNpcmNsZVNlZ21lbnQocjEsIGN3KSB7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIHIxICsgXCJBXCIgKyByMSArIFwiLFwiICsgcjEgKyBcIiAwIDEsXCIgKyBjdyArIFwiIDAsXCIgKyAtcjEgKyBcIkFcIiArIHIxICsgXCIsXCIgKyByMSArIFwiIDAgMSxcIiArIGN3ICsgXCIgMCxcIiArIHIxO1xuICAgIH1cbiAgICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbm5lclJhZGl1cztcbiAgICAgIGlubmVyUmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMub3V0ZXJSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRlclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29ybmVyUmFkaXVzO1xuICAgICAgY29ybmVyUmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkUmFkaXVzO1xuICAgICAgcGFkUmFkaXVzID0gdiA9PSBkM19zdmdfYXJjQXV0byA/IGQzX3N2Z19hcmNBdXRvIDogZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXJ0QW5nbGU7XG4gICAgICBzdGFydEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuZW5kQW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBlbmRBbmdsZTtcbiAgICAgIGVuZEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRBbmdsZTtcbiAgICAgIHBhZEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gKCtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiwgYSA9ICgrc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK2VuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiAtIGhhbGbPgDtcbiAgICAgIHJldHVybiBbIE1hdGguY29zKGEpICogciwgTWF0aC5zaW4oYSkgKiByIF07XG4gICAgfTtcbiAgICByZXR1cm4gYXJjO1xuICB9O1xuICB2YXIgZDNfc3ZnX2FyY0F1dG8gPSBcImF1dG9cIjtcbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY0lubmVyUmFkaXVzKGQpIHtcbiAgICByZXR1cm4gZC5pbm5lclJhZGl1cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjT3V0ZXJSYWRpdXMoZCkge1xuICAgIHJldHVybiBkLm91dGVyUmFkaXVzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNTdGFydEFuZ2xlKGQpIHtcbiAgICByZXR1cm4gZC5zdGFydEFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNFbmRBbmdsZShkKSB7XG4gICAgcmV0dXJuIGQuZW5kQW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY1BhZEFuZ2xlKGQpIHtcbiAgICByZXR1cm4gZCAmJiBkLnBhZEFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNTd2VlcCh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHJldHVybiAoeDAgLSB4MSkgKiB5MCAtICh5MCAtIHkxKSAqIHgwID4gMCA/IDAgOiAxO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhwMCwgcDEsIHIxLCByYywgY3cpIHtcbiAgICB2YXIgeDAxID0gcDBbMF0gLSBwMVswXSwgeTAxID0gcDBbMV0gLSBwMVsxXSwgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBNYXRoLnNxcnQoeDAxICogeDAxICsgeTAxICogeTAxKSwgb3ggPSBsbyAqIHkwMSwgb3kgPSAtbG8gKiB4MDEsIHgxID0gcDBbMF0gKyBveCwgeTEgPSBwMFsxXSArIG95LCB4MiA9IHAxWzBdICsgb3gsIHkyID0gcDFbMV0gKyBveSwgeDMgPSAoeDEgKyB4MikgLyAyLCB5MyA9ICh5MSArIHkyKSAvIDIsIGR4ID0geDIgLSB4MSwgZHkgPSB5MiAtIHkxLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5LCByID0gcjEgLSByYywgRCA9IHgxICogeTIgLSB4MiAqIHkxLCBkID0gKGR5IDwgMCA/IC0xIDogMSkgKiBNYXRoLnNxcnQociAqIHIgKiBkMiAtIEQgKiBEKSwgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMiwgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLCBkeDAgPSBjeDAgLSB4MywgZHkwID0gY3kwIC0geTMsIGR4MSA9IGN4MSAtIHgzLCBkeTEgPSBjeTEgLSB5MztcbiAgICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSBjeDAgPSBjeDEsIGN5MCA9IGN5MTtcbiAgICByZXR1cm4gWyBbIGN4MCAtIG94LCBjeTAgLSBveSBdLCBbIGN4MCAqIHIxIC8gciwgY3kwICogcjEgLyByIF0gXTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZShwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHggPSBkM19nZW9tX3BvaW50WCwgeSA9IGQzX2dlb21fcG9pbnRZLCBkZWZpbmVkID0gZDNfdHJ1ZSwgaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUxpbmVhciwgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZS5rZXksIHRlbnNpb24gPSAuNztcbiAgICBmdW5jdGlvbiBsaW5lKGRhdGEpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdLCBwb2ludHMgPSBbXSwgaSA9IC0xLCBuID0gZGF0YS5sZW5ndGgsIGQsIGZ4ID0gZDNfZnVuY3Rvcih4KSwgZnkgPSBkM19mdW5jdG9yKHkpO1xuICAgICAgZnVuY3Rpb24gc2VnbWVudCgpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChcIk1cIiwgaW50ZXJwb2xhdGUocHJvamVjdGlvbihwb2ludHMpLCB0ZW5zaW9uKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZGVmaW5lZC5jYWxsKHRoaXMsIGQgPSBkYXRhW2ldLCBpKSkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKFsgK2Z4LmNhbGwodGhpcywgZCwgaSksICtmeS5jYWxsKHRoaXMsIGQsIGkpIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWdtZW50KCk7XG4gICAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb2ludHMubGVuZ3RoKSBzZWdtZW50KCk7XG4gICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHMuam9pbihcIlwiKSA6IG51bGw7XG4gICAgfVxuICAgIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHg7XG4gICAgICB4ID0gXztcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICAgIHkgPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBsaW5lLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWZpbmVkO1xuICAgICAgZGVmaW5lZCA9IF87XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIGxpbmUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZUtleTtcbiAgICAgIGlmICh0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiKSBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlID0gXzsgZWxzZSBpbnRlcnBvbGF0ZUtleSA9IChpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lSW50ZXJwb2xhdG9ycy5nZXQoXykgfHwgZDNfc3ZnX2xpbmVMaW5lYXIpLmtleTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS50ZW5zaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGVuc2lvbjtcbiAgICAgIHRlbnNpb24gPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICByZXR1cm4gbGluZTtcbiAgfVxuICBkMy5zdmcubGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zdmdfbGluZShkM19pZGVudGl0eSk7XG4gIH07XG4gIHZhciBkM19zdmdfbGluZUludGVycG9sYXRvcnMgPSBkMy5tYXAoe1xuICAgIGxpbmVhcjogZDNfc3ZnX2xpbmVMaW5lYXIsXG4gICAgXCJsaW5lYXItY2xvc2VkXCI6IGQzX3N2Z19saW5lTGluZWFyQ2xvc2VkLFxuICAgIHN0ZXA6IGQzX3N2Z19saW5lU3RlcCxcbiAgICBcInN0ZXAtYmVmb3JlXCI6IGQzX3N2Z19saW5lU3RlcEJlZm9yZSxcbiAgICBcInN0ZXAtYWZ0ZXJcIjogZDNfc3ZnX2xpbmVTdGVwQWZ0ZXIsXG4gICAgYmFzaXM6IGQzX3N2Z19saW5lQmFzaXMsXG4gICAgXCJiYXNpcy1vcGVuXCI6IGQzX3N2Z19saW5lQmFzaXNPcGVuLFxuICAgIFwiYmFzaXMtY2xvc2VkXCI6IGQzX3N2Z19saW5lQmFzaXNDbG9zZWQsXG4gICAgYnVuZGxlOiBkM19zdmdfbGluZUJ1bmRsZSxcbiAgICBjYXJkaW5hbDogZDNfc3ZnX2xpbmVDYXJkaW5hbCxcbiAgICBcImNhcmRpbmFsLW9wZW5cIjogZDNfc3ZnX2xpbmVDYXJkaW5hbE9wZW4sXG4gICAgXCJjYXJkaW5hbC1jbG9zZWRcIjogZDNfc3ZnX2xpbmVDYXJkaW5hbENsb3NlZCxcbiAgICBtb25vdG9uZTogZDNfc3ZnX2xpbmVNb25vdG9uZVxuICB9KTtcbiAgZDNfc3ZnX2xpbmVJbnRlcnBvbGF0b3JzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhbHVlLmtleSA9IGtleTtcbiAgICB2YWx1ZS5jbG9zZWQgPSAvLWNsb3NlZCQvLnRlc3Qoa2V5KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMuam9pbihcIkxcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVMaW5lYXJDbG9zZWQocG9pbnRzKSB7XG4gICAgcmV0dXJuIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgKyBcIlpcIjtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVN0ZXAocG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aCwgcCA9IHBvaW50c1swXSwgcGF0aCA9IFsgcFswXSwgXCIsXCIsIHBbMV0gXTtcbiAgICB3aGlsZSAoKytpIDwgbikgcGF0aC5wdXNoKFwiSFwiLCAocFswXSArIChwID0gcG9pbnRzW2ldKVswXSkgLyAyLCBcIlZcIiwgcFsxXSk7XG4gICAgaWYgKG4gPiAxKSBwYXRoLnB1c2goXCJIXCIsIHBbMF0pO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVTdGVwQmVmb3JlKHBvaW50cykge1xuICAgIHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGgsIHAgPSBwb2ludHNbMF0sIHBhdGggPSBbIHBbMF0sIFwiLFwiLCBwWzFdIF07XG4gICAgd2hpbGUgKCsraSA8IG4pIHBhdGgucHVzaChcIlZcIiwgKHAgPSBwb2ludHNbaV0pWzFdLCBcIkhcIiwgcFswXSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVN0ZXBBZnRlcihwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoLCBwID0gcG9pbnRzWzBdLCBwYXRoID0gWyBwWzBdLCBcIixcIiwgcFsxXSBdO1xuICAgIHdoaWxlICgrK2kgPCBuKSBwYXRoLnB1c2goXCJIXCIsIChwID0gcG9pbnRzW2ldKVswXSwgXCJWXCIsIHBbMV0pO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbE9wZW4ocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPCA0ID8gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKSA6IHBvaW50c1sxXSArIGQzX3N2Z19saW5lSGVybWl0ZShwb2ludHMuc2xpY2UoMSwgLTEpLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMocG9pbnRzLCB0ZW5zaW9uKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbENsb3NlZChwb2ludHMsIHRlbnNpb24pIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA8IDMgPyBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpIDogcG9pbnRzWzBdICsgZDNfc3ZnX2xpbmVIZXJtaXRlKChwb2ludHMucHVzaChwb2ludHNbMF0pLCBcbiAgICBwb2ludHMpLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMoWyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdIF0uY29uY2F0KHBvaW50cywgWyBwb2ludHNbMV0gXSksIHRlbnNpb24pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUNhcmRpbmFsKHBvaW50cywgdGVuc2lvbikge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMyA/IGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgOiBwb2ludHNbMF0gKyBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLCBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMocG9pbnRzLCB0ZW5zaW9uKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVIZXJtaXRlKHBvaW50cywgdGFuZ2VudHMpIHtcbiAgICBpZiAodGFuZ2VudHMubGVuZ3RoIDwgMSB8fCBwb2ludHMubGVuZ3RoICE9IHRhbmdlbnRzLmxlbmd0aCAmJiBwb2ludHMubGVuZ3RoICE9IHRhbmdlbnRzLmxlbmd0aCArIDIpIHtcbiAgICAgIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIH1cbiAgICB2YXIgcXVhZCA9IHBvaW50cy5sZW5ndGggIT0gdGFuZ2VudHMubGVuZ3RoLCBwYXRoID0gXCJcIiwgcDAgPSBwb2ludHNbMF0sIHAgPSBwb2ludHNbMV0sIHQwID0gdGFuZ2VudHNbMF0sIHQgPSB0MCwgcGkgPSAxO1xuICAgIGlmIChxdWFkKSB7XG4gICAgICBwYXRoICs9IFwiUVwiICsgKHBbMF0gLSB0MFswXSAqIDIgLyAzKSArIFwiLFwiICsgKHBbMV0gLSB0MFsxXSAqIDIgLyAzKSArIFwiLFwiICsgcFswXSArIFwiLFwiICsgcFsxXTtcbiAgICAgIHAwID0gcG9pbnRzWzFdO1xuICAgICAgcGkgPSAyO1xuICAgIH1cbiAgICBpZiAodGFuZ2VudHMubGVuZ3RoID4gMSkge1xuICAgICAgdCA9IHRhbmdlbnRzWzFdO1xuICAgICAgcCA9IHBvaW50c1twaV07XG4gICAgICBwaSsrO1xuICAgICAgcGF0aCArPSBcIkNcIiArIChwMFswXSArIHQwWzBdKSArIFwiLFwiICsgKHAwWzFdICsgdDBbMV0pICsgXCIsXCIgKyAocFswXSAtIHRbMF0pICsgXCIsXCIgKyAocFsxXSAtIHRbMV0pICsgXCIsXCIgKyBwWzBdICsgXCIsXCIgKyBwWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB0YW5nZW50cy5sZW5ndGg7IGkrKywgcGkrKykge1xuICAgICAgICBwID0gcG9pbnRzW3BpXTtcbiAgICAgICAgdCA9IHRhbmdlbnRzW2ldO1xuICAgICAgICBwYXRoICs9IFwiU1wiICsgKHBbMF0gLSB0WzBdKSArIFwiLFwiICsgKHBbMV0gLSB0WzFdKSArIFwiLFwiICsgcFswXSArIFwiLFwiICsgcFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1YWQpIHtcbiAgICAgIHZhciBscCA9IHBvaW50c1twaV07XG4gICAgICBwYXRoICs9IFwiUVwiICsgKHBbMF0gKyB0WzBdICogMiAvIDMpICsgXCIsXCIgKyAocFsxXSArIHRbMV0gKiAyIC8gMykgKyBcIixcIiArIGxwWzBdICsgXCIsXCIgKyBscFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbFRhbmdlbnRzKHBvaW50cywgdGVuc2lvbikge1xuICAgIHZhciB0YW5nZW50cyA9IFtdLCBhID0gKDEgLSB0ZW5zaW9uKSAvIDIsIHAwLCBwMSA9IHBvaW50c1swXSwgcDIgPSBwb2ludHNbMV0sIGkgPSAxLCBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcDAgPSBwMTtcbiAgICAgIHAxID0gcDI7XG4gICAgICBwMiA9IHBvaW50c1tpXTtcbiAgICAgIHRhbmdlbnRzLnB1c2goWyBhICogKHAyWzBdIC0gcDBbMF0pLCBhICogKHAyWzFdIC0gcDBbMV0pIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFuZ2VudHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpcyhwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIHZhciBpID0gMSwgbiA9IHBvaW50cy5sZW5ndGgsIHBpID0gcG9pbnRzWzBdLCB4MCA9IHBpWzBdLCB5MCA9IHBpWzFdLCBweCA9IFsgeDAsIHgwLCB4MCwgKHBpID0gcG9pbnRzWzFdKVswXSBdLCBweSA9IFsgeTAsIHkwLCB5MCwgcGlbMV0gXSwgcGF0aCA9IFsgeDAsIFwiLFwiLCB5MCwgXCJMXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweSkgXTtcbiAgICBwb2ludHMucHVzaChwb2ludHNbbiAtIDFdKTtcbiAgICB3aGlsZSAoKytpIDw9IG4pIHtcbiAgICAgIHBpID0gcG9pbnRzW2ldO1xuICAgICAgcHguc2hpZnQoKTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkuc2hpZnQoKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgICAgZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCBweCwgcHkpO1xuICAgIH1cbiAgICBwb2ludHMucG9wKCk7XG4gICAgcGF0aC5wdXNoKFwiTFwiLCBwaSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUJhc2lzT3Blbihwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDQpIHJldHVybiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpO1xuICAgIHZhciBwYXRoID0gW10sIGkgPSAtMSwgbiA9IHBvaW50cy5sZW5ndGgsIHBpLCBweCA9IFsgMCBdLCBweSA9IFsgMCBdO1xuICAgIHdoaWxlICgrK2kgPCAzKSB7XG4gICAgICBwaSA9IHBvaW50c1tpXTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgfVxuICAgIHBhdGgucHVzaChkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB4KSArIFwiLFwiICsgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweSkpO1xuICAgIC0taTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcGkgPSBwb2ludHNbaV07XG4gICAgICBweC5zaGlmdCgpO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5zaGlmdCgpO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgICBkM19zdmdfbGluZUJhc2lzQmV6aWVyKHBhdGgsIHB4LCBweSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpc0Nsb3NlZChwb2ludHMpIHtcbiAgICB2YXIgcGF0aCwgaSA9IC0xLCBuID0gcG9pbnRzLmxlbmd0aCwgbSA9IG4gKyA0LCBwaSwgcHggPSBbXSwgcHkgPSBbXTtcbiAgICB3aGlsZSAoKytpIDwgNCkge1xuICAgICAgcGkgPSBwb2ludHNbaSAlIG5dO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICB9XG4gICAgcGF0aCA9IFsgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB5KSBdO1xuICAgIC0taTtcbiAgICB3aGlsZSAoKytpIDwgbSkge1xuICAgICAgcGkgPSBwb2ludHNbaSAlIG5dO1xuICAgICAgcHguc2hpZnQoKTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkuc2hpZnQoKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgICAgZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCBweCwgcHkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQnVuZGxlKHBvaW50cywgdGVuc2lvbikge1xuICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciB4MCA9IHBvaW50c1swXVswXSwgeTAgPSBwb2ludHNbMF1bMV0sIGR4ID0gcG9pbnRzW25dWzBdIC0geDAsIGR5ID0gcG9pbnRzW25dWzFdIC0geTAsIGkgPSAtMSwgcCwgdDtcbiAgICAgIHdoaWxlICgrK2kgPD0gbikge1xuICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICB0ID0gaSAvIG47XG4gICAgICAgIHBbMF0gPSB0ZW5zaW9uICogcFswXSArICgxIC0gdGVuc2lvbikgKiAoeDAgKyB0ICogZHgpO1xuICAgICAgICBwWzFdID0gdGVuc2lvbiAqIHBbMV0gKyAoMSAtIHRlbnNpb24pICogKHkwICsgdCAqIGR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3N2Z19saW5lQmFzaXMocG9pbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZURvdDQoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbiAgfVxuICB2YXIgZDNfc3ZnX2xpbmVCYXNpc0JlemllcjEgPSBbIDAsIDIgLyAzLCAxIC8gMywgMCBdLCBkM19zdmdfbGluZUJhc2lzQmV6aWVyMiA9IFsgMCwgMSAvIDMsIDIgLyAzLCAwIF0sIGQzX3N2Z19saW5lQmFzaXNCZXppZXIzID0gWyAwLCAxIC8gNiwgMiAvIDMsIDEgLyA2IF07XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQmFzaXNCZXppZXIocGF0aCwgeCwgeSkge1xuICAgIHBhdGgucHVzaChcIkNcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIxLCB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMSwgeSksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjIsIHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIyLCB5KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgeCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHkpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVNsb3BlKHAwLCBwMSkge1xuICAgIHJldHVybiAocDFbMV0gLSBwMFsxXSkgLyAocDFbMF0gLSBwMFswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVGaW5pdGVEaWZmZXJlbmNlcyhwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIGogPSBwb2ludHMubGVuZ3RoIC0gMSwgbSA9IFtdLCBwMCA9IHBvaW50c1swXSwgcDEgPSBwb2ludHNbMV0sIGQgPSBtWzBdID0gZDNfc3ZnX2xpbmVTbG9wZShwMCwgcDEpO1xuICAgIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgICBtW2ldID0gKGQgKyAoZCA9IGQzX3N2Z19saW5lU2xvcGUocDAgPSBwMSwgcDEgPSBwb2ludHNbaSArIDFdKSkpIC8gMjtcbiAgICB9XG4gICAgbVtpXSA9IGQ7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVNb25vdG9uZVRhbmdlbnRzKHBvaW50cykge1xuICAgIHZhciB0YW5nZW50cyA9IFtdLCBkLCBhLCBiLCBzLCBtID0gZDNfc3ZnX2xpbmVGaW5pdGVEaWZmZXJlbmNlcyhwb2ludHMpLCBpID0gLTEsIGogPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoKytpIDwgaikge1xuICAgICAgZCA9IGQzX3N2Z19saW5lU2xvcGUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgIGlmIChhYnMoZCkgPCDOtSkge1xuICAgICAgICBtW2ldID0gbVtpICsgMV0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IG1baV0gLyBkO1xuICAgICAgICBiID0gbVtpICsgMV0gLyBkO1xuICAgICAgICBzID0gYSAqIGEgKyBiICogYjtcbiAgICAgICAgaWYgKHMgPiA5KSB7XG4gICAgICAgICAgcyA9IGQgKiAzIC8gTWF0aC5zcXJ0KHMpO1xuICAgICAgICAgIG1baV0gPSBzICogYTtcbiAgICAgICAgICBtW2kgKyAxXSA9IHMgKiBiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDw9IGopIHtcbiAgICAgIHMgPSAocG9pbnRzW01hdGgubWluKGosIGkgKyAxKV1bMF0gLSBwb2ludHNbTWF0aC5tYXgoMCwgaSAtIDEpXVswXSkgLyAoNiAqICgxICsgbVtpXSAqIG1baV0pKTtcbiAgICAgIHRhbmdlbnRzLnB1c2goWyBzIHx8IDAsIG1baV0gKiBzIHx8IDAgXSk7XG4gICAgfVxuICAgIHJldHVybiB0YW5nZW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZU1vbm90b25lKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMyA/IGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgOiBwb2ludHNbMF0gKyBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLCBkM19zdmdfbGluZU1vbm90b25lVGFuZ2VudHMocG9pbnRzKSk7XG4gIH1cbiAgZDMuc3ZnLmxpbmUucmFkaWFsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpbmUgPSBkM19zdmdfbGluZShkM19zdmdfbGluZVJhZGlhbCk7XG4gICAgbGluZS5yYWRpdXMgPSBsaW5lLngsIGRlbGV0ZSBsaW5lLng7XG4gICAgbGluZS5hbmdsZSA9IGxpbmUueSwgZGVsZXRlIGxpbmUueTtcbiAgICByZXR1cm4gbGluZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVSYWRpYWwocG9pbnRzKSB7XG4gICAgdmFyIHBvaW50LCBpID0gLTEsIG4gPSBwb2ludHMubGVuZ3RoLCByLCBhO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIHIgPSBwb2ludFswXTtcbiAgICAgIGEgPSBwb2ludFsxXSAtIGhhbGbPgDtcbiAgICAgIHBvaW50WzBdID0gciAqIE1hdGguY29zKGEpO1xuICAgICAgcG9pbnRbMV0gPSByICogTWF0aC5zaW4oYSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyZWEocHJvamVjdGlvbikge1xuICAgIHZhciB4MCA9IGQzX2dlb21fcG9pbnRYLCB4MSA9IGQzX2dlb21fcG9pbnRYLCB5MCA9IDAsIHkxID0gZDNfZ2VvbV9wb2ludFksIGRlZmluZWQgPSBkM190cnVlLCBpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lTGluZWFyLCBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlLmtleSwgaW50ZXJwb2xhdGVSZXZlcnNlID0gaW50ZXJwb2xhdGUsIEwgPSBcIkxcIiwgdGVuc2lvbiA9IC43O1xuICAgIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gW10sIHBvaW50czAgPSBbXSwgcG9pbnRzMSA9IFtdLCBpID0gLTEsIG4gPSBkYXRhLmxlbmd0aCwgZCwgZngwID0gZDNfZnVuY3Rvcih4MCksIGZ5MCA9IGQzX2Z1bmN0b3IoeTApLCBmeDEgPSB4MCA9PT0geDEgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9IDogZDNfZnVuY3Rvcih4MSksIGZ5MSA9IHkwID09PSB5MSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH0gOiBkM19mdW5jdG9yKHkxKSwgeCwgeTtcbiAgICAgIGZ1bmN0aW9uIHNlZ21lbnQoKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goXCJNXCIsIGludGVycG9sYXRlKHByb2plY3Rpb24ocG9pbnRzMSksIHRlbnNpb24pLCBMLCBpbnRlcnBvbGF0ZVJldmVyc2UocHJvamVjdGlvbihwb2ludHMwLnJldmVyc2UoKSksIHRlbnNpb24pLCBcIlpcIik7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZGVmaW5lZC5jYWxsKHRoaXMsIGQgPSBkYXRhW2ldLCBpKSkge1xuICAgICAgICAgIHBvaW50czAucHVzaChbIHggPSArZngwLmNhbGwodGhpcywgZCwgaSksIHkgPSArZnkwLmNhbGwodGhpcywgZCwgaSkgXSk7XG4gICAgICAgICAgcG9pbnRzMS5wdXNoKFsgK2Z4MS5jYWxsKHRoaXMsIGQsIGkpLCArZnkxLmNhbGwodGhpcywgZCwgaSkgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzMC5sZW5ndGgpIHtcbiAgICAgICAgICBzZWdtZW50KCk7XG4gICAgICAgICAgcG9pbnRzMCA9IFtdO1xuICAgICAgICAgIHBvaW50czEgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvaW50czAubGVuZ3RoKSBzZWdtZW50KCk7XG4gICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHMuam9pbihcIlwiKSA6IG51bGw7XG4gICAgfVxuICAgIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDAgPSB4MSA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MDtcbiAgICAgIHgwID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS54MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkwID0geTEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTA7XG4gICAgICB5MCA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MTtcbiAgICAgIHkxID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmaW5lZDtcbiAgICAgIGRlZmluZWQgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW50ZXJwb2xhdGVLZXk7XG4gICAgICBpZiAodHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIikgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZSA9IF87IGVsc2UgaW50ZXJwb2xhdGVLZXkgPSAoaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUludGVycG9sYXRvcnMuZ2V0KF8pIHx8IGQzX3N2Z19saW5lTGluZWFyKS5rZXk7XG4gICAgICBpbnRlcnBvbGF0ZVJldmVyc2UgPSBpbnRlcnBvbGF0ZS5yZXZlcnNlIHx8IGludGVycG9sYXRlO1xuICAgICAgTCA9IGludGVycG9sYXRlLmNsb3NlZCA/IFwiTVwiIDogXCJMXCI7XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEudGVuc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRlbnNpb247XG4gICAgICB0ZW5zaW9uID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgcmV0dXJuIGFyZWE7XG4gIH1cbiAgZDNfc3ZnX2xpbmVTdGVwQmVmb3JlLnJldmVyc2UgPSBkM19zdmdfbGluZVN0ZXBBZnRlcjtcbiAgZDNfc3ZnX2xpbmVTdGVwQWZ0ZXIucmV2ZXJzZSA9IGQzX3N2Z19saW5lU3RlcEJlZm9yZTtcbiAgZDMuc3ZnLmFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc3ZnX2FyZWEoZDNfaWRlbnRpdHkpO1xuICB9O1xuICBkMy5zdmcuYXJlYS5yYWRpYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJlYSA9IGQzX3N2Z19hcmVhKGQzX3N2Z19saW5lUmFkaWFsKTtcbiAgICBhcmVhLnJhZGl1cyA9IGFyZWEueCwgZGVsZXRlIGFyZWEueDtcbiAgICBhcmVhLmlubmVyUmFkaXVzID0gYXJlYS54MCwgZGVsZXRlIGFyZWEueDA7XG4gICAgYXJlYS5vdXRlclJhZGl1cyA9IGFyZWEueDEsIGRlbGV0ZSBhcmVhLngxO1xuICAgIGFyZWEuYW5nbGUgPSBhcmVhLnksIGRlbGV0ZSBhcmVhLnk7XG4gICAgYXJlYS5zdGFydEFuZ2xlID0gYXJlYS55MCwgZGVsZXRlIGFyZWEueTA7XG4gICAgYXJlYS5lbmRBbmdsZSA9IGFyZWEueTEsIGRlbGV0ZSBhcmVhLnkxO1xuICAgIHJldHVybiBhcmVhO1xuICB9O1xuICBkMy5zdmcuY2hvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gZDNfc291cmNlLCB0YXJnZXQgPSBkM190YXJnZXQsIHJhZGl1cyA9IGQzX3N2Z19jaG9yZFJhZGl1cywgc3RhcnRBbmdsZSA9IGQzX3N2Z19hcmNTdGFydEFuZ2xlLCBlbmRBbmdsZSA9IGQzX3N2Z19hcmNFbmRBbmdsZTtcbiAgICBmdW5jdGlvbiBjaG9yZChkLCBpKSB7XG4gICAgICB2YXIgcyA9IHN1Ymdyb3VwKHRoaXMsIHNvdXJjZSwgZCwgaSksIHQgPSBzdWJncm91cCh0aGlzLCB0YXJnZXQsIGQsIGkpO1xuICAgICAgcmV0dXJuIFwiTVwiICsgcy5wMCArIGFyYyhzLnIsIHMucDEsIHMuYTEgLSBzLmEwKSArIChlcXVhbHMocywgdCkgPyBjdXJ2ZShzLnIsIHMucDEsIHMuciwgcy5wMCkgOiBjdXJ2ZShzLnIsIHMucDEsIHQuciwgdC5wMCkgKyBhcmModC5yLCB0LnAxLCB0LmExIC0gdC5hMCkgKyBjdXJ2ZSh0LnIsIHQucDEsIHMuciwgcy5wMCkpICsgXCJaXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1Ymdyb3VwKHNlbGYsIGYsIGQsIGkpIHtcbiAgICAgIHZhciBzdWJncm91cCA9IGYuY2FsbChzZWxmLCBkLCBpKSwgciA9IHJhZGl1cy5jYWxsKHNlbGYsIHN1Ymdyb3VwLCBpKSwgYTAgPSBzdGFydEFuZ2xlLmNhbGwoc2VsZiwgc3ViZ3JvdXAsIGkpIC0gaGFsZs+ALCBhMSA9IGVuZEFuZ2xlLmNhbGwoc2VsZiwgc3ViZ3JvdXAsIGkpIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogcixcbiAgICAgICAgYTA6IGEwLFxuICAgICAgICBhMTogYTEsXG4gICAgICAgIHAwOiBbIHIgKiBNYXRoLmNvcyhhMCksIHIgKiBNYXRoLnNpbihhMCkgXSxcbiAgICAgICAgcDE6IFsgciAqIE1hdGguY29zKGExKSwgciAqIE1hdGguc2luKGExKSBdXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgcmV0dXJuIGEuYTAgPT0gYi5hMCAmJiBhLmExID09IGIuYTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyYyhyLCBwLCBhKSB7XG4gICAgICByZXR1cm4gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCBcIiArICsoYSA+IM+AKSArIFwiLDEgXCIgKyBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXJ2ZShyMCwgcDAsIHIxLCBwMSkge1xuICAgICAgcmV0dXJuIFwiUSAwLDAgXCIgKyBwMTtcbiAgICB9XG4gICAgY2hvcmQucmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFkaXVzO1xuICAgICAgcmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvdXJjZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC50YXJnZXQgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXJ0QW5nbGU7XG4gICAgICBzdGFydEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLmVuZEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICByZXR1cm4gY2hvcmQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19jaG9yZFJhZGl1cyhkKSB7XG4gICAgcmV0dXJuIGQucmFkaXVzO1xuICB9XG4gIGQzLnN2Zy5kaWFnb25hbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSBkM19zb3VyY2UsIHRhcmdldCA9IGQzX3RhcmdldCwgcHJvamVjdGlvbiA9IGQzX3N2Z19kaWFnb25hbFByb2plY3Rpb247XG4gICAgZnVuY3Rpb24gZGlhZ29uYWwoZCwgaSkge1xuICAgICAgdmFyIHAwID0gc291cmNlLmNhbGwodGhpcywgZCwgaSksIHAzID0gdGFyZ2V0LmNhbGwodGhpcywgZCwgaSksIG0gPSAocDAueSArIHAzLnkpIC8gMiwgcCA9IFsgcDAsIHtcbiAgICAgICAgeDogcDAueCxcbiAgICAgICAgeTogbVxuICAgICAgfSwge1xuICAgICAgICB4OiBwMy54LFxuICAgICAgICB5OiBtXG4gICAgICB9LCBwMyBdO1xuICAgICAgcCA9IHAubWFwKHByb2plY3Rpb24pO1xuICAgICAgcmV0dXJuIFwiTVwiICsgcFswXSArIFwiQ1wiICsgcFsxXSArIFwiIFwiICsgcFsyXSArIFwiIFwiICsgcFszXTtcbiAgICB9XG4gICAgZGlhZ29uYWwuc291cmNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc291cmNlO1xuICAgICAgc291cmNlID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICB9O1xuICAgIGRpYWdvbmFsLnRhcmdldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHRhcmdldCA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICBkaWFnb25hbC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgIHByb2plY3Rpb24gPSB4O1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgcmV0dXJuIGRpYWdvbmFsO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfZGlhZ29uYWxQcm9qZWN0aW9uKGQpIHtcbiAgICByZXR1cm4gWyBkLngsIGQueSBdO1xuICB9XG4gIGQzLnN2Zy5kaWFnb25hbC5yYWRpYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlhZ29uYWwgPSBkMy5zdmcuZGlhZ29uYWwoKSwgcHJvamVjdGlvbiA9IGQzX3N2Z19kaWFnb25hbFByb2plY3Rpb24sIHByb2plY3Rpb25fID0gZGlhZ29uYWwucHJvamVjdGlvbjtcbiAgICBkaWFnb25hbC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBwcm9qZWN0aW9uXyhkM19zdmdfZGlhZ29uYWxSYWRpYWxQcm9qZWN0aW9uKHByb2plY3Rpb24gPSB4KSkgOiBwcm9qZWN0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIGRpYWdvbmFsO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfZGlhZ29uYWxSYWRpYWxQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZCA9IHByb2plY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgciA9IGRbMF0sIGEgPSBkWzFdIC0gaGFsZs+AO1xuICAgICAgcmV0dXJuIFsgciAqIE1hdGguY29zKGEpLCByICogTWF0aC5zaW4oYSkgXTtcbiAgICB9O1xuICB9XG4gIGQzLnN2Zy5zeW1ib2wgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHlwZSA9IGQzX3N2Z19zeW1ib2xUeXBlLCBzaXplID0gZDNfc3ZnX3N5bWJvbFNpemU7XG4gICAgZnVuY3Rpb24gc3ltYm9sKGQsIGkpIHtcbiAgICAgIHJldHVybiAoZDNfc3ZnX3N5bWJvbHMuZ2V0KHR5cGUuY2FsbCh0aGlzLCBkLCBpKSkgfHwgZDNfc3ZnX3N5bWJvbENpcmNsZSkoc2l6ZS5jYWxsKHRoaXMsIGQsIGkpKTtcbiAgICB9XG4gICAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0eXBlO1xuICAgICAgdHlwZSA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX3N5bWJvbFNpemUoKSB7XG4gICAgcmV0dXJuIDY0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19zeW1ib2xUeXBlKCkge1xuICAgIHJldHVybiBcImNpcmNsZVwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19zeW1ib2xDaXJjbGUoc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyDPgCk7XG4gICAgcmV0dXJuIFwiTTAsXCIgKyByICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCAxLDEgMCxcIiArIC1yICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCAxLDEgMCxcIiArIHIgKyBcIlpcIjtcbiAgfVxuICB2YXIgZDNfc3ZnX3N5bWJvbHMgPSBkMy5tYXAoe1xuICAgIGNpcmNsZTogZDNfc3ZnX3N5bWJvbENpcmNsZSxcbiAgICBjcm9zczogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHJldHVybiBcIk1cIiArIC0zICogciArIFwiLFwiICsgLXIgKyBcIkhcIiArIC1yICsgXCJWXCIgKyAtMyAqIHIgKyBcIkhcIiArIHIgKyBcIlZcIiArIC1yICsgXCJIXCIgKyAzICogciArIFwiVlwiICsgciArIFwiSFwiICsgciArIFwiVlwiICsgMyAqIHIgKyBcIkhcIiArIC1yICsgXCJWXCIgKyByICsgXCJIXCIgKyAtMyAqIHIgKyBcIlpcIjtcbiAgICB9LFxuICAgIGRpYW1vbmQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByeSA9IE1hdGguc3FydChzaXplIC8gKDIgKiBkM19zdmdfc3ltYm9sVGFuMzApKSwgcnggPSByeSAqIGQzX3N2Z19zeW1ib2xUYW4zMDtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgLXJ5ICsgXCJMXCIgKyByeCArIFwiLDBcIiArIFwiIDAsXCIgKyByeSArIFwiIFwiICsgLXJ4ICsgXCIsMFwiICsgXCJaXCI7XG4gICAgfSxcbiAgICBzcXVhcmU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUpIC8gMjtcbiAgICAgIHJldHVybiBcIk1cIiArIC1yICsgXCIsXCIgKyAtciArIFwiTFwiICsgciArIFwiLFwiICsgLXIgKyBcIiBcIiArIHIgKyBcIixcIiArIHIgKyBcIiBcIiArIC1yICsgXCIsXCIgKyByICsgXCJaXCI7XG4gICAgfSxcbiAgICBcInRyaWFuZ2xlLWRvd25cIjogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBkM19zdmdfc3ltYm9sU3FydDMpLCByeSA9IHJ4ICogZDNfc3ZnX3N5bWJvbFNxcnQzIC8gMjtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgcnkgKyBcIkxcIiArIHJ4ICsgXCIsXCIgKyAtcnkgKyBcIiBcIiArIC1yeCArIFwiLFwiICsgLXJ5ICsgXCJaXCI7XG4gICAgfSxcbiAgICBcInRyaWFuZ2xlLXVwXCI6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByeCA9IE1hdGguc3FydChzaXplIC8gZDNfc3ZnX3N5bWJvbFNxcnQzKSwgcnkgPSByeCAqIGQzX3N2Z19zeW1ib2xTcXJ0MyAvIDI7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIC1yeSArIFwiTFwiICsgcnggKyBcIixcIiArIHJ5ICsgXCIgXCIgKyAtcnggKyBcIixcIiArIHJ5ICsgXCJaXCI7XG4gICAgfVxuICB9KTtcbiAgZDMuc3ZnLnN5bWJvbFR5cGVzID0gZDNfc3ZnX3N5bWJvbHMua2V5cygpO1xuICB2YXIgZDNfc3ZnX3N5bWJvbFNxcnQzID0gTWF0aC5zcXJ0KDMpLCBkM19zdmdfc3ltYm9sVGFuMzAgPSBNYXRoLnRhbigzMCAqIGQzX3JhZGlhbnMpO1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaWQgPSBkM190cmFuc2l0aW9uSW5oZXJpdElkIHx8ICsrZDNfdHJhbnNpdGlvbklkLCBucyA9IGQzX3RyYW5zaXRpb25OYW1lc3BhY2UobmFtZSksIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgbm9kZSwgdHJhbnNpdGlvbiA9IGQzX3RyYW5zaXRpb25Jbmhlcml0IHx8IHtcbiAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICBlYXNlOiBkM19lYXNlX2N1YmljSW5PdXQsXG4gICAgICBkZWxheTogMCxcbiAgICAgIGR1cmF0aW9uOiAyNTBcbiAgICB9O1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBkM190cmFuc2l0aW9uTm9kZShub2RlLCBpLCBucywgaWQsIHRyYW5zaXRpb24pO1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZCk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChuYW1lID09IG51bGwgPyBkM19zZWxlY3Rpb25faW50ZXJydXB0IDogZDNfc2VsZWN0aW9uX2ludGVycnVwdE5TKGQzX3RyYW5zaXRpb25OYW1lc3BhY2UobmFtZSkpKTtcbiAgfTtcbiAgdmFyIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQgPSBkM19zZWxlY3Rpb25faW50ZXJydXB0TlMoZDNfdHJhbnNpdGlvbk5hbWVzcGFjZSgpKTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2ludGVycnVwdE5TKG5zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxvY2ssIGFjdGl2ZTtcbiAgICAgIGlmICgobG9jayA9IHRoaXNbbnNdKSAmJiAoYWN0aXZlID0gbG9ja1tsb2NrLmFjdGl2ZV0pKSB7XG4gICAgICAgIGlmICgtLWxvY2suY291bnQpIHtcbiAgICAgICAgICBkZWxldGUgbG9ja1tsb2NrLmFjdGl2ZV07XG4gICAgICAgICAgbG9jay5hY3RpdmUgKz0gLjU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXNbbnNdO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZS5ldmVudCAmJiBhY3RpdmUuZXZlbnQuaW50ZXJydXB0LmNhbGwodGhpcywgdGhpcy5fX2RhdGFfXywgYWN0aXZlLmluZGV4KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb24oZ3JvdXBzLCBucywgaWQpIHtcbiAgICBkM19zdWJjbGFzcyhncm91cHMsIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUpO1xuICAgIGdyb3Vwcy5uYW1lc3BhY2UgPSBucztcbiAgICBncm91cHMuaWQgPSBpZDtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG4gIHZhciBkM190cmFuc2l0aW9uUHJvdG90eXBlID0gW10sIGQzX3RyYW5zaXRpb25JZCA9IDAsIGQzX3RyYW5zaXRpb25Jbmhlcml0SWQsIGQzX3RyYW5zaXRpb25Jbmhlcml0O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmNhbGwgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2FsbDtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5lbXB0eSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5lbXB0eTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5ub2RlID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLm5vZGU7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc2l6ZSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5zaXplO1xuICBkMy50cmFuc2l0aW9uID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBuYW1lKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24udHJhbnNpdGlvbiA/IGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgPyBzZWxlY3Rpb24udHJhbnNpdGlvbihuYW1lKSA6IHNlbGVjdGlvbiA6IGQzX3NlbGVjdGlvblJvb3QudHJhbnNpdGlvbihzZWxlY3Rpb24pO1xuICB9O1xuICBkMy50cmFuc2l0aW9uLnByb3RvdHlwZSA9IGQzX3RyYW5zaXRpb25Qcm90b3R5cGU7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGUsIG5vZGU7XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSkge1xuICAgICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgICAgZDNfdHJhbnNpdGlvbk5vZGUoc3Vibm9kZSwgaSwgbnMsIGlkLCBub2RlW25zXVtpZF0pO1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2goc3Vibm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZCk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGVzLCBub2RlLCBzdWJub2RlLCB0cmFuc2l0aW9uO1xuICAgIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gbm9kZVtuc11baWRdO1xuICAgICAgICAgIHN1Ym5vZGVzID0gc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICAgICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gLTEsIG8gPSBzdWJub2Rlcy5sZW5ndGg7ICsrayA8IG87ICkge1xuICAgICAgICAgICAgaWYgKHN1Ym5vZGUgPSBzdWJub2Rlc1trXSkgZDNfdHJhbnNpdGlvbk5vZGUoc3Vibm9kZSwgaywgbnMsIGlkLCB0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIHN1Ymdyb3VwLnB1c2goc3Vibm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgbnMsIGlkKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBncm91cCwgbm9kZTtcbiAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkM19zZWxlY3Rpb25fZmlsdGVyKGZpbHRlcik7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSB0aGlzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBmaWx0ZXIuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLm5hbWVzcGFjZSwgdGhpcy5pZCk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUudHdlZW4gPSBmdW5jdGlvbihuYW1lLCB0d2Vlbikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS50d2Vlbi5nZXQobmFtZSk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIHR3ZWVuID09IG51bGwgPyBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4ucmVtb3ZlKG5hbWUpO1xuICAgIH0gOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4uc2V0KG5hbWUsIHR3ZWVuKTtcbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbl90d2Vlbihncm91cHMsIG5hbWUsIHZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBpZCA9IGdyb3Vwcy5pZCwgbnMgPSBncm91cHMubmFtZXNwYWNlO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaChncm91cHMsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgbm9kZVtuc11baWRdLnR3ZWVuLnNldChuYW1lLCB0d2Vlbih2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSk7XG4gICAgfSA6ICh2YWx1ZSA9IHR3ZWVuKHZhbHVlKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLnR3ZWVuLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfSkpO1xuICB9XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uKG5hbWVOUywgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZU5TKSB0aGlzLmF0dHIodmFsdWUsIG5hbWVOU1t2YWx1ZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBpbnRlcnBvbGF0ZSA9IG5hbWVOUyA9PSBcInRyYW5zZm9ybVwiID8gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBkM19pbnRlcnBvbGF0ZSwgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZU5TKTtcbiAgICBmdW5jdGlvbiBhdHRyTnVsbCgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyTnVsbE5TKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuKGIpIHtcbiAgICAgIHJldHVybiBiID09IG51bGwgPyBhdHRyTnVsbCA6IChiICs9IFwiXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpLCBpO1xuICAgICAgICByZXR1cm4gYSAhPT0gYiAmJiAoaSA9IGludGVycG9sYXRlKGEsIGIpLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgaSh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGIpIHtcbiAgICAgIHJldHVybiBiID09IG51bGwgPyBhdHRyTnVsbE5TIDogKGIgKz0gXCJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKSwgaTtcbiAgICAgICAgcmV0dXJuIGEgIT09IGIgJiYgKGkgPSBpbnRlcnBvbGF0ZShhLCBiKSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgaSh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uX3R3ZWVuKHRoaXMsIFwiYXR0ci5cIiArIG5hbWVOUywgdmFsdWUsIG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2Vlbik7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuYXR0clR3ZWVuID0gZnVuY3Rpb24obmFtZU5TLCB0d2Vlbikge1xuICAgIHZhciBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lTlMpO1xuICAgIGZ1bmN0aW9uIGF0dHJUd2VlbihkLCBpKSB7XG4gICAgICB2YXIgZiA9IHR3ZWVuLmNhbGwodGhpcywgZCwgaSwgdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSkpO1xuICAgICAgcmV0dXJuIGYgJiYgZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBmKHQpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGQsIGkpIHtcbiAgICAgIHZhciBmID0gdHdlZW4uY2FsbCh0aGlzLCBkLCBpLCB0aGlzLmdldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpKTtcbiAgICAgIHJldHVybiBmICYmIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCBmKHQpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnR3ZWVuKFwiYXR0ci5cIiArIG5hbWVOUywgbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDMpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobiA8IDIpIHZhbHVlID0gXCJcIjtcbiAgICAgICAgZm9yIChwcmlvcml0eSBpbiBuYW1lKSB0aGlzLnN0eWxlKHByaW9yaXR5LCBuYW1lW3ByaW9yaXR5XSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHByaW9yaXR5ID0gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGVOdWxsKCkge1xuICAgICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGVTdHJpbmcoYikge1xuICAgICAgcmV0dXJuIGIgPT0gbnVsbCA/IHN0eWxlTnVsbCA6IChiICs9IFwiXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IGQzX3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSksIGk7XG4gICAgICAgIHJldHVybiBhICE9PSBiICYmIChpID0gZDNfaW50ZXJwb2xhdGUoYSwgYiksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkodCksIHByaW9yaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb25fdHdlZW4odGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlLCBzdHlsZVN0cmluZyk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc3R5bGVUd2VlbiA9IGZ1bmN0aW9uKG5hbWUsIHR3ZWVuLCBwcmlvcml0eSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgcHJpb3JpdHkgPSBcIlwiO1xuICAgIGZ1bmN0aW9uIHN0eWxlVHdlZW4oZCwgaSkge1xuICAgICAgdmFyIGYgPSB0d2Vlbi5jYWxsKHRoaXMsIGQsIGksIGQzX3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICAgICAgcmV0dXJuIGYgJiYgZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGYodCksIHByaW9yaXR5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnR3ZWVuKFwic3R5bGUuXCIgKyBuYW1lLCBzdHlsZVR3ZWVuKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbl90d2Vlbih0aGlzLCBcInRleHRcIiwgdmFsdWUsIGQzX3RyYW5zaXRpb25fdGV4dCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb25fdGV4dChiKSB7XG4gICAgaWYgKGIgPT0gbnVsbCkgYiA9IFwiXCI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IGI7XG4gICAgfTtcbiAgfVxuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIHJldHVybiB0aGlzLmVhY2goXCJlbmQudHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwO1xuICAgICAgaWYgKHRoaXNbbnNdLmNvdW50IDwgMiAmJiAocCA9IHRoaXMucGFyZW50Tm9kZSkpIHAucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZWFzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLmVhc2U7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGQzLmVhc2UuYXBwbHkoZDMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5lYXNlID0gdmFsdWU7XG4gICAgfSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS5kZWxheTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBub2RlW25zXVtpZF0uZGVsYXkgPSArdmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICB9IDogKHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0uZGVsYXkgPSB2YWx1ZTtcbiAgICB9KSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS5kdXJhdGlvbjtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBub2RlW25zXVtpZF0uZHVyYXRpb24gPSBNYXRoLm1heCgxLCB2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKTtcbiAgICB9IDogKHZhbHVlID0gTWF0aC5tYXgoMSwgdmFsdWUpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0uZHVyYXRpb24gPSB2YWx1ZTtcbiAgICB9KSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHZhciBpbmhlcml0ID0gZDNfdHJhbnNpdGlvbkluaGVyaXQsIGluaGVyaXRJZCA9IGQzX3RyYW5zaXRpb25Jbmhlcml0SWQ7XG4gICAgICB0cnkge1xuICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdElkID0gaWQ7XG4gICAgICAgIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdCA9IG5vZGVbbnNdW2lkXTtcbiAgICAgICAgICB0eXBlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaik7XG4gICAgICAgIH0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDNfdHJhbnNpdGlvbkluaGVyaXQgPSBpbmhlcml0O1xuICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdElkID0gaW5oZXJpdElkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gbm9kZVtuc11baWRdO1xuICAgICAgICAodHJhbnNpdGlvbi5ldmVudCB8fCAodHJhbnNpdGlvbi5ldmVudCA9IGQzLmRpc3BhdGNoKFwic3RhcnRcIiwgXCJlbmRcIiwgXCJpbnRlcnJ1cHRcIikpKS5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZDAgPSB0aGlzLmlkLCBpZDEgPSArK2QzX3RyYW5zaXRpb25JZCwgbnMgPSB0aGlzLm5hbWVzcGFjZSwgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBncm91cCwgbm9kZSwgdHJhbnNpdGlvbjtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBub2RlW25zXVtpZDBdO1xuICAgICAgICAgIGQzX3RyYW5zaXRpb25Ob2RlKG5vZGUsIGksIG5zLCBpZDEsIHtcbiAgICAgICAgICAgIHRpbWU6IHRyYW5zaXRpb24udGltZSxcbiAgICAgICAgICAgIGVhc2U6IHRyYW5zaXRpb24uZWFzZSxcbiAgICAgICAgICAgIGRlbGF5OiB0cmFuc2l0aW9uLmRlbGF5ICsgdHJhbnNpdGlvbi5kdXJhdGlvbixcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0cmFuc2l0aW9uLmR1cmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCBucywgaWQxKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbk5hbWVzcGFjZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgPT0gbnVsbCA/IFwiX190cmFuc2l0aW9uX19cIiA6IFwiX190cmFuc2l0aW9uX1wiICsgbmFtZSArIFwiX19cIjtcbiAgfVxuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uTm9kZShub2RlLCBpLCBucywgaWQsIGluaGVyaXQpIHtcbiAgICB2YXIgbG9jayA9IG5vZGVbbnNdIHx8IChub2RlW25zXSA9IHtcbiAgICAgIGFjdGl2ZTogMCxcbiAgICAgIGNvdW50OiAwXG4gICAgfSksIHRyYW5zaXRpb24gPSBsb2NrW2lkXTtcbiAgICBpZiAoIXRyYW5zaXRpb24pIHtcbiAgICAgIHZhciB0aW1lID0gaW5oZXJpdC50aW1lO1xuICAgICAgdHJhbnNpdGlvbiA9IGxvY2tbaWRdID0ge1xuICAgICAgICB0d2VlbjogbmV3IGQzX01hcCgpLFxuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICBkZWxheTogaW5oZXJpdC5kZWxheSxcbiAgICAgICAgZHVyYXRpb246IGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZSxcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH07XG4gICAgICBpbmhlcml0ID0gbnVsbDtcbiAgICAgICsrbG9jay5jb3VudDtcbiAgICAgIGQzLnRpbWVyKGZ1bmN0aW9uKGVsYXBzZWQpIHtcbiAgICAgICAgdmFyIGRlbGF5ID0gdHJhbnNpdGlvbi5kZWxheSwgZHVyYXRpb24sIGVhc2UsIHRpbWVyID0gZDNfdGltZXJfYWN0aXZlLCB0d2VlbmVkID0gW107XG4gICAgICAgIHRpbWVyLnQgPSBkZWxheSArIHRpbWU7XG4gICAgICAgIGlmIChkZWxheSA8PSBlbGFwc2VkKSByZXR1cm4gc3RhcnQoZWxhcHNlZCAtIGRlbGF5KTtcbiAgICAgICAgdGltZXIuYyA9IHN0YXJ0O1xuICAgICAgICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgICAgICAgaWYgKGxvY2suYWN0aXZlID4gaWQpIHJldHVybiBzdG9wKCk7XG4gICAgICAgICAgdmFyIGFjdGl2ZSA9IGxvY2tbbG9jay5hY3RpdmVdO1xuICAgICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIC0tbG9jay5jb3VudDtcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NrW2xvY2suYWN0aXZlXTtcbiAgICAgICAgICAgIGFjdGl2ZS5ldmVudCAmJiBhY3RpdmUuZXZlbnQuaW50ZXJydXB0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgYWN0aXZlLmluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9jay5hY3RpdmUgPSBpZDtcbiAgICAgICAgICB0cmFuc2l0aW9uLmV2ZW50ICYmIHRyYW5zaXRpb24uZXZlbnQuc3RhcnQuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKTtcbiAgICAgICAgICB0cmFuc2l0aW9uLnR3ZWVuLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID0gdmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKSkge1xuICAgICAgICAgICAgICB0d2VlbmVkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVhc2UgPSB0cmFuc2l0aW9uLmVhc2U7XG4gICAgICAgICAgZHVyYXRpb24gPSB0cmFuc2l0aW9uLmR1cmF0aW9uO1xuICAgICAgICAgIGQzLnRpbWVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGltZXIuYyA9IHRpY2soZWxhcHNlZCB8fCAxKSA/IGQzX3RydWUgOiB0aWNrO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSwgMCwgdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgICAgICAgaWYgKGxvY2suYWN0aXZlICE9PSBpZCkgcmV0dXJuIDE7XG4gICAgICAgICAgdmFyIHQgPSBlbGFwc2VkIC8gZHVyYXRpb24sIGUgPSBlYXNlKHQpLCBuID0gdHdlZW5lZC5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgICB0d2VlbmVkWy0tbl0uY2FsbChub2RlLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbi5ldmVudCAmJiB0cmFuc2l0aW9uLmV2ZW50LmVuZC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICBpZiAoLS1sb2NrLmNvdW50KSBkZWxldGUgbG9ja1tpZF07IGVsc2UgZGVsZXRlIG5vZGVbbnNdO1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9LCAwLCB0aW1lKTtcbiAgICB9XG4gIH1cbiAgZDMuc3ZnLmF4aXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKSwgb3JpZW50ID0gZDNfc3ZnX2F4aXNEZWZhdWx0T3JpZW50LCBpbm5lclRpY2tTaXplID0gNiwgb3V0ZXJUaWNrU2l6ZSA9IDYsIHRpY2tQYWRkaW5nID0gMywgdGlja0FyZ3VtZW50c18gPSBbIDEwIF0sIHRpY2tWYWx1ZXMgPSBudWxsLCB0aWNrRm9ybWF0XztcbiAgICBmdW5jdGlvbiBheGlzKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGcgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgIHZhciBzY2FsZTAgPSB0aGlzLl9fY2hhcnRfXyB8fCBzY2FsZSwgc2NhbGUxID0gdGhpcy5fX2NoYXJ0X18gPSBzY2FsZS5jb3B5KCk7XG4gICAgICAgIHZhciB0aWNrcyA9IHRpY2tWYWx1ZXMgPT0gbnVsbCA/IHNjYWxlMS50aWNrcyA/IHNjYWxlMS50aWNrcy5hcHBseShzY2FsZTEsIHRpY2tBcmd1bWVudHNfKSA6IHNjYWxlMS5kb21haW4oKSA6IHRpY2tWYWx1ZXMsIHRpY2tGb3JtYXQgPSB0aWNrRm9ybWF0XyA9PSBudWxsID8gc2NhbGUxLnRpY2tGb3JtYXQgPyBzY2FsZTEudGlja0Zvcm1hdC5hcHBseShzY2FsZTEsIHRpY2tBcmd1bWVudHNfKSA6IGQzX2lkZW50aXR5IDogdGlja0Zvcm1hdF8sIHRpY2sgPSBnLnNlbGVjdEFsbChcIi50aWNrXCIpLmRhdGEodGlja3MsIHNjYWxlMSksIHRpY2tFbnRlciA9IHRpY2suZW50ZXIoKS5pbnNlcnQoXCJnXCIsIFwiLmRvbWFpblwiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpLnN0eWxlKFwib3BhY2l0eVwiLCDOtSksIHRpY2tFeGl0ID0gZDMudHJhbnNpdGlvbih0aWNrLmV4aXQoKSkuc3R5bGUoXCJvcGFjaXR5XCIsIM61KS5yZW1vdmUoKSwgdGlja1VwZGF0ZSA9IGQzLnRyYW5zaXRpb24odGljay5vcmRlcigpKS5zdHlsZShcIm9wYWNpdHlcIiwgMSksIHRpY2tTcGFjaW5nID0gTWF0aC5tYXgoaW5uZXJUaWNrU2l6ZSwgMCkgKyB0aWNrUGFkZGluZywgdGlja1RyYW5zZm9ybTtcbiAgICAgICAgdmFyIHJhbmdlID0gZDNfc2NhbGVSYW5nZShzY2FsZTEpLCBwYXRoID0gZy5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoWyAwIF0pLCBwYXRoVXBkYXRlID0gKHBhdGguZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKSwgXG4gICAgICAgIGQzLnRyYW5zaXRpb24ocGF0aCkpO1xuICAgICAgICB0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKTtcbiAgICAgICAgdGlja0VudGVyLmFwcGVuZChcInRleHRcIik7XG4gICAgICAgIHZhciBsaW5lRW50ZXIgPSB0aWNrRW50ZXIuc2VsZWN0KFwibGluZVwiKSwgbGluZVVwZGF0ZSA9IHRpY2tVcGRhdGUuc2VsZWN0KFwibGluZVwiKSwgdGV4dCA9IHRpY2suc2VsZWN0KFwidGV4dFwiKS50ZXh0KHRpY2tGb3JtYXQpLCB0ZXh0RW50ZXIgPSB0aWNrRW50ZXIuc2VsZWN0KFwidGV4dFwiKSwgdGV4dFVwZGF0ZSA9IHRpY2tVcGRhdGUuc2VsZWN0KFwidGV4dFwiKSwgc2lnbiA9IG9yaWVudCA9PT0gXCJ0b3BcIiB8fCBvcmllbnQgPT09IFwibGVmdFwiID8gLTEgOiAxLCB4MSwgeDIsIHkxLCB5MjtcbiAgICAgICAgaWYgKG9yaWVudCA9PT0gXCJib3R0b21cIiB8fCBvcmllbnQgPT09IFwidG9wXCIpIHtcbiAgICAgICAgICB0aWNrVHJhbnNmb3JtID0gZDNfc3ZnX2F4aXNYLCB4MSA9IFwieFwiLCB5MSA9IFwieVwiLCB4MiA9IFwieDJcIiwgeTIgPSBcInkyXCI7XG4gICAgICAgICAgdGV4dC5hdHRyKFwiZHlcIiwgc2lnbiA8IDAgPyBcIjBlbVwiIDogXCIuNzFlbVwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xuICAgICAgICAgIHBhdGhVcGRhdGUuYXR0cihcImRcIiwgXCJNXCIgKyByYW5nZVswXSArIFwiLFwiICsgc2lnbiAqIG91dGVyVGlja1NpemUgKyBcIlYwSFwiICsgcmFuZ2VbMV0gKyBcIlZcIiArIHNpZ24gKiBvdXRlclRpY2tTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWNrVHJhbnNmb3JtID0gZDNfc3ZnX2F4aXNZLCB4MSA9IFwieVwiLCB5MSA9IFwieFwiLCB4MiA9IFwieTJcIiwgeTIgPSBcIngyXCI7XG4gICAgICAgICAgdGV4dC5hdHRyKFwiZHlcIiwgXCIuMzJlbVwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIHNpZ24gPCAwID8gXCJlbmRcIiA6IFwic3RhcnRcIik7XG4gICAgICAgICAgcGF0aFVwZGF0ZS5hdHRyKFwiZFwiLCBcIk1cIiArIHNpZ24gKiBvdXRlclRpY2tTaXplICsgXCIsXCIgKyByYW5nZVswXSArIFwiSDBWXCIgKyByYW5nZVsxXSArIFwiSFwiICsgc2lnbiAqIG91dGVyVGlja1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVFbnRlci5hdHRyKHkyLCBzaWduICogaW5uZXJUaWNrU2l6ZSk7XG4gICAgICAgIHRleHRFbnRlci5hdHRyKHkxLCBzaWduICogdGlja1NwYWNpbmcpO1xuICAgICAgICBsaW5lVXBkYXRlLmF0dHIoeDIsIDApLmF0dHIoeTIsIHNpZ24gKiBpbm5lclRpY2tTaXplKTtcbiAgICAgICAgdGV4dFVwZGF0ZS5hdHRyKHgxLCAwKS5hdHRyKHkxLCBzaWduICogdGlja1NwYWNpbmcpO1xuICAgICAgICBpZiAoc2NhbGUxLnJhbmdlQmFuZCkge1xuICAgICAgICAgIHZhciB4ID0gc2NhbGUxLCBkeCA9IHgucmFuZ2VCYW5kKCkgLyAyO1xuICAgICAgICAgIHNjYWxlMCA9IHNjYWxlMSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB4KGQpICsgZHg7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2FsZTAucmFuZ2VCYW5kKSB7XG4gICAgICAgICAgc2NhbGUwID0gc2NhbGUxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpY2tFeGl0LmNhbGwodGlja1RyYW5zZm9ybSwgc2NhbGUxLCBzY2FsZTApO1xuICAgICAgICB9XG4gICAgICAgIHRpY2tFbnRlci5jYWxsKHRpY2tUcmFuc2Zvcm0sIHNjYWxlMCwgc2NhbGUxKTtcbiAgICAgICAgdGlja1VwZGF0ZS5jYWxsKHRpY2tUcmFuc2Zvcm0sIHNjYWxlMSwgc2NhbGUxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBheGlzLnNjYWxlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgICBzY2FsZSA9IHg7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZW50O1xuICAgICAgb3JpZW50ID0geCBpbiBkM19zdmdfYXhpc09yaWVudHMgPyB4ICsgXCJcIiA6IGQzX3N2Z19heGlzRGVmYXVsdE9yaWVudDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0FyZ3VtZW50c187XG4gICAgICB0aWNrQXJndW1lbnRzXyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrVmFsdWVzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1ZhbHVlcztcbiAgICAgIHRpY2tWYWx1ZXMgPSB4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tGb3JtYXQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0XztcbiAgICAgIHRpY2tGb3JtYXRfID0geDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbikgcmV0dXJuIGlubmVyVGlja1NpemU7XG4gICAgICBpbm5lclRpY2tTaXplID0gK3g7XG4gICAgICBvdXRlclRpY2tTaXplID0gK2FyZ3VtZW50c1tuIC0gMV07XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMuaW5uZXJUaWNrU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGlubmVyVGlja1NpemU7XG4gICAgICBpbm5lclRpY2tTaXplID0gK3g7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMub3V0ZXJUaWNrU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dGVyVGlja1NpemU7XG4gICAgICBvdXRlclRpY2tTaXplID0gK3g7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrUGFkZGluZztcbiAgICAgIHRpY2tQYWRkaW5nID0gK3g7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja1N1YmRpdmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggJiYgYXhpcztcbiAgICB9O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuICB2YXIgZDNfc3ZnX2F4aXNEZWZhdWx0T3JpZW50ID0gXCJib3R0b21cIiwgZDNfc3ZnX2F4aXNPcmllbnRzID0ge1xuICAgIHRvcDogMSxcbiAgICByaWdodDogMSxcbiAgICBib3R0b206IDEsXG4gICAgbGVmdDogMVxuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfYXhpc1goc2VsZWN0aW9uLCB4MCwgeDEpIHtcbiAgICBzZWxlY3Rpb24uYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgdjAgPSB4MChkKTtcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIChpc0Zpbml0ZSh2MCkgPyB2MCA6IHgxKGQpKSArIFwiLDApXCI7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2F4aXNZKHNlbGVjdGlvbiwgeTAsIHkxKSB7XG4gICAgc2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIHYwID0geTAoZCk7XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArIChpc0Zpbml0ZSh2MCkgPyB2MCA6IHkxKGQpKSArIFwiKVwiO1xuICAgIH0pO1xuICB9XG4gIGQzLnN2Zy5icnVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBldmVudCA9IGQzX2V2ZW50RGlzcGF0Y2goYnJ1c2gsIFwiYnJ1c2hzdGFydFwiLCBcImJydXNoXCIsIFwiYnJ1c2hlbmRcIiksIHggPSBudWxsLCB5ID0gbnVsbCwgeEV4dGVudCA9IFsgMCwgMCBdLCB5RXh0ZW50ID0gWyAwLCAwIF0sIHhFeHRlbnREb21haW4sIHlFeHRlbnREb21haW4sIHhDbGFtcCA9IHRydWUsIHlDbGFtcCA9IHRydWUsIHJlc2l6ZXMgPSBkM19zdmdfYnJ1c2hSZXNpemVzWzBdO1xuICAgIGZ1bmN0aW9uIGJydXNoKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGcgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKS5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIikub24oXCJtb3VzZWRvd24uYnJ1c2hcIiwgYnJ1c2hzdGFydCkub24oXCJ0b3VjaHN0YXJ0LmJydXNoXCIsIGJydXNoc3RhcnQpO1xuICAgICAgICB2YXIgYmFja2dyb3VuZCA9IGcuc2VsZWN0QWxsKFwiLmJhY2tncm91bmRcIikuZGF0YShbIDAgXSk7XG4gICAgICAgIGJhY2tncm91bmQuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIikuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpLnN0eWxlKFwiY3Vyc29yXCIsIFwiY3Jvc3NoYWlyXCIpO1xuICAgICAgICBnLnNlbGVjdEFsbChcIi5leHRlbnRcIikuZGF0YShbIDAgXSkuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBcImV4dGVudFwiKS5zdHlsZShcImN1cnNvclwiLCBcIm1vdmVcIik7XG4gICAgICAgIHZhciByZXNpemUgPSBnLnNlbGVjdEFsbChcIi5yZXNpemVcIikuZGF0YShyZXNpemVzLCBkM19pZGVudGl0eSk7XG4gICAgICAgIHJlc2l6ZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIHJlc2l6ZS5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gXCJyZXNpemUgXCIgKyBkO1xuICAgICAgICB9KS5zdHlsZShcImN1cnNvclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGQzX3N2Z19icnVzaEN1cnNvcltkXTtcbiAgICAgICAgfSkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwieFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIC9bZXddJC8udGVzdChkKSA/IC0zIDogbnVsbDtcbiAgICAgICAgfSkuYXR0cihcInlcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiAvXltuc10vLnRlc3QoZCkgPyAtMyA6IG51bGw7XG4gICAgICAgIH0pLmF0dHIoXCJ3aWR0aFwiLCA2KS5hdHRyKFwiaGVpZ2h0XCIsIDYpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgcmVzaXplLnN0eWxlKFwiZGlzcGxheVwiLCBicnVzaC5lbXB0eSgpID8gXCJub25lXCIgOiBudWxsKTtcbiAgICAgICAgdmFyIGdVcGRhdGUgPSBkMy50cmFuc2l0aW9uKGcpLCBiYWNrZ3JvdW5kVXBkYXRlID0gZDMudHJhbnNpdGlvbihiYWNrZ3JvdW5kKSwgcmFuZ2U7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHgpO1xuICAgICAgICAgIGJhY2tncm91bmRVcGRhdGUuYXR0cihcInhcIiwgcmFuZ2VbMF0pLmF0dHIoXCJ3aWR0aFwiLCByYW5nZVsxXSAtIHJhbmdlWzBdKTtcbiAgICAgICAgICByZWRyYXdYKGdVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHkpO1xuICAgICAgICAgIGJhY2tncm91bmRVcGRhdGUuYXR0cihcInlcIiwgcmFuZ2VbMF0pLmF0dHIoXCJoZWlnaHRcIiwgcmFuZ2VbMV0gLSByYW5nZVswXSk7XG4gICAgICAgICAgcmVkcmF3WShnVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZWRyYXcoZ1VwZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYnJ1c2guZXZlbnQgPSBmdW5jdGlvbihnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBldmVudF8gPSBldmVudC5vZih0aGlzLCBhcmd1bWVudHMpLCBleHRlbnQxID0ge1xuICAgICAgICAgIHg6IHhFeHRlbnQsXG4gICAgICAgICAgeTogeUV4dGVudCxcbiAgICAgICAgICBpOiB4RXh0ZW50RG9tYWluLFxuICAgICAgICAgIGo6IHlFeHRlbnREb21haW5cbiAgICAgICAgfSwgZXh0ZW50MCA9IHRoaXMuX19jaGFydF9fIHx8IGV4dGVudDE7XG4gICAgICAgIHRoaXMuX19jaGFydF9fID0gZXh0ZW50MTtcbiAgICAgICAgaWYgKGQzX3RyYW5zaXRpb25Jbmhlcml0SWQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmVhY2goXCJzdGFydC5icnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHhFeHRlbnREb21haW4gPSBleHRlbnQwLmk7XG4gICAgICAgICAgICB5RXh0ZW50RG9tYWluID0gZXh0ZW50MC5qO1xuICAgICAgICAgICAgeEV4dGVudCA9IGV4dGVudDAueDtcbiAgICAgICAgICAgIHlFeHRlbnQgPSBleHRlbnQwLnk7XG4gICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICB0eXBlOiBcImJydXNoc3RhcnRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkudHdlZW4oXCJicnVzaDpicnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB4aSA9IGQzX2ludGVycG9sYXRlQXJyYXkoeEV4dGVudCwgZXh0ZW50MS54KSwgeWkgPSBkM19pbnRlcnBvbGF0ZUFycmF5KHlFeHRlbnQsIGV4dGVudDEueSk7XG4gICAgICAgICAgICB4RXh0ZW50RG9tYWluID0geUV4dGVudERvbWFpbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICB4RXh0ZW50ID0gZXh0ZW50MS54ID0geGkodCk7XG4gICAgICAgICAgICAgIHlFeHRlbnQgPSBleHRlbnQxLnkgPSB5aSh0KTtcbiAgICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJydXNoXCIsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJyZXNpemVcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkuZWFjaChcImVuZC5icnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHhFeHRlbnREb21haW4gPSBleHRlbnQxLmk7XG4gICAgICAgICAgICB5RXh0ZW50RG9tYWluID0gZXh0ZW50MS5qO1xuICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgICBtb2RlOiBcInJlc2l6ZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hlbmRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hzdGFydFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgIG1vZGU6IFwicmVzaXplXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaGVuZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVkcmF3KGcpIHtcbiAgICAgIGcuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeEV4dGVudFsrL2UkLy50ZXN0KGQpXSArIFwiLFwiICsgeUV4dGVudFsrL15zLy50ZXN0KGQpXSArIFwiKVwiO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZHJhd1goZykge1xuICAgICAgZy5zZWxlY3QoXCIuZXh0ZW50XCIpLmF0dHIoXCJ4XCIsIHhFeHRlbnRbMF0pO1xuICAgICAgZy5zZWxlY3RBbGwoXCIuZXh0ZW50LC5uPnJlY3QsLnM+cmVjdFwiKS5hdHRyKFwid2lkdGhcIiwgeEV4dGVudFsxXSAtIHhFeHRlbnRbMF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWRyYXdZKGcpIHtcbiAgICAgIGcuc2VsZWN0KFwiLmV4dGVudFwiKS5hdHRyKFwieVwiLCB5RXh0ZW50WzBdKTtcbiAgICAgIGcuc2VsZWN0QWxsKFwiLmV4dGVudCwuZT5yZWN0LC53PnJlY3RcIikuYXR0cihcImhlaWdodFwiLCB5RXh0ZW50WzFdIC0geUV4dGVudFswXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJydXNoc3RhcnQoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcywgZXZlbnRUYXJnZXQgPSBkMy5zZWxlY3QoZDMuZXZlbnQudGFyZ2V0KSwgZXZlbnRfID0gZXZlbnQub2YodGFyZ2V0LCBhcmd1bWVudHMpLCBnID0gZDMuc2VsZWN0KHRhcmdldCksIHJlc2l6aW5nID0gZXZlbnRUYXJnZXQuZGF0dW0oKSwgcmVzaXppbmdYID0gIS9eKG58cykkLy50ZXN0KHJlc2l6aW5nKSAmJiB4LCByZXNpemluZ1kgPSAhL14oZXx3KSQvLnRlc3QocmVzaXppbmcpICYmIHksIGRyYWdnaW5nID0gZXZlbnRUYXJnZXQuY2xhc3NlZChcImV4dGVudFwiKSwgZHJhZ1Jlc3RvcmUgPSBkM19ldmVudF9kcmFnU3VwcHJlc3MoKSwgY2VudGVyLCBvcmlnaW4gPSBkMy5tb3VzZSh0YXJnZXQpLCBvZmZzZXQ7XG4gICAgICB2YXIgdyA9IGQzLnNlbGVjdChkM193aW5kb3cpLm9uKFwia2V5ZG93bi5icnVzaFwiLCBrZXlkb3duKS5vbihcImtleXVwLmJydXNoXCIsIGtleXVwKTtcbiAgICAgIGlmIChkMy5ldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICB3Lm9uKFwidG91Y2htb3ZlLmJydXNoXCIsIGJydXNobW92ZSkub24oXCJ0b3VjaGVuZC5icnVzaFwiLCBicnVzaGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lm9uKFwibW91c2Vtb3ZlLmJydXNoXCIsIGJydXNobW92ZSkub24oXCJtb3VzZXVwLmJydXNoXCIsIGJydXNoZW5kKTtcbiAgICAgIH1cbiAgICAgIGcuaW50ZXJydXB0KCkuc2VsZWN0QWxsKFwiKlwiKS5pbnRlcnJ1cHQoKTtcbiAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICBvcmlnaW5bMF0gPSB4RXh0ZW50WzBdIC0gb3JpZ2luWzBdO1xuICAgICAgICBvcmlnaW5bMV0gPSB5RXh0ZW50WzBdIC0gb3JpZ2luWzFdO1xuICAgICAgfSBlbHNlIGlmIChyZXNpemluZykge1xuICAgICAgICB2YXIgZXggPSArL3ckLy50ZXN0KHJlc2l6aW5nKSwgZXkgPSArL15uLy50ZXN0KHJlc2l6aW5nKTtcbiAgICAgICAgb2Zmc2V0ID0gWyB4RXh0ZW50WzEgLSBleF0gLSBvcmlnaW5bMF0sIHlFeHRlbnRbMSAtIGV5XSAtIG9yaWdpblsxXSBdO1xuICAgICAgICBvcmlnaW5bMF0gPSB4RXh0ZW50W2V4XTtcbiAgICAgICAgb3JpZ2luWzFdID0geUV4dGVudFtleV07XG4gICAgICB9IGVsc2UgaWYgKGQzLmV2ZW50LmFsdEtleSkgY2VudGVyID0gb3JpZ2luLnNsaWNlKCk7XG4gICAgICBnLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpLnNlbGVjdEFsbChcIi5yZXNpemVcIikuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpO1xuICAgICAgZDMuc2VsZWN0KFwiYm9keVwiKS5zdHlsZShcImN1cnNvclwiLCBldmVudFRhcmdldC5zdHlsZShcImN1cnNvclwiKSk7XG4gICAgICBldmVudF8oe1xuICAgICAgICB0eXBlOiBcImJydXNoc3RhcnRcIlxuICAgICAgfSk7XG4gICAgICBicnVzaG1vdmUoKTtcbiAgICAgIGZ1bmN0aW9uIGtleWRvd24oKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC5rZXlDb2RlID09IDMyKSB7XG4gICAgICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICAgICAgY2VudGVyID0gbnVsbDtcbiAgICAgICAgICAgIG9yaWdpblswXSAtPSB4RXh0ZW50WzFdO1xuICAgICAgICAgICAgb3JpZ2luWzFdIC09IHlFeHRlbnRbMV07XG4gICAgICAgICAgICBkcmFnZ2luZyA9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24ga2V5dXAoKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC5rZXlDb2RlID09IDMyICYmIGRyYWdnaW5nID09IDIpIHtcbiAgICAgICAgICBvcmlnaW5bMF0gKz0geEV4dGVudFsxXTtcbiAgICAgICAgICBvcmlnaW5bMV0gKz0geUV4dGVudFsxXTtcbiAgICAgICAgICBkcmFnZ2luZyA9IDA7XG4gICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBicnVzaG1vdmUoKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGQzLm1vdXNlKHRhcmdldCksIG1vdmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICBwb2ludFswXSArPSBvZmZzZXRbMF07XG4gICAgICAgICAgcG9pbnRbMV0gKz0gb2Zmc2V0WzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgICAgICBpZiAoZDMuZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICBpZiAoIWNlbnRlcikgY2VudGVyID0gWyAoeEV4dGVudFswXSArIHhFeHRlbnRbMV0pIC8gMiwgKHlFeHRlbnRbMF0gKyB5RXh0ZW50WzFdKSAvIDIgXTtcbiAgICAgICAgICAgIG9yaWdpblswXSA9IHhFeHRlbnRbKyhwb2ludFswXSA8IGNlbnRlclswXSldO1xuICAgICAgICAgICAgb3JpZ2luWzFdID0geUV4dGVudFsrKHBvaW50WzFdIDwgY2VudGVyWzFdKV07XG4gICAgICAgICAgfSBlbHNlIGNlbnRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2l6aW5nWCAmJiBtb3ZlMShwb2ludCwgeCwgMCkpIHtcbiAgICAgICAgICByZWRyYXdYKGcpO1xuICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzaXppbmdZICYmIG1vdmUxKHBvaW50LCB5LCAxKSkge1xuICAgICAgICAgIHJlZHJhd1koZyk7XG4gICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICAgIHJlZHJhdyhnKTtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgbW9kZTogZHJhZ2dpbmcgPyBcIm1vdmVcIiA6IFwicmVzaXplXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbW92ZTEocG9pbnQsIHNjYWxlLCBpKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGQzX3NjYWxlUmFuZ2Uoc2NhbGUpLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdLCBwb3NpdGlvbiA9IG9yaWdpbltpXSwgZXh0ZW50ID0gaSA/IHlFeHRlbnQgOiB4RXh0ZW50LCBzaXplID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdLCBtaW4sIG1heDtcbiAgICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgICAgcjAgLT0gcG9zaXRpb247XG4gICAgICAgICAgcjEgLT0gc2l6ZSArIHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIG1pbiA9IChpID8geUNsYW1wIDogeENsYW1wKSA/IE1hdGgubWF4KHIwLCBNYXRoLm1pbihyMSwgcG9pbnRbaV0pKSA6IHBvaW50W2ldO1xuICAgICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgICBtYXggPSAobWluICs9IHBvc2l0aW9uKSArIHNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNlbnRlcikgcG9zaXRpb24gPSBNYXRoLm1heChyMCwgTWF0aC5taW4ocjEsIDIgKiBjZW50ZXJbaV0gLSBtaW4pKTtcbiAgICAgICAgICBpZiAocG9zaXRpb24gPCBtaW4pIHtcbiAgICAgICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgICAgIG1pbiA9IHBvc2l0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXggPSBwb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVudFswXSAhPSBtaW4gfHwgZXh0ZW50WzFdICE9IG1heCkge1xuICAgICAgICAgIGlmIChpKSB5RXh0ZW50RG9tYWluID0gbnVsbDsgZWxzZSB4RXh0ZW50RG9tYWluID0gbnVsbDtcbiAgICAgICAgICBleHRlbnRbMF0gPSBtaW47XG4gICAgICAgICAgZXh0ZW50WzFdID0gbWF4O1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBicnVzaGVuZCgpIHtcbiAgICAgICAgYnJ1c2htb3ZlKCk7XG4gICAgICAgIGcuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKS5zZWxlY3RBbGwoXCIucmVzaXplXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBicnVzaC5lbXB0eSgpID8gXCJub25lXCIgOiBudWxsKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiYm9keVwiKS5zdHlsZShcImN1cnNvclwiLCBudWxsKTtcbiAgICAgICAgdy5vbihcIm1vdXNlbW92ZS5icnVzaFwiLCBudWxsKS5vbihcIm1vdXNldXAuYnJ1c2hcIiwgbnVsbCkub24oXCJ0b3VjaG1vdmUuYnJ1c2hcIiwgbnVsbCkub24oXCJ0b3VjaGVuZC5icnVzaFwiLCBudWxsKS5vbihcImtleWRvd24uYnJ1c2hcIiwgbnVsbCkub24oXCJrZXl1cC5icnVzaFwiLCBudWxsKTtcbiAgICAgICAgZHJhZ1Jlc3RvcmUoKTtcbiAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICB0eXBlOiBcImJydXNoZW5kXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGJydXNoLnggPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgICAgeCA9IHo7XG4gICAgICByZXNpemVzID0gZDNfc3ZnX2JydXNoUmVzaXplc1sheCA8PCAxIHwgIXldO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2gueSA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHk7XG4gICAgICB5ID0gejtcbiAgICAgIHJlc2l6ZXMgPSBkM19zdmdfYnJ1c2hSZXNpemVzWyF4IDw8IDEgfCAheV07XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC5jbGFtcCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHggJiYgeSA/IFsgeENsYW1wLCB5Q2xhbXAgXSA6IHggPyB4Q2xhbXAgOiB5ID8geUNsYW1wIDogbnVsbDtcbiAgICAgIGlmICh4ICYmIHkpIHhDbGFtcCA9ICEhelswXSwgeUNsYW1wID0gISF6WzFdOyBlbHNlIGlmICh4KSB4Q2xhbXAgPSAhIXo7IGVsc2UgaWYgKHkpIHlDbGFtcCA9ICEhejtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmV4dGVudCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIHZhciB4MCwgeDEsIHkwLCB5MSwgdDtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIGlmICh4RXh0ZW50RG9tYWluKSB7XG4gICAgICAgICAgICB4MCA9IHhFeHRlbnREb21haW5bMF0sIHgxID0geEV4dGVudERvbWFpblsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeDAgPSB4RXh0ZW50WzBdLCB4MSA9IHhFeHRlbnRbMV07XG4gICAgICAgICAgICBpZiAoeC5pbnZlcnQpIHgwID0geC5pbnZlcnQoeDApLCB4MSA9IHguaW52ZXJ0KHgxKTtcbiAgICAgICAgICAgIGlmICh4MSA8IHgwKSB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICBpZiAoeUV4dGVudERvbWFpbikge1xuICAgICAgICAgICAgeTAgPSB5RXh0ZW50RG9tYWluWzBdLCB5MSA9IHlFeHRlbnREb21haW5bMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkwID0geUV4dGVudFswXSwgeTEgPSB5RXh0ZW50WzFdO1xuICAgICAgICAgICAgaWYgKHkuaW52ZXJ0KSB5MCA9IHkuaW52ZXJ0KHkwKSwgeTEgPSB5LmludmVydCh5MSk7XG4gICAgICAgICAgICBpZiAoeTEgPCB5MCkgdCA9IHkwLCB5MCA9IHkxLCB5MSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4ICYmIHkgPyBbIFsgeDAsIHkwIF0sIFsgeDEsIHkxIF0gXSA6IHggPyBbIHgwLCB4MSBdIDogeSAmJiBbIHkwLCB5MSBdO1xuICAgICAgfVxuICAgICAgaWYgKHgpIHtcbiAgICAgICAgeDAgPSB6WzBdLCB4MSA9IHpbMV07XG4gICAgICAgIGlmICh5KSB4MCA9IHgwWzBdLCB4MSA9IHgxWzBdO1xuICAgICAgICB4RXh0ZW50RG9tYWluID0gWyB4MCwgeDEgXTtcbiAgICAgICAgaWYgKHguaW52ZXJ0KSB4MCA9IHgoeDApLCB4MSA9IHgoeDEpO1xuICAgICAgICBpZiAoeDEgPCB4MCkgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gICAgICAgIGlmICh4MCAhPSB4RXh0ZW50WzBdIHx8IHgxICE9IHhFeHRlbnRbMV0pIHhFeHRlbnQgPSBbIHgwLCB4MSBdO1xuICAgICAgfVxuICAgICAgaWYgKHkpIHtcbiAgICAgICAgeTAgPSB6WzBdLCB5MSA9IHpbMV07XG4gICAgICAgIGlmICh4KSB5MCA9IHkwWzFdLCB5MSA9IHkxWzFdO1xuICAgICAgICB5RXh0ZW50RG9tYWluID0gWyB5MCwgeTEgXTtcbiAgICAgICAgaWYgKHkuaW52ZXJ0KSB5MCA9IHkoeTApLCB5MSA9IHkoeTEpO1xuICAgICAgICBpZiAoeTEgPCB5MCkgdCA9IHkwLCB5MCA9IHkxLCB5MSA9IHQ7XG4gICAgICAgIGlmICh5MCAhPSB5RXh0ZW50WzBdIHx8IHkxICE9IHlFeHRlbnRbMV0pIHlFeHRlbnQgPSBbIHkwLCB5MSBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghYnJ1c2guZW1wdHkoKSkge1xuICAgICAgICB4RXh0ZW50ID0gWyAwLCAwIF0sIHlFeHRlbnQgPSBbIDAsIDAgXTtcbiAgICAgICAgeEV4dGVudERvbWFpbiA9IHlFeHRlbnREb21haW4gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXggJiYgeEV4dGVudFswXSA9PSB4RXh0ZW50WzFdIHx8ICEheSAmJiB5RXh0ZW50WzBdID09IHlFeHRlbnRbMV07XG4gICAgfTtcbiAgICByZXR1cm4gZDMucmViaW5kKGJydXNoLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgdmFyIGQzX3N2Z19icnVzaEN1cnNvciA9IHtcbiAgICBuOiBcIm5zLXJlc2l6ZVwiLFxuICAgIGU6IFwiZXctcmVzaXplXCIsXG4gICAgczogXCJucy1yZXNpemVcIixcbiAgICB3OiBcImV3LXJlc2l6ZVwiLFxuICAgIG53OiBcIm53c2UtcmVzaXplXCIsXG4gICAgbmU6IFwibmVzdy1yZXNpemVcIixcbiAgICBzZTogXCJud3NlLXJlc2l6ZVwiLFxuICAgIHN3OiBcIm5lc3ctcmVzaXplXCJcbiAgfTtcbiAgdmFyIGQzX3N2Z19icnVzaFJlc2l6ZXMgPSBbIFsgXCJuXCIsIFwiZVwiLCBcInNcIiwgXCJ3XCIsIFwibndcIiwgXCJuZVwiLCBcInNlXCIsIFwic3dcIiBdLCBbIFwiZVwiLCBcIndcIiBdLCBbIFwiblwiLCBcInNcIiBdLCBbXSBdO1xuICB2YXIgZDNfdGltZV9mb3JtYXQgPSBkM190aW1lLmZvcm1hdCA9IGQzX2xvY2FsZV9lblVTLnRpbWVGb3JtYXQ7XG4gIHZhciBkM190aW1lX2Zvcm1hdFV0YyA9IGQzX3RpbWVfZm9ybWF0LnV0YztcbiAgdmFyIGQzX3RpbWVfZm9ybWF0SXNvID0gZDNfdGltZV9mb3JtYXRVdGMoXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIik7XG4gIGQzX3RpbWVfZm9ybWF0LmlzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmICtuZXcgRGF0ZShcIjIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKSA/IGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlIDogZDNfdGltZV9mb3JtYXRJc287XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xuICB9XG4gIGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcpO1xuICAgIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xuICB9O1xuICBkM190aW1lX2Zvcm1hdElzb05hdGl2ZS50b1N0cmluZyA9IGQzX3RpbWVfZm9ybWF0SXNvLnRvU3RyaW5nO1xuICBkM190aW1lLnNlY29uZCA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBuZXcgZDNfZGF0ZShNYXRoLmZsb29yKGRhdGUgLyAxZTMpICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFNlY29uZHMoKTtcbiAgfSk7XG4gIGQzX3RpbWUuc2Vjb25kcyA9IGQzX3RpbWUuc2Vjb25kLnJhbmdlO1xuICBkM190aW1lLnNlY29uZHMudXRjID0gZDNfdGltZS5zZWNvbmQudXRjLnJhbmdlO1xuICBkM190aW1lLm1pbnV0ZSA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBuZXcgZDNfZGF0ZShNYXRoLmZsb29yKGRhdGUgLyA2ZTQpICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbiAgfSk7XG4gIGQzX3RpbWUubWludXRlcyA9IGQzX3RpbWUubWludXRlLnJhbmdlO1xuICBkM190aW1lLm1pbnV0ZXMudXRjID0gZDNfdGltZS5taW51dGUudXRjLnJhbmdlO1xuICBkM190aW1lLmhvdXIgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgdGltZXpvbmUgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLyA2MDtcbiAgICByZXR1cm4gbmV3IGQzX2RhdGUoKE1hdGguZmxvb3IoZGF0ZSAvIDM2ZTUgLSB0aW1lem9uZSkgKyB0aW1lem9uZSkgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogMzZlNSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRIb3VycygpO1xuICB9KTtcbiAgZDNfdGltZS5ob3VycyA9IGQzX3RpbWUuaG91ci5yYW5nZTtcbiAgZDNfdGltZS5ob3Vycy51dGMgPSBkM190aW1lLmhvdXIudXRjLnJhbmdlO1xuICBkM190aW1lLm1vbnRoID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZSA9IGQzX3RpbWUuZGF5KGRhdGUpO1xuICAgIGRhdGUuc2V0RGF0ZSgxKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcbiAgfSk7XG4gIGQzX3RpbWUubW9udGhzID0gZDNfdGltZS5tb250aC5yYW5nZTtcbiAgZDNfdGltZS5tb250aHMudXRjID0gZDNfdGltZS5tb250aC51dGMucmFuZ2U7XG4gIGZ1bmN0aW9uIGQzX3RpbWVfc2NhbGUobGluZWFyLCBtZXRob2RzLCBmb3JtYXQpIHtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gbGluZWFyKHgpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9zY2FsZURhdGUobGluZWFyLmludmVydCh4KSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsaW5lYXIuZG9tYWluKCkubWFwKGQzX3RpbWVfc2NhbGVEYXRlKTtcbiAgICAgIGxpbmVhci5kb21haW4oeCk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB0aWNrTWV0aG9kKGV4dGVudCwgY291bnQpIHtcbiAgICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdLCB0YXJnZXQgPSBzcGFuIC8gY291bnQsIGkgPSBkMy5iaXNlY3QoZDNfdGltZV9zY2FsZVN0ZXBzLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuIGkgPT0gZDNfdGltZV9zY2FsZVN0ZXBzLmxlbmd0aCA/IFsgbWV0aG9kcy55ZWFyLCBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZXh0ZW50Lm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkIC8gMzE1MzZlNjtcbiAgICAgIH0pLCBjb3VudClbMl0gXSA6ICFpID8gWyBkM190aW1lX3NjYWxlTWlsbGlzZWNvbmRzLCBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZXh0ZW50LCBjb3VudClbMl0gXSA6IG1ldGhvZHNbdGFyZ2V0IC8gZDNfdGltZV9zY2FsZVN0ZXBzW2kgLSAxXSA8IGQzX3RpbWVfc2NhbGVTdGVwc1tpXSAvIHRhcmdldCA/IGkgLSAxIDogaV07XG4gICAgfVxuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCwgc2tpcCkge1xuICAgICAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpLCBleHRlbnQgPSBkM19zY2FsZUV4dGVudChkb21haW4pLCBtZXRob2QgPSBpbnRlcnZhbCA9PSBudWxsID8gdGlja01ldGhvZChleHRlbnQsIDEwKSA6IHR5cGVvZiBpbnRlcnZhbCA9PT0gXCJudW1iZXJcIiAmJiB0aWNrTWV0aG9kKGV4dGVudCwgaW50ZXJ2YWwpO1xuICAgICAgaWYgKG1ldGhvZCkgaW50ZXJ2YWwgPSBtZXRob2RbMF0sIHNraXAgPSBtZXRob2RbMV07XG4gICAgICBmdW5jdGlvbiBza2lwcGVkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihkYXRlKSAmJiAhaW50ZXJ2YWwucmFuZ2UoZGF0ZSwgZDNfdGltZV9zY2FsZURhdGUoK2RhdGUgKyAxKSwgc2tpcCkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjYWxlLmRvbWFpbihkM19zY2FsZV9uaWNlKGRvbWFpbiwgc2tpcCA+IDEgPyB7XG4gICAgICAgIGZsb29yOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgd2hpbGUgKHNraXBwZWQoZGF0ZSA9IGludGVydmFsLmZsb29yKGRhdGUpKSkgZGF0ZSA9IGQzX3RpbWVfc2NhbGVEYXRlKGRhdGUgLSAxKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2VpbDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgIHdoaWxlIChza2lwcGVkKGRhdGUgPSBpbnRlcnZhbC5jZWlsKGRhdGUpKSkgZGF0ZSA9IGQzX3RpbWVfc2NhbGVEYXRlKCtkYXRlICsgMSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gOiBpbnRlcnZhbCkpO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc2tpcCkge1xuICAgICAgdmFyIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KHNjYWxlLmRvbWFpbigpKSwgbWV0aG9kID0gaW50ZXJ2YWwgPT0gbnVsbCA/IHRpY2tNZXRob2QoZXh0ZW50LCAxMCkgOiB0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIgPyB0aWNrTWV0aG9kKGV4dGVudCwgaW50ZXJ2YWwpIDogIWludGVydmFsLnJhbmdlICYmIFsge1xuICAgICAgICByYW5nZTogaW50ZXJ2YWxcbiAgICAgIH0sIHNraXAgXTtcbiAgICAgIGlmIChtZXRob2QpIGludGVydmFsID0gbWV0aG9kWzBdLCBza2lwID0gbWV0aG9kWzFdO1xuICAgICAgcmV0dXJuIGludGVydmFsLnJhbmdlKGV4dGVudFswXSwgZDNfdGltZV9zY2FsZURhdGUoK2V4dGVudFsxXSArIDEpLCBza2lwIDwgMSA/IDEgOiBza2lwKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9zY2FsZShsaW5lYXIuY29weSgpLCBtZXRob2RzLCBmb3JtYXQpO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3NjYWxlRGF0ZSh0KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHQpO1xuICB9XG4gIHZhciBkM190aW1lX3NjYWxlU3RlcHMgPSBbIDFlMywgNWUzLCAxNWUzLCAzZTQsIDZlNCwgM2U1LCA5ZTUsIDE4ZTUsIDM2ZTUsIDEwOGU1LCAyMTZlNSwgNDMyZTUsIDg2NGU1LCAxNzI4ZTUsIDYwNDhlNSwgMjU5MmU2LCA3Nzc2ZTYsIDMxNTM2ZTYgXTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMgPSBbIFsgZDNfdGltZS5zZWNvbmQsIDEgXSwgWyBkM190aW1lLnNlY29uZCwgNSBdLCBbIGQzX3RpbWUuc2Vjb25kLCAxNSBdLCBbIGQzX3RpbWUuc2Vjb25kLCAzMCBdLCBbIGQzX3RpbWUubWludXRlLCAxIF0sIFsgZDNfdGltZS5taW51dGUsIDUgXSwgWyBkM190aW1lLm1pbnV0ZSwgMTUgXSwgWyBkM190aW1lLm1pbnV0ZSwgMzAgXSwgWyBkM190aW1lLmhvdXIsIDEgXSwgWyBkM190aW1lLmhvdXIsIDMgXSwgWyBkM190aW1lLmhvdXIsIDYgXSwgWyBkM190aW1lLmhvdXIsIDEyIF0sIFsgZDNfdGltZS5kYXksIDEgXSwgWyBkM190aW1lLmRheSwgMiBdLCBbIGQzX3RpbWUud2VlaywgMSBdLCBbIGQzX3RpbWUubW9udGgsIDEgXSwgWyBkM190aW1lLm1vbnRoLCAzIF0sIFsgZDNfdGltZS55ZWFyLCAxIF0gXTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVMb2NhbEZvcm1hdCA9IGQzX3RpbWVfZm9ybWF0Lm11bHRpKFsgWyBcIi4lTFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIH0gXSwgWyBcIjolU1wiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0U2Vjb25kcygpO1xuICB9IF0sIFsgXCIlSTolTVwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0TWludXRlcygpO1xuICB9IF0sIFsgXCIlSSAlcFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0SG91cnMoKTtcbiAgfSBdLCBbIFwiJWEgJWRcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldERheSgpICYmIGQuZ2V0RGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiViICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXREYXRlKCkgIT0gMTtcbiAgfSBdLCBbIFwiJUJcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldE1vbnRoKCk7XG4gIH0gXSwgWyBcIiVZXCIsIGQzX3RydWUgXSBdKTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVNaWxsaXNlY29uZHMgPSB7XG4gICAgcmFuZ2U6IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICByZXR1cm4gZDMucmFuZ2UoTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCkgKiBzdGVwLCArc3RvcCwgc3RlcCkubWFwKGQzX3RpbWVfc2NhbGVEYXRlKTtcbiAgICB9LFxuICAgIGZsb29yOiBkM19pZGVudGl0eSxcbiAgICBjZWlsOiBkM19pZGVudGl0eVxuICB9O1xuICBkM190aW1lX3NjYWxlTG9jYWxNZXRob2RzLnllYXIgPSBkM190aW1lLnllYXI7XG4gIGQzX3RpbWUuc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfdGltZV9zY2FsZShkMy5zY2FsZS5saW5lYXIoKSwgZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcywgZDNfdGltZV9zY2FsZUxvY2FsRm9ybWF0KTtcbiAgfTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVVdGNNZXRob2RzID0gZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcy5tYXAoZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBbIG1bMF0udXRjLCBtWzFdIF07XG4gIH0pO1xuICB2YXIgZDNfdGltZV9zY2FsZVV0Y0Zvcm1hdCA9IGQzX3RpbWVfZm9ybWF0VXRjLm11bHRpKFsgWyBcIi4lTFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIH0gXSwgWyBcIjolU1wiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDU2Vjb25kcygpO1xuICB9IF0sIFsgXCIlSTolTVwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDTWludXRlcygpO1xuICB9IF0sIFsgXCIlSSAlcFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDSG91cnMoKTtcbiAgfSBdLCBbIFwiJWEgJWRcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0RheSgpICYmIGQuZ2V0VVRDRGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiViICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENEYXRlKCkgIT0gMTtcbiAgfSBdLCBbIFwiJUJcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ01vbnRoKCk7XG4gIH0gXSwgWyBcIiVZXCIsIGQzX3RydWUgXSBdKTtcbiAgZDNfdGltZV9zY2FsZVV0Y01ldGhvZHMueWVhciA9IGQzX3RpbWUueWVhci51dGM7XG4gIGQzX3RpbWUuc2NhbGUudXRjID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3RpbWVfc2NhbGUoZDMuc2NhbGUubGluZWFyKCksIGQzX3RpbWVfc2NhbGVVdGNNZXRob2RzLCBkM190aW1lX3NjYWxlVXRjRm9ybWF0KTtcbiAgfTtcbiAgZDMudGV4dCA9IGQzX3hoclR5cGUoZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHJldHVybiByZXF1ZXN0LnJlc3BvbnNlVGV4dDtcbiAgfSk7XG4gIGQzLmpzb24gPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGQzX3hocih1cmwsIFwiYXBwbGljYXRpb24vanNvblwiLCBkM19qc29uLCBjYWxsYmFjayk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2pzb24ocmVxdWVzdCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgfVxuICBkMy5odG1sID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBkM194aHIodXJsLCBcInRleHQvaHRtbFwiLCBkM19odG1sLCBjYWxsYmFjayk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2h0bWwocmVxdWVzdCkge1xuICAgIHZhciByYW5nZSA9IGQzX2RvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZShkM19kb2N1bWVudC5ib2R5KTtcbiAgICByZXR1cm4gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgfVxuICBkMy54bWwgPSBkM194aHJUeXBlKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVhNTDtcbiAgfSk7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGQzKTsgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkMztcbiAgdGhpcy5kMyA9IGQzO1xufSgpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvZDMvZDMuanNcIixcIi9ub2RlX21vZHVsZXMvZDNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCBpZiBicm93c2VyIHN1cHBvcnRzIFR5cGVkIEFycmF5cy4gU3VwcG9ydGVkIGJyb3dzZXJzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssXG4gIC8vIENocm9tZSA3KywgU2FmYXJpIDUuMSssIE9wZXJhIDExLjYrLCBpT1MgNC4yKy4gSWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhZGRpbmdcbiAgLy8gcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLCB0aGVuIHRoYXQncyB0aGUgc2FtZSBhcyBubyBgVWludDhBcnJheWAgc3VwcG9ydFxuICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy4gVGhpcyBpcyBhbiBpc3N1ZVxuICAvLyBpbiBGaXJlZm94IDQtMjkuIE5vdyBmaXhlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJlxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nIC8vIENocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBXb3JrYXJvdW5kOiBub2RlJ3MgYmFzZTY0IGltcGxlbWVudGF0aW9uIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBzdHJpbmdzXG4gIC8vIHdoaWxlIGJhc2U2NC1qcyBkb2VzIG5vdC5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JyAmJiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHN1YmplY3QgPSBzdHJpbmd0cmltKHN1YmplY3QpXG4gICAgd2hpbGUgKHN1YmplY3QubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgc3ViamVjdCA9IHN1YmplY3QgKyAnPSdcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpIC8vIGFzc3VtZSB0aGF0IG9iamVjdCBpcyBhcnJheS1saWtlXG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSlcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdFtpXVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9PSBudWxsICYmIGIgIT09IHVuZGVmaW5lZCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggLyAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgYXNzZXJ0KGlzQXJyYXkobGlzdCksICdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbicgK1xuICAgICAgJ2xpc3Qgc2hvdWxkIGJlIGFuIEFycmF5LicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHRvdGFsTGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBfaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyXG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIF91dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gX2FzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kICE9PSB1bmRlZmluZWQpXG4gICAgPyBOdW1iZXIoZW5kKVxuICAgIDogZW5kID0gc2VsZi5sZW5ndGhcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmIChlbmQgPT09IHN0YXJ0KVxuICAgIHJldHVybiAnJ1xuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMCB8fCAhQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIF91dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gX2FzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBfYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gX2FzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBfaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpKzFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmW29mZnNldF0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMl0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICAgIHZhbCB8PSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMClcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAxXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAyXSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDNdXG4gICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXRdIDw8IDI0ID4+PiAwKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHRoaXMud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQzMihidWYsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSksICd2YWx1ZSBpcyBub3QgYSBudW1iZXInKVxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSlcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuZnVuY3Rpb24gY2xhbXAgKGluZGV4LCBsZW4sIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICBpbmRleCA9IH5+aW5kZXg7ICAvLyBDb2VyY2UgdG8gaW50ZWdlci5cbiAgaWYgKGluZGV4ID49IGxlbikgcmV0dXJuIGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIGluZGV4ICs9IGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGNvZXJjZSAobGVuZ3RoKSB7XG4gIC8vIENvZXJjZSBsZW5ndGggdG8gYSBudW1iZXIgKHBvc3NpYmx5IE5hTiksIHJvdW5kIHVwXG4gIC8vIGluIGNhc2UgaXQncyBmcmFjdGlvbmFsIChlLmcuIDEyMy40NTYpIHRoZW4gZG8gYVxuICAvLyBkb3VibGUgbmVnYXRlIHRvIGNvZXJjZSBhIE5hTiB0byAwLiBFYXN5LCByaWdodD9cbiAgbGVuZ3RoID0gfn5NYXRoLmNlaWwoK2xlbmd0aClcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICB9KShzdWJqZWN0KVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKVxuICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3NcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdFxuICogaXMgbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3RcbiAqIGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQgKHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZzaW50ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qc1wiLFwiL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlclwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qc1wiLFwiL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1wiLFwiL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiLFwiL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3NcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgbWdycyA9IHJlcXVpcmUoJ21ncnMnKTtcblxuZnVuY3Rpb24gUG9pbnQoeCwgeSwgeikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCB6KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgIHRoaXMueCA9IHhbMF07XG4gICAgdGhpcy55ID0geFsxXTtcbiAgICB0aGlzLnogPSB4WzJdIHx8IDAuMDtcbiAgfWVsc2UgaWYodHlwZW9mIHggPT09ICdvYmplY3QnKXtcbiAgICB0aGlzLnggPSB4Lng7XG4gICAgdGhpcy55ID0geC55O1xuICAgIHRoaXMueiA9IHgueiB8fCAwLjA7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnICYmIHR5cGVvZiB5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBjb29yZHMgPSB4LnNwbGl0KCcsJyk7XG4gICAgdGhpcy54ID0gcGFyc2VGbG9hdChjb29yZHNbMF0sIDEwKTtcbiAgICB0aGlzLnkgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSwgMTApO1xuICAgIHRoaXMueiA9IHBhcnNlRmxvYXQoY29vcmRzWzJdLCAxMCkgfHwgMC4wO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6IHx8IDAuMDtcbiAgfVxuICBjb25zb2xlLndhcm4oJ3Byb2o0LlBvaW50IHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDMsIHVzZSBwcm9qNC50b1BvaW50Jyk7XG59XG5cblBvaW50LmZyb21NR1JTID0gZnVuY3Rpb24obWdyc1N0cikge1xuICByZXR1cm4gbmV3IFBvaW50KG1ncnMudG9Qb2ludChtZ3JzU3RyKSk7XG59O1xuUG9pbnQucHJvdG90eXBlLnRvTUdSUyA9IGZ1bmN0aW9uKGFjY3VyYWN5KSB7XG4gIHJldHVybiBtZ3JzLmZvcndhcmQoW3RoaXMueCwgdGhpcy55XSwgYWNjdXJhY3kpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvUG9pbnQuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHBhcnNlQ29kZSA9IHJlcXVpcmUoXCIuL3BhcnNlQ29kZVwiKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xudmFyIHByb2plY3Rpb25zID0gcmVxdWlyZSgnLi9wcm9qZWN0aW9ucycpO1xudmFyIGRlcml2ZUNvbnN0YW50cyA9IHJlcXVpcmUoJy4vZGVyaXZlQ29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIFByb2plY3Rpb24oc3JzQ29kZSxjYWxsYmFjaykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvamVjdGlvbikpIHtcbiAgICByZXR1cm4gbmV3IFByb2plY3Rpb24oc3JzQ29kZSk7XG4gIH1cbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnJvcil7XG4gICAgaWYoZXJyb3Ipe1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICB2YXIganNvbiA9IHBhcnNlQ29kZShzcnNDb2RlKTtcbiAgaWYodHlwZW9mIGpzb24gIT09ICdvYmplY3QnKXtcbiAgICBjYWxsYmFjayhzcnNDb2RlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1vZGlmaWVkSlNPTiA9IGRlcml2ZUNvbnN0YW50cyhqc29uKTtcbiAgdmFyIG91clByb2ogPSBQcm9qZWN0aW9uLnByb2plY3Rpb25zLmdldChtb2RpZmllZEpTT04ucHJvak5hbWUpO1xuICBpZihvdXJQcm9qKXtcbiAgICBleHRlbmQodGhpcywgbW9kaWZpZWRKU09OKTtcbiAgICBleHRlbmQodGhpcywgb3VyUHJvaik7XG4gICAgdGhpcy5pbml0KCk7XG4gICAgY2FsbGJhY2sobnVsbCwgdGhpcyk7XG4gIH1lbHNle1xuICAgIGNhbGxiYWNrKHNyc0NvZGUpO1xuICB9XG59XG5Qcm9qZWN0aW9uLnByb2plY3Rpb25zID0gcHJvamVjdGlvbnM7XG5Qcm9qZWN0aW9uLnByb2plY3Rpb25zLnN0YXJ0KCk7XG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3Rpb247XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9Qcm9qLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY3JzLCBkZW5vcm0sIHBvaW50KSB7XG4gIHZhciB4aW4gPSBwb2ludC54LFxuICAgIHlpbiA9IHBvaW50LnksXG4gICAgemluID0gcG9pbnQueiB8fCAwLjA7XG4gIHZhciB2LCB0LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgaWYgKGRlbm9ybSAmJiBpID09PSAyICYmIHBvaW50LnogPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICB2ID0geGluO1xuICAgICAgdCA9ICd4JztcbiAgICB9XG4gICAgZWxzZSBpZiAoaSA9PT0gMSkge1xuICAgICAgdiA9IHlpbjtcbiAgICAgIHQgPSAneSc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdiA9IHppbjtcbiAgICAgIHQgPSAneic7XG4gICAgfVxuICAgIHN3aXRjaCAoY3JzLmF4aXNbaV0pIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHBvaW50W3RdID0gdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3cnOlxuICAgICAgcG9pbnRbdF0gPSAtdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ24nOlxuICAgICAgcG9pbnRbdF0gPSB2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncyc6XG4gICAgICBwb2ludFt0XSA9IC12O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndSc6XG4gICAgICBpZiAocG9pbnRbdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludC56ID0gdjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2QnOlxuICAgICAgaWYgKHBvaW50W3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9pbnQueiA9IC12O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vY29uc29sZS5sb2coXCJFUlJPUjogdW5rbm93IGF4aXMgKFwiK2Nycy5heGlzW2ldK1wiKSAtIGNoZWNrIGRlZmluaXRpb24gb2YgXCIrY3JzLnByb2pOYW1lKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnQ7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvYWRqdXN0X2F4aXMuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChNYXRoLmFicyh4KSA8IEhBTEZfUEkpID8geCA6ICh4IC0gKHNpZ24oeCkgKiBNYXRoLlBJKSk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9hZGp1c3RfbGF0LmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb25cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgVFdPX1BJID0gTWF0aC5QSSAqIDI7XG4vLyBTUEkgaXMgc2xpZ2h0bHkgZ3JlYXRlciB0aGFuIE1hdGguUEksIHNvIHZhbHVlcyB0aGF0IGV4Y2VlZCB0aGUgLTE4MC4uMTgwXG4vLyBkZWdyZWUgcmFuZ2UgYnkgYSB0aW55IGFtb3VudCBkb24ndCBnZXQgd3JhcHBlZC4gVGhpcyBwcmV2ZW50cyBwb2ludHMgdGhhdFxuLy8gaGF2ZSBkcmlmdGVkIGZyb20gdGhlaXIgb3JpZ2luYWwgbG9jYXRpb24gYWxvbmcgdGhlIDE4MHRoIG1lcmlkaWFuIChkdWUgdG9cbi8vIGZsb2F0aW5nIHBvaW50IGVycm9yKSBmcm9tIGNoYW5naW5nIHRoZWlyIHNpZ24uXG52YXIgU1BJID0gMy4xNDE1OTI2NTM1OTtcbnZhciBzaWduID0gcmVxdWlyZSgnLi9zaWduJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKE1hdGguYWJzKHgpIDw9IFNQSSkgPyB4IDogKHggLSAoc2lnbih4KSAqIFRXT19QSSkpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vYWRqdXN0X2xvbi5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih4KSB7XG4gIGlmIChNYXRoLmFicyh4KSA+IDEpIHtcbiAgICB4ID0gKHggPiAxKSA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4gTWF0aC5hc2luKHgpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vYXNpbnouanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKDEgLSAwLjI1ICogeCAqICgxICsgeCAvIDE2ICogKDMgKyAxLjI1ICogeCkpKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL2UwZm4uanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKDAuMzc1ICogeCAqICgxICsgMC4yNSAqIHggKiAoMSArIDAuNDY4NzUgKiB4KSkpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vZTFmbi5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoMC4wNTg1OTM3NSAqIHggKiB4ICogKDEgKyAwLjc1ICogeCkpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vZTJmbi5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoeCAqIHggKiB4ICogKDM1IC8gMzA3MikpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vZTNmbi5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBlLCBzaW5waGkpIHtcbiAgdmFyIHRlbXAgPSBlICogc2lucGhpO1xuICByZXR1cm4gYSAvIE1hdGguc3FydCgxIC0gdGVtcCAqIHRlbXApO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vZ04uanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWwsIGUwLCBlMSwgZTIsIGUzKSB7XG4gIHZhciBwaGk7XG4gIHZhciBkcGhpO1xuXG4gIHBoaSA9IG1sIC8gZTA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICAgIGRwaGkgPSAobWwgLSAoZTAgKiBwaGkgLSBlMSAqIE1hdGguc2luKDIgKiBwaGkpICsgZTIgKiBNYXRoLnNpbig0ICogcGhpKSAtIGUzICogTWF0aC5zaW4oNiAqIHBoaSkpKSAvIChlMCAtIDIgKiBlMSAqIE1hdGguY29zKDIgKiBwaGkpICsgNCAqIGUyICogTWF0aC5jb3MoNCAqIHBoaSkgLSA2ICogZTMgKiBNYXRoLmNvcyg2ICogcGhpKSk7XG4gICAgcGhpICs9IGRwaGk7XG4gICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IDAuMDAwMDAwMDAwMSkge1xuICAgICAgcmV0dXJuIHBoaTtcbiAgICB9XG4gIH1cblxuICAvLy4ucmVwb3J0RXJyb3IoXCJJTUxGTi1DT05WOkxhdGl0dWRlIGZhaWxlZCB0byBjb252ZXJnZSBhZnRlciAxNSBpdGVyYXRpb25zXCIpO1xuICByZXR1cm4gTmFOO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vaW1sZm4uanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVjY2VudCwgcSkge1xuICB2YXIgdGVtcCA9IDEgLSAoMSAtIGVjY2VudCAqIGVjY2VudCkgLyAoMiAqIGVjY2VudCkgKiBNYXRoLmxvZygoMSAtIGVjY2VudCkgLyAoMSArIGVjY2VudCkpO1xuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMocSkgLSB0ZW1wKSA8IDEuMEUtNikge1xuICAgIGlmIChxIDwgMCkge1xuICAgICAgcmV0dXJuICgtMSAqIEhBTEZfUEkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBIQUxGX1BJO1xuICAgIH1cbiAgfVxuICAvL3ZhciBwaGkgPSAwLjUqIHEvKDEtZWNjZW50KmVjY2VudCk7XG4gIHZhciBwaGkgPSBNYXRoLmFzaW4oMC41ICogcSk7XG4gIHZhciBkcGhpO1xuICB2YXIgc2luX3BoaTtcbiAgdmFyIGNvc19waGk7XG4gIHZhciBjb247XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzA7IGkrKykge1xuICAgIHNpbl9waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgIGNvc19waGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvbiA9IGVjY2VudCAqIHNpbl9waGk7XG4gICAgZHBoaSA9IE1hdGgucG93KDEgLSBjb24gKiBjb24sIDIpIC8gKDIgKiBjb3NfcGhpKSAqIChxIC8gKDEgLSBlY2NlbnQgKiBlY2NlbnQpIC0gc2luX3BoaSAvICgxIC0gY29uICogY29uKSArIDAuNSAvIGVjY2VudCAqIE1hdGgubG9nKCgxIC0gY29uKSAvICgxICsgY29uKSkpO1xuICAgIHBoaSArPSBkcGhpO1xuICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSAwLjAwMDAwMDAwMDEpIHtcbiAgICAgIHJldHVybiBwaGk7XG4gICAgfVxuICB9XG5cbiAgLy9jb25zb2xlLmxvZyhcIklRU0ZOLUNPTlY6TGF0aXR1ZGUgZmFpbGVkIHRvIGNvbnZlcmdlIGFmdGVyIDMwIGl0ZXJhdGlvbnNcIik7XG4gIHJldHVybiBOYU47XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9pcXNmbnouanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZTAsIGUxLCBlMiwgZTMsIHBoaSkge1xuICByZXR1cm4gKGUwICogcGhpIC0gZTEgKiBNYXRoLnNpbigyICogcGhpKSArIGUyICogTWF0aC5zaW4oNCAqIHBoaSkgLSBlMyAqIE1hdGguc2luKDYgKiBwaGkpKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uL21sZm4uanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWNjZW50LCBzaW5waGksIGNvc3BoaSkge1xuICB2YXIgY29uID0gZWNjZW50ICogc2lucGhpO1xuICByZXR1cm4gY29zcGhpIC8gKE1hdGguc3FydCgxIC0gY29uICogY29uKSk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9tc2Zuei5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVjY2VudCwgdHMpIHtcbiAgdmFyIGVjY250aCA9IDAuNSAqIGVjY2VudDtcbiAgdmFyIGNvbiwgZHBoaTtcbiAgdmFyIHBoaSA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKHRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMTU7IGkrKykge1xuICAgIGNvbiA9IGVjY2VudCAqIE1hdGguc2luKHBoaSk7XG4gICAgZHBoaSA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKHRzICogKE1hdGgucG93KCgoMSAtIGNvbikgLyAoMSArIGNvbikpLCBlY2NudGgpKSkgLSBwaGk7XG4gICAgcGhpICs9IGRwaGk7XG4gICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IDAuMDAwMDAwMDAwMSkge1xuICAgICAgcmV0dXJuIHBoaTtcbiAgICB9XG4gIH1cbiAgLy9jb25zb2xlLmxvZyhcInBoaTJ6IGhhcyBOb0NvbnZlcmdlbmNlXCIpO1xuICByZXR1cm4gLTk5OTk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9waGkyei5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEMwMCA9IDE7XG52YXIgQzAyID0gMC4yNTtcbnZhciBDMDQgPSAwLjA0Njg3NTtcbnZhciBDMDYgPSAwLjAxOTUzMTI1O1xudmFyIEMwOCA9IDAuMDEwNjgxMTUyMzQzNzU7XG52YXIgQzIyID0gMC43NTtcbnZhciBDNDQgPSAwLjQ2ODc1O1xudmFyIEM0NiA9IDAuMDEzMDIwODMzMzMzMzMzMzMzMzM7XG52YXIgQzQ4ID0gMC4wMDcxMjA3NjgyMjkxNjY2NjY2NjtcbnZhciBDNjYgPSAwLjM2NDU4MzMzMzMzMzMzMzMzMzMzO1xudmFyIEM2OCA9IDAuMDA1Njk2NjE0NTgzMzMzMzMzMzM7XG52YXIgQzg4ID0gMC4zMDc2MTcxODc1O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVzKSB7XG4gIHZhciBlbiA9IFtdO1xuICBlblswXSA9IEMwMCAtIGVzICogKEMwMiArIGVzICogKEMwNCArIGVzICogKEMwNiArIGVzICogQzA4KSkpO1xuICBlblsxXSA9IGVzICogKEMyMiAtIGVzICogKEMwNCArIGVzICogKEMwNiArIGVzICogQzA4KSkpO1xuICB2YXIgdCA9IGVzICogZXM7XG4gIGVuWzJdID0gdCAqIChDNDQgLSBlcyAqIChDNDYgKyBlcyAqIEM0OCkpO1xuICB0ICo9IGVzO1xuICBlblszXSA9IHQgKiAoQzY2IC0gZXMgKiBDNjgpO1xuICBlbls0XSA9IHQgKiBlcyAqIEM4ODtcbiAgcmV0dXJuIGVuO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vcGpfZW5mbi5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHBqX21sZm4gPSByZXF1aXJlKFwiLi9wal9tbGZuXCIpO1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBNQVhfSVRFUiA9IDIwO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcmcsIGVzLCBlbikge1xuICB2YXIgayA9IDEgLyAoMSAtIGVzKTtcbiAgdmFyIHBoaSA9IGFyZztcbiAgZm9yICh2YXIgaSA9IE1BWF9JVEVSOyBpOyAtLWkpIHsgLyogcmFyZWx5IGdvZXMgb3ZlciAyIGl0ZXJhdGlvbnMgKi9cbiAgICB2YXIgcyA9IE1hdGguc2luKHBoaSk7XG4gICAgdmFyIHQgPSAxIC0gZXMgKiBzICogcztcbiAgICAvL3QgPSB0aGlzLnBqX21sZm4ocGhpLCBzLCBNYXRoLmNvcyhwaGkpLCBlbikgLSBhcmc7XG4gICAgLy9waGkgLT0gdCAqICh0ICogTWF0aC5zcXJ0KHQpKSAqIGs7XG4gICAgdCA9IChwal9tbGZuKHBoaSwgcywgTWF0aC5jb3MocGhpKSwgZW4pIC0gYXJnKSAqICh0ICogTWF0aC5zcXJ0KHQpKSAqIGs7XG4gICAgcGhpIC09IHQ7XG4gICAgaWYgKE1hdGguYWJzKHQpIDwgRVBTTE4pIHtcbiAgICAgIHJldHVybiBwaGk7XG4gICAgfVxuICB9XG4gIC8vLi5yZXBvcnRFcnJvcihcImNhc3M6cGpfaW52X21sZm46IENvbnZlcmdlbmNlIGVycm9yXCIpO1xuICByZXR1cm4gcGhpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vcGpfaW52X21sZm4uanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGhpLCBzcGhpLCBjcGhpLCBlbikge1xuICBjcGhpICo9IHNwaGk7XG4gIHNwaGkgKj0gc3BoaTtcbiAgcmV0dXJuIChlblswXSAqIHBoaSAtIGNwaGkgKiAoZW5bMV0gKyBzcGhpICogKGVuWzJdICsgc3BoaSAqIChlblszXSArIHNwaGkgKiBlbls0XSkpKSk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9wal9tbGZuLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb25cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVjY2VudCwgc2lucGhpKSB7XG4gIHZhciBjb247XG4gIGlmIChlY2NlbnQgPiAxLjBlLTcpIHtcbiAgICBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gICAgcmV0dXJuICgoMSAtIGVjY2VudCAqIGVjY2VudCkgKiAoc2lucGhpIC8gKDEgLSBjb24gKiBjb24pIC0gKDAuNSAvIGVjY2VudCkgKiBNYXRoLmxvZygoMSAtIGNvbikgLyAoMSArIGNvbikpKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuICgyICogc2lucGhpKTtcbiAgfVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vcXNmbnouanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDwwID8gLTEgOiAxO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vc2lnbi5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29tbW9uXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlc2lucCwgZXhwKSB7XG4gIHJldHVybiAoTWF0aC5wb3coKDEgLSBlc2lucCkgLyAoMSArIGVzaW5wKSwgZXhwKSk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi9zcmF0LmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb25cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnJheSl7XG4gIHZhciBvdXQgPSB7XG4gICAgeDogYXJyYXlbMF0sXG4gICAgeTogYXJyYXlbMV1cbiAgfTtcbiAgaWYgKGFycmF5Lmxlbmd0aD4yKSB7XG4gICAgb3V0LnogPSBhcnJheVsyXTtcbiAgfVxuICBpZiAoYXJyYXkubGVuZ3RoPjMpIHtcbiAgICBvdXQubSA9IGFycmF5WzNdO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vbi90b1BvaW50LmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb25cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlY2NlbnQsIHBoaSwgc2lucGhpKSB7XG4gIHZhciBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gIHZhciBjb20gPSAwLjUgKiBlY2NlbnQ7XG4gIGNvbiA9IE1hdGgucG93KCgoMSAtIGNvbikgLyAoMSArIGNvbikpLCBjb20pO1xuICByZXR1cm4gKE1hdGgudGFuKDAuNSAqIChIQUxGX1BJIC0gcGhpKSkgLyBjb24pO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb21tb24vdHNmbnouanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbW1vblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmV4cG9ydHMud2dzODQgPSB7XG4gIHRvd2dzODQ6IFwiMCwwLDBcIixcbiAgZWxsaXBzZTogXCJXR1M4NFwiLFxuICBkYXR1bU5hbWU6IFwiV0dTODRcIlxufTtcbmV4cG9ydHMuY2gxOTAzID0ge1xuICB0b3dnczg0OiBcIjY3NC4zNzQsMTUuMDU2LDQwNS4zNDZcIixcbiAgZWxsaXBzZTogXCJiZXNzZWxcIixcbiAgZGF0dW1OYW1lOiBcInN3aXNzXCJcbn07XG5leHBvcnRzLmdncnM4NyA9IHtcbiAgdG93Z3M4NDogXCItMTk5Ljg3LDc0Ljc5LDI0Ni42MlwiLFxuICBlbGxpcHNlOiBcIkdSUzgwXCIsXG4gIGRhdHVtTmFtZTogXCJHcmVla19HZW9kZXRpY19SZWZlcmVuY2VfU3lzdGVtXzE5ODdcIlxufTtcbmV4cG9ydHMubmFkODMgPSB7XG4gIHRvd2dzODQ6IFwiMCwwLDBcIixcbiAgZWxsaXBzZTogXCJHUlM4MFwiLFxuICBkYXR1bU5hbWU6IFwiTm9ydGhfQW1lcmljYW5fRGF0dW1fMTk4M1wiXG59O1xuZXhwb3J0cy5uYWQyNyA9IHtcbiAgbmFkZ3JpZHM6IFwiQGNvbnVzLEBhbGFza2EsQG50djJfMC5nc2IsQG50djFfY2FuLmRhdFwiLFxuICBlbGxpcHNlOiBcImNscms2NlwiLFxuICBkYXR1bU5hbWU6IFwiTm9ydGhfQW1lcmljYW5fRGF0dW1fMTkyN1wiXG59O1xuZXhwb3J0cy5wb3RzZGFtID0ge1xuICB0b3dnczg0OiBcIjYwNi4wLDIzLjAsNDEzLjBcIixcbiAgZWxsaXBzZTogXCJiZXNzZWxcIixcbiAgZGF0dW1OYW1lOiBcIlBvdHNkYW0gUmF1ZW5iZXJnIDE5NTAgREhETlwiXG59O1xuZXhwb3J0cy5jYXJ0aGFnZSA9IHtcbiAgdG93Z3M4NDogXCItMjYzLjAsNi4wLDQzMS4wXCIsXG4gIGVsbGlwc2U6IFwiY2xhcms4MFwiLFxuICBkYXR1bU5hbWU6IFwiQ2FydGhhZ2UgMTkzNCBUdW5pc2lhXCJcbn07XG5leHBvcnRzLmhlcm1hbm5za29nZWwgPSB7XG4gIHRvd2dzODQ6IFwiNjUzLjAsLTIxMi4wLDQ0OS4wXCIsXG4gIGVsbGlwc2U6IFwiYmVzc2VsXCIsXG4gIGRhdHVtTmFtZTogXCJIZXJtYW5uc2tvZ2VsXCJcbn07XG5leHBvcnRzLmlyZTY1ID0ge1xuICB0b3dnczg0OiBcIjQ4Mi41MzAsLTEzMC41OTYsNTY0LjU1NywtMS4wNDIsLTAuMjE0LC0wLjYzMSw4LjE1XCIsXG4gIGVsbGlwc2U6IFwibW9kX2FpcnlcIixcbiAgZGF0dW1OYW1lOiBcIklyZWxhbmQgMTk2NVwiXG59O1xuZXhwb3J0cy5yYXNzYWRpcmFuID0ge1xuICB0b3dnczg0OiBcIi0xMzMuNjMsLTE1Ny41LC0xNTguNjJcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSYXNzYWRpcmFuXCJcbn07XG5leHBvcnRzLm56Z2Q0OSA9IHtcbiAgdG93Z3M4NDogXCI1OS40NywtNS4wNCwxODcuNDQsMC40NywtMC4xLDEuMDI0LC00LjU5OTNcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJOZXcgWmVhbGFuZCBHZW9kZXRpYyBEYXR1bSAxOTQ5XCJcbn07XG5leHBvcnRzLm9zZ2IzNiA9IHtcbiAgdG93Z3M4NDogXCI0NDYuNDQ4LC0xMjUuMTU3LDU0Mi4wNjAsMC4xNTAyLDAuMjQ3MCwwLjg0MjEsLTIwLjQ4OTRcIixcbiAgZWxsaXBzZTogXCJhaXJ5XCIsXG4gIGRhdHVtTmFtZTogXCJBaXJ5IDE4MzBcIlxufTtcbmV4cG9ydHMuc19qdHNrID0ge1xuICB0b3dnczg0OiBcIjU4OSw3Niw0ODBcIixcbiAgZWxsaXBzZTogJ2Jlc3NlbCcsXG4gIGRhdHVtTmFtZTogJ1MtSlRTSyAoRmVycm8pJ1xufTtcbmV4cG9ydHMuYmVkdWFyYW0gPSB7XG4gIHRvd2dzODQ6ICctMTA2LC04NywxODgnLFxuICBlbGxpcHNlOiAnY2xyazgwJyxcbiAgZGF0dW1OYW1lOiAnQmVkdWFyYW0nXG59O1xuZXhwb3J0cy5ndW51bmdfc2VnYXJhID0ge1xuICB0b3dnczg0OiAnLTQwMyw2ODQsNDEnLFxuICBlbGxpcHNlOiAnYmVzc2VsJyxcbiAgZGF0dW1OYW1lOiAnR3VudW5nIFNlZ2FyYSBKYWthcnRhJ1xufTtcbmV4cG9ydHMucm5iNzIgPSB7XG4gIHRvd2dzODQ6IFwiMTA2Ljg2OSwtNTIuMjk3OCwxMDMuNzI0LC0wLjMzNjU3LDAuNDU2OTU1LC0xLjg0MjE4LDFcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSZXNlYXUgTmF0aW9uYWwgQmVsZ2UgMTk3MlwiXG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy9EYXR1bS5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvY29uc3RhbnRzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuZXhwb3J0cy5NRVJJVCA9IHtcbiAgYTogNjM3ODEzNy4wLFxuICByZjogMjk4LjI1NyxcbiAgZWxsaXBzZU5hbWU6IFwiTUVSSVQgMTk4M1wiXG59O1xuZXhwb3J0cy5TR1M4NSA9IHtcbiAgYTogNjM3ODEzNi4wLFxuICByZjogMjk4LjI1NyxcbiAgZWxsaXBzZU5hbWU6IFwiU292aWV0IEdlb2RldGljIFN5c3RlbSA4NVwiXG59O1xuZXhwb3J0cy5HUlM4MCA9IHtcbiAgYTogNjM3ODEzNy4wLFxuICByZjogMjk4LjI1NzIyMjEwMSxcbiAgZWxsaXBzZU5hbWU6IFwiR1JTIDE5ODAoSVVHRywgMTk4MClcIlxufTtcbmV4cG9ydHMuSUFVNzYgPSB7XG4gIGE6IDYzNzgxNDAuMCxcbiAgcmY6IDI5OC4yNTcsXG4gIGVsbGlwc2VOYW1lOiBcIklBVSAxOTc2XCJcbn07XG5leHBvcnRzLmFpcnkgPSB7XG4gIGE6IDYzNzc1NjMuMzk2LFxuICBiOiA2MzU2MjU2LjkxMCxcbiAgZWxsaXBzZU5hbWU6IFwiQWlyeSAxODMwXCJcbn07XG5leHBvcnRzLkFQTDQgPSB7XG4gIGE6IDYzNzgxMzcsXG4gIHJmOiAyOTguMjUsXG4gIGVsbGlwc2VOYW1lOiBcIkFwcGwuIFBoeXNpY3MuIDE5NjVcIlxufTtcbmV4cG9ydHMuTldMOUQgPSB7XG4gIGE6IDYzNzgxNDUuMCxcbiAgcmY6IDI5OC4yNSxcbiAgZWxsaXBzZU5hbWU6IFwiTmF2YWwgV2VhcG9ucyBMYWIuLCAxOTY1XCJcbn07XG5leHBvcnRzLm1vZF9haXJ5ID0ge1xuICBhOiA2Mzc3MzQwLjE4OSxcbiAgYjogNjM1NjAzNC40NDYsXG4gIGVsbGlwc2VOYW1lOiBcIk1vZGlmaWVkIEFpcnlcIlxufTtcbmV4cG9ydHMuYW5kcmFlID0ge1xuICBhOiA2Mzc3MTA0LjQzLFxuICByZjogMzAwLjAsXG4gIGVsbGlwc2VOYW1lOiBcIkFuZHJhZSAxODc2IChEZW4uLCBJY2xuZC4pXCJcbn07XG5leHBvcnRzLmF1c3RfU0EgPSB7XG4gIGE6IDYzNzgxNjAuMCxcbiAgcmY6IDI5OC4yNSxcbiAgZWxsaXBzZU5hbWU6IFwiQXVzdHJhbGlhbiBOYXRsICYgUy4gQW1lci4gMTk2OVwiXG59O1xuZXhwb3J0cy5HUlM2NyA9IHtcbiAgYTogNjM3ODE2MC4wLFxuICByZjogMjk4LjI0NzE2NzQyNzAsXG4gIGVsbGlwc2VOYW1lOiBcIkdSUyA2NyhJVUdHIDE5NjcpXCJcbn07XG5leHBvcnRzLmJlc3NlbCA9IHtcbiAgYTogNjM3NzM5Ny4xNTUsXG4gIHJmOiAyOTkuMTUyODEyOCxcbiAgZWxsaXBzZU5hbWU6IFwiQmVzc2VsIDE4NDFcIlxufTtcbmV4cG9ydHMuYmVzc19uYW0gPSB7XG4gIGE6IDYzNzc0ODMuODY1LFxuICByZjogMjk5LjE1MjgxMjgsXG4gIGVsbGlwc2VOYW1lOiBcIkJlc3NlbCAxODQxIChOYW1pYmlhKVwiXG59O1xuZXhwb3J0cy5jbHJrNjYgPSB7XG4gIGE6IDYzNzgyMDYuNCxcbiAgYjogNjM1NjU4My44LFxuICBlbGxpcHNlTmFtZTogXCJDbGFya2UgMTg2NlwiXG59O1xuZXhwb3J0cy5jbHJrODAgPSB7XG4gIGE6IDYzNzgyNDkuMTQ1LFxuICByZjogMjkzLjQ2NjMsXG4gIGVsbGlwc2VOYW1lOiBcIkNsYXJrZSAxODgwIG1vZC5cIlxufTtcbmV4cG9ydHMuY2xyazU4ID0ge1xuICBhOiA2Mzc4MjkzLjY0NTIwODc1OSxcbiAgcmY6IDI5NC4yNjA2NzYzNjkyNjU0LFxuICBlbGxpcHNlTmFtZTogXCJDbGFya2UgMTg1OFwiXG59O1xuZXhwb3J0cy5DUE0gPSB7XG4gIGE6IDYzNzU3MzguNyxcbiAgcmY6IDMzNC4yOSxcbiAgZWxsaXBzZU5hbWU6IFwiQ29tbS4gZGVzIFBvaWRzIGV0IE1lc3VyZXMgMTc5OVwiXG59O1xuZXhwb3J0cy5kZWxtYnIgPSB7XG4gIGE6IDYzNzY0MjguMCxcbiAgcmY6IDMxMS41LFxuICBlbGxpcHNlTmFtZTogXCJEZWxhbWJyZSAxODEwIChCZWxnaXVtKVwiXG59O1xuZXhwb3J0cy5lbmdlbGlzID0ge1xuICBhOiA2Mzc4MTM2LjA1LFxuICByZjogMjk4LjI1NjYsXG4gIGVsbGlwc2VOYW1lOiBcIkVuZ2VsaXMgMTk4NVwiXG59O1xuZXhwb3J0cy5ldnJzdDMwID0ge1xuICBhOiA2Mzc3Mjc2LjM0NSxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE4MzBcIlxufTtcbmV4cG9ydHMuZXZyc3Q0OCA9IHtcbiAgYTogNjM3NzMwNC4wNjMsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAxOTQ4XCJcbn07XG5leHBvcnRzLmV2cnN0NTYgPSB7XG4gIGE6IDYzNzczMDEuMjQzLFxuICByZjogMzAwLjgwMTcsXG4gIGVsbGlwc2VOYW1lOiBcIkV2ZXJlc3QgMTk1NlwiXG59O1xuZXhwb3J0cy5ldnJzdDY5ID0ge1xuICBhOiA2Mzc3Mjk1LjY2NCxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NjlcIlxufTtcbmV4cG9ydHMuZXZyc3RTUyA9IHtcbiAgYTogNjM3NzI5OC41NTYsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAoU2FiYWggJiBTYXJhd2FrKVwiXG59O1xuZXhwb3J0cy5mc2NocjYwID0ge1xuICBhOiA2Mzc4MTY2LjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiRmlzY2hlciAoTWVyY3VyeSBEYXR1bSkgMTk2MFwiXG59O1xuZXhwb3J0cy5mc2NocjYwbSA9IHtcbiAgYTogNjM3ODE1NS4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIkZpc2NoZXIgMTk2MFwiXG59O1xuZXhwb3J0cy5mc2NocjY4ID0ge1xuICBhOiA2Mzc4MTUwLjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiRmlzY2hlciAxOTY4XCJcbn07XG5leHBvcnRzLmhlbG1lcnQgPSB7XG4gIGE6IDYzNzgyMDAuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJIZWxtZXJ0IDE5MDZcIlxufTtcbmV4cG9ydHMuaG91Z2ggPSB7XG4gIGE6IDYzNzgyNzAuMCxcbiAgcmY6IDI5Ny4wLFxuICBlbGxpcHNlTmFtZTogXCJIb3VnaFwiXG59O1xuZXhwb3J0cy5pbnRsID0ge1xuICBhOiA2Mzc4Mzg4LjAsXG4gIHJmOiAyOTcuMCxcbiAgZWxsaXBzZU5hbWU6IFwiSW50ZXJuYXRpb25hbCAxOTA5IChIYXlmb3JkKVwiXG59O1xuZXhwb3J0cy5rYXVsYSA9IHtcbiAgYTogNjM3ODE2My4wLFxuICByZjogMjk4LjI0LFxuICBlbGxpcHNlTmFtZTogXCJLYXVsYSAxOTYxXCJcbn07XG5leHBvcnRzLmxlcmNoID0ge1xuICBhOiA2Mzc4MTM5LjAsXG4gIHJmOiAyOTguMjU3LFxuICBlbGxpcHNlTmFtZTogXCJMZXJjaCAxOTc5XCJcbn07XG5leHBvcnRzLm1wcnRzID0ge1xuICBhOiA2Mzk3MzAwLjAsXG4gIHJmOiAxOTEuMCxcbiAgZWxsaXBzZU5hbWU6IFwiTWF1cGVydGl1cyAxNzM4XCJcbn07XG5leHBvcnRzLm5ld19pbnRsID0ge1xuICBhOiA2Mzc4MTU3LjUsXG4gIGI6IDYzNTY3NzIuMixcbiAgZWxsaXBzZU5hbWU6IFwiTmV3IEludGVybmF0aW9uYWwgMTk2N1wiXG59O1xuZXhwb3J0cy5wbGVzc2lzID0ge1xuICBhOiA2Mzc2NTIzLjAsXG4gIHJmOiA2MzU1ODYzLjAsXG4gIGVsbGlwc2VOYW1lOiBcIlBsZXNzaXMgMTgxNyAoRnJhbmNlKVwiXG59O1xuZXhwb3J0cy5rcmFzcyA9IHtcbiAgYTogNjM3ODI0NS4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIktyYXNzb3Zza3ksIDE5NDJcIlxufTtcbmV4cG9ydHMuU0Vhc2lhID0ge1xuICBhOiA2Mzc4MTU1LjAsXG4gIGI6IDYzNTY3NzMuMzIwNSxcbiAgZWxsaXBzZU5hbWU6IFwiU291dGhlYXN0IEFzaWFcIlxufTtcbmV4cG9ydHMud2FsYmVjayA9IHtcbiAgYTogNjM3Njg5Ni4wLFxuICBiOiA2MzU1ODM0Ljg0NjcsXG4gIGVsbGlwc2VOYW1lOiBcIldhbGJlY2tcIlxufTtcbmV4cG9ydHMuV0dTNjAgPSB7XG4gIGE6IDYzNzgxNjUuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJXR1MgNjBcIlxufTtcbmV4cG9ydHMuV0dTNjYgPSB7XG4gIGE6IDYzNzgxNDUuMCxcbiAgcmY6IDI5OC4yNSxcbiAgZWxsaXBzZU5hbWU6IFwiV0dTIDY2XCJcbn07XG5leHBvcnRzLldHUzcgPSB7XG4gIGE6IDYzNzgxMzUuMCxcbiAgcmY6IDI5OC4yNixcbiAgZWxsaXBzZU5hbWU6IFwiV0dTIDcyXCJcbn07XG5leHBvcnRzLldHUzg0ID0ge1xuICBhOiA2Mzc4MTM3LjAsXG4gIHJmOiAyOTguMjU3MjIzNTYzLFxuICBlbGxpcHNlTmFtZTogXCJXR1MgODRcIlxufTtcbmV4cG9ydHMuc3BoZXJlID0ge1xuICBhOiA2MzcwOTk3LjAsXG4gIGI6IDYzNzA5OTcuMCxcbiAgZWxsaXBzZU5hbWU6IFwiTm9ybWFsIFNwaGVyZSAocj02MzcwOTk3KVwiXG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy9FbGxpcHNvaWQuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50c1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmV4cG9ydHMuZ3JlZW53aWNoID0gMC4wOyAvL1wiMGRFXCIsXG5leHBvcnRzLmxpc2JvbiA9IC05LjEzMTkwNjExMTExMTsgLy9cIjlkMDcnNTQuODYyXFxcIldcIixcbmV4cG9ydHMucGFyaXMgPSAyLjMzNzIyOTE2NjY2NzsgLy9cIjJkMjAnMTQuMDI1XFxcIkVcIixcbmV4cG9ydHMuYm9nb3RhID0gLTc0LjA4MDkxNjY2NjY2NzsgLy9cIjc0ZDA0JzUxLjNcXFwiV1wiLFxuZXhwb3J0cy5tYWRyaWQgPSAtMy42ODc5Mzg4ODg4ODk7IC8vXCIzZDQxJzE2LjU4XFxcIldcIixcbmV4cG9ydHMucm9tZSA9IDEyLjQ1MjMzMzMzMzMzMzsgLy9cIjEyZDI3JzguNFxcXCJFXCIsXG5leHBvcnRzLmJlcm4gPSA3LjQzOTU4MzMzMzMzMzsgLy9cIjdkMjYnMjIuNVxcXCJFXCIsXG5leHBvcnRzLmpha2FydGEgPSAxMDYuODA3NzE5NDQ0NDQ0OyAvL1wiMTA2ZDQ4JzI3Ljc5XFxcIkVcIixcbmV4cG9ydHMuZmVycm8gPSAtMTcuNjY2NjY2NjY2NjY3OyAvL1wiMTdkNDAnV1wiLFxuZXhwb3J0cy5icnVzc2VscyA9IDQuMzY3OTc1OyAvL1wiNGQyMic0LjcxXFxcIkVcIixcbmV4cG9ydHMuc3RvY2tob2xtID0gMTguMDU4Mjc3Nzc3Nzc4OyAvL1wiMThkMycyOS44XFxcIkVcIixcbmV4cG9ydHMuYXRoZW5zID0gMjMuNzE2MzM3NTsgLy9cIjIzZDQyJzU4LjgxNVxcXCJFXCIsXG5leHBvcnRzLm9zbG8gPSAxMC43MjI5MTY2NjY2Njc7IC8vXCIxMGQ0MycyMi41XFxcIkVcIlxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvbnN0YW50cy9QcmltZU1lcmlkaWFuLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9jb25zdGFudHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgcHJvaiA9IHJlcXVpcmUoJy4vUHJvaicpO1xudmFyIHRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtJyk7XG52YXIgd2dzODQgPSBwcm9qKCdXR1M4NCcpO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcihmcm9tLCB0bywgY29vcmRzKSB7XG4gIHZhciB0cmFuc2Zvcm1lZEFycmF5O1xuICBpZiAoQXJyYXkuaXNBcnJheShjb29yZHMpKSB7XG4gICAgdHJhbnNmb3JtZWRBcnJheSA9IHRyYW5zZm9ybShmcm9tLCB0bywgY29vcmRzKTtcbiAgICBpZiAoY29vcmRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIFt0cmFuc2Zvcm1lZEFycmF5LngsIHRyYW5zZm9ybWVkQXJyYXkueSwgdHJhbnNmb3JtZWRBcnJheS56XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3RyYW5zZm9ybWVkQXJyYXkueCwgdHJhbnNmb3JtZWRBcnJheS55XTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybShmcm9tLCB0bywgY29vcmRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb2ooaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIHByb2opIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuICBpZiAoaXRlbS5vUHJvaikge1xuICAgIHJldHVybiBpdGVtLm9Qcm9qO1xuICB9XG4gIHJldHVybiBwcm9qKGl0ZW0pO1xufVxuZnVuY3Rpb24gcHJvajQoZnJvbVByb2osIHRvUHJvaiwgY29vcmQpIHtcbiAgZnJvbVByb2ogPSBjaGVja1Byb2ooZnJvbVByb2opO1xuICB2YXIgc2luZ2xlID0gZmFsc2U7XG4gIHZhciBvYmo7XG4gIGlmICh0eXBlb2YgdG9Qcm9qID09PSAndW5kZWZpbmVkJykge1xuICAgIHRvUHJvaiA9IGZyb21Qcm9qO1xuICAgIGZyb21Qcm9qID0gd2dzODQ7XG4gICAgc2luZ2xlID0gdHJ1ZTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgdG9Qcm9qLnggIT09ICd1bmRlZmluZWQnIHx8IEFycmF5LmlzQXJyYXkodG9Qcm9qKSkge1xuICAgIGNvb3JkID0gdG9Qcm9qO1xuICAgIHRvUHJvaiA9IGZyb21Qcm9qO1xuICAgIGZyb21Qcm9qID0gd2dzODQ7XG4gICAgc2luZ2xlID0gdHJ1ZTtcbiAgfVxuICB0b1Byb2ogPSBjaGVja1Byb2oodG9Qcm9qKTtcbiAgaWYgKGNvb3JkKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyKGZyb21Qcm9qLCB0b1Byb2osIGNvb3JkKTtcbiAgfVxuICBlbHNlIHtcbiAgICBvYmogPSB7XG4gICAgICBmb3J3YXJkOiBmdW5jdGlvbihjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKGZyb21Qcm9qLCB0b1Byb2osIGNvb3Jkcyk7XG4gICAgICB9LFxuICAgICAgaW52ZXJzZTogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcih0b1Byb2osIGZyb21Qcm9qLCBjb29yZHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHNpbmdsZSkge1xuICAgICAgb2JqLm9Qcm9qID0gdG9Qcm9qO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHByb2o0O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2NvcmUuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgUEpEXzNQQVJBTSA9IDE7XG52YXIgUEpEXzdQQVJBTSA9IDI7XG52YXIgUEpEX0dSSURTSElGVCA9IDM7XG52YXIgUEpEX1dHUzg0ID0gNDsgLy8gV0dTODQgb3IgZXF1aXZhbGVudFxudmFyIFBKRF9OT0RBVFVNID0gNTsgLy8gV0dTODQgb3IgZXF1aXZhbGVudFxudmFyIFNFQ19UT19SQUQgPSA0Ljg0ODEzNjgxMTA5NTM1OTkzNTg5OTE0MTAyMzU3ZS02O1xudmFyIEFEX0MgPSAxLjAwMjYwMDA7XG52YXIgQ09TXzY3UDUgPSAwLjM4MjY4MzQzMjM2NTA4OTc3O1xudmFyIGRhdHVtID0gZnVuY3Rpb24ocHJvaikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgZGF0dW0pKSB7XG4gICAgcmV0dXJuIG5ldyBkYXR1bShwcm9qKTtcbiAgfVxuICB0aGlzLmRhdHVtX3R5cGUgPSBQSkRfV0dTODQ7IC8vZGVmYXVsdCBzZXR0aW5nXG4gIGlmICghcHJvaikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvai5kYXR1bUNvZGUgJiYgcHJvai5kYXR1bUNvZGUgPT09ICdub25lJykge1xuICAgIHRoaXMuZGF0dW1fdHlwZSA9IFBKRF9OT0RBVFVNO1xuICB9XG4gIGlmIChwcm9qLmRhdHVtX3BhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvai5kYXR1bV9wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2ouZGF0dW1fcGFyYW1zW2ldID0gcGFyc2VGbG9hdChwcm9qLmRhdHVtX3BhcmFtc1tpXSk7XG4gICAgfVxuICAgIGlmIChwcm9qLmRhdHVtX3BhcmFtc1swXSAhPT0gMCB8fCBwcm9qLmRhdHVtX3BhcmFtc1sxXSAhPT0gMCB8fCBwcm9qLmRhdHVtX3BhcmFtc1syXSAhPT0gMCkge1xuICAgICAgdGhpcy5kYXR1bV90eXBlID0gUEpEXzNQQVJBTTtcbiAgICB9XG4gICAgaWYgKHByb2ouZGF0dW1fcGFyYW1zLmxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChwcm9qLmRhdHVtX3BhcmFtc1szXSAhPT0gMCB8fCBwcm9qLmRhdHVtX3BhcmFtc1s0XSAhPT0gMCB8fCBwcm9qLmRhdHVtX3BhcmFtc1s1XSAhPT0gMCB8fCBwcm9qLmRhdHVtX3BhcmFtc1s2XSAhPT0gMCkge1xuICAgICAgICB0aGlzLmRhdHVtX3R5cGUgPSBQSkRfN1BBUkFNO1xuICAgICAgICBwcm9qLmRhdHVtX3BhcmFtc1szXSAqPSBTRUNfVE9fUkFEO1xuICAgICAgICBwcm9qLmRhdHVtX3BhcmFtc1s0XSAqPSBTRUNfVE9fUkFEO1xuICAgICAgICBwcm9qLmRhdHVtX3BhcmFtc1s1XSAqPSBTRUNfVE9fUkFEO1xuICAgICAgICBwcm9qLmRhdHVtX3BhcmFtc1s2XSA9IChwcm9qLmRhdHVtX3BhcmFtc1s2XSAvIDEwMDAwMDAuMCkgKyAxLjA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIERHUiAyMDExLTAzLTIxIDogbmFkZ3JpZHMgc3VwcG9ydFxuICB0aGlzLmRhdHVtX3R5cGUgPSBwcm9qLmdyaWRzID8gUEpEX0dSSURTSElGVCA6IHRoaXMuZGF0dW1fdHlwZTtcblxuICB0aGlzLmEgPSBwcm9qLmE7IC8vZGF0dW0gb2JqZWN0IGFsc28gdXNlcyB0aGVzZSB2YWx1ZXNcbiAgdGhpcy5iID0gcHJvai5iO1xuICB0aGlzLmVzID0gcHJvai5lcztcbiAgdGhpcy5lcDIgPSBwcm9qLmVwMjtcbiAgdGhpcy5kYXR1bV9wYXJhbXMgPSBwcm9qLmRhdHVtX3BhcmFtcztcbiAgaWYgKHRoaXMuZGF0dW1fdHlwZSA9PT0gUEpEX0dSSURTSElGVCkge1xuICAgIHRoaXMuZ3JpZHMgPSBwcm9qLmdyaWRzO1xuICB9XG59O1xuZGF0dW0ucHJvdG90eXBlID0ge1xuXG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8vIGNzX2NvbXBhcmVfZGF0dW1zKClcbiAgLy8gICBSZXR1cm5zIFRSVUUgaWYgdGhlIHR3byBkYXR1bXMgbWF0Y2gsIG90aGVyd2lzZSBGQUxTRS5cbiAgY29tcGFyZV9kYXR1bXM6IGZ1bmN0aW9uKGRlc3QpIHtcbiAgICBpZiAodGhpcy5kYXR1bV90eXBlICE9PSBkZXN0LmRhdHVtX3R5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gZmFsc2UsIGRhdHVtcyBhcmUgbm90IGVxdWFsXG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuYSAhPT0gZGVzdC5hIHx8IE1hdGguYWJzKHRoaXMuZXMgLSBkZXN0LmVzKSA+IDAuMDAwMDAwMDAwMDUwKSB7XG4gICAgICAvLyB0aGUgdG9sZXJlbmNlIGZvciBlcyBpcyB0byBlbnN1cmUgdGhhdCBHUlM4MCBhbmQgV0dTODRcbiAgICAgIC8vIGFyZSBjb25zaWRlcmVkIGlkZW50aWNhbFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmRhdHVtX3R5cGUgPT09IFBKRF8zUEFSQU0pIHtcbiAgICAgIHJldHVybiAodGhpcy5kYXR1bV9wYXJhbXNbMF0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzBdICYmIHRoaXMuZGF0dW1fcGFyYW1zWzFdID09PSBkZXN0LmRhdHVtX3BhcmFtc1sxXSAmJiB0aGlzLmRhdHVtX3BhcmFtc1syXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMl0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmRhdHVtX3R5cGUgPT09IFBKRF83UEFSQU0pIHtcbiAgICAgIHJldHVybiAodGhpcy5kYXR1bV9wYXJhbXNbMF0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzBdICYmIHRoaXMuZGF0dW1fcGFyYW1zWzFdID09PSBkZXN0LmRhdHVtX3BhcmFtc1sxXSAmJiB0aGlzLmRhdHVtX3BhcmFtc1syXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMl0gJiYgdGhpcy5kYXR1bV9wYXJhbXNbM10gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzNdICYmIHRoaXMuZGF0dW1fcGFyYW1zWzRdID09PSBkZXN0LmRhdHVtX3BhcmFtc1s0XSAmJiB0aGlzLmRhdHVtX3BhcmFtc1s1XSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbNV0gJiYgdGhpcy5kYXR1bV9wYXJhbXNbNl0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzZdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5kYXR1bV90eXBlID09PSBQSkRfR1JJRFNISUZUIHx8IGRlc3QuZGF0dW1fdHlwZSA9PT0gUEpEX0dSSURTSElGVCkge1xuICAgICAgLy9hbGVydChcIkVSUk9SOiBHcmlkIHNoaWZ0IHRyYW5zZm9ybWF0aW9ucyBhcmUgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICAgIC8vcmV0dXJuIGZhbHNlXG4gICAgICAvL0RHUiAyMDEyLTA3LTI5IGxhenkgLi4uXG4gICAgICByZXR1cm4gdGhpcy5uYWRncmlkcyA9PT0gZGVzdC5uYWRncmlkcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gZGF0dW1zIGFyZSBlcXVhbFxuICAgIH1cbiAgfSwgLy8gY3NfY29tcGFyZV9kYXR1bXMoKVxuXG4gIC8qXG4gICAqIFRoZSBmdW5jdGlvbiBDb252ZXJ0X0dlb2RldGljX1RvX0dlb2NlbnRyaWMgY29udmVydHMgZ2VvZGV0aWMgY29vcmRpbmF0ZXNcbiAgICogKGxhdGl0dWRlLCBsb25naXR1ZGUsIGFuZCBoZWlnaHQpIHRvIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMgKFgsIFksIFopLFxuICAgKiBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgZWxsaXBzb2lkIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqICAgIExhdGl0dWRlICA6IEdlb2RldGljIGxhdGl0dWRlIGluIHJhZGlhbnMgICAgICAgICAgICAgICAgICAgICAoaW5wdXQpXG4gICAqICAgIExvbmdpdHVkZSA6IEdlb2RldGljIGxvbmdpdHVkZSBpbiByYWRpYW5zICAgICAgICAgICAgICAgICAgICAoaW5wdXQpXG4gICAqICAgIEhlaWdodCAgICA6IEdlb2RldGljIGhlaWdodCwgaW4gbWV0ZXJzICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQpXG4gICAqICAgIFggICAgICAgICA6IENhbGN1bGF0ZWQgR2VvY2VudHJpYyBYIGNvb3JkaW5hdGUsIGluIG1ldGVycyAgICAob3V0cHV0KVxuICAgKiAgICBZICAgICAgICAgOiBDYWxjdWxhdGVkIEdlb2NlbnRyaWMgWSBjb29yZGluYXRlLCBpbiBtZXRlcnMgICAgKG91dHB1dClcbiAgICogICAgWiAgICAgICAgIDogQ2FsY3VsYXRlZCBHZW9jZW50cmljIFogY29vcmRpbmF0ZSwgaW4gbWV0ZXJzICAgIChvdXRwdXQpXG4gICAqXG4gICAqL1xuICBnZW9kZXRpY190b19nZW9jZW50cmljOiBmdW5jdGlvbihwKSB7XG4gICAgdmFyIExvbmdpdHVkZSA9IHAueDtcbiAgICB2YXIgTGF0aXR1ZGUgPSBwLnk7XG4gICAgdmFyIEhlaWdodCA9IHAueiA/IHAueiA6IDA7IC8vWiB2YWx1ZSBub3QgYWx3YXlzIHN1cHBsaWVkXG4gICAgdmFyIFg7IC8vIG91dHB1dFxuICAgIHZhciBZO1xuICAgIHZhciBaO1xuXG4gICAgdmFyIEVycm9yX0NvZGUgPSAwOyAvLyAgR0VPQ0VOVF9OT19FUlJPUjtcbiAgICB2YXIgUm47IC8qICBFYXJ0aCByYWRpdXMgYXQgbG9jYXRpb24gICovXG4gICAgdmFyIFNpbl9MYXQ7IC8qICBNYXRoLnNpbihMYXRpdHVkZSkgICovXG4gICAgdmFyIFNpbjJfTGF0OyAvKiAgU3F1YXJlIG9mIE1hdGguc2luKExhdGl0dWRlKSAgKi9cbiAgICB2YXIgQ29zX0xhdDsgLyogIE1hdGguY29zKExhdGl0dWRlKSAgKi9cblxuICAgIC8qXG4gICAgICoqIERvbid0IGJsb3cgdXAgaWYgTGF0aXR1ZGUgaXMganVzdCBhIGxpdHRsZSBvdXQgb2YgdGhlIHZhbHVlXG4gICAgICoqIHJhbmdlIGFzIGl0IG1heSBqdXN0IGJlIGEgcm91bmRpbmcgaXNzdWUuICBBbHNvIHJlbW92ZWQgbG9uZ2l0dWRlXG4gICAgICoqIHRlc3QsIGl0IHNob3VsZCBiZSB3cmFwcGVkIGJ5IE1hdGguY29zKCkgYW5kIE1hdGguc2luKCkuICBORlcgZm9yIFBST0ouNCwgU2VwLzIwMDEuXG4gICAgICovXG4gICAgaWYgKExhdGl0dWRlIDwgLUhBTEZfUEkgJiYgTGF0aXR1ZGUgPiAtMS4wMDEgKiBIQUxGX1BJKSB7XG4gICAgICBMYXRpdHVkZSA9IC1IQUxGX1BJO1xuICAgIH1cbiAgICBlbHNlIGlmIChMYXRpdHVkZSA+IEhBTEZfUEkgJiYgTGF0aXR1ZGUgPCAxLjAwMSAqIEhBTEZfUEkpIHtcbiAgICAgIExhdGl0dWRlID0gSEFMRl9QSTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKExhdGl0dWRlIDwgLUhBTEZfUEkpIHx8IChMYXRpdHVkZSA+IEhBTEZfUEkpKSB7XG4gICAgICAvKiBMYXRpdHVkZSBvdXQgb2YgcmFuZ2UgKi9cbiAgICAgIC8vLi5yZXBvcnRFcnJvcignZ2VvY2VudDpsYXQgb3V0IG9mIHJhbmdlOicgKyBMYXRpdHVkZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoTG9uZ2l0dWRlID4gTWF0aC5QSSkge1xuICAgICAgTG9uZ2l0dWRlIC09ICgyICogTWF0aC5QSSk7XG4gICAgfVxuICAgIFNpbl9MYXQgPSBNYXRoLnNpbihMYXRpdHVkZSk7XG4gICAgQ29zX0xhdCA9IE1hdGguY29zKExhdGl0dWRlKTtcbiAgICBTaW4yX0xhdCA9IFNpbl9MYXQgKiBTaW5fTGF0O1xuICAgIFJuID0gdGhpcy5hIC8gKE1hdGguc3FydCgxLjBlMCAtIHRoaXMuZXMgKiBTaW4yX0xhdCkpO1xuICAgIFggPSAoUm4gKyBIZWlnaHQpICogQ29zX0xhdCAqIE1hdGguY29zKExvbmdpdHVkZSk7XG4gICAgWSA9IChSbiArIEhlaWdodCkgKiBDb3NfTGF0ICogTWF0aC5zaW4oTG9uZ2l0dWRlKTtcbiAgICBaID0gKChSbiAqICgxIC0gdGhpcy5lcykpICsgSGVpZ2h0KSAqIFNpbl9MYXQ7XG5cbiAgICBwLnggPSBYO1xuICAgIHAueSA9IFk7XG4gICAgcC56ID0gWjtcbiAgICByZXR1cm4gRXJyb3JfQ29kZTtcbiAgfSwgLy8gY3NfZ2VvZGV0aWNfdG9fZ2VvY2VudHJpYygpXG5cblxuICBnZW9jZW50cmljX3RvX2dlb2RldGljOiBmdW5jdGlvbihwKSB7XG4gICAgLyogbG9jYWwgZGVmaW50aW9ucyBhbmQgdmFyaWFibGVzICovXG4gICAgLyogZW5kLWNyaXRlcml1bSBvZiBsb29wLCBhY2N1cmFjeSBvZiBzaW4oTGF0aXR1ZGUpICovXG4gICAgdmFyIGdlbmF1ID0gMWUtMTI7XG4gICAgdmFyIGdlbmF1MiA9IChnZW5hdSAqIGdlbmF1KTtcbiAgICB2YXIgbWF4aXRlciA9IDMwO1xuXG4gICAgdmFyIFA7IC8qIGRpc3RhbmNlIGJldHdlZW4gc2VtaS1taW5vciBheGlzIGFuZCBsb2NhdGlvbiAqL1xuICAgIHZhciBSUjsgLyogZGlzdGFuY2UgYmV0d2VlbiBjZW50ZXIgYW5kIGxvY2F0aW9uICovXG4gICAgdmFyIENUOyAvKiBzaW4gb2YgZ2VvY2VudHJpYyBsYXRpdHVkZSAqL1xuICAgIHZhciBTVDsgLyogY29zIG9mIGdlb2NlbnRyaWMgbGF0aXR1ZGUgKi9cbiAgICB2YXIgUlg7XG4gICAgdmFyIFJLO1xuICAgIHZhciBSTjsgLyogRWFydGggcmFkaXVzIGF0IGxvY2F0aW9uICovXG4gICAgdmFyIENQSEkwOyAvKiBjb3Mgb2Ygc3RhcnQgb3Igb2xkIGdlb2RldGljIGxhdGl0dWRlIGluIGl0ZXJhdGlvbnMgKi9cbiAgICB2YXIgU1BISTA7IC8qIHNpbiBvZiBzdGFydCBvciBvbGQgZ2VvZGV0aWMgbGF0aXR1ZGUgaW4gaXRlcmF0aW9ucyAqL1xuICAgIHZhciBDUEhJOyAvKiBjb3Mgb2Ygc2VhcmNoZWQgZ2VvZGV0aWMgbGF0aXR1ZGUgKi9cbiAgICB2YXIgU1BISTsgLyogc2luIG9mIHNlYXJjaGVkIGdlb2RldGljIGxhdGl0dWRlICovXG4gICAgdmFyIFNEUEhJOyAvKiBlbmQtY3JpdGVyaXVtOiBhZGRpdGlvbi10aGVvcmVtIG9mIHNpbihMYXRpdHVkZShpdGVyKS1MYXRpdHVkZShpdGVyLTEpKSAqL1xuICAgIHZhciBBdF9Qb2xlOyAvKiBpbmRpY2F0ZXMgbG9jYXRpb24gaXMgaW4gcG9sYXIgcmVnaW9uICovXG4gICAgdmFyIGl0ZXI7IC8qICMgb2YgY29udGlub3VzIGl0ZXJhdGlvbiwgbWF4LiAzMCBpcyBhbHdheXMgZW5vdWdoIChzLmEuKSAqL1xuXG4gICAgdmFyIFggPSBwLng7XG4gICAgdmFyIFkgPSBwLnk7XG4gICAgdmFyIFogPSBwLnogPyBwLnogOiAwLjA7IC8vWiB2YWx1ZSBub3QgYWx3YXlzIHN1cHBsaWVkXG4gICAgdmFyIExvbmdpdHVkZTtcbiAgICB2YXIgTGF0aXR1ZGU7XG4gICAgdmFyIEhlaWdodDtcblxuICAgIEF0X1BvbGUgPSBmYWxzZTtcbiAgICBQID0gTWF0aC5zcXJ0KFggKiBYICsgWSAqIFkpO1xuICAgIFJSID0gTWF0aC5zcXJ0KFggKiBYICsgWSAqIFkgKyBaICogWik7XG5cbiAgICAvKiAgICAgIHNwZWNpYWwgY2FzZXMgZm9yIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKi9cbiAgICBpZiAoUCAvIHRoaXMuYSA8IGdlbmF1KSB7XG5cbiAgICAgIC8qICBzcGVjaWFsIGNhc2UsIGlmIFA9MC4gKFg9MC4sIFk9MC4pICovXG4gICAgICBBdF9Qb2xlID0gdHJ1ZTtcbiAgICAgIExvbmdpdHVkZSA9IDAuMDtcblxuICAgICAgLyogIGlmIChYLFksWik9KDAuLDAuLDAuKSB0aGVuIEhlaWdodCBiZWNvbWVzIHNlbWktbWlub3IgYXhpc1xuICAgICAgICogIG9mIGVsbGlwc29pZCAoPWNlbnRlciBvZiBtYXNzKSwgTGF0aXR1ZGUgYmVjb21lcyBQSS8yICovXG4gICAgICBpZiAoUlIgLyB0aGlzLmEgPCBnZW5hdSkge1xuICAgICAgICBMYXRpdHVkZSA9IEhBTEZfUEk7XG4gICAgICAgIEhlaWdodCA9IC10aGlzLmI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvKiAgZWxsaXBzb2lkYWwgKGdlb2RldGljKSBsb25naXR1ZGVcbiAgICAgICAqICBpbnRlcnZhbDogLVBJIDwgTG9uZ2l0dWRlIDw9ICtQSSAqL1xuICAgICAgTG9uZ2l0dWRlID0gTWF0aC5hdGFuMihZLCBYKTtcbiAgICB9XG5cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIEZvbGxvd2luZyBpdGVyYXRpdmUgYWxnb3JpdGhtIHdhcyBkZXZlbG9wcGVkIGJ5XG4gICAgICogXCJJbnN0aXR1dCBmb3IgRXJkbWVzc3VuZ1wiLCBVbml2ZXJzaXR5IG9mIEhhbm5vdmVyLCBKdWx5IDE5ODguXG4gICAgICogSW50ZXJuZXQ6IHd3dy5pZmUudW5pLWhhbm5vdmVyLmRlXG4gICAgICogSXRlcmF0aXZlIGNvbXB1dGF0aW9uIG9mIENQSEksU1BISSBhbmQgSGVpZ2h0LlxuICAgICAqIEl0ZXJhdGlvbiBvZiBDUEhJIGFuZCBTUEhJIHRvIDEwKiotMTIgcmFkaWFuIHJlc3AuXG4gICAgICogMioxMCoqLTcgYXJjc2VjLlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICovXG4gICAgQ1QgPSBaIC8gUlI7XG4gICAgU1QgPSBQIC8gUlI7XG4gICAgUlggPSAxLjAgLyBNYXRoLnNxcnQoMS4wIC0gdGhpcy5lcyAqICgyLjAgLSB0aGlzLmVzKSAqIFNUICogU1QpO1xuICAgIENQSEkwID0gU1QgKiAoMS4wIC0gdGhpcy5lcykgKiBSWDtcbiAgICBTUEhJMCA9IENUICogUlg7XG4gICAgaXRlciA9IDA7XG5cbiAgICAvKiBsb29wIHRvIGZpbmQgc2luKExhdGl0dWRlKSByZXNwLiBMYXRpdHVkZVxuICAgICAqIHVudGlsIHxzaW4oTGF0aXR1ZGUoaXRlciktTGF0aXR1ZGUoaXRlci0xKSl8IDwgZ2VuYXUgKi9cbiAgICBkbyB7XG4gICAgICBpdGVyKys7XG4gICAgICBSTiA9IHRoaXMuYSAvIE1hdGguc3FydCgxLjAgLSB0aGlzLmVzICogU1BISTAgKiBTUEhJMCk7XG5cbiAgICAgIC8qICBlbGxpcHNvaWRhbCAoZ2VvZGV0aWMpIGhlaWdodCAqL1xuICAgICAgSGVpZ2h0ID0gUCAqIENQSEkwICsgWiAqIFNQSEkwIC0gUk4gKiAoMS4wIC0gdGhpcy5lcyAqIFNQSEkwICogU1BISTApO1xuXG4gICAgICBSSyA9IHRoaXMuZXMgKiBSTiAvIChSTiArIEhlaWdodCk7XG4gICAgICBSWCA9IDEuMCAvIE1hdGguc3FydCgxLjAgLSBSSyAqICgyLjAgLSBSSykgKiBTVCAqIFNUKTtcbiAgICAgIENQSEkgPSBTVCAqICgxLjAgLSBSSykgKiBSWDtcbiAgICAgIFNQSEkgPSBDVCAqIFJYO1xuICAgICAgU0RQSEkgPSBTUEhJICogQ1BISTAgLSBDUEhJICogU1BISTA7XG4gICAgICBDUEhJMCA9IENQSEk7XG4gICAgICBTUEhJMCA9IFNQSEk7XG4gICAgfVxuICAgIHdoaWxlIChTRFBISSAqIFNEUEhJID4gZ2VuYXUyICYmIGl0ZXIgPCBtYXhpdGVyKTtcblxuICAgIC8qICAgICAgZWxsaXBzb2lkYWwgKGdlb2RldGljKSBsYXRpdHVkZSAqL1xuICAgIExhdGl0dWRlID0gTWF0aC5hdGFuKFNQSEkgLyBNYXRoLmFicyhDUEhJKSk7XG5cbiAgICBwLnggPSBMb25naXR1ZGU7XG4gICAgcC55ID0gTGF0aXR1ZGU7XG4gICAgcC56ID0gSGVpZ2h0O1xuICAgIHJldHVybiBwO1xuICB9LCAvLyBjc19nZW9jZW50cmljX3RvX2dlb2RldGljKClcblxuICAvKiogQ29udmVydF9HZW9jZW50cmljX1RvX0dlb2RldGljXG4gICAqIFRoZSBtZXRob2QgdXNlZCBoZXJlIGlzIGRlcml2ZWQgZnJvbSAnQW4gSW1wcm92ZWQgQWxnb3JpdGhtIGZvclxuICAgKiBHZW9jZW50cmljIHRvIEdlb2RldGljIENvb3JkaW5hdGUgQ29udmVyc2lvbicsIGJ5IFJhbHBoIFRvbXMsIEZlYiAxOTk2XG4gICAqL1xuICBnZW9jZW50cmljX3RvX2dlb2RldGljX25vbml0ZXI6IGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgWCA9IHAueDtcbiAgICB2YXIgWSA9IHAueTtcbiAgICB2YXIgWiA9IHAueiA/IHAueiA6IDA7IC8vWiB2YWx1ZSBub3QgYWx3YXlzIHN1cHBsaWVkXG4gICAgdmFyIExvbmdpdHVkZTtcbiAgICB2YXIgTGF0aXR1ZGU7XG4gICAgdmFyIEhlaWdodDtcblxuICAgIHZhciBXOyAvKiBkaXN0YW5jZSBmcm9tIFogYXhpcyAqL1xuICAgIHZhciBXMjsgLyogc3F1YXJlIG9mIGRpc3RhbmNlIGZyb20gWiBheGlzICovXG4gICAgdmFyIFQwOyAvKiBpbml0aWFsIGVzdGltYXRlIG9mIHZlcnRpY2FsIGNvbXBvbmVudCAqL1xuICAgIHZhciBUMTsgLyogY29ycmVjdGVkIGVzdGltYXRlIG9mIHZlcnRpY2FsIGNvbXBvbmVudCAqL1xuICAgIHZhciBTMDsgLyogaW5pdGlhbCBlc3RpbWF0ZSBvZiBob3Jpem9udGFsIGNvbXBvbmVudCAqL1xuICAgIHZhciBTMTsgLyogY29ycmVjdGVkIGVzdGltYXRlIG9mIGhvcml6b250YWwgY29tcG9uZW50ICovXG4gICAgdmFyIFNpbl9CMDsgLyogTWF0aC5zaW4oQjApLCBCMCBpcyBlc3RpbWF0ZSBvZiBCb3dyaW5nIGF1eCB2YXJpYWJsZSAqL1xuICAgIHZhciBTaW4zX0IwOyAvKiBjdWJlIG9mIE1hdGguc2luKEIwKSAqL1xuICAgIHZhciBDb3NfQjA7IC8qIE1hdGguY29zKEIwKSAqL1xuICAgIHZhciBTaW5fcDE7IC8qIE1hdGguc2luKHBoaTEpLCBwaGkxIGlzIGVzdGltYXRlZCBsYXRpdHVkZSAqL1xuICAgIHZhciBDb3NfcDE7IC8qIE1hdGguY29zKHBoaTEpICovXG4gICAgdmFyIFJuOyAvKiBFYXJ0aCByYWRpdXMgYXQgbG9jYXRpb24gKi9cbiAgICB2YXIgU3VtOyAvKiBudW1lcmF0b3Igb2YgTWF0aC5jb3MocGhpMSkgKi9cbiAgICB2YXIgQXRfUG9sZTsgLyogaW5kaWNhdGVzIGxvY2F0aW9uIGlzIGluIHBvbGFyIHJlZ2lvbiAqL1xuXG4gICAgWCA9IHBhcnNlRmxvYXQoWCk7IC8vIGNhc3QgZnJvbSBzdHJpbmcgdG8gZmxvYXRcbiAgICBZID0gcGFyc2VGbG9hdChZKTtcbiAgICBaID0gcGFyc2VGbG9hdChaKTtcblxuICAgIEF0X1BvbGUgPSBmYWxzZTtcbiAgICBpZiAoWCAhPT0gMC4wKSB7XG4gICAgICBMb25naXR1ZGUgPSBNYXRoLmF0YW4yKFksIFgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChZID4gMCkge1xuICAgICAgICBMb25naXR1ZGUgPSBIQUxGX1BJO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoWSA8IDApIHtcbiAgICAgICAgTG9uZ2l0dWRlID0gLUhBTEZfUEk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgQXRfUG9sZSA9IHRydWU7XG4gICAgICAgIExvbmdpdHVkZSA9IDAuMDtcbiAgICAgICAgaWYgKFogPiAwLjApIHsgLyogbm9ydGggcG9sZSAqL1xuICAgICAgICAgIExhdGl0dWRlID0gSEFMRl9QSTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChaIDwgMC4wKSB7IC8qIHNvdXRoIHBvbGUgKi9cbiAgICAgICAgICBMYXRpdHVkZSA9IC1IQUxGX1BJO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvKiBjZW50ZXIgb2YgZWFydGggKi9cbiAgICAgICAgICBMYXRpdHVkZSA9IEhBTEZfUEk7XG4gICAgICAgICAgSGVpZ2h0ID0gLXRoaXMuYjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgVzIgPSBYICogWCArIFkgKiBZO1xuICAgIFcgPSBNYXRoLnNxcnQoVzIpO1xuICAgIFQwID0gWiAqIEFEX0M7XG4gICAgUzAgPSBNYXRoLnNxcnQoVDAgKiBUMCArIFcyKTtcbiAgICBTaW5fQjAgPSBUMCAvIFMwO1xuICAgIENvc19CMCA9IFcgLyBTMDtcbiAgICBTaW4zX0IwID0gU2luX0IwICogU2luX0IwICogU2luX0IwO1xuICAgIFQxID0gWiArIHRoaXMuYiAqIHRoaXMuZXAyICogU2luM19CMDtcbiAgICBTdW0gPSBXIC0gdGhpcy5hICogdGhpcy5lcyAqIENvc19CMCAqIENvc19CMCAqIENvc19CMDtcbiAgICBTMSA9IE1hdGguc3FydChUMSAqIFQxICsgU3VtICogU3VtKTtcbiAgICBTaW5fcDEgPSBUMSAvIFMxO1xuICAgIENvc19wMSA9IFN1bSAvIFMxO1xuICAgIFJuID0gdGhpcy5hIC8gTWF0aC5zcXJ0KDEuMCAtIHRoaXMuZXMgKiBTaW5fcDEgKiBTaW5fcDEpO1xuICAgIGlmIChDb3NfcDEgPj0gQ09TXzY3UDUpIHtcbiAgICAgIEhlaWdodCA9IFcgLyBDb3NfcDEgLSBSbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoQ29zX3AxIDw9IC1DT1NfNjdQNSkge1xuICAgICAgSGVpZ2h0ID0gVyAvIC1Db3NfcDEgLSBSbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBIZWlnaHQgPSBaIC8gU2luX3AxICsgUm4gKiAodGhpcy5lcyAtIDEuMCk7XG4gICAgfVxuICAgIGlmIChBdF9Qb2xlID09PSBmYWxzZSkge1xuICAgICAgTGF0aXR1ZGUgPSBNYXRoLmF0YW4oU2luX3AxIC8gQ29zX3AxKTtcbiAgICB9XG5cbiAgICBwLnggPSBMb25naXR1ZGU7XG4gICAgcC55ID0gTGF0aXR1ZGU7XG4gICAgcC56ID0gSGVpZ2h0O1xuICAgIHJldHVybiBwO1xuICB9LCAvLyBnZW9jZW50cmljX3RvX2dlb2RldGljX25vbml0ZXIoKVxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvLyBwal9nZW9jZW50aWNfdG9fd2dzODQoIHAgKVxuICAvLyAgcCA9IHBvaW50IHRvIHRyYW5zZm9ybSBpbiBnZW9jZW50cmljIGNvb3JkaW5hdGVzICh4LHkseilcbiAgZ2VvY2VudHJpY190b193Z3M4NDogZnVuY3Rpb24ocCkge1xuXG4gICAgaWYgKHRoaXMuZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSkge1xuICAgICAgLy8gaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgICAvLyAgICBjb250aW51ZTtcbiAgICAgIHAueCArPSB0aGlzLmRhdHVtX3BhcmFtc1swXTtcbiAgICAgIHAueSArPSB0aGlzLmRhdHVtX3BhcmFtc1sxXTtcbiAgICAgIHAueiArPSB0aGlzLmRhdHVtX3BhcmFtc1syXTtcblxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmRhdHVtX3R5cGUgPT09IFBKRF83UEFSQU0pIHtcbiAgICAgIHZhciBEeF9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzBdO1xuICAgICAgdmFyIER5X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbMV07XG4gICAgICB2YXIgRHpfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1syXTtcbiAgICAgIHZhciBSeF9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzNdO1xuICAgICAgdmFyIFJ5X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbNF07XG4gICAgICB2YXIgUnpfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1s1XTtcbiAgICAgIHZhciBNX0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbNl07XG4gICAgICAvLyBpZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAgIC8vICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIHhfb3V0ID0gTV9CRiAqIChwLnggLSBSel9CRiAqIHAueSArIFJ5X0JGICogcC56KSArIER4X0JGO1xuICAgICAgdmFyIHlfb3V0ID0gTV9CRiAqIChSel9CRiAqIHAueCArIHAueSAtIFJ4X0JGICogcC56KSArIER5X0JGO1xuICAgICAgdmFyIHpfb3V0ID0gTV9CRiAqICgtUnlfQkYgKiBwLnggKyBSeF9CRiAqIHAueSArIHAueikgKyBEel9CRjtcbiAgICAgIHAueCA9IHhfb3V0O1xuICAgICAgcC55ID0geV9vdXQ7XG4gICAgICBwLnogPSB6X291dDtcbiAgICB9XG4gIH0sIC8vIGNzX2dlb2NlbnRyaWNfdG9fd2dzODRcblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLy8gcGpfZ2VvY2VudGljX2Zyb21fd2dzODQoKVxuICAvLyAgY29vcmRpbmF0ZSBzeXN0ZW0gZGVmaW5pdGlvbixcbiAgLy8gIHBvaW50IHRvIHRyYW5zZm9ybSBpbiBnZW9jZW50cmljIGNvb3JkaW5hdGVzICh4LHkseilcbiAgZ2VvY2VudHJpY19mcm9tX3dnczg0OiBmdW5jdGlvbihwKSB7XG5cbiAgICBpZiAodGhpcy5kYXR1bV90eXBlID09PSBQSkRfM1BBUkFNKSB7XG4gICAgICAvL2lmKCB4W2lvXSA9PT0gSFVHRV9WQUwgKVxuICAgICAgLy8gICAgY29udGludWU7XG4gICAgICBwLnggLT0gdGhpcy5kYXR1bV9wYXJhbXNbMF07XG4gICAgICBwLnkgLT0gdGhpcy5kYXR1bV9wYXJhbXNbMV07XG4gICAgICBwLnogLT0gdGhpcy5kYXR1bV9wYXJhbXNbMl07XG5cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5kYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSB7XG4gICAgICB2YXIgRHhfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1swXTtcbiAgICAgIHZhciBEeV9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzFdO1xuICAgICAgdmFyIER6X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbMl07XG4gICAgICB2YXIgUnhfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1szXTtcbiAgICAgIHZhciBSeV9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzRdO1xuICAgICAgdmFyIFJ6X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbNV07XG4gICAgICB2YXIgTV9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzZdO1xuICAgICAgdmFyIHhfdG1wID0gKHAueCAtIER4X0JGKSAvIE1fQkY7XG4gICAgICB2YXIgeV90bXAgPSAocC55IC0gRHlfQkYpIC8gTV9CRjtcbiAgICAgIHZhciB6X3RtcCA9IChwLnogLSBEel9CRikgLyBNX0JGO1xuICAgICAgLy9pZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAgIC8vICAgIGNvbnRpbnVlO1xuXG4gICAgICBwLnggPSB4X3RtcCArIFJ6X0JGICogeV90bXAgLSBSeV9CRiAqIHpfdG1wO1xuICAgICAgcC55ID0gLVJ6X0JGICogeF90bXAgKyB5X3RtcCArIFJ4X0JGICogel90bXA7XG4gICAgICBwLnogPSBSeV9CRiAqIHhfdG1wIC0gUnhfQkYgKiB5X3RtcCArIHpfdG1wO1xuICAgIH0gLy9jc19nZW9jZW50cmljX2Zyb21fd2dzODQoKVxuICB9XG59O1xuXG4vKiogcG9pbnQgb2JqZWN0LCBub3RoaW5nIGZhbmN5LCBqdXN0IGFsbG93cyB2YWx1ZXMgdG8gYmVcbiAgICBwYXNzZWQgYmFjayBhbmQgZm9ydGggYnkgcmVmZXJlbmNlIHJhdGhlciB0aGFuIGJ5IHZhbHVlLlxuICAgIE90aGVyIHBvaW50IGNsYXNzZXMgbWF5IGJlIHVzZWQgYXMgbG9uZyBhcyB0aGV5IGhhdmVcbiAgICB4IGFuZCB5IHByb3BlcnRpZXMsIHdoaWNoIHdpbGwgZ2V0IG1vZGlmaWVkIGluIHRoZSB0cmFuc2Zvcm0gbWV0aG9kLlxuKi9cbm1vZHVsZS5leHBvcnRzID0gZGF0dW07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kYXR1bS5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgUEpEXzNQQVJBTSA9IDE7XG52YXIgUEpEXzdQQVJBTSA9IDI7XG52YXIgUEpEX0dSSURTSElGVCA9IDM7XG52YXIgUEpEX05PREFUVU0gPSA1OyAvLyBXR1M4NCBvciBlcXVpdmFsZW50XG52YXIgU1JTX1dHUzg0X1NFTUlNQUpPUiA9IDYzNzgxMzc7IC8vIG9ubHkgdXNlZCBpbiBncmlkIHNoaWZ0IHRyYW5zZm9ybXNcbnZhciBTUlNfV0dTODRfRVNRVUFSRUQgPSAwLjAwNjY5NDM3OTk5MDE0MTMxNjsgLy9ER1I6IDIwMTItMDctMjlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc291cmNlLCBkZXN0LCBwb2ludCkge1xuICB2YXIgd3AsIGksIGw7XG5cbiAgZnVuY3Rpb24gY2hlY2tQYXJhbXMoZmFsbGJhY2spIHtcbiAgICByZXR1cm4gKGZhbGxiYWNrID09PSBQSkRfM1BBUkFNIHx8IGZhbGxiYWNrID09PSBQSkRfN1BBUkFNKTtcbiAgfVxuICAvLyBTaG9ydCBjdXQgaWYgdGhlIGRhdHVtcyBhcmUgaWRlbnRpY2FsLlxuICBpZiAoc291cmNlLmNvbXBhcmVfZGF0dW1zKGRlc3QpKSB7XG4gICAgcmV0dXJuIHBvaW50OyAvLyBpbiB0aGlzIGNhc2UsIHplcm8gaXMgc3VjZXNzLFxuICAgIC8vIHdoZXJlYXMgY3NfY29tcGFyZV9kYXR1bXMgcmV0dXJucyAxIHRvIGluZGljYXRlIFRSVUVcbiAgICAvLyBjb25mdXNpbmcsIHNob3VsZCBmaXggdGhpc1xuICB9XG5cbiAgLy8gRXhwbGljaXRseSBza2lwIGRhdHVtIHRyYW5zZm9ybSBieSBzZXR0aW5nICdkYXR1bT1ub25lJyBhcyBwYXJhbWV0ZXIgZm9yIGVpdGhlciBzb3VyY2Ugb3IgZGVzdFxuICBpZiAoc291cmNlLmRhdHVtX3R5cGUgPT09IFBKRF9OT0RBVFVNIHx8IGRlc3QuZGF0dW1fdHlwZSA9PT0gUEpEX05PREFUVU0pIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICAvL0RHUjogMjAxMi0wNy0yOSA6IGFkZCBuYWRncmlkcyBzdXBwb3J0IChiZWdpbilcbiAgdmFyIHNyY19hID0gc291cmNlLmE7XG4gIHZhciBzcmNfZXMgPSBzb3VyY2UuZXM7XG5cbiAgdmFyIGRzdF9hID0gZGVzdC5hO1xuICB2YXIgZHN0X2VzID0gZGVzdC5lcztcblxuICB2YXIgZmFsbGJhY2sgPSBzb3VyY2UuZGF0dW1fdHlwZTtcbiAgLy8gSWYgdGhpcyBkYXR1bSByZXF1aXJlcyBncmlkIHNoaWZ0cywgdGhlbiBhcHBseSBpdCB0byBnZW9kZXRpYyBjb29yZGluYXRlcy5cbiAgaWYgKGZhbGxiYWNrID09PSBQSkRfR1JJRFNISUZUKSB7XG4gICAgaWYgKHRoaXMuYXBwbHlfZ3JpZHNoaWZ0KHNvdXJjZSwgMCwgcG9pbnQpID09PSAwKSB7XG4gICAgICBzb3VyY2UuYSA9IFNSU19XR1M4NF9TRU1JTUFKT1I7XG4gICAgICBzb3VyY2UuZXMgPSBTUlNfV0dTODRfRVNRVUFSRUQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdHJ5IDMgb3IgNyBwYXJhbXMgdHJhbnNmb3JtYXRpb24gb3Igbm90aGluZyA/XG4gICAgICBpZiAoIXNvdXJjZS5kYXR1bV9wYXJhbXMpIHtcbiAgICAgICAgc291cmNlLmEgPSBzcmNfYTtcbiAgICAgICAgc291cmNlLmVzID0gc291cmNlLmVzO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9XG4gICAgICB3cCA9IDE7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gc291cmNlLmRhdHVtX3BhcmFtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgd3AgKj0gc291cmNlLmRhdHVtX3BhcmFtc1tpXTtcbiAgICAgIH1cbiAgICAgIGlmICh3cCA9PT0gMCkge1xuICAgICAgICBzb3VyY2UuYSA9IHNyY19hO1xuICAgICAgICBzb3VyY2UuZXMgPSBzb3VyY2UuZXM7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UuZGF0dW1fcGFyYW1zLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgZmFsbGJhY2sgPSBQSkRfN1BBUkFNO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZhbGxiYWNrID0gUEpEXzNQQVJBTTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRlc3QuZGF0dW1fdHlwZSA9PT0gUEpEX0dSSURTSElGVCkge1xuICAgIGRlc3QuYSA9IFNSU19XR1M4NF9TRU1JTUFKT1I7XG4gICAgZGVzdC5lcyA9IFNSU19XR1M4NF9FU1FVQVJFRDtcbiAgfVxuICAvLyBEbyB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggZ2VvY2VudHJpYyBjb29yZGluYXRlcz9cbiAgaWYgKHNvdXJjZS5lcyAhPT0gZGVzdC5lcyB8fCBzb3VyY2UuYSAhPT0gZGVzdC5hIHx8IGNoZWNrUGFyYW1zKGZhbGxiYWNrKSB8fCBjaGVja1BhcmFtcyhkZXN0LmRhdHVtX3R5cGUpKSB7XG4gICAgLy9ER1I6IDIwMTItMDctMjkgOiBhZGQgbmFkZ3JpZHMgc3VwcG9ydCAoZW5kKVxuICAgIC8vIENvbnZlcnQgdG8gZ2VvY2VudHJpYyBjb29yZGluYXRlcy5cbiAgICBzb3VyY2UuZ2VvZGV0aWNfdG9fZ2VvY2VudHJpYyhwb2ludCk7XG4gICAgLy8gQ0hFQ0tfUkVUVVJOO1xuICAgIC8vIENvbnZlcnQgYmV0d2VlbiBkYXR1bXNcbiAgICBpZiAoY2hlY2tQYXJhbXMoc291cmNlLmRhdHVtX3R5cGUpKSB7XG4gICAgICBzb3VyY2UuZ2VvY2VudHJpY190b193Z3M4NChwb2ludCk7XG4gICAgICAvLyBDSEVDS19SRVRVUk47XG4gICAgfVxuICAgIGlmIChjaGVja1BhcmFtcyhkZXN0LmRhdHVtX3R5cGUpKSB7XG4gICAgICBkZXN0Lmdlb2NlbnRyaWNfZnJvbV93Z3M4NChwb2ludCk7XG4gICAgICAvLyBDSEVDS19SRVRVUk47XG4gICAgfVxuICAgIC8vIENvbnZlcnQgYmFjayB0byBnZW9kZXRpYyBjb29yZGluYXRlc1xuICAgIGRlc3QuZ2VvY2VudHJpY190b19nZW9kZXRpYyhwb2ludCk7XG4gICAgLy8gQ0hFQ0tfUkVUVVJOO1xuICB9XG4gIC8vIEFwcGx5IGdyaWQgc2hpZnQgdG8gZGVzdGluYXRpb24gaWYgcmVxdWlyZWRcbiAgaWYgKGRlc3QuZGF0dW1fdHlwZSA9PT0gUEpEX0dSSURTSElGVCkge1xuICAgIHRoaXMuYXBwbHlfZ3JpZHNoaWZ0KGRlc3QsIDEsIHBvaW50KTtcbiAgICAvLyBDSEVDS19SRVRVUk47XG4gIH1cblxuICBzb3VyY2UuYSA9IHNyY19hO1xuICBzb3VyY2UuZXMgPSBzcmNfZXM7XG4gIGRlc3QuYSA9IGRzdF9hO1xuICBkZXN0LmVzID0gZHN0X2VzO1xuXG4gIHJldHVybiBwb2ludDtcbn07XG5cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2RhdHVtX3RyYW5zZm9ybS5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4vZ2xvYmFsJyk7XG52YXIgcGFyc2VQcm9qID0gcmVxdWlyZSgnLi9wcm9qU3RyaW5nJyk7XG52YXIgd2t0ID0gcmVxdWlyZSgnLi93a3QnKTtcblxuZnVuY3Rpb24gZGVmcyhuYW1lKSB7XG4gIC8qZ2xvYmFsIGNvbnNvbGUqL1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGRlZiA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChkZWYuY2hhckF0KDApID09PSAnKycpIHtcbiAgICAgICAgZGVmc1tuYW1lXSA9IHBhcnNlUHJvaihhcmd1bWVudHNbMV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlZnNbbmFtZV0gPSB3a3QoYXJndW1lbnRzWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmc1tuYW1lXSA9IGRlZjtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gbmFtZS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIGRlZnMuYXBwbHkodGhhdCwgdik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVmcyh2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG5hbWUgaW4gZGVmcykge1xuICAgICAgICByZXR1cm4gZGVmc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoJ0VQU0cnIGluIG5hbWUpIHtcbiAgICAgIGRlZnNbJ0VQU0c6JyArIG5hbWUuRVBTR10gPSBuYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmICgnRVNSSScgaW4gbmFtZSkge1xuICAgICAgZGVmc1snRVNSSTonICsgbmFtZS5FU1JJXSA9IG5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdJQVUyMDAwJyBpbiBuYW1lKSB7XG4gICAgICBkZWZzWydJQVUyMDAwOicgKyBuYW1lLklBVTIwMDBdID0gbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cblxufVxuZ2xvYmFscyhkZWZzKTtcbm1vZHVsZS5leHBvcnRzID0gZGVmcztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2RlZnMuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIERhdHVtID0gcmVxdWlyZSgnLi9jb25zdGFudHMvRGF0dW0nKTtcbnZhciBFbGxpcHNvaWQgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9FbGxpcHNvaWQnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xudmFyIGRhdHVtID0gcmVxdWlyZSgnLi9kYXR1bScpO1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbi8vIGVsbGlwb2lkIHBqX3NldF9lbGwuY1xudmFyIFNJWFRIID0gMC4xNjY2NjY2NjY2NjY2NjY2NjY3O1xuLyogMS82ICovXG52YXIgUkE0ID0gMC4wNDcyMjIyMjIyMjIyMjIyMjIyMjtcbi8qIDE3LzM2MCAqL1xudmFyIFJBNiA9IDAuMDIyMTU2MDg0NjU2MDg0NjU2MDg7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGpzb24pIHtcbiAgLy8gREdSIDIwMTEtMDMtMjAgOiBuYWdyaWRzIC0+IG5hZGdyaWRzXG4gIGlmIChqc29uLmRhdHVtQ29kZSAmJiBqc29uLmRhdHVtQ29kZSAhPT0gJ25vbmUnKSB7XG4gICAgdmFyIGRhdHVtRGVmID0gRGF0dW1banNvbi5kYXR1bUNvZGVdO1xuICAgIGlmIChkYXR1bURlZikge1xuICAgICAganNvbi5kYXR1bV9wYXJhbXMgPSBkYXR1bURlZi50b3dnczg0ID8gZGF0dW1EZWYudG93Z3M4NC5zcGxpdCgnLCcpIDogbnVsbDtcbiAgICAgIGpzb24uZWxscHMgPSBkYXR1bURlZi5lbGxpcHNlO1xuICAgICAganNvbi5kYXR1bU5hbWUgPSBkYXR1bURlZi5kYXR1bU5hbWUgPyBkYXR1bURlZi5kYXR1bU5hbWUgOiBqc29uLmRhdHVtQ29kZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFqc29uLmEpIHsgLy8gZG8gd2UgaGF2ZSBhbiBlbGxpcHNvaWQ/XG4gICAgdmFyIGVsbGlwc2UgPSBFbGxpcHNvaWRbanNvbi5lbGxwc10gPyBFbGxpcHNvaWRbanNvbi5lbGxwc10gOiBFbGxpcHNvaWQuV0dTODQ7XG4gICAgZXh0ZW5kKGpzb24sIGVsbGlwc2UpO1xuICB9XG4gIGlmIChqc29uLnJmICYmICFqc29uLmIpIHtcbiAgICBqc29uLmIgPSAoMS4wIC0gMS4wIC8ganNvbi5yZikgKiBqc29uLmE7XG4gIH1cbiAgaWYgKGpzb24ucmYgPT09IDAgfHwgTWF0aC5hYnMoanNvbi5hIC0ganNvbi5iKSA8IEVQU0xOKSB7XG4gICAganNvbi5zcGhlcmUgPSB0cnVlO1xuICAgIGpzb24uYiA9IGpzb24uYTtcbiAgfVxuICBqc29uLmEyID0ganNvbi5hICoganNvbi5hOyAvLyB1c2VkIGluIGdlb2NlbnRyaWNcbiAganNvbi5iMiA9IGpzb24uYiAqIGpzb24uYjsgLy8gdXNlZCBpbiBnZW9jZW50cmljXG4gIGpzb24uZXMgPSAoanNvbi5hMiAtIGpzb24uYjIpIC8ganNvbi5hMjsgLy8gZSBeIDJcbiAganNvbi5lID0gTWF0aC5zcXJ0KGpzb24uZXMpOyAvLyBlY2NlbnRyaWNpdHlcbiAgaWYgKGpzb24uUl9BKSB7XG4gICAganNvbi5hICo9IDEgLSBqc29uLmVzICogKFNJWFRIICsganNvbi5lcyAqIChSQTQgKyBqc29uLmVzICogUkE2KSk7XG4gICAganNvbi5hMiA9IGpzb24uYSAqIGpzb24uYTtcbiAgICBqc29uLmIyID0ganNvbi5iICoganNvbi5iO1xuICAgIGpzb24uZXMgPSAwO1xuICB9XG4gIGpzb24uZXAyID0gKGpzb24uYTIgLSBqc29uLmIyKSAvIGpzb24uYjI7IC8vIHVzZWQgaW4gZ2VvY2VudHJpY1xuICBpZiAoIWpzb24uazApIHtcbiAgICBqc29uLmswID0gMS4wOyAvL2RlZmF1bHQgdmFsdWVcbiAgfVxuICAvL0RHUiAyMDEwLTExLTEyOiBheGlzXG4gIGlmICghanNvbi5heGlzKSB7XG4gICAganNvbi5heGlzID0gXCJlbnVcIjtcbiAgfVxuXG4gIGlmICghanNvbi5kYXR1bSkge1xuICAgIGpzb24uZGF0dW0gPSBkYXR1bShqc29uKTtcbiAgfVxuICByZXR1cm4ganNvbjtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9kZXJpdmVDb25zdGFudHMuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gIGRlc3RpbmF0aW9uID0gZGVzdGluYXRpb24gfHwge307XG4gIHZhciB2YWx1ZSwgcHJvcGVydHk7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG4gIGZvciAocHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL2V4dGVuZC5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRlZnMpIHtcbiAgZGVmcygnRVBTRzo0MzI2JywgXCIrdGl0bGU9V0dTIDg0IChsb25nL2xhdCkgK3Byb2o9bG9uZ2xhdCArZWxscHM9V0dTODQgK2RhdHVtPVdHUzg0ICt1bml0cz1kZWdyZWVzXCIpO1xuICBkZWZzKCdFUFNHOjQyNjknLCBcIit0aXRsZT1OQUQ4MyAobG9uZy9sYXQpICtwcm9qPWxvbmdsYXQgK2E9NjM3ODEzNy4wICtiPTYzNTY3NTIuMzE0MTQwMzYgK2VsbHBzPUdSUzgwICtkYXR1bT1OQUQ4MyArdW5pdHM9ZGVncmVlc1wiKTtcbiAgZGVmcygnRVBTRzozODU3JywgXCIrdGl0bGU9V0dTIDg0IC8gUHNldWRvLU1lcmNhdG9yICtwcm9qPW1lcmMgK2E9NjM3ODEzNyArYj02Mzc4MTM3ICtsYXRfdHM9MC4wICtsb25fMD0wLjAgK3hfMD0wLjAgK3lfMD0wICtrPTEuMCArdW5pdHM9bSArbmFkZ3JpZHM9QG51bGwgK25vX2RlZnNcIik7XG5cbiAgZGVmcy5XR1M4NCA9IGRlZnNbJ0VQU0c6NDMyNiddO1xuICBkZWZzWydFUFNHOjM3ODUnXSA9IGRlZnNbJ0VQU0c6Mzg1NyddOyAvLyBtYWludGFpbiBiYWNrd2FyZCBjb21wYXQsIG9mZmljaWFsIGNvZGUgaXMgMzg1N1xuICBkZWZzLkdPT0dMRSA9IGRlZnNbJ0VQU0c6Mzg1NyddO1xuICBkZWZzWydFUFNHOjkwMDkxMyddID0gZGVmc1snRVBTRzozODU3J107XG4gIGRlZnNbJ0VQU0c6MTAyMTEzJ10gPSBkZWZzWydFUFNHOjM4NTcnXTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9nbG9iYWwuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHByb2pzID0gW1xuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL3RtZXJjJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvdXRtJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvc3RlcmVhJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvc3RlcmUnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9zb21lcmMnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9vbWVyYycpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL2xjYycpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL2tyb3ZhaycpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL2Nhc3MnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9sYWVhJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvYWVhJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvZ25vbScpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL2NlYScpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL2VxYycpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL3BvbHknKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9uem1nJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvbWlsbCcpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL3NpbnUnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9tb2xsJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvZXFkYycpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL3ZhbmRnJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvYWVxZCcpXG5dO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm9qNCl7XG4gIHByb2pzLmZvckVhY2goZnVuY3Rpb24ocHJvail7XG4gICAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQocHJvaik7XG4gIH0pO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9pbmNsdWRlZFByb2plY3Rpb25zLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBwcm9qNCA9IHJlcXVpcmUoJy4vY29yZScpO1xucHJvajQuZGVmYXVsdERhdHVtID0gJ1dHUzg0JzsgLy9kZWZhdWx0IGRhdHVtXG5wcm9qNC5Qcm9qID0gcmVxdWlyZSgnLi9Qcm9qJyk7XG5wcm9qNC5XR1M4NCA9IG5ldyBwcm9qNC5Qcm9qKCdXR1M4NCcpO1xucHJvajQuUG9pbnQgPSByZXF1aXJlKCcuL1BvaW50Jyk7XG5wcm9qNC50b1BvaW50ID0gcmVxdWlyZShcIi4vY29tbW9uL3RvUG9pbnRcIik7XG5wcm9qNC5kZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG5wcm9qNC50cmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybScpO1xucHJvajQubWdycyA9IHJlcXVpcmUoJ21ncnMnKTtcbnByb2o0LnZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xucmVxdWlyZSgnLi9pbmNsdWRlZFByb2plY3Rpb25zJykocHJvajQpO1xubW9kdWxlLmV4cG9ydHMgPSBwcm9qNDtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9pbmRleC5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgZGVmcyA9IHJlcXVpcmUoJy4vZGVmcycpO1xudmFyIHdrdCA9IHJlcXVpcmUoJy4vd2t0Jyk7XG52YXIgcHJvalN0ciA9IHJlcXVpcmUoJy4vcHJvalN0cmluZycpO1xuZnVuY3Rpb24gdGVzdE9iaihjb2RlKXtcbiAgcmV0dXJuIHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIHRlc3REZWYoY29kZSl7XG4gIHJldHVybiBjb2RlIGluIGRlZnM7XG59XG5mdW5jdGlvbiB0ZXN0V0tUKGNvZGUpe1xuICB2YXIgY29kZVdvcmRzID0gWydHRU9HQ1MnLCdHRU9DQ1MnLCdQUk9KQ1MnLCdMT0NBTF9DUyddO1xuICByZXR1cm4gY29kZVdvcmRzLnJlZHVjZShmdW5jdGlvbihhLGIpe1xuICAgIHJldHVybiBhKzErY29kZS5pbmRleE9mKGIpO1xuICB9LDApO1xufVxuZnVuY3Rpb24gdGVzdFByb2ooY29kZSl7XG4gIHJldHVybiBjb2RlWzBdID09PSAnKyc7XG59XG5mdW5jdGlvbiBwYXJzZShjb2RlKXtcbiAgaWYgKHRlc3RPYmooY29kZSkpIHtcbiAgICAvL2NoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIGEgV0tUIHN0cmluZ1xuICAgIGlmICh0ZXN0RGVmKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZGVmc1tjb2RlXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGVzdFdLVChjb2RlKSkge1xuICAgICAgcmV0dXJuIHdrdChjb2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGVzdFByb2ooY29kZSkpIHtcbiAgICAgIHJldHVybiBwcm9qU3RyKGNvZGUpO1xuICAgIH1cbiAgfWVsc2V7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wYXJzZUNvZGUuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEQyUiA9IDAuMDE3NDUzMjkyNTE5OTQzMjk1Nzc7XG52YXIgUHJpbWVNZXJpZGlhbiA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL1ByaW1lTWVyaWRpYW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZWZEYXRhKSB7XG4gIHZhciBzZWxmID0ge307XG4gIHZhciBwYXJhbU9iaiA9IHt9O1xuICBkZWZEYXRhLnNwbGl0KFwiK1wiKS5tYXAoZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2LnRyaW0oKTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfSkuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgdmFyIHNwbGl0ID0gYS5zcGxpdChcIj1cIik7XG4gICAgc3BsaXQucHVzaCh0cnVlKTtcbiAgICBwYXJhbU9ialtzcGxpdFswXS50b0xvd2VyQ2FzZSgpXSA9IHNwbGl0WzFdO1xuICB9KTtcbiAgdmFyIHBhcmFtTmFtZSwgcGFyYW1WYWwsIHBhcmFtT3V0bmFtZTtcbiAgdmFyIHBhcmFtcyA9IHtcbiAgICBwcm9qOiAncHJvak5hbWUnLFxuICAgIGRhdHVtOiAnZGF0dW1Db2RlJyxcbiAgICByZjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5yZiA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBsYXRfMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sYXQwID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxhdF8xOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxhdDEgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbGF0XzI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubGF0MiA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsYXRfdHM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubGF0X3RzID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxvbl8wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxvbmcwID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxvbl8xOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxvbmcxID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxvbl8yOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxvbmcyID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGFscGhhOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmFscGhhID0gcGFyc2VGbG9hdCh2KSAqIEQyUjtcbiAgICB9LFxuICAgIGxvbmM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubG9uZ2MgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgeF8wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLngwID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIHlfMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi55MCA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBrXzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuazAgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgazogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5rMCA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICBhOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmEgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgYjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5iID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIHJfYTogZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLlJfQSA9IHRydWU7XG4gICAgfSxcbiAgICB6b25lOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnpvbmUgPSBwYXJzZUludCh2LCAxMCk7XG4gICAgfSxcbiAgICBzb3V0aDogZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnV0bVNvdXRoID0gdHJ1ZTtcbiAgICB9LFxuICAgIHRvd2dzODQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuZGF0dW1fcGFyYW1zID0gdi5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRvX21ldGVyOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLnRvX21ldGVyID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGZyb21fZ3JlZW53aWNoOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmZyb21fZ3JlZW53aWNoID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIHBtOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmZyb21fZ3JlZW53aWNoID0gKFByaW1lTWVyaWRpYW5bdl0gPyBQcmltZU1lcmlkaWFuW3ZdIDogcGFyc2VGbG9hdCh2KSkgKiBEMlI7XG4gICAgfSxcbiAgICBuYWRncmlkczogZnVuY3Rpb24odikge1xuICAgICAgaWYgKHYgPT09ICdAbnVsbCcpIHtcbiAgICAgICAgc2VsZi5kYXR1bUNvZGUgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZi5uYWRncmlkcyA9IHY7XG4gICAgICB9XG4gICAgfSxcbiAgICBheGlzOiBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgbGVnYWxBeGlzID0gXCJld25zdWRcIjtcbiAgICAgIGlmICh2Lmxlbmd0aCA9PT0gMyAmJiBsZWdhbEF4aXMuaW5kZXhPZih2LnN1YnN0cigwLCAxKSkgIT09IC0xICYmIGxlZ2FsQXhpcy5pbmRleE9mKHYuc3Vic3RyKDEsIDEpKSAhPT0gLTEgJiYgbGVnYWxBeGlzLmluZGV4T2Yodi5zdWJzdHIoMiwgMSkpICE9PSAtMSkge1xuICAgICAgICBzZWxmLmF4aXMgPSB2O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZm9yIChwYXJhbU5hbWUgaW4gcGFyYW1PYmopIHtcbiAgICBwYXJhbVZhbCA9IHBhcmFtT2JqW3BhcmFtTmFtZV07XG4gICAgaWYgKHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtT3V0bmFtZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbU91dG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGFyYW1PdXRuYW1lKHBhcmFtVmFsKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmW3BhcmFtT3V0bmFtZV0gPSBwYXJhbVZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzZWxmW3BhcmFtTmFtZV0gPSBwYXJhbVZhbDtcbiAgICB9XG4gIH1cbiAgaWYodHlwZW9mIHNlbGYuZGF0dW1Db2RlID09PSAnc3RyaW5nJyAmJiBzZWxmLmRhdHVtQ29kZSAhPT0gXCJXR1M4NFwiKXtcbiAgICBzZWxmLmRhdHVtQ29kZSA9IHNlbGYuZGF0dW1Db2RlLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvalN0cmluZy5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgcHJvanMgPSBbXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvbWVyYycpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL2xvbmdsYXQnKVxuXTtcbnZhciBuYW1lcyA9IHt9O1xudmFyIHByb2pTdG9yZSA9IFtdO1xuXG5mdW5jdGlvbiBhZGQocHJvaiwgaSkge1xuICB2YXIgbGVuID0gcHJvalN0b3JlLmxlbmd0aDtcbiAgaWYgKCFwcm9qLm5hbWVzKSB7XG4gICAgY29uc29sZS5sb2coaSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcHJvalN0b3JlW2xlbl0gPSBwcm9qO1xuICBwcm9qLm5hbWVzLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIG5hbWVzW24udG9Mb3dlckNhc2UoKV0gPSBsZW47XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0cy5hZGQgPSBhZGQ7XG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG4gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmICh0eXBlb2YgbmFtZXNbbl0gIT09ICd1bmRlZmluZWQnICYmIHByb2pTdG9yZVtuYW1lc1tuXV0pIHtcbiAgICByZXR1cm4gcHJvalN0b3JlW25hbWVzW25dXTtcbiAgfVxufTtcbmV4cG9ydHMuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgcHJvanMuZm9yRWFjaChhZGQpO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgbXNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vbXNmbnonKTtcbnZhciBxc2ZueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9xc2ZueicpO1xudmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIGFzaW56ID0gcmVxdWlyZSgnLi4vY29tbW9uL2FzaW56Jyk7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAoTWF0aC5hYnModGhpcy5sYXQxICsgdGhpcy5sYXQyKSA8IEVQU0xOKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMudGVtcCA9IHRoaXMuYiAvIHRoaXMuYTtcbiAgdGhpcy5lcyA9IDEgLSBNYXRoLnBvdyh0aGlzLnRlbXAsIDIpO1xuICB0aGlzLmUzID0gTWF0aC5zcXJ0KHRoaXMuZXMpO1xuXG4gIHRoaXMuc2luX3BvID0gTWF0aC5zaW4odGhpcy5sYXQxKTtcbiAgdGhpcy5jb3NfcG8gPSBNYXRoLmNvcyh0aGlzLmxhdDEpO1xuICB0aGlzLnQxID0gdGhpcy5zaW5fcG87XG4gIHRoaXMuY29uID0gdGhpcy5zaW5fcG87XG4gIHRoaXMubXMxID0gbXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcbiAgdGhpcy5xczEgPSBxc2Zueih0aGlzLmUzLCB0aGlzLnNpbl9wbywgdGhpcy5jb3NfcG8pO1xuXG4gIHRoaXMuc2luX3BvID0gTWF0aC5zaW4odGhpcy5sYXQyKTtcbiAgdGhpcy5jb3NfcG8gPSBNYXRoLmNvcyh0aGlzLmxhdDIpO1xuICB0aGlzLnQyID0gdGhpcy5zaW5fcG87XG4gIHRoaXMubXMyID0gbXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcbiAgdGhpcy5xczIgPSBxc2Zueih0aGlzLmUzLCB0aGlzLnNpbl9wbywgdGhpcy5jb3NfcG8pO1xuXG4gIHRoaXMuc2luX3BvID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgdGhpcy5jb3NfcG8gPSBNYXRoLmNvcyh0aGlzLmxhdDApO1xuICB0aGlzLnQzID0gdGhpcy5zaW5fcG87XG4gIHRoaXMucXMwID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuICBpZiAoTWF0aC5hYnModGhpcy5sYXQxIC0gdGhpcy5sYXQyKSA+IEVQU0xOKSB7XG4gICAgdGhpcy5uczAgPSAodGhpcy5tczEgKiB0aGlzLm1zMSAtIHRoaXMubXMyICogdGhpcy5tczIpIC8gKHRoaXMucXMyIC0gdGhpcy5xczEpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMubnMwID0gdGhpcy5jb247XG4gIH1cbiAgdGhpcy5jID0gdGhpcy5tczEgKiB0aGlzLm1zMSArIHRoaXMubnMwICogdGhpcy5xczE7XG4gIHRoaXMucmggPSB0aGlzLmEgKiBNYXRoLnNxcnQodGhpcy5jIC0gdGhpcy5uczAgKiB0aGlzLnFzMCkgLyB0aGlzLm5zMDtcbn07XG5cbi8qIEFsYmVycyBDb25pY2FsIEVxdWFsIEFyZWEgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgdGhpcy5zaW5fcGhpID0gTWF0aC5zaW4obGF0KTtcbiAgdGhpcy5jb3NfcGhpID0gTWF0aC5jb3MobGF0KTtcblxuICB2YXIgcXMgPSBxc2Zueih0aGlzLmUzLCB0aGlzLnNpbl9waGksIHRoaXMuY29zX3BoaSk7XG4gIHZhciByaDEgPSB0aGlzLmEgKiBNYXRoLnNxcnQodGhpcy5jIC0gdGhpcy5uczAgKiBxcykgLyB0aGlzLm5zMDtcbiAgdmFyIHRoZXRhID0gdGhpcy5uczAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgeCA9IHJoMSAqIE1hdGguc2luKHRoZXRhKSArIHRoaXMueDA7XG4gIHZhciB5ID0gdGhpcy5yaCAtIHJoMSAqIE1hdGguY29zKHRoZXRhKSArIHRoaXMueTA7XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59O1xuXG5cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIHJoMSwgcXMsIGNvbiwgdGhldGEsIGxvbiwgbGF0O1xuXG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgPSB0aGlzLnJoIC0gcC55ICsgdGhpcy55MDtcbiAgaWYgKHRoaXMubnMwID49IDApIHtcbiAgICByaDEgPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBjb24gPSAxO1xuICB9XG4gIGVsc2Uge1xuICAgIHJoMSA9IC1NYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBjb24gPSAtMTtcbiAgfVxuICB0aGV0YSA9IDA7XG4gIGlmIChyaDEgIT09IDApIHtcbiAgICB0aGV0YSA9IE1hdGguYXRhbjIoY29uICogcC54LCBjb24gKiBwLnkpO1xuICB9XG4gIGNvbiA9IHJoMSAqIHRoaXMubnMwIC8gdGhpcy5hO1xuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBsYXQgPSBNYXRoLmFzaW4oKHRoaXMuYyAtIGNvbiAqIGNvbikgLyAoMiAqIHRoaXMubnMwKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcXMgPSAodGhpcy5jIC0gY29uICogY29uKSAvIHRoaXMubnMwO1xuICAgIGxhdCA9IHRoaXMucGhpMXoodGhpcy5lMywgcXMpO1xuICB9XG5cbiAgbG9uID0gYWRqdXN0X2xvbih0aGV0YSAvIHRoaXMubnMwICsgdGhpcy5sb25nMCk7XG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn07XG5cbi8qIEZ1bmN0aW9uIHRvIGNvbXB1dGUgcGhpMSwgdGhlIGxhdGl0dWRlIGZvciB0aGUgaW52ZXJzZSBvZiB0aGVcbiAgIEFsYmVycyBDb25pY2FsIEVxdWFsLUFyZWEgcHJvamVjdGlvbi5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5waGkxeiA9IGZ1bmN0aW9uKGVjY2VudCwgcXMpIHtcbiAgdmFyIHNpbnBoaSwgY29zcGhpLCBjb24sIGNvbSwgZHBoaTtcbiAgdmFyIHBoaSA9IGFzaW56KDAuNSAqIHFzKTtcbiAgaWYgKGVjY2VudCA8IEVQU0xOKSB7XG4gICAgcmV0dXJuIHBoaTtcbiAgfVxuXG4gIHZhciBlY2NudHMgPSBlY2NlbnQgKiBlY2NlbnQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IDI1OyBpKyspIHtcbiAgICBzaW5waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgIGNvc3BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgY29uID0gZWNjZW50ICogc2lucGhpO1xuICAgIGNvbSA9IDEgLSBjb24gKiBjb247XG4gICAgZHBoaSA9IDAuNSAqIGNvbSAqIGNvbSAvIGNvc3BoaSAqIChxcyAvICgxIC0gZWNjbnRzKSAtIHNpbnBoaSAvIGNvbSArIDAuNSAvIGVjY2VudCAqIE1hdGgubG9nKCgxIC0gY29uKSAvICgxICsgY29uKSkpO1xuICAgIHBoaSA9IHBoaSArIGRwaGk7XG4gICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IDFlLTcpIHtcbiAgICAgIHJldHVybiBwaGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJBbGJlcnNfQ29uaWNfRXF1YWxfQXJlYVwiLCBcIkFsYmVyc1wiLCBcImFlYVwiXTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2FlYS5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgbWxmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tbGZuJyk7XG52YXIgZTBmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMGZuJyk7XG52YXIgZTFmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMWZuJyk7XG52YXIgZTJmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMmZuJyk7XG52YXIgZTNmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lM2ZuJyk7XG52YXIgZ04gPSByZXF1aXJlKCcuLi9jb21tb24vZ04nKTtcbnZhciBhc2lueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hc2lueicpO1xudmFyIGltbGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2ltbGZuJyk7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zaW5fcDEyID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgdGhpcy5jb3NfcDEyID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbn07XG5cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHNpbnBoaSA9IE1hdGguc2luKHAueSk7XG4gIHZhciBjb3NwaGkgPSBNYXRoLmNvcyhwLnkpO1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciBlMCwgZTEsIGUyLCBlMywgTWxwLCBNbCwgdGFucGhpLCBObDEsIE5sLCBwc2ksIEF6LCBHLCBILCBHSCwgSHMsIGMsIGtwLCBjb3NfYywgcywgczIsIHMzLCBzNCwgczU7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgLSAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Ob3J0aCBQb2xlIGNhc2VcbiAgICAgIHAueCA9IHRoaXMueDAgKyB0aGlzLmEgKiAoSEFMRl9QSSAtIGxhdCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgLSB0aGlzLmEgKiAoSEFMRl9QSSAtIGxhdCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgKyAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Tb3V0aCBQb2xlIGNhc2VcbiAgICAgIHAueCA9IHRoaXMueDAgKyB0aGlzLmEgKiAoSEFMRl9QSSArIGxhdCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgKyB0aGlzLmEgKiAoSEFMRl9QSSArIGxhdCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vZGVmYXVsdCBjYXNlXG4gICAgICBjb3NfYyA9IHRoaXMuc2luX3AxMiAqIHNpbnBoaSArIHRoaXMuY29zX3AxMiAqIGNvc3BoaSAqIE1hdGguY29zKGRsb24pO1xuICAgICAgYyA9IE1hdGguYWNvcyhjb3NfYyk7XG4gICAgICBrcCA9IGMgLyBNYXRoLnNpbihjKTtcbiAgICAgIHAueCA9IHRoaXMueDAgKyB0aGlzLmEgKiBrcCAqIGNvc3BoaSAqIE1hdGguc2luKGRsb24pO1xuICAgICAgcC55ID0gdGhpcy55MCArIHRoaXMuYSAqIGtwICogKHRoaXMuY29zX3AxMiAqIHNpbnBoaSAtIHRoaXMuc2luX3AxMiAqIGNvc3BoaSAqIE1hdGguY29zKGRsb24pKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBlMCA9IGUwZm4odGhpcy5lcyk7XG4gICAgZTEgPSBlMWZuKHRoaXMuZXMpO1xuICAgIGUyID0gZTJmbih0aGlzLmVzKTtcbiAgICBlMyA9IGUzZm4odGhpcy5lcyk7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiAtIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL05vcnRoIFBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICBNbCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIGxhdCk7XG4gICAgICBwLnggPSB0aGlzLngwICsgKE1scCAtIE1sKSAqIE1hdGguc2luKGRsb24pO1xuICAgICAgcC55ID0gdGhpcy55MCAtIChNbHAgLSBNbCkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgKyAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Tb3V0aCBQb2xlIGNhc2VcbiAgICAgIE1scCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIEhBTEZfUEkpO1xuICAgICAgTWwgPSB0aGlzLmEgKiBtbGZuKGUwLCBlMSwgZTIsIGUzLCBsYXQpO1xuICAgICAgcC54ID0gdGhpcy54MCArIChNbHAgKyBNbCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgKyAoTWxwICsgTWwpICogTWF0aC5jb3MoZGxvbik7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL0RlZmF1bHQgY2FzZVxuICAgICAgdGFucGhpID0gc2lucGhpIC8gY29zcGhpO1xuICAgICAgTmwxID0gZ04odGhpcy5hLCB0aGlzLmUsIHRoaXMuc2luX3AxMik7XG4gICAgICBObCA9IGdOKHRoaXMuYSwgdGhpcy5lLCBzaW5waGkpO1xuICAgICAgcHNpID0gTWF0aC5hdGFuKCgxIC0gdGhpcy5lcykgKiB0YW5waGkgKyB0aGlzLmVzICogTmwxICogdGhpcy5zaW5fcDEyIC8gKE5sICogY29zcGhpKSk7XG4gICAgICBBeiA9IE1hdGguYXRhbjIoTWF0aC5zaW4oZGxvbiksIHRoaXMuY29zX3AxMiAqIE1hdGgudGFuKHBzaSkgLSB0aGlzLnNpbl9wMTIgKiBNYXRoLmNvcyhkbG9uKSk7XG4gICAgICBpZiAoQXogPT09IDApIHtcbiAgICAgICAgcyA9IE1hdGguYXNpbih0aGlzLmNvc19wMTIgKiBNYXRoLnNpbihwc2kpIC0gdGhpcy5zaW5fcDEyICogTWF0aC5jb3MocHNpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChNYXRoLmFicyhNYXRoLmFicyhBeikgLSBNYXRoLlBJKSA8PSBFUFNMTikge1xuICAgICAgICBzID0gLU1hdGguYXNpbih0aGlzLmNvc19wMTIgKiBNYXRoLnNpbihwc2kpIC0gdGhpcy5zaW5fcDEyICogTWF0aC5jb3MocHNpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcyA9IE1hdGguYXNpbihNYXRoLnNpbihkbG9uKSAqIE1hdGguY29zKHBzaSkgLyBNYXRoLnNpbihBeikpO1xuICAgICAgfVxuICAgICAgRyA9IHRoaXMuZSAqIHRoaXMuc2luX3AxMiAvIE1hdGguc3FydCgxIC0gdGhpcy5lcyk7XG4gICAgICBIID0gdGhpcy5lICogdGhpcy5jb3NfcDEyICogTWF0aC5jb3MoQXopIC8gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKTtcbiAgICAgIEdIID0gRyAqIEg7XG4gICAgICBIcyA9IEggKiBIO1xuICAgICAgczIgPSBzICogcztcbiAgICAgIHMzID0gczIgKiBzO1xuICAgICAgczQgPSBzMyAqIHM7XG4gICAgICBzNSA9IHM0ICogcztcbiAgICAgIGMgPSBObDEgKiBzICogKDEgLSBzMiAqIEhzICogKDEgLSBIcykgLyA2ICsgczMgLyA4ICogR0ggKiAoMSAtIDIgKiBIcykgKyBzNCAvIDEyMCAqIChIcyAqICg0IC0gNyAqIEhzKSAtIDMgKiBHICogRyAqICgxIC0gNyAqIEhzKSkgLSBzNSAvIDQ4ICogR0gpO1xuICAgICAgcC54ID0gdGhpcy54MCArIGMgKiBNYXRoLnNpbihBeik7XG4gICAgICBwLnkgPSB0aGlzLnkwICsgYyAqIE1hdGguY29zKEF6KTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfVxuXG5cbn07XG5cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgcmgsIHosIHNpbnosIGNvc3osIGxvbiwgbGF0LCBjb24sIGUwLCBlMSwgZTIsIGUzLCBNbHAsIE0sIE4xLCBwc2ksIEF6LCBjb3NBeiwgdG1wLCBBLCBCLCBELCBFZSwgRjtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICBpZiAocmggPiAoMiAqIEhBTEZfUEkgKiB0aGlzLmEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHogPSByaCAvIHRoaXMuYTtcblxuICAgIHNpbnogPSBNYXRoLnNpbih6KTtcbiAgICBjb3N6ID0gTWF0aC5jb3Moeik7XG5cbiAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIGlmIChNYXRoLmFicyhyaCkgPD0gRVBTTE4pIHtcbiAgICAgIGxhdCA9IHRoaXMubGF0MDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsYXQgPSBhc2lueihjb3N6ICogdGhpcy5zaW5fcDEyICsgKHAueSAqIHNpbnogKiB0aGlzLmNvc19wMTIpIC8gcmgpO1xuICAgICAgY29uID0gTWF0aC5hYnModGhpcy5sYXQwKSAtIEhBTEZfUEk7XG4gICAgICBpZiAoTWF0aC5hYnMoY29uKSA8PSBFUFNMTikge1xuICAgICAgICBpZiAodGhpcy5sYXQwID49IDApIHtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSBwLnkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgLSBNYXRoLmF0YW4yKC1wLngsIHAueSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLypjb24gPSBjb3N6IC0gdGhpcy5zaW5fcDEyICogTWF0aC5zaW4obGF0KTtcbiAgICAgICAgaWYgKChNYXRoLmFicyhjb24pIDwgRVBTTE4pICYmIChNYXRoLmFicyhwLngpIDwgRVBTTE4pKSB7XG4gICAgICAgICAgLy9uby1vcCwganVzdCBrZWVwIHRoZSBsb24gdmFsdWUgYXMgaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IE1hdGguYXRhbjIoKHAueCAqIHNpbnogKiB0aGlzLmNvc19wMTIpLCAoY29uICogcmgpKTtcbiAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKChwLnggKiBzaW56ICogdGhpcy5jb3NfcDEyKSwgKGNvbiAqIHJoKSkpO1xuICAgICAgICB9Ki9cbiAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLnggKiBzaW56LCByaCAqIHRoaXMuY29zX3AxMiAqIGNvc3ogLSBwLnkgKiB0aGlzLnNpbl9wMTIgKiBzaW56KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICBlMCA9IGUwZm4odGhpcy5lcyk7XG4gICAgZTEgPSBlMWZuKHRoaXMuZXMpO1xuICAgIGUyID0gZTJmbih0aGlzLmVzKTtcbiAgICBlMyA9IGUzZm4odGhpcy5lcyk7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiAtIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL05vcnRoIHBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgICAgTSA9IE1scCAtIHJoO1xuICAgICAgbGF0ID0gaW1sZm4oTSAvIHRoaXMuYSwgZTAsIGUxLCBlMiwgZTMpO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIC0gMSAqIHAueSkpO1xuICAgICAgcC54ID0gbG9uO1xuICAgICAgcC55ID0gbGF0O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiArIDEpIDw9IEVQU0xOKSB7XG4gICAgICAvL1NvdXRoIHBvbGUgY2FzZVxuICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG4gICAgICByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgICAgTSA9IHJoIC0gTWxwO1xuXG4gICAgICBsYXQgPSBpbWxmbihNIC8gdGhpcy5hLCBlMCwgZTEsIGUyLCBlMyk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgcC55KSk7XG4gICAgICBwLnggPSBsb247XG4gICAgICBwLnkgPSBsYXQ7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2RlZmF1bHQgY2FzZVxuICAgICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICAgIEF6ID0gTWF0aC5hdGFuMihwLngsIHAueSk7XG4gICAgICBOMSA9IGdOKHRoaXMuYSwgdGhpcy5lLCB0aGlzLnNpbl9wMTIpO1xuICAgICAgY29zQXogPSBNYXRoLmNvcyhBeik7XG4gICAgICB0bXAgPSB0aGlzLmUgKiB0aGlzLmNvc19wMTIgKiBjb3NBejtcbiAgICAgIEEgPSAtdG1wICogdG1wIC8gKDEgLSB0aGlzLmVzKTtcbiAgICAgIEIgPSAzICogdGhpcy5lcyAqICgxIC0gQSkgKiB0aGlzLnNpbl9wMTIgKiB0aGlzLmNvc19wMTIgKiBjb3NBeiAvICgxIC0gdGhpcy5lcyk7XG4gICAgICBEID0gcmggLyBOMTtcbiAgICAgIEVlID0gRCAtIEEgKiAoMSArIEEpICogTWF0aC5wb3coRCwgMykgLyA2IC0gQiAqICgxICsgMyAqIEEpICogTWF0aC5wb3coRCwgNCkgLyAyNDtcbiAgICAgIEYgPSAxIC0gQSAqIEVlICogRWUgLyAyIC0gRCAqIEVlICogRWUgKiBFZSAvIDY7XG4gICAgICBwc2kgPSBNYXRoLmFzaW4odGhpcy5zaW5fcDEyICogTWF0aC5jb3MoRWUpICsgdGhpcy5jb3NfcDEyICogTWF0aC5zaW4oRWUpICogY29zQXopO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hc2luKE1hdGguc2luKEF6KSAqIE1hdGguc2luKEVlKSAvIE1hdGguY29zKHBzaSkpKTtcbiAgICAgIGxhdCA9IE1hdGguYXRhbigoMSAtIHRoaXMuZXMgKiBGICogdGhpcy5zaW5fcDEyIC8gTWF0aC5zaW4ocHNpKSkgKiBNYXRoLnRhbihwc2kpIC8gKDEgLSB0aGlzLmVzKSk7XG4gICAgICBwLnggPSBsb247XG4gICAgICBwLnkgPSBsYXQ7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH1cblxufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJBemltdXRoYWxfRXF1aWRpc3RhbnRcIiwgXCJhZXFkXCJdO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvYWVxZC5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgbWxmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tbGZuJyk7XG52YXIgZTBmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMGZuJyk7XG52YXIgZTFmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMWZuJyk7XG52YXIgZTJmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMmZuJyk7XG52YXIgZTNmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lM2ZuJyk7XG52YXIgZ04gPSByZXF1aXJlKCcuLi9jb21tb24vZ04nKTtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBhZGp1c3RfbGF0ID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sYXQnKTtcbnZhciBpbWxmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9pbWxmbicpO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5zcGhlcmUpIHtcbiAgICB0aGlzLmUwID0gZTBmbih0aGlzLmVzKTtcbiAgICB0aGlzLmUxID0gZTFmbih0aGlzLmVzKTtcbiAgICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgICB0aGlzLmUzID0gZTNmbih0aGlzLmVzKTtcbiAgICB0aGlzLm1sMCA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQwKTtcbiAgfVxufTtcblxuXG5cbi8qIENhc3NpbmkgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcblxuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB2YXIgeCwgeTtcbiAgdmFyIGxhbSA9IHAueDtcbiAgdmFyIHBoaSA9IHAueTtcbiAgbGFtID0gYWRqdXN0X2xvbihsYW0gLSB0aGlzLmxvbmcwKTtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICB4ID0gdGhpcy5hICogTWF0aC5hc2luKE1hdGguY29zKHBoaSkgKiBNYXRoLnNpbihsYW0pKTtcbiAgICB5ID0gdGhpcy5hICogKE1hdGguYXRhbjIoTWF0aC50YW4ocGhpKSwgTWF0aC5jb3MobGFtKSkgLSB0aGlzLmxhdDApO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vZWxsaXBzb2lkXG4gICAgdmFyIHNpbnBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgdmFyIGNvc3BoaSA9IE1hdGguY29zKHBoaSk7XG4gICAgdmFyIG5sID0gZ04odGhpcy5hLCB0aGlzLmUsIHNpbnBoaSk7XG4gICAgdmFyIHRsID0gTWF0aC50YW4ocGhpKSAqIE1hdGgudGFuKHBoaSk7XG4gICAgdmFyIGFsID0gbGFtICogTWF0aC5jb3MocGhpKTtcbiAgICB2YXIgYXNxID0gYWwgKiBhbDtcbiAgICB2YXIgY2wgPSB0aGlzLmVzICogY29zcGhpICogY29zcGhpIC8gKDEgLSB0aGlzLmVzKTtcbiAgICB2YXIgbWwgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIHBoaSk7XG5cbiAgICB4ID0gbmwgKiBhbCAqICgxIC0gYXNxICogdGwgKiAoMSAvIDYgLSAoOCAtIHRsICsgOCAqIGNsKSAqIGFzcSAvIDEyMCkpO1xuICAgIHkgPSBtbCAtIHRoaXMubWwwICsgbmwgKiBzaW5waGkgLyBjb3NwaGkgKiBhc3EgKiAoMC41ICsgKDUgLSB0bCArIDYgKiBjbCkgKiBhc3EgLyAyNCk7XG5cblxuICB9XG5cbiAgcC54ID0geCArIHRoaXMueDA7XG4gIHAueSA9IHkgKyB0aGlzLnkwO1xuICByZXR1cm4gcDtcbn07XG5cbi8qIEludmVyc2UgZXF1YXRpb25zXG4gIC0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgeCA9IHAueCAvIHRoaXMuYTtcbiAgdmFyIHkgPSBwLnkgLyB0aGlzLmE7XG4gIHZhciBwaGksIGxhbTtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICB2YXIgZGQgPSB5ICsgdGhpcy5sYXQwO1xuICAgIHBoaSA9IE1hdGguYXNpbihNYXRoLnNpbihkZCkgKiBNYXRoLmNvcyh4KSk7XG4gICAgbGFtID0gTWF0aC5hdGFuMihNYXRoLnRhbih4KSwgTWF0aC5jb3MoZGQpKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvKiBlbGxpcHNvaWQgKi9cbiAgICB2YXIgbWwxID0gdGhpcy5tbDAgLyB0aGlzLmEgKyB5O1xuICAgIHZhciBwaGkxID0gaW1sZm4obWwxLCB0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMocGhpMSkgLSBIQUxGX1BJKSA8PSBFUFNMTikge1xuICAgICAgcC54ID0gdGhpcy5sb25nMDtcbiAgICAgIHAueSA9IEhBTEZfUEk7XG4gICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgcC55ICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHZhciBubDEgPSBnTih0aGlzLmEsIHRoaXMuZSwgTWF0aC5zaW4ocGhpMSkpO1xuXG4gICAgdmFyIHJsMSA9IG5sMSAqIG5sMSAqIG5sMSAvIHRoaXMuYSAvIHRoaXMuYSAqICgxIC0gdGhpcy5lcyk7XG4gICAgdmFyIHRsMSA9IE1hdGgucG93KE1hdGgudGFuKHBoaTEpLCAyKTtcbiAgICB2YXIgZGwgPSB4ICogdGhpcy5hIC8gbmwxO1xuICAgIHZhciBkc3EgPSBkbCAqIGRsO1xuICAgIHBoaSA9IHBoaTEgLSBubDEgKiBNYXRoLnRhbihwaGkxKSAvIHJsMSAqIGRsICogZGwgKiAoMC41IC0gKDEgKyAzICogdGwxKSAqIGRsICogZGwgLyAyNCk7XG4gICAgbGFtID0gZGwgKiAoMSAtIGRzcSAqICh0bDEgLyAzICsgKDEgKyAzICogdGwxKSAqIHRsMSAqIGRzcSAvIDE1KSkgLyBNYXRoLmNvcyhwaGkxKTtcblxuICB9XG5cbiAgcC54ID0gYWRqdXN0X2xvbihsYW0gKyB0aGlzLmxvbmcwKTtcbiAgcC55ID0gYWRqdXN0X2xhdChwaGkpO1xuICByZXR1cm4gcDtcblxufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJDYXNzaW5pXCIsIFwiQ2Fzc2luaV9Tb2xkbmVyXCIsIFwiY2Fzc1wiXTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9jYXNzLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9uc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBxc2ZueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9xc2ZueicpO1xudmFyIG1zZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL21zZm56Jyk7XG52YXIgaXFzZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL2lxc2ZueicpO1xuLypcbiAgcmVmZXJlbmNlOiAgXG4gICAgXCJDYXJ0b2dyYXBoaWMgUHJvamVjdGlvbiBQcm9jZWR1cmVzIGZvciB0aGUgVU5JWCBFbnZpcm9ubWVudC1cbiAgICBBIFVzZXIncyBNYW51YWxcIiBieSBHZXJhbGQgSS4gRXZlbmRlbixcbiAgICBVU0dTIE9wZW4gRmlsZSBSZXBvcnQgOTAtMjg0YW5kIFJlbGVhc2UgNCBJbnRlcmltIFJlcG9ydHMgKDIwMDMpXG4qL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIC8vbm8tb3BcbiAgaWYgKCF0aGlzLnNwaGVyZSkge1xuICAgIHRoaXMuazAgPSBtc2Zueih0aGlzLmUsIE1hdGguc2luKHRoaXMubGF0X3RzKSwgTWF0aC5jb3ModGhpcy5sYXRfdHMpKTtcbiAgfVxufTtcblxuXG4vKiBDeWxpbmRyaWNhbCBFcXVhbCBBcmVhIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciB4LCB5O1xuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHggPSB0aGlzLngwICsgdGhpcy5hICogZGxvbiAqIE1hdGguY29zKHRoaXMubGF0X3RzKTtcbiAgICB5ID0gdGhpcy55MCArIHRoaXMuYSAqIE1hdGguc2luKGxhdCkgLyBNYXRoLmNvcyh0aGlzLmxhdF90cyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHFzID0gcXNmbnoodGhpcy5lLCBNYXRoLnNpbihsYXQpKTtcbiAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIHRoaXMuazAgKiBkbG9uO1xuICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICogcXMgKiAwLjUgLyB0aGlzLmswO1xuICB9XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBDeWxpbmRyaWNhbCBFcXVhbCBBcmVhIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgdmFyIGxvbiwgbGF0O1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIChwLnggLyB0aGlzLmEpIC8gTWF0aC5jb3ModGhpcy5sYXRfdHMpKTtcbiAgICBsYXQgPSBNYXRoLmFzaW4oKHAueSAvIHRoaXMuYSkgKiBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IGlxc2Zueih0aGlzLmUsIDIgKiBwLnkgKiB0aGlzLmswIC8gdGhpcy5hKTtcbiAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBwLnggLyAodGhpcy5hICogdGhpcy5rMCkpO1xuICB9XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJjZWFcIl07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9jZWEuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIGFkanVzdF9sYXQgPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xhdCcpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgdGhpcy54MCA9IHRoaXMueDAgfHwgMDtcbiAgdGhpcy55MCA9IHRoaXMueTAgfHwgMDtcbiAgdGhpcy5sYXQwID0gdGhpcy5sYXQwIHx8IDA7XG4gIHRoaXMubG9uZzAgPSB0aGlzLmxvbmcwIHx8IDA7XG4gIHRoaXMubGF0X3RzID0gdGhpcy5sYXRfdHMgfHwgMDtcbiAgdGhpcy50aXRsZSA9IHRoaXMudGl0bGUgfHwgXCJFcXVpZGlzdGFudCBDeWxpbmRyaWNhbCAoUGxhdGUgQ2FycmUpXCI7XG5cbiAgdGhpcy5yYyA9IE1hdGguY29zKHRoaXMubGF0X3RzKTtcbn07XG5cblxuLy8gZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgZGxhdCA9IGFkanVzdF9sYXQobGF0IC0gdGhpcy5sYXQwKTtcbiAgcC54ID0gdGhpcy54MCArICh0aGlzLmEgKiBkbG9uICogdGhpcy5yYyk7XG4gIHAueSA9IHRoaXMueTAgKyAodGhpcy5hICogZGxhdCk7XG4gIHJldHVybiBwO1xufTtcblxuLy8gaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciB4ID0gcC54O1xuICB2YXIgeSA9IHAueTtcblxuICBwLnggPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAoKHggLSB0aGlzLngwKSAvICh0aGlzLmEgKiB0aGlzLnJjKSkpO1xuICBwLnkgPSBhZGp1c3RfbGF0KHRoaXMubGF0MCArICgoeSAtIHRoaXMueTApIC8gKHRoaXMuYSkpKTtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIkVxdWlyZWN0YW5ndWxhclwiLCBcIkVxdWlkaXN0YW50X0N5bGluZHJpY2FsXCIsIFwiZXFjXCJdO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvZXFjLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9uc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBlMGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UwZm4nKTtcbnZhciBlMWZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UxZm4nKTtcbnZhciBlMmZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UyZm4nKTtcbnZhciBlM2ZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UzZm4nKTtcbnZhciBtc2ZueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tc2ZueicpO1xudmFyIG1sZm4gPSByZXF1aXJlKCcuLi9jb21tb24vbWxmbicpO1xudmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIGFkanVzdF9sYXQgPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xhdCcpO1xudmFyIGltbGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2ltbGZuJyk7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8vIFN0YW5kYXJkIFBhcmFsbGVscyBjYW5ub3QgYmUgZXF1YWwgYW5kIG9uIG9wcG9zaXRlIHNpZGVzIG9mIHRoZSBlcXVhdG9yXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgKyB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXQyID0gdGhpcy5sYXQyIHx8IHRoaXMubGF0MTtcbiAgdGhpcy50ZW1wID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmVzID0gMSAtIE1hdGgucG93KHRoaXMudGVtcCwgMik7XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gIHRoaXMuZTEgPSBlMWZuKHRoaXMuZXMpO1xuICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG5cbiAgdGhpcy5zaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDEpO1xuICB0aGlzLmNvc3BoaSA9IE1hdGguY29zKHRoaXMubGF0MSk7XG5cbiAgdGhpcy5tczEgPSBtc2Zueih0aGlzLmUsIHRoaXMuc2lucGhpLCB0aGlzLmNvc3BoaSk7XG4gIHRoaXMubWwxID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDEpO1xuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgLSB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcbiAgICB0aGlzLm5zID0gdGhpcy5zaW5waGk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5zaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDIpO1xuICAgIHRoaXMuY29zcGhpID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcbiAgICB0aGlzLm1zMiA9IG1zZm56KHRoaXMuZSwgdGhpcy5zaW5waGksIHRoaXMuY29zcGhpKTtcbiAgICB0aGlzLm1sMiA9IG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQyKTtcbiAgICB0aGlzLm5zID0gKHRoaXMubXMxIC0gdGhpcy5tczIpIC8gKHRoaXMubWwyIC0gdGhpcy5tbDEpO1xuICB9XG4gIHRoaXMuZyA9IHRoaXMubWwxICsgdGhpcy5tczEgLyB0aGlzLm5zO1xuICB0aGlzLm1sMCA9IG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQwKTtcbiAgdGhpcy5yaCA9IHRoaXMuYSAqICh0aGlzLmcgLSB0aGlzLm1sMCk7XG59O1xuXG5cbi8qIEVxdWlkaXN0YW50IENvbmljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciByaDE7XG5cbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgcmgxID0gdGhpcy5hICogKHRoaXMuZyAtIGxhdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIG1sID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBsYXQpO1xuICAgIHJoMSA9IHRoaXMuYSAqICh0aGlzLmcgLSBtbCk7XG4gIH1cbiAgdmFyIHRoZXRhID0gdGhpcy5ucyAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciB4ID0gdGhpcy54MCArIHJoMSAqIE1hdGguc2luKHRoZXRhKTtcbiAgdmFyIHkgPSB0aGlzLnkwICsgdGhpcy5yaCAtIHJoMSAqIE1hdGguY29zKHRoZXRhKTtcbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAtLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgPSB0aGlzLnJoIC0gcC55ICsgdGhpcy55MDtcbiAgdmFyIGNvbiwgcmgxLCBsYXQsIGxvbjtcbiAgaWYgKHRoaXMubnMgPj0gMCkge1xuICAgIHJoMSA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgIGNvbiA9IDE7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmgxID0gLU1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgIGNvbiA9IC0xO1xuICB9XG4gIHZhciB0aGV0YSA9IDA7XG4gIGlmIChyaDEgIT09IDApIHtcbiAgICB0aGV0YSA9IE1hdGguYXRhbjIoY29uICogcC54LCBjb24gKiBwLnkpO1xuICB9XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgdGhldGEgLyB0aGlzLm5zKTtcbiAgICBsYXQgPSBhZGp1c3RfbGF0KHRoaXMuZyAtIHJoMSAvIHRoaXMuYSk7XG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgbWwgPSB0aGlzLmcgLSByaDEgLyB0aGlzLmE7XG4gICAgbGF0ID0gaW1sZm4obWwsIHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMpO1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHRoZXRhIC8gdGhpcy5ucyk7XG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuXG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIkVxdWlkaXN0YW50X0NvbmljXCIsIFwiZXFkY1wiXTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2VxZGMuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEZPUlRQSSA9IE1hdGguUEkvNDtcbnZhciBzcmF0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3NyYXQnKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIE1BWF9JVEVSID0gMjA7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNwaGkgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICB2YXIgY3BoaSA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gIGNwaGkgKj0gY3BoaTtcbiAgdGhpcy5yYyA9IE1hdGguc3FydCgxIC0gdGhpcy5lcykgLyAoMSAtIHRoaXMuZXMgKiBzcGhpICogc3BoaSk7XG4gIHRoaXMuQyA9IE1hdGguc3FydCgxICsgdGhpcy5lcyAqIGNwaGkgKiBjcGhpIC8gKDEgLSB0aGlzLmVzKSk7XG4gIHRoaXMucGhpYzAgPSBNYXRoLmFzaW4oc3BoaSAvIHRoaXMuQyk7XG4gIHRoaXMucmF0ZXhwID0gMC41ICogdGhpcy5DICogdGhpcy5lO1xuICB0aGlzLksgPSBNYXRoLnRhbigwLjUgKiB0aGlzLnBoaWMwICsgRk9SVFBJKSAvIChNYXRoLnBvdyhNYXRoLnRhbigwLjUgKiB0aGlzLmxhdDAgKyBGT1JUUEkpLCB0aGlzLkMpICogc3JhdCh0aGlzLmUgKiBzcGhpLCB0aGlzLnJhdGV4cCkpO1xufTtcblxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIHAueSA9IDIgKiBNYXRoLmF0YW4odGhpcy5LICogTWF0aC5wb3coTWF0aC50YW4oMC41ICogbGF0ICsgRk9SVFBJKSwgdGhpcy5DKSAqIHNyYXQodGhpcy5lICogTWF0aC5zaW4obGF0KSwgdGhpcy5yYXRleHApKSAtIEhBTEZfUEk7XG4gIHAueCA9IHRoaXMuQyAqIGxvbjtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBERUxfVE9MID0gMWUtMTQ7XG4gIHZhciBsb24gPSBwLnggLyB0aGlzLkM7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciBudW0gPSBNYXRoLnBvdyhNYXRoLnRhbigwLjUgKiBsYXQgKyBGT1JUUEkpIC8gdGhpcy5LLCAxIC8gdGhpcy5DKTtcbiAgZm9yICh2YXIgaSA9IE1BWF9JVEVSOyBpID4gMDsgLS1pKSB7XG4gICAgbGF0ID0gMiAqIE1hdGguYXRhbihudW0gKiBzcmF0KHRoaXMuZSAqIE1hdGguc2luKHAueSksIC0gMC41ICogdGhpcy5lKSkgLSBIQUxGX1BJO1xuICAgIGlmIChNYXRoLmFicyhsYXQgLSBwLnkpIDwgREVMX1RPTCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHAueSA9IGxhdDtcbiAgfVxuICAvKiBjb252ZXJnZW5jZSBmYWlsZWQgKi9cbiAgaWYgKCFpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJnYXVzc1wiXTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2dhdXNzLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9uc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgYXNpbnogPSByZXF1aXJlKCcuLi9jb21tb24vYXNpbnonKTtcblxuLypcbiAgcmVmZXJlbmNlOlxuICAgIFdvbGZyYW0gTWF0aHdvcmxkIFwiR25vbW9uaWMgUHJvamVjdGlvblwiXG4gICAgaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9Hbm9tb25pY1Byb2plY3Rpb24uaHRtbFxuICAgIEFjY2Vzc2VkOiAxMnRoIE5vdmVtYmVyIDIwMDlcbiAgKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIC8qIFBsYWNlIHBhcmFtZXRlcnMgaW4gc3RhdGljIHN0b3JhZ2UgZm9yIGNvbW1vbiB1c2VcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB0aGlzLnNpbl9wMTQgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICB0aGlzLmNvc19wMTQgPSBNYXRoLmNvcyh0aGlzLmxhdDApO1xuICAvLyBBcHByb3hpbWF0aW9uIGZvciBwcm9qZWN0aW5nIHBvaW50cyB0byB0aGUgaG9yaXpvbiAoaW5maW5pdHkpXG4gIHRoaXMuaW5maW5pdHlfZGlzdCA9IDEwMDAgKiB0aGlzLmE7XG4gIHRoaXMucmMgPSAxO1xufTtcblxuXG4vKiBHbm9tb25pYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgc2lucGhpLCBjb3NwaGk7IC8qIHNpbiBhbmQgY29zIHZhbHVlICAgICAgICAqL1xuICB2YXIgZGxvbjsgLyogZGVsdGEgbG9uZ2l0dWRlIHZhbHVlICAgICAgKi9cbiAgdmFyIGNvc2xvbjsgLyogY29zIG9mIGxvbmdpdHVkZSAgICAgICAgKi9cbiAgdmFyIGtzcDsgLyogc2NhbGUgZmFjdG9yICAgICAgICAgICovXG4gIHZhciBnO1xuICB2YXIgeCwgeTtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG5cbiAgc2lucGhpID0gTWF0aC5zaW4obGF0KTtcbiAgY29zcGhpID0gTWF0aC5jb3MobGF0KTtcblxuICBjb3Nsb24gPSBNYXRoLmNvcyhkbG9uKTtcbiAgZyA9IHRoaXMuc2luX3AxNCAqIHNpbnBoaSArIHRoaXMuY29zX3AxNCAqIGNvc3BoaSAqIGNvc2xvbjtcbiAga3NwID0gMTtcbiAgaWYgKChnID4gMCkgfHwgKE1hdGguYWJzKGcpIDw9IEVQU0xOKSkge1xuICAgIHggPSB0aGlzLngwICsgdGhpcy5hICoga3NwICogY29zcGhpICogTWF0aC5zaW4oZGxvbikgLyBnO1xuICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICoga3NwICogKHRoaXMuY29zX3AxNCAqIHNpbnBoaSAtIHRoaXMuc2luX3AxNCAqIGNvc3BoaSAqIGNvc2xvbikgLyBnO1xuICB9XG4gIGVsc2Uge1xuXG4gICAgLy8gUG9pbnQgaXMgaW4gdGhlIG9wcG9zaW5nIGhlbWlzcGhlcmUgYW5kIGlzIHVucHJvamVjdGFibGVcbiAgICAvLyBXZSBzdGlsbCBuZWVkIHRvIHJldHVybiBhIHJlYXNvbmFibGUgcG9pbnQsIHNvIHdlIHByb2plY3QgXG4gICAgLy8gdG8gaW5maW5pdHksIG9uIGEgYmVhcmluZyBcbiAgICAvLyBlcXVpdmFsZW50IHRvIHRoZSBub3J0aGVybiBoZW1pc3BoZXJlIGVxdWl2YWxlbnRcbiAgICAvLyBUaGlzIGlzIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uIGZvciBzaG9ydCBzaGFwZXMgYW5kIGxpbmVzIHRoYXQgXG4gICAgLy8gc3RyYWRkbGUgdGhlIGhvcml6b24uXG5cbiAgICB4ID0gdGhpcy54MCArIHRoaXMuaW5maW5pdHlfZGlzdCAqIGNvc3BoaSAqIE1hdGguc2luKGRsb24pO1xuICAgIHkgPSB0aGlzLnkwICsgdGhpcy5pbmZpbml0eV9kaXN0ICogKHRoaXMuY29zX3AxNCAqIHNpbnBoaSAtIHRoaXMuc2luX3AxNCAqIGNvc3BoaSAqIGNvc2xvbik7XG5cbiAgfVxuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn07XG5cblxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgcmg7IC8qIFJobyAqL1xuICB2YXIgc2luYywgY29zYztcbiAgdmFyIGM7XG4gIHZhciBsb24sIGxhdDtcblxuICAvKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBwLnggPSAocC54IC0gdGhpcy54MCkgLyB0aGlzLmE7XG4gIHAueSA9IChwLnkgLSB0aGlzLnkwKSAvIHRoaXMuYTtcblxuICBwLnggLz0gdGhpcy5rMDtcbiAgcC55IC89IHRoaXMuazA7XG5cbiAgaWYgKChyaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpKSkge1xuICAgIGMgPSBNYXRoLmF0YW4yKHJoLCB0aGlzLnJjKTtcbiAgICBzaW5jID0gTWF0aC5zaW4oYyk7XG4gICAgY29zYyA9IE1hdGguY29zKGMpO1xuXG4gICAgbGF0ID0gYXNpbnooY29zYyAqIHRoaXMuc2luX3AxNCArIChwLnkgKiBzaW5jICogdGhpcy5jb3NfcDE0KSAvIHJoKTtcbiAgICBsb24gPSBNYXRoLmF0YW4yKHAueCAqIHNpbmMsIHJoICogdGhpcy5jb3NfcDE0ICogY29zYyAtIHAueSAqIHRoaXMuc2luX3AxNCAqIHNpbmMpO1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIGxvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGF0ID0gdGhpcy5waGljMDtcbiAgICBsb24gPSAwO1xuICB9XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJnbm9tXCJdO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvZ25vbS5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5hID0gNjM3NzM5Ny4xNTU7XG4gIHRoaXMuZXMgPSAwLjAwNjY3NDM3MjIzMDYxNDtcbiAgdGhpcy5lID0gTWF0aC5zcXJ0KHRoaXMuZXMpO1xuICBpZiAoIXRoaXMubGF0MCkge1xuICAgIHRoaXMubGF0MCA9IDAuODYzOTM3OTc5NzM3MTkzO1xuICB9XG4gIGlmICghdGhpcy5sb25nMCkge1xuICAgIHRoaXMubG9uZzAgPSAwLjc0MTc2NDkzMjA5NzU5MDEgLSAwLjMwODM0MTUwMTE4NTY2NTtcbiAgfVxuICAvKiBpZiBzY2FsZSBub3Qgc2V0IGRlZmF1bHQgdG8gMC45OTk5ICovXG4gIGlmICghdGhpcy5rMCkge1xuICAgIHRoaXMuazAgPSAwLjk5OTk7XG4gIH1cbiAgdGhpcy5zNDUgPSAwLjc4NTM5ODE2MzM5NzQ0ODsgLyogNDUgKi9cbiAgdGhpcy5zOTAgPSAyICogdGhpcy5zNDU7XG4gIHRoaXMuZmkwID0gdGhpcy5sYXQwO1xuICB0aGlzLmUyID0gdGhpcy5lcztcbiAgdGhpcy5lID0gTWF0aC5zcXJ0KHRoaXMuZTIpO1xuICB0aGlzLmFsZmEgPSBNYXRoLnNxcnQoMSArICh0aGlzLmUyICogTWF0aC5wb3coTWF0aC5jb3ModGhpcy5maTApLCA0KSkgLyAoMSAtIHRoaXMuZTIpKTtcbiAgdGhpcy51cSA9IDEuMDQyMTY4NTYzODA0NzQ7XG4gIHRoaXMudTAgPSBNYXRoLmFzaW4oTWF0aC5zaW4odGhpcy5maTApIC8gdGhpcy5hbGZhKTtcbiAgdGhpcy5nID0gTWF0aC5wb3coKDEgKyB0aGlzLmUgKiBNYXRoLnNpbih0aGlzLmZpMCkpIC8gKDEgLSB0aGlzLmUgKiBNYXRoLnNpbih0aGlzLmZpMCkpLCB0aGlzLmFsZmEgKiB0aGlzLmUgLyAyKTtcbiAgdGhpcy5rID0gTWF0aC50YW4odGhpcy51MCAvIDIgKyB0aGlzLnM0NSkgLyBNYXRoLnBvdyhNYXRoLnRhbih0aGlzLmZpMCAvIDIgKyB0aGlzLnM0NSksIHRoaXMuYWxmYSkgKiB0aGlzLmc7XG4gIHRoaXMuazEgPSB0aGlzLmswO1xuICB0aGlzLm4wID0gdGhpcy5hICogTWF0aC5zcXJ0KDEgLSB0aGlzLmUyKSAvICgxIC0gdGhpcy5lMiAqIE1hdGgucG93KE1hdGguc2luKHRoaXMuZmkwKSwgMikpO1xuICB0aGlzLnMwID0gMS4zNzAwODM0NjI4MTU1NTtcbiAgdGhpcy5uID0gTWF0aC5zaW4odGhpcy5zMCk7XG4gIHRoaXMucm8wID0gdGhpcy5rMSAqIHRoaXMubjAgLyBNYXRoLnRhbih0aGlzLnMwKTtcbiAgdGhpcy5hZCA9IHRoaXMuczkwIC0gdGhpcy51cTtcbn07XG5cbi8qIGVsbGlwc29pZCAqL1xuLyogY2FsY3VsYXRlIHh5IGZyb20gbGF0L2xvbiAqL1xuLyogQ29uc3RhbnRzLCBpZGVudGljYWwgdG8gaW52ZXJzZSB0cmFuc2Zvcm0gZnVuY3Rpb24gKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGdmaSwgdSwgZGVsdGF2LCBzLCBkLCBlcHMsIHJvO1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICB2YXIgZGVsdGFfbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgLyogVHJhbnNmb3JtYXRpb24gKi9cbiAgZ2ZpID0gTWF0aC5wb3coKCgxICsgdGhpcy5lICogTWF0aC5zaW4obGF0KSkgLyAoMSAtIHRoaXMuZSAqIE1hdGguc2luKGxhdCkpKSwgKHRoaXMuYWxmYSAqIHRoaXMuZSAvIDIpKTtcbiAgdSA9IDIgKiAoTWF0aC5hdGFuKHRoaXMuayAqIE1hdGgucG93KE1hdGgudGFuKGxhdCAvIDIgKyB0aGlzLnM0NSksIHRoaXMuYWxmYSkgLyBnZmkpIC0gdGhpcy5zNDUpO1xuICBkZWx0YXYgPSAtZGVsdGFfbG9uICogdGhpcy5hbGZhO1xuICBzID0gTWF0aC5hc2luKE1hdGguY29zKHRoaXMuYWQpICogTWF0aC5zaW4odSkgKyBNYXRoLnNpbih0aGlzLmFkKSAqIE1hdGguY29zKHUpICogTWF0aC5jb3MoZGVsdGF2KSk7XG4gIGQgPSBNYXRoLmFzaW4oTWF0aC5jb3ModSkgKiBNYXRoLnNpbihkZWx0YXYpIC8gTWF0aC5jb3MocykpO1xuICBlcHMgPSB0aGlzLm4gKiBkO1xuICBybyA9IHRoaXMucm8wICogTWF0aC5wb3coTWF0aC50YW4odGhpcy5zMCAvIDIgKyB0aGlzLnM0NSksIHRoaXMubikgLyBNYXRoLnBvdyhNYXRoLnRhbihzIC8gMiArIHRoaXMuczQ1KSwgdGhpcy5uKTtcbiAgcC55ID0gcm8gKiBNYXRoLmNvcyhlcHMpIC8gMTtcbiAgcC54ID0gcm8gKiBNYXRoLnNpbihlcHMpIC8gMTtcblxuICBpZiAoIXRoaXMuY3plY2gpIHtcbiAgICBwLnkgKj0gLTE7XG4gICAgcC54ICo9IC0xO1xuICB9XG4gIHJldHVybiAocCk7XG59O1xuXG4vKiBjYWxjdWxhdGUgbGF0L2xvbiBmcm9tIHh5ICovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciB1LCBkZWx0YXYsIHMsIGQsIGVwcywgcm8sIGZpMTtcbiAgdmFyIG9rO1xuXG4gIC8qIFRyYW5zZm9ybWF0aW9uICovXG4gIC8qIHJldmVydCB5LCB4Ki9cbiAgdmFyIHRtcCA9IHAueDtcbiAgcC54ID0gcC55O1xuICBwLnkgPSB0bXA7XG4gIGlmICghdGhpcy5jemVjaCkge1xuICAgIHAueSAqPSAtMTtcbiAgICBwLnggKj0gLTE7XG4gIH1cbiAgcm8gPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgZXBzID0gTWF0aC5hdGFuMihwLnksIHAueCk7XG4gIGQgPSBlcHMgLyBNYXRoLnNpbih0aGlzLnMwKTtcbiAgcyA9IDIgKiAoTWF0aC5hdGFuKE1hdGgucG93KHRoaXMucm8wIC8gcm8sIDEgLyB0aGlzLm4pICogTWF0aC50YW4odGhpcy5zMCAvIDIgKyB0aGlzLnM0NSkpIC0gdGhpcy5zNDUpO1xuICB1ID0gTWF0aC5hc2luKE1hdGguY29zKHRoaXMuYWQpICogTWF0aC5zaW4ocykgLSBNYXRoLnNpbih0aGlzLmFkKSAqIE1hdGguY29zKHMpICogTWF0aC5jb3MoZCkpO1xuICBkZWx0YXYgPSBNYXRoLmFzaW4oTWF0aC5jb3MocykgKiBNYXRoLnNpbihkKSAvIE1hdGguY29zKHUpKTtcbiAgcC54ID0gdGhpcy5sb25nMCAtIGRlbHRhdiAvIHRoaXMuYWxmYTtcbiAgZmkxID0gdTtcbiAgb2sgPSAwO1xuICB2YXIgaXRlciA9IDA7XG4gIGRvIHtcbiAgICBwLnkgPSAyICogKE1hdGguYXRhbihNYXRoLnBvdyh0aGlzLmssIC0gMSAvIHRoaXMuYWxmYSkgKiBNYXRoLnBvdyhNYXRoLnRhbih1IC8gMiArIHRoaXMuczQ1KSwgMSAvIHRoaXMuYWxmYSkgKiBNYXRoLnBvdygoMSArIHRoaXMuZSAqIE1hdGguc2luKGZpMSkpIC8gKDEgLSB0aGlzLmUgKiBNYXRoLnNpbihmaTEpKSwgdGhpcy5lIC8gMikpIC0gdGhpcy5zNDUpO1xuICAgIGlmIChNYXRoLmFicyhmaTEgLSBwLnkpIDwgMC4wMDAwMDAwMDAxKSB7XG4gICAgICBvayA9IDE7XG4gICAgfVxuICAgIGZpMSA9IHAueTtcbiAgICBpdGVyICs9IDE7XG4gIH0gd2hpbGUgKG9rID09PSAwICYmIGl0ZXIgPCAxNSk7XG4gIGlmIChpdGVyID49IDE1KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKHApO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJLcm92YWtcIiwgXCJrcm92YWtcIl07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9rcm92YWsuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRk9SVFBJID0gTWF0aC5QSS80O1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBxc2ZueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9xc2ZueicpO1xudmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xuLypcbiAgcmVmZXJlbmNlXG4gICAgXCJOZXcgRXF1YWwtQXJlYSBNYXAgUHJvamVjdGlvbnMgZm9yIE5vbmNpcmN1bGFyIFJlZ2lvbnNcIiwgSm9obiBQLiBTbnlkZXIsXG4gICAgVGhlIEFtZXJpY2FuIENhcnRvZ3JhcGhlciwgVm9sIDE1LCBOby4gNCwgT2N0b2JlciAxOTg4LCBwcC4gMzQxLTM1NS5cbiAgKi9cblxuZXhwb3J0cy5TX1BPTEUgPSAxO1xuZXhwb3J0cy5OX1BPTEUgPSAyO1xuZXhwb3J0cy5FUVVJVCA9IDM7XG5leHBvcnRzLk9CTElRID0gNDtcblxuXG4vKiBJbml0aWFsaXplIHRoZSBMYW1iZXJ0IEF6aW11dGhhbCBFcXVhbCBBcmVhIHByb2plY3Rpb25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IE1hdGguYWJzKHRoaXMubGF0MCk7XG4gIGlmIChNYXRoLmFicyh0IC0gSEFMRl9QSSkgPCBFUFNMTikge1xuICAgIHRoaXMubW9kZSA9IHRoaXMubGF0MCA8IDAgPyB0aGlzLlNfUE9MRSA6IHRoaXMuTl9QT0xFO1xuICB9XG4gIGVsc2UgaWYgKE1hdGguYWJzKHQpIDwgRVBTTE4pIHtcbiAgICB0aGlzLm1vZGUgPSB0aGlzLkVRVUlUO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMubW9kZSA9IHRoaXMuT0JMSVE7XG4gIH1cbiAgaWYgKHRoaXMuZXMgPiAwKSB7XG4gICAgdmFyIHNpbnBoaTtcblxuICAgIHRoaXMucXAgPSBxc2Zueih0aGlzLmUsIDEpO1xuICAgIHRoaXMubW1mID0gMC41IC8gKDEgLSB0aGlzLmVzKTtcbiAgICB0aGlzLmFwYSA9IHRoaXMuYXV0aHNldCh0aGlzLmVzKTtcbiAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgdGhpcy5OX1BPTEU6XG4gICAgICB0aGlzLmRkID0gMTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5TX1BPTEU6XG4gICAgICB0aGlzLmRkID0gMTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5FUVVJVDpcbiAgICAgIHRoaXMucnEgPSBNYXRoLnNxcnQoMC41ICogdGhpcy5xcCk7XG4gICAgICB0aGlzLmRkID0gMSAvIHRoaXMucnE7XG4gICAgICB0aGlzLnhtZiA9IDE7XG4gICAgICB0aGlzLnltZiA9IDAuNSAqIHRoaXMucXA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuT0JMSVE6XG4gICAgICB0aGlzLnJxID0gTWF0aC5zcXJ0KDAuNSAqIHRoaXMucXApO1xuICAgICAgc2lucGhpID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgICAgIHRoaXMuc2luYjEgPSBxc2Zueih0aGlzLmUsIHNpbnBoaSkgLyB0aGlzLnFwO1xuICAgICAgdGhpcy5jb3NiMSA9IE1hdGguc3FydCgxIC0gdGhpcy5zaW5iMSAqIHRoaXMuc2luYjEpO1xuICAgICAgdGhpcy5kZCA9IE1hdGguY29zKHRoaXMubGF0MCkgLyAoTWF0aC5zcXJ0KDEgLSB0aGlzLmVzICogc2lucGhpICogc2lucGhpKSAqIHRoaXMucnEgKiB0aGlzLmNvc2IxKTtcbiAgICAgIHRoaXMueW1mID0gKHRoaXMueG1mID0gdGhpcy5ycSkgLyB0aGlzLmRkO1xuICAgICAgdGhpcy54bWYgKj0gdGhpcy5kZDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRKSB7XG4gICAgICB0aGlzLnNpbnBoMCA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gICAgICB0aGlzLmNvc3BoMCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gICAgfVxuICB9XG59O1xuXG4vKiBMYW1iZXJ0IEF6aW11dGhhbCBFcXVhbCBBcmVhIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG5cbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdmFyIHgsIHksIGNvc2xhbSwgc2lubGFtLCBzaW5waGksIHEsIHNpbmIsIGNvc2IsIGIsIGNvc3BoaTtcbiAgdmFyIGxhbSA9IHAueDtcbiAgdmFyIHBoaSA9IHAueTtcblxuICBsYW0gPSBhZGp1c3RfbG9uKGxhbSAtIHRoaXMubG9uZzApO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHNpbnBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgY29zcGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICBjb3NsYW0gPSBNYXRoLmNvcyhsYW0pO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG4gICAgICB5ID0gKHRoaXMubW9kZSA9PT0gdGhpcy5FUVVJVCkgPyAxICsgY29zcGhpICogY29zbGFtIDogMSArIHRoaXMuc2lucGgwICogc2lucGhpICsgdGhpcy5jb3NwaDAgKiBjb3NwaGkgKiBjb3NsYW07XG4gICAgICBpZiAoeSA8PSBFUFNMTikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHkgPSBNYXRoLnNxcnQoMiAvIHkpO1xuICAgICAgeCA9IHkgKiBjb3NwaGkgKiBNYXRoLnNpbihsYW0pO1xuICAgICAgeSAqPSAodGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSA/IHNpbnBoaSA6IHRoaXMuY29zcGgwICogc2lucGhpIC0gdGhpcy5zaW5waDAgKiBjb3NwaGkgKiBjb3NsYW07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5OX1BPTEUgfHwgdGhpcy5tb2RlID09PSB0aGlzLlNfUE9MRSkge1xuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5OX1BPTEUpIHtcbiAgICAgICAgY29zbGFtID0gLWNvc2xhbTtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhwaGkgKyB0aGlzLnBoaTApIDwgRVBTTE4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB5ID0gRk9SVFBJIC0gcGhpICogMC41O1xuICAgICAgeSA9IDIgKiAoKHRoaXMubW9kZSA9PT0gdGhpcy5TX1BPTEUpID8gTWF0aC5jb3MoeSkgOiBNYXRoLnNpbih5KSk7XG4gICAgICB4ID0geSAqIE1hdGguc2luKGxhbSk7XG4gICAgICB5ICo9IGNvc2xhbTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgc2luYiA9IDA7XG4gICAgY29zYiA9IDA7XG4gICAgYiA9IDA7XG4gICAgY29zbGFtID0gTWF0aC5jb3MobGFtKTtcbiAgICBzaW5sYW0gPSBNYXRoLnNpbihsYW0pO1xuICAgIHNpbnBoaSA9IE1hdGguc2luKHBoaSk7XG4gICAgcSA9IHFzZm56KHRoaXMuZSwgc2lucGhpKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5FUVVJVCkge1xuICAgICAgc2luYiA9IHEgLyB0aGlzLnFwO1xuICAgICAgY29zYiA9IE1hdGguc3FydCgxIC0gc2luYiAqIHNpbmIpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgdGhpcy5PQkxJUTpcbiAgICAgIGIgPSAxICsgdGhpcy5zaW5iMSAqIHNpbmIgKyB0aGlzLmNvc2IxICogY29zYiAqIGNvc2xhbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5FUVVJVDpcbiAgICAgIGIgPSAxICsgY29zYiAqIGNvc2xhbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5OX1BPTEU6XG4gICAgICBiID0gSEFMRl9QSSArIHBoaTtcbiAgICAgIHEgPSB0aGlzLnFwIC0gcTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5TX1BPTEU6XG4gICAgICBiID0gcGhpIC0gSEFMRl9QSTtcbiAgICAgIHEgPSB0aGlzLnFwICsgcTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoYikgPCBFUFNMTikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSB0aGlzLk9CTElROlxuICAgIGNhc2UgdGhpcy5FUVVJVDpcbiAgICAgIGIgPSBNYXRoLnNxcnQoMiAvIGIpO1xuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSkge1xuICAgICAgICB5ID0gdGhpcy55bWYgKiBiICogKHRoaXMuY29zYjEgKiBzaW5iIC0gdGhpcy5zaW5iMSAqIGNvc2IgKiBjb3NsYW0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHkgPSAoYiA9IE1hdGguc3FydCgyIC8gKDEgKyBjb3NiICogY29zbGFtKSkpICogc2luYiAqIHRoaXMueW1mO1xuICAgICAgfVxuICAgICAgeCA9IHRoaXMueG1mICogYiAqIGNvc2IgKiBzaW5sYW07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuTl9QT0xFOlxuICAgIGNhc2UgdGhpcy5TX1BPTEU6XG4gICAgICBpZiAocSA+PSAwKSB7XG4gICAgICAgIHggPSAoYiA9IE1hdGguc3FydChxKSkgKiBzaW5sYW07XG4gICAgICAgIHkgPSBjb3NsYW0gKiAoKHRoaXMubW9kZSA9PT0gdGhpcy5TX1BPTEUpID8gYiA6IC1iKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB4ID0geSA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwLnggPSB0aGlzLmEgKiB4ICsgdGhpcy54MDtcbiAgcC55ID0gdGhpcy5hICogeSArIHRoaXMueTA7XG4gIHJldHVybiBwO1xufTtcblxuLyogSW52ZXJzZSBlcXVhdGlvbnNcbiAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICBwLnggLT0gdGhpcy54MDtcbiAgcC55IC09IHRoaXMueTA7XG4gIHZhciB4ID0gcC54IC8gdGhpcy5hO1xuICB2YXIgeSA9IHAueSAvIHRoaXMuYTtcbiAgdmFyIGxhbSwgcGhpLCBjQ2UsIHNDZSwgcSwgcmhvLCBhYjtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICB2YXIgY29zeiA9IDAsXG4gICAgICByaCwgc2lueiA9IDA7XG5cbiAgICByaCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICBwaGkgPSByaCAqIDAuNTtcbiAgICBpZiAocGhpID4gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBoaSA9IDIgKiBNYXRoLmFzaW4ocGhpKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5FUVVJVCkge1xuICAgICAgc2lueiA9IE1hdGguc2luKHBoaSk7XG4gICAgICBjb3N6ID0gTWF0aC5jb3MocGhpKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIHRoaXMuRVFVSVQ6XG4gICAgICBwaGkgPSAoTWF0aC5hYnMocmgpIDw9IEVQU0xOKSA/IDAgOiBNYXRoLmFzaW4oeSAqIHNpbnogLyByaCk7XG4gICAgICB4ICo9IHNpbno7XG4gICAgICB5ID0gY29zeiAqIHJoO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLk9CTElROlxuICAgICAgcGhpID0gKE1hdGguYWJzKHJoKSA8PSBFUFNMTikgPyB0aGlzLnBoaTAgOiBNYXRoLmFzaW4oY29zeiAqIHRoaXMuc2lucGgwICsgeSAqIHNpbnogKiB0aGlzLmNvc3BoMCAvIHJoKTtcbiAgICAgIHggKj0gc2lueiAqIHRoaXMuY29zcGgwO1xuICAgICAgeSA9IChjb3N6IC0gTWF0aC5zaW4ocGhpKSAqIHRoaXMuc2lucGgwKSAqIHJoO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLk5fUE9MRTpcbiAgICAgIHkgPSAteTtcbiAgICAgIHBoaSA9IEhBTEZfUEkgLSBwaGk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuU19QT0xFOlxuICAgICAgcGhpIC09IEhBTEZfUEk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGFtID0gKHkgPT09IDAgJiYgKHRoaXMubW9kZSA9PT0gdGhpcy5FUVVJVCB8fCB0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEpKSA/IDAgOiBNYXRoLmF0YW4yKHgsIHkpO1xuICB9XG4gIGVsc2Uge1xuICAgIGFiID0gMDtcbiAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5FUVVJVCkge1xuICAgICAgeCAvPSB0aGlzLmRkO1xuICAgICAgeSAqPSB0aGlzLmRkO1xuICAgICAgcmhvID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgaWYgKHJobyA8IEVQU0xOKSB7XG4gICAgICAgIHAueCA9IDA7XG4gICAgICAgIHAueSA9IHRoaXMucGhpMDtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG4gICAgICBzQ2UgPSAyICogTWF0aC5hc2luKDAuNSAqIHJobyAvIHRoaXMucnEpO1xuICAgICAgY0NlID0gTWF0aC5jb3Moc0NlKTtcbiAgICAgIHggKj0gKHNDZSA9IE1hdGguc2luKHNDZSkpO1xuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSkge1xuICAgICAgICBhYiA9IGNDZSAqIHRoaXMuc2luYjEgKyB5ICogc0NlICogdGhpcy5jb3NiMSAvIHJobztcbiAgICAgICAgcSA9IHRoaXMucXAgKiBhYjtcbiAgICAgICAgeSA9IHJobyAqIHRoaXMuY29zYjEgKiBjQ2UgLSB5ICogdGhpcy5zaW5iMSAqIHNDZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhYiA9IHkgKiBzQ2UgLyByaG87XG4gICAgICAgIHEgPSB0aGlzLnFwICogYWI7XG4gICAgICAgIHkgPSByaG8gKiBjQ2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5OX1BPTEUgfHwgdGhpcy5tb2RlID09PSB0aGlzLlNfUE9MRSkge1xuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5OX1BPTEUpIHtcbiAgICAgICAgeSA9IC15O1xuICAgICAgfVxuICAgICAgcSA9ICh4ICogeCArIHkgKiB5KTtcbiAgICAgIGlmICghcSkge1xuICAgICAgICBwLnggPSAwO1xuICAgICAgICBwLnkgPSB0aGlzLnBoaTA7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfVxuICAgICAgYWIgPSAxIC0gcSAvIHRoaXMucXA7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLlNfUE9MRSkge1xuICAgICAgICBhYiA9IC1hYjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFtID0gTWF0aC5hdGFuMih4LCB5KTtcbiAgICBwaGkgPSB0aGlzLmF1dGhsYXQoTWF0aC5hc2luKGFiKSwgdGhpcy5hcGEpO1xuICB9XG5cblxuICBwLnggPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBsYW0pO1xuICBwLnkgPSBwaGk7XG4gIHJldHVybiBwO1xufTtcblxuLyogZGV0ZXJtaW5lIGxhdGl0dWRlIGZyb20gYXV0aGFsaWMgbGF0aXR1ZGUgKi9cbmV4cG9ydHMuUDAwID0gMC4zMzMzMzMzMzMzMzMzMzMzMzMzMztcbmV4cG9ydHMuUDAxID0gMC4xNzIyMjIyMjIyMjIyMjIyMjIyMjtcbmV4cG9ydHMuUDAyID0gMC4xMDI1NzkzNjUwNzkzNjUwNzkzNjtcbmV4cG9ydHMuUDEwID0gMC4wNjM4ODg4ODg4ODg4ODg4ODg4ODtcbmV4cG9ydHMuUDExID0gMC4wNjY0MDIxMTY0MDIxMTY0MDIxMTtcbmV4cG9ydHMuUDIwID0gMC4wMTY0MTUwMTI5NDIxOTE1NDQ0MztcblxuZXhwb3J0cy5hdXRoc2V0ID0gZnVuY3Rpb24oZXMpIHtcbiAgdmFyIHQ7XG4gIHZhciBBUEEgPSBbXTtcbiAgQVBBWzBdID0gZXMgKiB0aGlzLlAwMDtcbiAgdCA9IGVzICogZXM7XG4gIEFQQVswXSArPSB0ICogdGhpcy5QMDE7XG4gIEFQQVsxXSA9IHQgKiB0aGlzLlAxMDtcbiAgdCAqPSBlcztcbiAgQVBBWzBdICs9IHQgKiB0aGlzLlAwMjtcbiAgQVBBWzFdICs9IHQgKiB0aGlzLlAxMTtcbiAgQVBBWzJdID0gdCAqIHRoaXMuUDIwO1xuICByZXR1cm4gQVBBO1xufTtcblxuZXhwb3J0cy5hdXRobGF0ID0gZnVuY3Rpb24oYmV0YSwgQVBBKSB7XG4gIHZhciB0ID0gYmV0YSArIGJldGE7XG4gIHJldHVybiAoYmV0YSArIEFQQVswXSAqIE1hdGguc2luKHQpICsgQVBBWzFdICogTWF0aC5zaW4odCArIHQpICsgQVBBWzJdICogTWF0aC5zaW4odCArIHQgKyB0KSk7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIkxhbWJlcnQgQXppbXV0aGFsIEVxdWFsIEFyZWFcIiwgXCJMYW1iZXJ0X0F6aW11dGhhbF9FcXVhbF9BcmVhXCIsIFwibGFlYVwiXTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL2xhZWEuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBtc2ZueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tc2ZueicpO1xudmFyIHRzZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL3RzZm56Jyk7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbnZhciBzaWduID0gcmVxdWlyZSgnLi4vY29tbW9uL3NpZ24nKTtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBwaGkyeiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9waGkyeicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgLy8gYXJyYXkgb2Y6ICByX21haixyX21pbixsYXQxLGxhdDIsY19sb24sY19sYXQsZmFsc2VfZWFzdCxmYWxzZV9ub3J0aFxuICAvL2RvdWJsZSBjX2xhdDsgICAgICAgICAgICAgICAgICAgLyogY2VudGVyIGxhdGl0dWRlICAgICAgICAgICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIGNfbG9uOyAgICAgICAgICAgICAgICAgICAvKiBjZW50ZXIgbG9uZ2l0dWRlICAgICAgICAgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgbGF0MTsgICAgICAgICAgICAgICAgICAgIC8qIGZpcnN0IHN0YW5kYXJkIHBhcmFsbGVsICAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSBsYXQyOyAgICAgICAgICAgICAgICAgICAgLyogc2Vjb25kIHN0YW5kYXJkIHBhcmFsbGVsICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIHJfbWFqOyAgICAgICAgICAgICAgICAgICAvKiBtYWpvciBheGlzICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgcl9taW47ICAgICAgICAgICAgICAgICAgIC8qIG1pbm9yIGF4aXMgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSBmYWxzZV9lYXN0OyAgICAgICAgICAgICAgLyogeCBvZmZzZXQgaW4gbWV0ZXJzICAgICAgICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIGZhbHNlX25vcnRoOyAgICAgICAgICAgICAvKiB5IG9mZnNldCBpbiBtZXRlcnMgICAgICAgICAgICAgICAgICAgKi9cblxuICBpZiAoIXRoaXMubGF0Mikge1xuICAgIHRoaXMubGF0MiA9IHRoaXMubGF0MTtcbiAgfSAvL2lmIGxhdDIgaXMgbm90IGRlZmluZWRcbiAgaWYgKCF0aGlzLmswKSB7XG4gICAgdGhpcy5rMCA9IDE7XG4gIH1cbiAgdGhpcy54MCA9IHRoaXMueDAgfHwgMDtcbiAgdGhpcy55MCA9IHRoaXMueTAgfHwgMDtcbiAgLy8gU3RhbmRhcmQgUGFyYWxsZWxzIGNhbm5vdCBiZSBlcXVhbCBhbmQgb24gb3Bwb3NpdGUgc2lkZXMgb2YgdGhlIGVxdWF0b3JcbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSArIHRoaXMubGF0MikgPCBFUFNMTikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0ZW1wID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmUgPSBNYXRoLnNxcnQoMSAtIHRlbXAgKiB0ZW1wKTtcblxuICB2YXIgc2luMSA9IE1hdGguc2luKHRoaXMubGF0MSk7XG4gIHZhciBjb3MxID0gTWF0aC5jb3ModGhpcy5sYXQxKTtcbiAgdmFyIG1zMSA9IG1zZm56KHRoaXMuZSwgc2luMSwgY29zMSk7XG4gIHZhciB0czEgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MSwgc2luMSk7XG5cbiAgdmFyIHNpbjIgPSBNYXRoLnNpbih0aGlzLmxhdDIpO1xuICB2YXIgY29zMiA9IE1hdGguY29zKHRoaXMubGF0Mik7XG4gIHZhciBtczIgPSBtc2Zueih0aGlzLmUsIHNpbjIsIGNvczIpO1xuICB2YXIgdHMyID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDIsIHNpbjIpO1xuXG4gIHZhciB0czAgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MCwgTWF0aC5zaW4odGhpcy5sYXQwKSk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSAtIHRoaXMubGF0MikgPiBFUFNMTikge1xuICAgIHRoaXMubnMgPSBNYXRoLmxvZyhtczEgLyBtczIpIC8gTWF0aC5sb2codHMxIC8gdHMyKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm5zID0gc2luMTtcbiAgfVxuICBpZiAoaXNOYU4odGhpcy5ucykpIHtcbiAgICB0aGlzLm5zID0gc2luMTtcbiAgfVxuICB0aGlzLmYwID0gbXMxIC8gKHRoaXMubnMgKiBNYXRoLnBvdyh0czEsIHRoaXMubnMpKTtcbiAgdGhpcy5yaCA9IHRoaXMuYSAqIHRoaXMuZjAgKiBNYXRoLnBvdyh0czAsIHRoaXMubnMpO1xuICBpZiAoIXRoaXMudGl0bGUpIHtcbiAgICB0aGlzLnRpdGxlID0gXCJMYW1iZXJ0IENvbmZvcm1hbCBDb25pY1wiO1xuICB9XG59O1xuXG5cbi8vIExhbWJlcnQgQ29uZm9ybWFsIGNvbmljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcblxuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIC8vIHNpbmd1bGFyIGNhc2VzIDpcbiAgaWYgKE1hdGguYWJzKDIgKiBNYXRoLmFicyhsYXQpIC0gTWF0aC5QSSkgPD0gRVBTTE4pIHtcbiAgICBsYXQgPSBzaWduKGxhdCkgKiAoSEFMRl9QSSAtIDIgKiBFUFNMTik7XG4gIH1cblxuICB2YXIgY29uID0gTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpO1xuICB2YXIgdHMsIHJoMTtcbiAgaWYgKGNvbiA+IEVQU0xOKSB7XG4gICAgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCwgTWF0aC5zaW4obGF0KSk7XG4gICAgcmgxID0gdGhpcy5hICogdGhpcy5mMCAqIE1hdGgucG93KHRzLCB0aGlzLm5zKTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb24gPSBsYXQgKiB0aGlzLm5zO1xuICAgIGlmIChjb24gPD0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJoMSA9IDA7XG4gIH1cbiAgdmFyIHRoZXRhID0gdGhpcy5ucyAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHAueCA9IHRoaXMuazAgKiAocmgxICogTWF0aC5zaW4odGhldGEpKSArIHRoaXMueDA7XG4gIHAueSA9IHRoaXMuazAgKiAodGhpcy5yaCAtIHJoMSAqIE1hdGguY29zKHRoZXRhKSkgKyB0aGlzLnkwO1xuXG4gIHJldHVybiBwO1xufTtcblxuLy8gTGFtYmVydCBDb25mb3JtYWwgQ29uaWMgaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciByaDEsIGNvbiwgdHM7XG4gIHZhciBsYXQsIGxvbjtcbiAgdmFyIHggPSAocC54IC0gdGhpcy54MCkgLyB0aGlzLmswO1xuICB2YXIgeSA9ICh0aGlzLnJoIC0gKHAueSAtIHRoaXMueTApIC8gdGhpcy5rMCk7XG4gIGlmICh0aGlzLm5zID4gMCkge1xuICAgIHJoMSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICBjb24gPSAxO1xuICB9XG4gIGVsc2Uge1xuICAgIHJoMSA9IC1NYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgY29uID0gLTE7XG4gIH1cbiAgdmFyIHRoZXRhID0gMDtcbiAgaWYgKHJoMSAhPT0gMCkge1xuICAgIHRoZXRhID0gTWF0aC5hdGFuMigoY29uICogeCksIChjb24gKiB5KSk7XG4gIH1cbiAgaWYgKChyaDEgIT09IDApIHx8ICh0aGlzLm5zID4gMCkpIHtcbiAgICBjb24gPSAxIC8gdGhpcy5ucztcbiAgICB0cyA9IE1hdGgucG93KChyaDEgLyAodGhpcy5hICogdGhpcy5mMCkpLCBjb24pO1xuICAgIGxhdCA9IHBoaTJ6KHRoaXMuZSwgdHMpO1xuICAgIGlmIChsYXQgPT09IC05OTk5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgbGF0ID0gLUhBTEZfUEk7XG4gIH1cbiAgbG9uID0gYWRqdXN0X2xvbih0aGV0YSAvIHRoaXMubnMgKyB0aGlzLmxvbmcwKTtcblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLm5hbWVzID0gW1wiTGFtYmVydCBUYW5nZW50aWFsIENvbmZvcm1hbCBDb25pYyBQcm9qZWN0aW9uXCIsIFwiTGFtYmVydF9Db25mb3JtYWxfQ29uaWNcIiwgXCJMYW1iZXJ0X0NvbmZvcm1hbF9Db25pY18yU1BcIiwgXCJsY2NcIl07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9sY2MuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIC8vbm8tb3AgZm9yIGxvbmdsYXRcbn07XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHB0KSB7XG4gIHJldHVybiBwdDtcbn1cbmV4cG9ydHMuZm9yd2FyZCA9IGlkZW50aXR5O1xuZXhwb3J0cy5pbnZlcnNlID0gaWRlbnRpdHk7XG5leHBvcnRzLm5hbWVzID0gW1wibG9uZ2xhdFwiLCBcImlkZW50aXR5XCJdO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbG9uZ2xhdC5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgbXNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vbXNmbnonKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBSMkQgPSA1Ny4yOTU3Nzk1MTMwODIzMjA4ODtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBGT1JUUEkgPSBNYXRoLlBJLzQ7XG52YXIgdHNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vdHNmbnonKTtcbnZhciBwaGkyeiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9waGkyeicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb24gPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZXMgPSAxIC0gY29uICogY29uO1xuICBpZighKCd4MCcgaW4gdGhpcykpe1xuICAgIHRoaXMueDAgPSAwO1xuICB9XG4gIGlmKCEoJ3kwJyBpbiB0aGlzKSl7XG4gICAgdGhpcy55MCA9IDA7XG4gIH1cbiAgdGhpcy5lID0gTWF0aC5zcXJ0KHRoaXMuZXMpO1xuICBpZiAodGhpcy5sYXRfdHMpIHtcbiAgICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICAgIHRoaXMuazAgPSBNYXRoLmNvcyh0aGlzLmxhdF90cyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5rMCA9IG1zZm56KHRoaXMuZSwgTWF0aC5zaW4odGhpcy5sYXRfdHMpLCBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoIXRoaXMuazApIHtcbiAgICAgIGlmICh0aGlzLmspIHtcbiAgICAgICAgdGhpcy5rMCA9IHRoaXMuaztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmswID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qIE1lcmNhdG9yIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgLy8gY29udmVydCB0byByYWRpYW5zXG4gIGlmIChsYXQgKiBSMkQgPiA5MCAmJiBsYXQgKiBSMkQgPCAtOTAgJiYgbG9uICogUjJEID4gMTgwICYmIGxvbiAqIFIyRCA8IC0xODApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB4LCB5O1xuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpIDw9IEVQU0xOKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIHRoaXMuazAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICAgICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiB0aGlzLmswICogTWF0aC5sb2coTWF0aC50YW4oRk9SVFBJICsgMC41ICogbGF0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpbnBoaSA9IE1hdGguc2luKGxhdCk7XG4gICAgICB2YXIgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCwgc2lucGhpKTtcbiAgICAgIHggPSB0aGlzLngwICsgdGhpcy5hICogdGhpcy5rMCAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gICAgICB5ID0gdGhpcy55MCAtIHRoaXMuYSAqIHRoaXMuazAgKiBNYXRoLmxvZyh0cyk7XG4gICAgfVxuICAgIHAueCA9IHg7XG4gICAgcC55ID0geTtcbiAgICByZXR1cm4gcDtcbiAgfVxufTtcblxuXG4vKiBNZXJjYXRvciBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuXG4gIHZhciB4ID0gcC54IC0gdGhpcy54MDtcbiAgdmFyIHkgPSBwLnkgLSB0aGlzLnkwO1xuICB2YXIgbG9uLCBsYXQ7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbGF0ID0gSEFMRl9QSSAtIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoLXkgLyAodGhpcy5hICogdGhpcy5rMCkpKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgdHMgPSBNYXRoLmV4cCgteSAvICh0aGlzLmEgKiB0aGlzLmswKSk7XG4gICAgbGF0ID0gcGhpMnoodGhpcy5lLCB0cyk7XG4gICAgaWYgKGxhdCA9PT0gLTk5OTkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyB4IC8gKHRoaXMuYSAqIHRoaXMuazApKTtcblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLm5hbWVzID0gW1wiTWVyY2F0b3JcIiwgXCJQb3B1bGFyIFZpc3VhbGlzYXRpb24gUHNldWRvIE1lcmNhdG9yXCIsIFwiTWVyY2F0b3JfMVNQXCIsIFwiTWVyY2F0b3JfQXV4aWxpYXJ5X1NwaGVyZVwiLCBcIm1lcmNcIl07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9tZXJjLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9uc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbi8qXG4gIHJlZmVyZW5jZVxuICAgIFwiTmV3IEVxdWFsLUFyZWEgTWFwIFByb2plY3Rpb25zIGZvciBOb25jaXJjdWxhciBSZWdpb25zXCIsIEpvaG4gUC4gU255ZGVyLFxuICAgIFRoZSBBbWVyaWNhbiBDYXJ0b2dyYXBoZXIsIFZvbCAxNSwgTm8uIDQsIE9jdG9iZXIgMTk4OCwgcHAuIDM0MS0zNTUuXG4gICovXG5cblxuLyogSW5pdGlhbGl6ZSB0aGUgTWlsbGVyIEN5bGluZHJpY2FsIHByb2plY3Rpb25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgLy9uby1vcFxufTtcblxuXG4vKiBNaWxsZXIgQ3lsaW5kcmljYWwgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgeCA9IHRoaXMueDAgKyB0aGlzLmEgKiBkbG9uO1xuICB2YXIgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiBNYXRoLmxvZyhNYXRoLnRhbigoTWF0aC5QSSAvIDQpICsgKGxhdCAvIDIuNSkpKSAqIDEuMjU7XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBNaWxsZXIgQ3lsaW5kcmljYWwgaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuXG4gIHZhciBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBwLnggLyB0aGlzLmEpO1xuICB2YXIgbGF0ID0gMi41ICogKE1hdGguYXRhbihNYXRoLmV4cCgwLjggKiBwLnkgLyB0aGlzLmEpKSAtIE1hdGguUEkgLyA0KTtcblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIk1pbGxlcl9DeWxpbmRyaWNhbFwiLCBcIm1pbGxcIl07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9taWxsLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9uc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHt9O1xuXG4vKiBNb2xsd2VpZGUgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG5cbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICB2YXIgZGVsdGFfbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIHRoZXRhID0gbGF0O1xuICB2YXIgY29uID0gTWF0aC5QSSAqIE1hdGguc2luKGxhdCk7XG5cbiAgLyogSXRlcmF0ZSB1c2luZyB0aGUgTmV3dG9uLVJhcGhzb24gbWV0aG9kIHRvIGZpbmQgdGhldGFcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgZm9yICh2YXIgaSA9IDA7IHRydWU7IGkrKykge1xuICAgIHZhciBkZWx0YV90aGV0YSA9IC0odGhldGEgKyBNYXRoLnNpbih0aGV0YSkgLSBjb24pIC8gKDEgKyBNYXRoLmNvcyh0aGV0YSkpO1xuICAgIHRoZXRhICs9IGRlbHRhX3RoZXRhO1xuICAgIGlmIChNYXRoLmFicyhkZWx0YV90aGV0YSkgPCBFUFNMTikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoZXRhIC89IDI7XG5cbiAgLyogSWYgdGhlIGxhdGl0dWRlIGlzIDkwIGRlZywgZm9yY2UgdGhlIHggY29vcmRpbmF0ZSB0byBiZSBcIjAgKyBmYWxzZSBlYXN0aW5nXCJcbiAgICAgICB0aGlzIGlzIGRvbmUgaGVyZSBiZWNhdXNlIG9mIHByZWNpc2lvbiBwcm9ibGVtcyB3aXRoIFwiY29zKHRoZXRhKVwiXG4gICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBpZiAoTWF0aC5QSSAvIDIgLSBNYXRoLmFicyhsYXQpIDwgRVBTTE4pIHtcbiAgICBkZWx0YV9sb24gPSAwO1xuICB9XG4gIHZhciB4ID0gMC45MDAzMTYzMTYxNTggKiB0aGlzLmEgKiBkZWx0YV9sb24gKiBNYXRoLmNvcyh0aGV0YSkgKyB0aGlzLngwO1xuICB2YXIgeSA9IDEuNDE0MjEzNTYyMzczMSAqIHRoaXMuYSAqIE1hdGguc2luKHRoZXRhKSArIHRoaXMueTA7XG5cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciB0aGV0YTtcbiAgdmFyIGFyZztcblxuICAvKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBwLnggLT0gdGhpcy54MDtcbiAgcC55IC09IHRoaXMueTA7XG4gIGFyZyA9IHAueSAvICgxLjQxNDIxMzU2MjM3MzEgKiB0aGlzLmEpO1xuXG4gIC8qIEJlY2F1c2Ugb2YgZGl2aXNpb24gYnkgemVybyBwcm9ibGVtcywgJ2FyZycgY2FuIG5vdCBiZSAxLiAgVGhlcmVmb3JlXG4gICAgICAgYSBudW1iZXIgdmVyeSBjbG9zZSB0byBvbmUgaXMgdXNlZCBpbnN0ZWFkLlxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBpZiAoTWF0aC5hYnMoYXJnKSA+IDAuOTk5OTk5OTk5OTk5KSB7XG4gICAgYXJnID0gMC45OTk5OTk5OTk5OTk7XG4gIH1cbiAgdGhldGEgPSBNYXRoLmFzaW4oYXJnKTtcbiAgdmFyIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIChwLnggLyAoMC45MDAzMTYzMTYxNTggKiB0aGlzLmEgKiBNYXRoLmNvcyh0aGV0YSkpKSk7XG4gIGlmIChsb24gPCAoLU1hdGguUEkpKSB7XG4gICAgbG9uID0gLU1hdGguUEk7XG4gIH1cbiAgaWYgKGxvbiA+IE1hdGguUEkpIHtcbiAgICBsb24gPSBNYXRoLlBJO1xuICB9XG4gIGFyZyA9ICgyICogdGhldGEgKyBNYXRoLnNpbigyICogdGhldGEpKSAvIE1hdGguUEk7XG4gIGlmIChNYXRoLmFicyhhcmcpID4gMSkge1xuICAgIGFyZyA9IDE7XG4gIH1cbiAgdmFyIGxhdCA9IE1hdGguYXNpbihhcmcpO1xuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiTW9sbHdlaWRlXCIsIFwibW9sbFwiXTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL21vbGwuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFNFQ19UT19SQUQgPSA0Ljg0ODEzNjgxMTA5NTM1OTkzNTg5OTE0MTAyMzU3ZS02O1xuLypcbiAgcmVmZXJlbmNlXG4gICAgRGVwYXJ0bWVudCBvZiBMYW5kIGFuZCBTdXJ2ZXkgVGVjaG5pY2FsIENpcmN1bGFyIDE5NzMvMzJcbiAgICAgIGh0dHA6Ly93d3cubGluei5nb3Z0Lm56L2RvY3MvbWlzY2VsbGFuZW91cy9uei1tYXAtZGVmaW5pdGlvbi5wZGZcbiAgICBPU0cgVGVjaG5pY2FsIFJlcG9ydCA0LjFcbiAgICAgIGh0dHA6Ly93d3cubGluei5nb3Z0Lm56L2RvY3MvbWlzY2VsbGFuZW91cy9uem1nLnBkZlxuICAqL1xuXG4vKipcbiAqIGl0ZXJhdGlvbnM6IE51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJlZmluZSBpbnZlcnNlIHRyYW5zZm9ybS5cbiAqICAgICAwIC0+IGttIGFjY3VyYWN5XG4gKiAgICAgMSAtPiBtIGFjY3VyYWN5IC0tIHN1aXRhYmxlIGZvciBtb3N0IG1hcHBpbmcgYXBwbGljYXRpb25zXG4gKiAgICAgMiAtPiBtbSBhY2N1cmFjeVxuICovXG5leHBvcnRzLml0ZXJhdGlvbnMgPSAxO1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5BID0gW107XG4gIHRoaXMuQVsxXSA9IDAuNjM5OTE3NTA3MztcbiAgdGhpcy5BWzJdID0gLTAuMTM1ODc5NzYxMztcbiAgdGhpcy5BWzNdID0gMC4wNjMyOTQ0MDk7XG4gIHRoaXMuQVs0XSA9IC0wLjAyNTI2ODUzO1xuICB0aGlzLkFbNV0gPSAwLjAxMTc4Nzk7XG4gIHRoaXMuQVs2XSA9IC0wLjAwNTUxNjE7XG4gIHRoaXMuQVs3XSA9IDAuMDAyNjkwNjtcbiAgdGhpcy5BWzhdID0gLTAuMDAxMzMzO1xuICB0aGlzLkFbOV0gPSAwLjAwMDY3O1xuICB0aGlzLkFbMTBdID0gLTAuMDAwMzQ7XG5cbiAgdGhpcy5CX3JlID0gW107XG4gIHRoaXMuQl9pbSA9IFtdO1xuICB0aGlzLkJfcmVbMV0gPSAwLjc1NTc4NTMyMjg7XG4gIHRoaXMuQl9pbVsxXSA9IDA7XG4gIHRoaXMuQl9yZVsyXSA9IDAuMjQ5MjA0NjQ2O1xuICB0aGlzLkJfaW1bMl0gPSAwLjAwMzM3MTUwNztcbiAgdGhpcy5CX3JlWzNdID0gLTAuMDAxNTQxNzM5O1xuICB0aGlzLkJfaW1bM10gPSAwLjA0MTA1ODU2MDtcbiAgdGhpcy5CX3JlWzRdID0gLTAuMTAxNjI5MDc7XG4gIHRoaXMuQl9pbVs0XSA9IDAuMDE3Mjc2MDk7XG4gIHRoaXMuQl9yZVs1XSA9IC0wLjI2NjIzNDg5O1xuICB0aGlzLkJfaW1bNV0gPSAtMC4zNjI0OTIxODtcbiAgdGhpcy5CX3JlWzZdID0gLTAuNjg3MDk4MztcbiAgdGhpcy5CX2ltWzZdID0gLTEuMTY1MTk2NztcblxuICB0aGlzLkNfcmUgPSBbXTtcbiAgdGhpcy5DX2ltID0gW107XG4gIHRoaXMuQ19yZVsxXSA9IDEuMzIzMTI3MDQzOTtcbiAgdGhpcy5DX2ltWzFdID0gMDtcbiAgdGhpcy5DX3JlWzJdID0gLTAuNTc3MjQ1Nzg5O1xuICB0aGlzLkNfaW1bMl0gPSAtMC4wMDc4MDk1OTg7XG4gIHRoaXMuQ19yZVszXSA9IDAuNTA4MzA3NTEzO1xuICB0aGlzLkNfaW1bM10gPSAtMC4xMTIyMDg5NTI7XG4gIHRoaXMuQ19yZVs0XSA9IC0wLjE1MDk0NzYyO1xuICB0aGlzLkNfaW1bNF0gPSAwLjE4MjAwNjAyO1xuICB0aGlzLkNfcmVbNV0gPSAxLjAxNDE4MTc5O1xuICB0aGlzLkNfaW1bNV0gPSAxLjY0NDk3Njk2O1xuICB0aGlzLkNfcmVbNl0gPSAxLjk2NjA1NDk7XG4gIHRoaXMuQ19pbVs2XSA9IDIuNTEyNzY0NTtcblxuICB0aGlzLkQgPSBbXTtcbiAgdGhpcy5EWzFdID0gMS41NjI3MDE0MjQzO1xuICB0aGlzLkRbMl0gPSAwLjUxODU0MDYzOTg7XG4gIHRoaXMuRFszXSA9IC0wLjAzMzMzMDk4O1xuICB0aGlzLkRbNF0gPSAtMC4xMDUyOTA2O1xuICB0aGlzLkRbNV0gPSAtMC4wMzY4NTk0O1xuICB0aGlzLkRbNl0gPSAwLjAwNzMxNztcbiAgdGhpcy5EWzddID0gMC4wMTIyMDtcbiAgdGhpcy5EWzhdID0gMC4wMDM5NDtcbiAgdGhpcy5EWzldID0gLTAuMDAxMztcbn07XG5cbi8qKlxuICAgIE5ldyBaZWFsYW5kIE1hcCBHcmlkIEZvcndhcmQgIC0gbG9uZy9sYXQgdG8geC95XG4gICAgbG9uZy9sYXQgaW4gcmFkaWFuc1xuICAqL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbjtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICB2YXIgZGVsdGFfbGF0ID0gbGF0IC0gdGhpcy5sYXQwO1xuICB2YXIgZGVsdGFfbG9uID0gbG9uIC0gdGhpcy5sb25nMDtcblxuICAvLyAxLiBDYWxjdWxhdGUgZF9waGkgYW5kIGRfcHNpICAgIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGRfbGFtYmRhXG4gIC8vIEZvciB0aGlzIGFsZ29yaXRobSwgZGVsdGFfbGF0aXR1ZGUgaXMgaW4gc2Vjb25kcyBvZiBhcmMgeCAxMC01LCBzbyB3ZSBuZWVkIHRvIHNjYWxlIHRvIHRob3NlIHVuaXRzLiBMb25naXR1ZGUgaXMgcmFkaWFucy5cbiAgdmFyIGRfcGhpID0gZGVsdGFfbGF0IC8gU0VDX1RPX1JBRCAqIDFFLTU7XG4gIHZhciBkX2xhbWJkYSA9IGRlbHRhX2xvbjtcbiAgdmFyIGRfcGhpX24gPSAxOyAvLyBkX3BoaV4wXG5cbiAgdmFyIGRfcHNpID0gMDtcbiAgZm9yIChuID0gMTsgbiA8PSAxMDsgbisrKSB7XG4gICAgZF9waGlfbiA9IGRfcGhpX24gKiBkX3BoaTtcbiAgICBkX3BzaSA9IGRfcHNpICsgdGhpcy5BW25dICogZF9waGlfbjtcbiAgfVxuXG4gIC8vIDIuIENhbGN1bGF0ZSB0aGV0YVxuICB2YXIgdGhfcmUgPSBkX3BzaTtcbiAgdmFyIHRoX2ltID0gZF9sYW1iZGE7XG5cbiAgLy8gMy4gQ2FsY3VsYXRlIHpcbiAgdmFyIHRoX25fcmUgPSAxO1xuICB2YXIgdGhfbl9pbSA9IDA7IC8vIHRoZXRhXjBcbiAgdmFyIHRoX25fcmUxO1xuICB2YXIgdGhfbl9pbTE7XG5cbiAgdmFyIHpfcmUgPSAwO1xuICB2YXIgel9pbSA9IDA7XG4gIGZvciAobiA9IDE7IG4gPD0gNjsgbisrKSB7XG4gICAgdGhfbl9yZTEgPSB0aF9uX3JlICogdGhfcmUgLSB0aF9uX2ltICogdGhfaW07XG4gICAgdGhfbl9pbTEgPSB0aF9uX2ltICogdGhfcmUgKyB0aF9uX3JlICogdGhfaW07XG4gICAgdGhfbl9yZSA9IHRoX25fcmUxO1xuICAgIHRoX25faW0gPSB0aF9uX2ltMTtcbiAgICB6X3JlID0gel9yZSArIHRoaXMuQl9yZVtuXSAqIHRoX25fcmUgLSB0aGlzLkJfaW1bbl0gKiB0aF9uX2ltO1xuICAgIHpfaW0gPSB6X2ltICsgdGhpcy5CX2ltW25dICogdGhfbl9yZSArIHRoaXMuQl9yZVtuXSAqIHRoX25faW07XG4gIH1cblxuICAvLyA0LiBDYWxjdWxhdGUgZWFzdGluZyBhbmQgbm9ydGhpbmdcbiAgcC54ID0gKHpfaW0gKiB0aGlzLmEpICsgdGhpcy54MDtcbiAgcC55ID0gKHpfcmUgKiB0aGlzLmEpICsgdGhpcy55MDtcblxuICByZXR1cm4gcDtcbn07XG5cblxuLyoqXG4gICAgTmV3IFplYWxhbmQgTWFwIEdyaWQgSW52ZXJzZSAgLSAgeC95IHRvIGxvbmcvbGF0XG4gICovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBuO1xuICB2YXIgeCA9IHAueDtcbiAgdmFyIHkgPSBwLnk7XG5cbiAgdmFyIGRlbHRhX3ggPSB4IC0gdGhpcy54MDtcbiAgdmFyIGRlbHRhX3kgPSB5IC0gdGhpcy55MDtcblxuICAvLyAxLiBDYWxjdWxhdGUgelxuICB2YXIgel9yZSA9IGRlbHRhX3kgLyB0aGlzLmE7XG4gIHZhciB6X2ltID0gZGVsdGFfeCAvIHRoaXMuYTtcblxuICAvLyAyYS4gQ2FsY3VsYXRlIHRoZXRhIC0gZmlyc3QgYXBwcm94aW1hdGlvbiBnaXZlcyBrbSBhY2N1cmFjeVxuICB2YXIgel9uX3JlID0gMTtcbiAgdmFyIHpfbl9pbSA9IDA7IC8vIHpeMFxuICB2YXIgel9uX3JlMTtcbiAgdmFyIHpfbl9pbTE7XG5cbiAgdmFyIHRoX3JlID0gMDtcbiAgdmFyIHRoX2ltID0gMDtcbiAgZm9yIChuID0gMTsgbiA8PSA2OyBuKyspIHtcbiAgICB6X25fcmUxID0gel9uX3JlICogel9yZSAtIHpfbl9pbSAqIHpfaW07XG4gICAgel9uX2ltMSA9IHpfbl9pbSAqIHpfcmUgKyB6X25fcmUgKiB6X2ltO1xuICAgIHpfbl9yZSA9IHpfbl9yZTE7XG4gICAgel9uX2ltID0gel9uX2ltMTtcbiAgICB0aF9yZSA9IHRoX3JlICsgdGhpcy5DX3JlW25dICogel9uX3JlIC0gdGhpcy5DX2ltW25dICogel9uX2ltO1xuICAgIHRoX2ltID0gdGhfaW0gKyB0aGlzLkNfaW1bbl0gKiB6X25fcmUgKyB0aGlzLkNfcmVbbl0gKiB6X25faW07XG4gIH1cblxuICAvLyAyYi4gSXRlcmF0ZSB0byByZWZpbmUgdGhlIGFjY3VyYWN5IG9mIHRoZSBjYWxjdWxhdGlvblxuICAvLyAgICAgICAgMCBpdGVyYXRpb25zIGdpdmVzIGttIGFjY3VyYWN5XG4gIC8vICAgICAgICAxIGl0ZXJhdGlvbiBnaXZlcyBtIGFjY3VyYWN5IC0tIGdvb2QgZW5vdWdoIGZvciBtb3N0IG1hcHBpbmcgYXBwbGljYXRpb25zXG4gIC8vICAgICAgICAyIGl0ZXJhdGlvbnMgYml2ZXMgbW0gYWNjdXJhY3lcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZXJhdGlvbnM7IGkrKykge1xuICAgIHZhciB0aF9uX3JlID0gdGhfcmU7XG4gICAgdmFyIHRoX25faW0gPSB0aF9pbTtcbiAgICB2YXIgdGhfbl9yZTE7XG4gICAgdmFyIHRoX25faW0xO1xuXG4gICAgdmFyIG51bV9yZSA9IHpfcmU7XG4gICAgdmFyIG51bV9pbSA9IHpfaW07XG4gICAgZm9yIChuID0gMjsgbiA8PSA2OyBuKyspIHtcbiAgICAgIHRoX25fcmUxID0gdGhfbl9yZSAqIHRoX3JlIC0gdGhfbl9pbSAqIHRoX2ltO1xuICAgICAgdGhfbl9pbTEgPSB0aF9uX2ltICogdGhfcmUgKyB0aF9uX3JlICogdGhfaW07XG4gICAgICB0aF9uX3JlID0gdGhfbl9yZTE7XG4gICAgICB0aF9uX2ltID0gdGhfbl9pbTE7XG4gICAgICBudW1fcmUgPSBudW1fcmUgKyAobiAtIDEpICogKHRoaXMuQl9yZVtuXSAqIHRoX25fcmUgLSB0aGlzLkJfaW1bbl0gKiB0aF9uX2ltKTtcbiAgICAgIG51bV9pbSA9IG51bV9pbSArIChuIC0gMSkgKiAodGhpcy5CX2ltW25dICogdGhfbl9yZSArIHRoaXMuQl9yZVtuXSAqIHRoX25faW0pO1xuICAgIH1cblxuICAgIHRoX25fcmUgPSAxO1xuICAgIHRoX25faW0gPSAwO1xuICAgIHZhciBkZW5fcmUgPSB0aGlzLkJfcmVbMV07XG4gICAgdmFyIGRlbl9pbSA9IHRoaXMuQl9pbVsxXTtcbiAgICBmb3IgKG4gPSAyOyBuIDw9IDY7IG4rKykge1xuICAgICAgdGhfbl9yZTEgPSB0aF9uX3JlICogdGhfcmUgLSB0aF9uX2ltICogdGhfaW07XG4gICAgICB0aF9uX2ltMSA9IHRoX25faW0gKiB0aF9yZSArIHRoX25fcmUgKiB0aF9pbTtcbiAgICAgIHRoX25fcmUgPSB0aF9uX3JlMTtcbiAgICAgIHRoX25faW0gPSB0aF9uX2ltMTtcbiAgICAgIGRlbl9yZSA9IGRlbl9yZSArIG4gKiAodGhpcy5CX3JlW25dICogdGhfbl9yZSAtIHRoaXMuQl9pbVtuXSAqIHRoX25faW0pO1xuICAgICAgZGVuX2ltID0gZGVuX2ltICsgbiAqICh0aGlzLkJfaW1bbl0gKiB0aF9uX3JlICsgdGhpcy5CX3JlW25dICogdGhfbl9pbSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcGxleCBkaXZpc2lvblxuICAgIHZhciBkZW4yID0gZGVuX3JlICogZGVuX3JlICsgZGVuX2ltICogZGVuX2ltO1xuICAgIHRoX3JlID0gKG51bV9yZSAqIGRlbl9yZSArIG51bV9pbSAqIGRlbl9pbSkgLyBkZW4yO1xuICAgIHRoX2ltID0gKG51bV9pbSAqIGRlbl9yZSAtIG51bV9yZSAqIGRlbl9pbSkgLyBkZW4yO1xuICB9XG5cbiAgLy8gMy4gQ2FsY3VsYXRlIGRfcGhpICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZF9sYW1iZGFcbiAgdmFyIGRfcHNpID0gdGhfcmU7XG4gIHZhciBkX2xhbWJkYSA9IHRoX2ltO1xuICB2YXIgZF9wc2lfbiA9IDE7IC8vIGRfcHNpXjBcblxuICB2YXIgZF9waGkgPSAwO1xuICBmb3IgKG4gPSAxOyBuIDw9IDk7IG4rKykge1xuICAgIGRfcHNpX24gPSBkX3BzaV9uICogZF9wc2k7XG4gICAgZF9waGkgPSBkX3BoaSArIHRoaXMuRFtuXSAqIGRfcHNpX247XG4gIH1cblxuICAvLyA0LiBDYWxjdWxhdGUgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZVxuICAvLyBkX3BoaSBpcyBjYWxjdWF0ZWQgaW4gc2Vjb25kIG9mIGFyYyAqIDEwXi01LCBzbyB3ZSBuZWVkIHRvIHNjYWxlIGJhY2sgdG8gcmFkaWFucy4gZF9sYW1iZGEgaXMgaW4gcmFkaWFucy5cbiAgdmFyIGxhdCA9IHRoaXMubGF0MCArIChkX3BoaSAqIFNFQ19UT19SQUQgKiAxRTUpO1xuICB2YXIgbG9uID0gdGhpcy5sb25nMCArIGRfbGFtYmRhO1xuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuXG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJOZXdfWmVhbGFuZF9NYXBfR3JpZFwiLCBcIm56bWdcIl07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvbnptZy5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgdHNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vdHNmbnonKTtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBwaGkyeiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9waGkyeicpO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRk9SVFBJID0gTWF0aC5QSS80O1xudmFyIEVQU0xOID0gMS4wZS0xMDtcblxuLyogSW5pdGlhbGl6ZSB0aGUgT2JsaXF1ZSBNZXJjYXRvciAgcHJvamVjdGlvblxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ub19vZmYgPSB0aGlzLm5vX29mZiB8fCBmYWxzZTtcbiAgdGhpcy5ub19yb3QgPSB0aGlzLm5vX3JvdCB8fCBmYWxzZTtcblxuICBpZiAoaXNOYU4odGhpcy5rMCkpIHtcbiAgICB0aGlzLmswID0gMTtcbiAgfVxuICB2YXIgc2lubGF0ID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgdmFyIGNvc2xhdCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gIHZhciBjb24gPSB0aGlzLmUgKiBzaW5sYXQ7XG5cbiAgdGhpcy5ibCA9IE1hdGguc3FydCgxICsgdGhpcy5lcyAvICgxIC0gdGhpcy5lcykgKiBNYXRoLnBvdyhjb3NsYXQsIDQpKTtcbiAgdGhpcy5hbCA9IHRoaXMuYSAqIHRoaXMuYmwgKiB0aGlzLmswICogTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKSAvICgxIC0gY29uICogY29uKTtcbiAgdmFyIHQwID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDAsIHNpbmxhdCk7XG4gIHZhciBkbCA9IHRoaXMuYmwgLyBjb3NsYXQgKiBNYXRoLnNxcnQoKDEgLSB0aGlzLmVzKSAvICgxIC0gY29uICogY29uKSk7XG4gIGlmIChkbCAqIGRsIDwgMSkge1xuICAgIGRsID0gMTtcbiAgfVxuICB2YXIgZmw7XG4gIHZhciBnbDtcbiAgaWYgKCFpc05hTih0aGlzLmxvbmdjKSkge1xuICAgIC8vQ2VudHJhbCBwb2ludCBhbmQgYXppbXV0aCBtZXRob2RcblxuICAgIGlmICh0aGlzLmxhdDAgPj0gMCkge1xuICAgICAgZmwgPSBkbCArIE1hdGguc3FydChkbCAqIGRsIC0gMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmwgPSBkbCAtIE1hdGguc3FydChkbCAqIGRsIC0gMSk7XG4gICAgfVxuICAgIHRoaXMuZWwgPSBmbCAqIE1hdGgucG93KHQwLCB0aGlzLmJsKTtcbiAgICBnbCA9IDAuNSAqIChmbCAtIDEgLyBmbCk7XG4gICAgdGhpcy5nYW1tYTAgPSBNYXRoLmFzaW4oTWF0aC5zaW4odGhpcy5hbHBoYSkgLyBkbCk7XG4gICAgdGhpcy5sb25nMCA9IHRoaXMubG9uZ2MgLSBNYXRoLmFzaW4oZ2wgKiBNYXRoLnRhbih0aGlzLmdhbW1hMCkpIC8gdGhpcy5ibDtcblxuICB9XG4gIGVsc2Uge1xuICAgIC8vMiBwb2ludHMgbWV0aG9kXG4gICAgdmFyIHQxID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDEsIE1hdGguc2luKHRoaXMubGF0MSkpO1xuICAgIHZhciB0MiA9IHRzZm56KHRoaXMuZSwgdGhpcy5sYXQyLCBNYXRoLnNpbih0aGlzLmxhdDIpKTtcbiAgICBpZiAodGhpcy5sYXQwID49IDApIHtcbiAgICAgIHRoaXMuZWwgPSAoZGwgKyBNYXRoLnNxcnQoZGwgKiBkbCAtIDEpKSAqIE1hdGgucG93KHQwLCB0aGlzLmJsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmVsID0gKGRsIC0gTWF0aC5zcXJ0KGRsICogZGwgLSAxKSkgKiBNYXRoLnBvdyh0MCwgdGhpcy5ibCk7XG4gICAgfVxuICAgIHZhciBobCA9IE1hdGgucG93KHQxLCB0aGlzLmJsKTtcbiAgICB2YXIgbGwgPSBNYXRoLnBvdyh0MiwgdGhpcy5ibCk7XG4gICAgZmwgPSB0aGlzLmVsIC8gaGw7XG4gICAgZ2wgPSAwLjUgKiAoZmwgLSAxIC8gZmwpO1xuICAgIHZhciBqbCA9ICh0aGlzLmVsICogdGhpcy5lbCAtIGxsICogaGwpIC8gKHRoaXMuZWwgKiB0aGlzLmVsICsgbGwgKiBobCk7XG4gICAgdmFyIHBsID0gKGxsIC0gaGwpIC8gKGxsICsgaGwpO1xuICAgIHZhciBkbG9uMTIgPSBhZGp1c3RfbG9uKHRoaXMubG9uZzEgLSB0aGlzLmxvbmcyKTtcbiAgICB0aGlzLmxvbmcwID0gMC41ICogKHRoaXMubG9uZzEgKyB0aGlzLmxvbmcyKSAtIE1hdGguYXRhbihqbCAqIE1hdGgudGFuKDAuNSAqIHRoaXMuYmwgKiAoZGxvbjEyKSkgLyBwbCkgLyB0aGlzLmJsO1xuICAgIHRoaXMubG9uZzAgPSBhZGp1c3RfbG9uKHRoaXMubG9uZzApO1xuICAgIHZhciBkbG9uMTAgPSBhZGp1c3RfbG9uKHRoaXMubG9uZzEgLSB0aGlzLmxvbmcwKTtcbiAgICB0aGlzLmdhbW1hMCA9IE1hdGguYXRhbihNYXRoLnNpbih0aGlzLmJsICogKGRsb24xMCkpIC8gZ2wpO1xuICAgIHRoaXMuYWxwaGEgPSBNYXRoLmFzaW4oZGwgKiBNYXRoLnNpbih0aGlzLmdhbW1hMCkpO1xuICB9XG5cbiAgaWYgKHRoaXMubm9fb2ZmKSB7XG4gICAgdGhpcy51YyA9IDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHRoaXMubGF0MCA+PSAwKSB7XG4gICAgICB0aGlzLnVjID0gdGhpcy5hbCAvIHRoaXMuYmwgKiBNYXRoLmF0YW4yKE1hdGguc3FydChkbCAqIGRsIC0gMSksIE1hdGguY29zKHRoaXMuYWxwaGEpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnVjID0gLTEgKiB0aGlzLmFsIC8gdGhpcy5ibCAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGRsICogZGwgLSAxKSwgTWF0aC5jb3ModGhpcy5hbHBoYSkpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cbi8qIE9ibGlxdWUgTWVyY2F0b3IgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIHVzLCB2cztcbiAgdmFyIGNvbjtcbiAgaWYgKE1hdGguYWJzKE1hdGguYWJzKGxhdCkgLSBIQUxGX1BJKSA8PSBFUFNMTikge1xuICAgIGlmIChsYXQgPiAwKSB7XG4gICAgICBjb24gPSAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb24gPSAxO1xuICAgIH1cbiAgICB2cyA9IHRoaXMuYWwgLyB0aGlzLmJsICogTWF0aC5sb2coTWF0aC50YW4oRk9SVFBJICsgY29uICogdGhpcy5nYW1tYTAgKiAwLjUpKTtcbiAgICB1cyA9IC0xICogY29uICogSEFMRl9QSSAqIHRoaXMuYWwgLyB0aGlzLmJsO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciB0ID0gdHNmbnoodGhpcy5lLCBsYXQsIE1hdGguc2luKGxhdCkpO1xuICAgIHZhciBxbCA9IHRoaXMuZWwgLyBNYXRoLnBvdyh0LCB0aGlzLmJsKTtcbiAgICB2YXIgc2wgPSAwLjUgKiAocWwgLSAxIC8gcWwpO1xuICAgIHZhciB0bCA9IDAuNSAqIChxbCArIDEgLyBxbCk7XG4gICAgdmFyIHZsID0gTWF0aC5zaW4odGhpcy5ibCAqIChkbG9uKSk7XG4gICAgdmFyIHVsID0gKHNsICogTWF0aC5zaW4odGhpcy5nYW1tYTApIC0gdmwgKiBNYXRoLmNvcyh0aGlzLmdhbW1hMCkpIC8gdGw7XG4gICAgaWYgKE1hdGguYWJzKE1hdGguYWJzKHVsKSAtIDEpIDw9IEVQU0xOKSB7XG4gICAgICB2cyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2cyA9IDAuNSAqIHRoaXMuYWwgKiBNYXRoLmxvZygoMSAtIHVsKSAvICgxICsgdWwpKSAvIHRoaXMuYmw7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhNYXRoLmNvcyh0aGlzLmJsICogKGRsb24pKSkgPD0gRVBTTE4pIHtcbiAgICAgIHVzID0gdGhpcy5hbCAqIHRoaXMuYmwgKiAoZGxvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdXMgPSB0aGlzLmFsICogTWF0aC5hdGFuMihzbCAqIE1hdGguY29zKHRoaXMuZ2FtbWEwKSArIHZsICogTWF0aC5zaW4odGhpcy5nYW1tYTApLCBNYXRoLmNvcyh0aGlzLmJsICogZGxvbikpIC8gdGhpcy5ibDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5ub19yb3QpIHtcbiAgICBwLnggPSB0aGlzLngwICsgdXM7XG4gICAgcC55ID0gdGhpcy55MCArIHZzO1xuICB9XG4gIGVsc2Uge1xuXG4gICAgdXMgLT0gdGhpcy51YztcbiAgICBwLnggPSB0aGlzLngwICsgdnMgKiBNYXRoLmNvcyh0aGlzLmFscGhhKSArIHVzICogTWF0aC5zaW4odGhpcy5hbHBoYSk7XG4gICAgcC55ID0gdGhpcy55MCArIHVzICogTWF0aC5jb3ModGhpcy5hbHBoYSkgLSB2cyAqIE1hdGguc2luKHRoaXMuYWxwaGEpO1xuICB9XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgdXMsIHZzO1xuICBpZiAodGhpcy5ub19yb3QpIHtcbiAgICB2cyA9IHAueSAtIHRoaXMueTA7XG4gICAgdXMgPSBwLnggLSB0aGlzLngwO1xuICB9XG4gIGVsc2Uge1xuICAgIHZzID0gKHAueCAtIHRoaXMueDApICogTWF0aC5jb3ModGhpcy5hbHBoYSkgLSAocC55IC0gdGhpcy55MCkgKiBNYXRoLnNpbih0aGlzLmFscGhhKTtcbiAgICB1cyA9IChwLnkgLSB0aGlzLnkwKSAqIE1hdGguY29zKHRoaXMuYWxwaGEpICsgKHAueCAtIHRoaXMueDApICogTWF0aC5zaW4odGhpcy5hbHBoYSk7XG4gICAgdXMgKz0gdGhpcy51YztcbiAgfVxuICB2YXIgcXAgPSBNYXRoLmV4cCgtMSAqIHRoaXMuYmwgKiB2cyAvIHRoaXMuYWwpO1xuICB2YXIgc3AgPSAwLjUgKiAocXAgLSAxIC8gcXApO1xuICB2YXIgdHAgPSAwLjUgKiAocXAgKyAxIC8gcXApO1xuICB2YXIgdnAgPSBNYXRoLnNpbih0aGlzLmJsICogdXMgLyB0aGlzLmFsKTtcbiAgdmFyIHVwID0gKHZwICogTWF0aC5jb3ModGhpcy5nYW1tYTApICsgc3AgKiBNYXRoLnNpbih0aGlzLmdhbW1hMCkpIC8gdHA7XG4gIHZhciB0cyA9IE1hdGgucG93KHRoaXMuZWwgLyBNYXRoLnNxcnQoKDEgKyB1cCkgLyAoMSAtIHVwKSksIDEgLyB0aGlzLmJsKTtcbiAgaWYgKE1hdGguYWJzKHVwIC0gMSkgPCBFUFNMTikge1xuICAgIHAueCA9IHRoaXMubG9uZzA7XG4gICAgcC55ID0gSEFMRl9QSTtcbiAgfVxuICBlbHNlIGlmIChNYXRoLmFicyh1cCArIDEpIDwgRVBTTE4pIHtcbiAgICBwLnggPSB0aGlzLmxvbmcwO1xuICAgIHAueSA9IC0xICogSEFMRl9QSTtcbiAgfVxuICBlbHNlIHtcbiAgICBwLnkgPSBwaGkyeih0aGlzLmUsIHRzKTtcbiAgICBwLnggPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgLSBNYXRoLmF0YW4yKHNwICogTWF0aC5jb3ModGhpcy5nYW1tYTApIC0gdnAgKiBNYXRoLnNpbih0aGlzLmdhbW1hMCksIE1hdGguY29zKHRoaXMuYmwgKiB1cyAvIHRoaXMuYWwpKSAvIHRoaXMuYmwpO1xuICB9XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5uYW1lcyA9IFtcIkhvdGluZV9PYmxpcXVlX01lcmNhdG9yXCIsIFwiSG90aW5lIE9ibGlxdWUgTWVyY2F0b3JcIiwgXCJIb3RpbmVfT2JsaXF1ZV9NZXJjYXRvcl9BemltdXRoX05hdHVyYWxfT3JpZ2luXCIsIFwiSG90aW5lX09ibGlxdWVfTWVyY2F0b3JfQXppbXV0aF9DZW50ZXJcIiwgXCJvbWVyY1wiXTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9vbWVyYy5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgZTBmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMGZuJyk7XG52YXIgZTFmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMWZuJyk7XG52YXIgZTJmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMmZuJyk7XG52YXIgZTNmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lM2ZuJyk7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgYWRqdXN0X2xhdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbGF0Jyk7XG52YXIgbWxmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tbGZuJyk7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIGdOID0gcmVxdWlyZSgnLi4vY29tbW9uL2dOJyk7XG52YXIgTUFYX0lURVIgPSAyMDtcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAvKiBQbGFjZSBwYXJhbWV0ZXJzIGluIHN0YXRpYyBzdG9yYWdlIGZvciBjb21tb24gdXNlXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdGhpcy50ZW1wID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmVzID0gMSAtIE1hdGgucG93KHRoaXMudGVtcCwgMik7IC8vIGRldmFpdCBldHJlIGRhbnMgdG1lcmMuanMgbWFpcyBuIHkgZXN0IHBhcyBkb25jIGplIGNvbW1lbnRlIHNpbm9uIHJldG91ciBkZSB2YWxldXJzIG51bGxlc1xuICB0aGlzLmUgPSBNYXRoLnNxcnQodGhpcy5lcyk7XG4gIHRoaXMuZTAgPSBlMGZuKHRoaXMuZXMpO1xuICB0aGlzLmUxID0gZTFmbih0aGlzLmVzKTtcbiAgdGhpcy5lMiA9IGUyZm4odGhpcy5lcyk7XG4gIHRoaXMuZTMgPSBlM2ZuKHRoaXMuZXMpO1xuICB0aGlzLm1sMCA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQwKTsgLy9zaSBxdWUgZGVzIHplcm9zIGxlIGNhbGN1bCBuZSBzZSBmYWl0IHBhc1xufTtcblxuXG4vKiBQb2x5Y29uaWMgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHgsIHksIGVsO1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIGVsID0gZGxvbiAqIE1hdGguc2luKGxhdCk7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmIChNYXRoLmFicyhsYXQpIDw9IEVQU0xOKSB7XG4gICAgICB4ID0gdGhpcy5hICogZGxvbjtcbiAgICAgIHkgPSAtMSAqIHRoaXMuYSAqIHRoaXMubGF0MDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB4ID0gdGhpcy5hICogTWF0aC5zaW4oZWwpIC8gTWF0aC50YW4obGF0KTtcbiAgICAgIHkgPSB0aGlzLmEgKiAoYWRqdXN0X2xhdChsYXQgLSB0aGlzLmxhdDApICsgKDEgLSBNYXRoLmNvcyhlbCkpIC8gTWF0aC50YW4obGF0KSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmIChNYXRoLmFicyhsYXQpIDw9IEVQU0xOKSB7XG4gICAgICB4ID0gdGhpcy5hICogZGxvbjtcbiAgICAgIHkgPSAtMSAqIHRoaXMubWwwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBubCA9IGdOKHRoaXMuYSwgdGhpcy5lLCBNYXRoLnNpbihsYXQpKSAvIE1hdGgudGFuKGxhdCk7XG4gICAgICB4ID0gbmwgKiBNYXRoLnNpbihlbCk7XG4gICAgICB5ID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBsYXQpIC0gdGhpcy5tbDAgKyBubCAqICgxIC0gTWF0aC5jb3MoZWwpKTtcbiAgICB9XG5cbiAgfVxuICBwLnggPSB4ICsgdGhpcy54MDtcbiAgcC55ID0geSArIHRoaXMueTA7XG4gIHJldHVybiBwO1xufTtcblxuXG4vKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAtLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24sIGxhdCwgeCwgeSwgaTtcbiAgdmFyIGFsLCBibDtcbiAgdmFyIHBoaSwgZHBoaTtcbiAgeCA9IHAueCAtIHRoaXMueDA7XG4gIHkgPSBwLnkgLSB0aGlzLnkwO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmIChNYXRoLmFicyh5ICsgdGhpcy5hICogdGhpcy5sYXQwKSA8PSBFUFNMTikge1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih4IC8gdGhpcy5hICsgdGhpcy5sb25nMCk7XG4gICAgICBsYXQgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFsID0gdGhpcy5sYXQwICsgeSAvIHRoaXMuYTtcbiAgICAgIGJsID0geCAqIHggLyB0aGlzLmEgLyB0aGlzLmEgKyBhbCAqIGFsO1xuICAgICAgcGhpID0gYWw7XG4gICAgICB2YXIgdGFucGhpO1xuICAgICAgZm9yIChpID0gTUFYX0lURVI7IGk7IC0taSkge1xuICAgICAgICB0YW5waGkgPSBNYXRoLnRhbihwaGkpO1xuICAgICAgICBkcGhpID0gLTEgKiAoYWwgKiAocGhpICogdGFucGhpICsgMSkgLSBwaGkgLSAwLjUgKiAocGhpICogcGhpICsgYmwpICogdGFucGhpKSAvICgocGhpIC0gYWwpIC8gdGFucGhpIC0gMSk7XG4gICAgICAgIHBoaSArPSBkcGhpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gRVBTTE4pIHtcbiAgICAgICAgICBsYXQgPSBwaGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIChNYXRoLmFzaW4oeCAqIE1hdGgudGFuKHBoaSkgLyB0aGlzLmEpKSAvIE1hdGguc2luKGxhdCkpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoTWF0aC5hYnMoeSArIHRoaXMubWwwKSA8PSBFUFNMTikge1xuICAgICAgbGF0ID0gMDtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHggLyB0aGlzLmEpO1xuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgYWwgPSAodGhpcy5tbDAgKyB5KSAvIHRoaXMuYTtcbiAgICAgIGJsID0geCAqIHggLyB0aGlzLmEgLyB0aGlzLmEgKyBhbCAqIGFsO1xuICAgICAgcGhpID0gYWw7XG4gICAgICB2YXIgY2wsIG1sbiwgbWxucCwgbWE7XG4gICAgICB2YXIgY29uO1xuICAgICAgZm9yIChpID0gTUFYX0lURVI7IGk7IC0taSkge1xuICAgICAgICBjb24gPSB0aGlzLmUgKiBNYXRoLnNpbihwaGkpO1xuICAgICAgICBjbCA9IE1hdGguc3FydCgxIC0gY29uICogY29uKSAqIE1hdGgudGFuKHBoaSk7XG4gICAgICAgIG1sbiA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgcGhpKTtcbiAgICAgICAgbWxucCA9IHRoaXMuZTAgLSAyICogdGhpcy5lMSAqIE1hdGguY29zKDIgKiBwaGkpICsgNCAqIHRoaXMuZTIgKiBNYXRoLmNvcyg0ICogcGhpKSAtIDYgKiB0aGlzLmUzICogTWF0aC5jb3MoNiAqIHBoaSk7XG4gICAgICAgIG1hID0gbWxuIC8gdGhpcy5hO1xuICAgICAgICBkcGhpID0gKGFsICogKGNsICogbWEgKyAxKSAtIG1hIC0gMC41ICogY2wgKiAobWEgKiBtYSArIGJsKSkgLyAodGhpcy5lcyAqIE1hdGguc2luKDIgKiBwaGkpICogKG1hICogbWEgKyBibCAtIDIgKiBhbCAqIG1hKSAvICg0ICogY2wpICsgKGFsIC0gbWEpICogKGNsICogbWxucCAtIDIgLyBNYXRoLnNpbigyICogcGhpKSkgLSBtbG5wKTtcbiAgICAgICAgcGhpIC09IGRwaGk7XG4gICAgICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSBFUFNMTikge1xuICAgICAgICAgIGxhdCA9IHBoaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2xhdD1waGk0eih0aGlzLmUsdGhpcy5lMCx0aGlzLmUxLHRoaXMuZTIsdGhpcy5lMyxhbCxibCwwLDApO1xuICAgICAgY2wgPSBNYXRoLnNxcnQoMSAtIHRoaXMuZXMgKiBNYXRoLnBvdyhNYXRoLnNpbihsYXQpLCAyKSkgKiBNYXRoLnRhbihsYXQpO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hc2luKHggKiBjbCAvIHRoaXMuYSkgLyBNYXRoLnNpbihsYXQpKTtcbiAgICB9XG4gIH1cblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIlBvbHljb25pY1wiLCBcInBvbHlcIl07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvcG9seS5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgYWRqdXN0X2xhdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbGF0Jyk7XG52YXIgcGpfZW5mbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9wal9lbmZuJyk7XG52YXIgTUFYX0lURVIgPSAyMDtcbnZhciBwal9tbGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL3BqX21sZm4nKTtcbnZhciBwal9pbnZfbWxmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9wal9pbnZfbWxmbicpO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIGFzaW56ID0gcmVxdWlyZSgnLi4vY29tbW9uL2FzaW56Jyk7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbiAgaWYgKCF0aGlzLnNwaGVyZSkge1xuICAgIHRoaXMuZW4gPSBwal9lbmZuKHRoaXMuZXMpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMubiA9IDE7XG4gICAgdGhpcy5tID0gMDtcbiAgICB0aGlzLmVzID0gMDtcbiAgICB0aGlzLkNfeSA9IE1hdGguc3FydCgodGhpcy5tICsgMSkgLyB0aGlzLm4pO1xuICAgIHRoaXMuQ194ID0gdGhpcy5DX3kgLyAodGhpcy5tICsgMSk7XG4gIH1cblxufTtcblxuLyogU2ludXNvaWRhbCBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgeCwgeTtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgaWYgKCF0aGlzLm0pIHtcbiAgICAgIGxhdCA9IHRoaXMubiAhPT0gMSA/IE1hdGguYXNpbih0aGlzLm4gKiBNYXRoLnNpbihsYXQpKSA6IGxhdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgayA9IHRoaXMubiAqIE1hdGguc2luKGxhdCk7XG4gICAgICBmb3IgKHZhciBpID0gTUFYX0lURVI7IGk7IC0taSkge1xuICAgICAgICB2YXIgViA9ICh0aGlzLm0gKiBsYXQgKyBNYXRoLnNpbihsYXQpIC0gaykgLyAodGhpcy5tICsgTWF0aC5jb3MobGF0KSk7XG4gICAgICAgIGxhdCAtPSBWO1xuICAgICAgICBpZiAoTWF0aC5hYnMoVikgPCBFUFNMTikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHggPSB0aGlzLmEgKiB0aGlzLkNfeCAqIGxvbiAqICh0aGlzLm0gKyBNYXRoLmNvcyhsYXQpKTtcbiAgICB5ID0gdGhpcy5hICogdGhpcy5DX3kgKiBsYXQ7XG5cbiAgfVxuICBlbHNlIHtcblxuICAgIHZhciBzID0gTWF0aC5zaW4obGF0KTtcbiAgICB2YXIgYyA9IE1hdGguY29zKGxhdCk7XG4gICAgeSA9IHRoaXMuYSAqIHBqX21sZm4obGF0LCBzLCBjLCB0aGlzLmVuKTtcbiAgICB4ID0gdGhpcy5hICogbG9uICogYyAvIE1hdGguc3FydCgxIC0gdGhpcy5lcyAqIHMgKiBzKTtcbiAgfVxuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbGF0LCB0ZW1wLCBsb24sIHM7XG5cbiAgcC54IC09IHRoaXMueDA7XG4gIGxvbiA9IHAueCAvIHRoaXMuYTtcbiAgcC55IC09IHRoaXMueTA7XG4gIGxhdCA9IHAueSAvIHRoaXMuYTtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBsYXQgLz0gdGhpcy5DX3k7XG4gICAgbG9uID0gbG9uIC8gKHRoaXMuQ194ICogKHRoaXMubSArIE1hdGguY29zKGxhdCkpKTtcbiAgICBpZiAodGhpcy5tKSB7XG4gICAgICBsYXQgPSBhc2lueigodGhpcy5tICogbGF0ICsgTWF0aC5zaW4obGF0KSkgLyB0aGlzLm4pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLm4gIT09IDEpIHtcbiAgICAgIGxhdCA9IGFzaW56KE1hdGguc2luKGxhdCkgLyB0aGlzLm4pO1xuICAgIH1cbiAgICBsb24gPSBhZGp1c3RfbG9uKGxvbiArIHRoaXMubG9uZzApO1xuICAgIGxhdCA9IGFkanVzdF9sYXQobGF0KTtcbiAgfVxuICBlbHNlIHtcbiAgICBsYXQgPSBwal9pbnZfbWxmbihwLnkgLyB0aGlzLmEsIHRoaXMuZXMsIHRoaXMuZW4pO1xuICAgIHMgPSBNYXRoLmFicyhsYXQpO1xuICAgIGlmIChzIDwgSEFMRl9QSSkge1xuICAgICAgcyA9IE1hdGguc2luKGxhdCk7XG4gICAgICB0ZW1wID0gdGhpcy5sb25nMCArIHAueCAqIE1hdGguc3FydCgxIC0gdGhpcy5lcyAqIHMgKiBzKSAvICh0aGlzLmEgKiBNYXRoLmNvcyhsYXQpKTtcbiAgICAgIC8vdGVtcCA9IHRoaXMubG9uZzAgKyBwLnggLyAodGhpcy5hICogTWF0aC5jb3MobGF0KSk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRlbXApO1xuICAgIH1cbiAgICBlbHNlIGlmICgocyAtIEVQU0xOKSA8IEhBTEZfUEkpIHtcbiAgICAgIGxvbiA9IHRoaXMubG9uZzA7XG4gICAgfVxuICB9XG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiU2ludXNvaWRhbFwiLCBcInNpbnVcIl07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvc2ludS5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKlxuICByZWZlcmVuY2VzOlxuICAgIEZvcm11bGVzIGV0IGNvbnN0YW50ZXMgcG91ciBsZSBDYWxjdWwgcG91ciBsYVxuICAgIHByb2plY3Rpb24gY3lsaW5kcmlxdWUgY29uZm9ybWUgw6AgYXhlIG9ibGlxdWUgZXQgcG91ciBsYSB0cmFuc2Zvcm1hdGlvbiBlbnRyZVxuICAgIGRlcyBzeXN0w6htZXMgZGUgcsOpZsOpcmVuY2UuXG4gICAgaHR0cDovL3d3dy5zd2lzc3RvcG8uYWRtaW4uY2gvaW50ZXJuZXQvc3dpc3N0b3BvL2ZyL2hvbWUvdG9waWNzL3N1cnZleS9zeXMvcmVmc3lzL3N3aXR6ZXJsYW5kLnBhcnN5c3JlbGF0ZWQxLjMxMjE2LmRvd25sb2FkTGlzdC43NzAwNC5Eb3dubG9hZEZpbGUudG1wL3N3aXNzcHJvamVjdGlvbmZyLnBkZlxuICAqL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwaHkwID0gdGhpcy5sYXQwO1xuICB0aGlzLmxhbWJkYTAgPSB0aGlzLmxvbmcwO1xuICB2YXIgc2luUGh5MCA9IE1hdGguc2luKHBoeTApO1xuICB2YXIgc2VtaU1ham9yQXhpcyA9IHRoaXMuYTtcbiAgdmFyIGludkYgPSB0aGlzLnJmO1xuICB2YXIgZmxhdHRlbmluZyA9IDEgLyBpbnZGO1xuICB2YXIgZTIgPSAyICogZmxhdHRlbmluZyAtIE1hdGgucG93KGZsYXR0ZW5pbmcsIDIpO1xuICB2YXIgZSA9IHRoaXMuZSA9IE1hdGguc3FydChlMik7XG4gIHRoaXMuUiA9IHRoaXMuazAgKiBzZW1pTWFqb3JBeGlzICogTWF0aC5zcXJ0KDEgLSBlMikgLyAoMSAtIGUyICogTWF0aC5wb3coc2luUGh5MCwgMikpO1xuICB0aGlzLmFscGhhID0gTWF0aC5zcXJ0KDEgKyBlMiAvICgxIC0gZTIpICogTWF0aC5wb3coTWF0aC5jb3MocGh5MCksIDQpKTtcbiAgdGhpcy5iMCA9IE1hdGguYXNpbihzaW5QaHkwIC8gdGhpcy5hbHBoYSk7XG4gIHZhciBrMSA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgdGhpcy5iMCAvIDIpKTtcbiAgdmFyIGsyID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBwaHkwIC8gMikpO1xuICB2YXIgazMgPSBNYXRoLmxvZygoMSArIGUgKiBzaW5QaHkwKSAvICgxIC0gZSAqIHNpblBoeTApKTtcbiAgdGhpcy5LID0gazEgLSB0aGlzLmFscGhhICogazIgKyB0aGlzLmFscGhhICogZSAvIDIgKiBrMztcbn07XG5cblxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgU2ExID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgLSBwLnkgLyAyKSk7XG4gIHZhciBTYTIgPSB0aGlzLmUgLyAyICogTWF0aC5sb2coKDEgKyB0aGlzLmUgKiBNYXRoLnNpbihwLnkpKSAvICgxIC0gdGhpcy5lICogTWF0aC5zaW4ocC55KSkpO1xuICB2YXIgUyA9IC10aGlzLmFscGhhICogKFNhMSArIFNhMikgKyB0aGlzLks7XG5cbiAgLy8gc3BoZXJpYyBsYXRpdHVkZVxuICB2YXIgYiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKFMpKSAtIE1hdGguUEkgLyA0KTtcblxuICAvLyBzcGhlcmljIGxvbmdpdHVkZVxuICB2YXIgSSA9IHRoaXMuYWxwaGEgKiAocC54IC0gdGhpcy5sYW1iZGEwKTtcblxuICAvLyBwc29ldWRvIGVxdWF0b3JpYWwgcm90YXRpb25cbiAgdmFyIHJvdEkgPSBNYXRoLmF0YW4oTWF0aC5zaW4oSSkgLyAoTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLnRhbihiKSArIE1hdGguY29zKHRoaXMuYjApICogTWF0aC5jb3MoSSkpKTtcblxuICB2YXIgcm90QiA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmIwKSAqIE1hdGguc2luKGIpIC0gTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLmNvcyhiKSAqIE1hdGguY29zKEkpKTtcblxuICBwLnkgPSB0aGlzLlIgLyAyICogTWF0aC5sb2coKDEgKyBNYXRoLnNpbihyb3RCKSkgLyAoMSAtIE1hdGguc2luKHJvdEIpKSkgKyB0aGlzLnkwO1xuICBwLnggPSB0aGlzLlIgKiByb3RJICsgdGhpcy54MDtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBZID0gcC54IC0gdGhpcy54MDtcbiAgdmFyIFggPSBwLnkgLSB0aGlzLnkwO1xuXG4gIHZhciByb3RJID0gWSAvIHRoaXMuUjtcbiAgdmFyIHJvdEIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChYIC8gdGhpcy5SKSkgLSBNYXRoLlBJIC8gNCk7XG5cbiAgdmFyIGIgPSBNYXRoLmFzaW4oTWF0aC5jb3ModGhpcy5iMCkgKiBNYXRoLnNpbihyb3RCKSArIE1hdGguc2luKHRoaXMuYjApICogTWF0aC5jb3Mocm90QikgKiBNYXRoLmNvcyhyb3RJKSk7XG4gIHZhciBJID0gTWF0aC5hdGFuKE1hdGguc2luKHJvdEkpIC8gKE1hdGguY29zKHRoaXMuYjApICogTWF0aC5jb3Mocm90SSkgLSBNYXRoLnNpbih0aGlzLmIwKSAqIE1hdGgudGFuKHJvdEIpKSk7XG5cbiAgdmFyIGxhbWJkYSA9IHRoaXMubGFtYmRhMCArIEkgLyB0aGlzLmFscGhhO1xuXG4gIHZhciBTID0gMDtcbiAgdmFyIHBoeSA9IGI7XG4gIHZhciBwcmV2UGh5ID0gLTEwMDA7XG4gIHZhciBpdGVyYXRpb24gPSAwO1xuICB3aGlsZSAoTWF0aC5hYnMocGh5IC0gcHJldlBoeSkgPiAwLjAwMDAwMDEpIHtcbiAgICBpZiAoKytpdGVyYXRpb24gPiAyMCkge1xuICAgICAgLy8uLi5yZXBvcnRFcnJvcihcIm9tZXJjRndkSW5maW5pdHlcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vUyA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgcGh5IC8gMikpO1xuICAgIFMgPSAxIC8gdGhpcy5hbHBoYSAqIChNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIGIgLyAyKSkgLSB0aGlzLkspICsgdGhpcy5lICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBNYXRoLmFzaW4odGhpcy5lICogTWF0aC5zaW4ocGh5KSkgLyAyKSk7XG4gICAgcHJldlBoeSA9IHBoeTtcbiAgICBwaHkgPSAyICogTWF0aC5hdGFuKE1hdGguZXhwKFMpKSAtIE1hdGguUEkgLyAyO1xuICB9XG5cbiAgcC54ID0gbGFtYmRhO1xuICBwLnkgPSBwaHk7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5uYW1lcyA9IFtcInNvbWVyY1wiXTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zL3NvbWVyYy5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9zaWduJyk7XG52YXIgbXNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vbXNmbnonKTtcbnZhciB0c2ZueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi90c2ZueicpO1xudmFyIHBoaTJ6ID0gcmVxdWlyZSgnLi4vY29tbW9uL3BoaTJ6Jyk7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG5leHBvcnRzLnNzZm5fID0gZnVuY3Rpb24ocGhpdCwgc2lucGhpLCBlY2Nlbikge1xuICBzaW5waGkgKj0gZWNjZW47XG4gIHJldHVybiAoTWF0aC50YW4oMC41ICogKEhBTEZfUEkgKyBwaGl0KSkgKiBNYXRoLnBvdygoMSAtIHNpbnBoaSkgLyAoMSArIHNpbnBoaSksIDAuNSAqIGVjY2VuKSk7XG59O1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb3NsYXQwID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgdGhpcy5zaW5sYXQwID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgaWYgKHRoaXMuazAgPT09IDEgJiYgIWlzTmFOKHRoaXMubGF0X3RzKSAmJiBNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG4gICAgICB0aGlzLmswID0gMC41ICogKDEgKyBzaWduKHRoaXMubGF0MCkgKiBNYXRoLnNpbih0aGlzLmxhdF90cykpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8PSBFUFNMTikge1xuICAgICAgaWYgKHRoaXMubGF0MCA+IDApIHtcbiAgICAgICAgLy9Ob3J0aCBwb2xlXG4gICAgICAgIC8vdHJhY2UoJ3N0ZXJlOm5vcnRoIHBvbGUnKTtcbiAgICAgICAgdGhpcy5jb24gPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vU291dGggcG9sZVxuICAgICAgICAvL3RyYWNlKCdzdGVyZTpzb3V0aCBwb2xlJyk7XG4gICAgICAgIHRoaXMuY29uID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29ucyA9IE1hdGguc3FydChNYXRoLnBvdygxICsgdGhpcy5lLCAxICsgdGhpcy5lKSAqIE1hdGgucG93KDEgLSB0aGlzLmUsIDEgLSB0aGlzLmUpKTtcbiAgICBpZiAodGhpcy5rMCA9PT0gMSAmJiAhaXNOYU4odGhpcy5sYXRfdHMpICYmIE1hdGguYWJzKHRoaXMuY29zbGF0MCkgPD0gRVBTTE4pIHtcbiAgICAgIHRoaXMuazAgPSAwLjUgKiB0aGlzLmNvbnMgKiBtc2Zueih0aGlzLmUsIE1hdGguc2luKHRoaXMubGF0X3RzKSwgTWF0aC5jb3ModGhpcy5sYXRfdHMpKSAvIHRzZm56KHRoaXMuZSwgdGhpcy5jb24gKiB0aGlzLmxhdF90cywgdGhpcy5jb24gKiBNYXRoLnNpbih0aGlzLmxhdF90cykpO1xuICAgIH1cbiAgICB0aGlzLm1zMSA9IG1zZm56KHRoaXMuZSwgdGhpcy5zaW5sYXQwLCB0aGlzLmNvc2xhdDApO1xuICAgIHRoaXMuWDAgPSAyICogTWF0aC5hdGFuKHRoaXMuc3Nmbl8odGhpcy5sYXQwLCB0aGlzLnNpbmxhdDAsIHRoaXMuZSkpIC0gSEFMRl9QSTtcbiAgICB0aGlzLmNvc1gwID0gTWF0aC5jb3ModGhpcy5YMCk7XG4gICAgdGhpcy5zaW5YMCA9IE1hdGguc2luKHRoaXMuWDApO1xuICB9XG59O1xuXG4vLyBTdGVyZW9ncmFwaGljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuICB2YXIgc2lubGF0ID0gTWF0aC5zaW4obGF0KTtcbiAgdmFyIGNvc2xhdCA9IE1hdGguY29zKGxhdCk7XG4gIHZhciBBLCBYLCBzaW5YLCBjb3NYLCB0cywgcmg7XG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblxuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMobG9uIC0gdGhpcy5sb25nMCkgLSBNYXRoLlBJKSA8PSBFUFNMTiAmJiBNYXRoLmFicyhsYXQgKyB0aGlzLmxhdDApIDw9IEVQU0xOKSB7XG4gICAgLy9jYXNlIG9mIHRoZSBvcmlnaW5lIHBvaW50XG4gICAgLy90cmFjZSgnc3RlcmU6dGhpcyBpcyB0aGUgb3JpZ2luIHBvaW50Jyk7XG4gICAgcC54ID0gTmFOO1xuICAgIHAueSA9IE5hTjtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICAvL3RyYWNlKCdzdGVyZTpzcGhlcmUgY2FzZScpO1xuICAgIEEgPSAyICogdGhpcy5rMCAvICgxICsgdGhpcy5zaW5sYXQwICogc2lubGF0ICsgdGhpcy5jb3NsYXQwICogY29zbGF0ICogTWF0aC5jb3MoZGxvbikpO1xuICAgIHAueCA9IHRoaXMuYSAqIEEgKiBjb3NsYXQgKiBNYXRoLnNpbihkbG9uKSArIHRoaXMueDA7XG4gICAgcC55ID0gdGhpcy5hICogQSAqICh0aGlzLmNvc2xhdDAgKiBzaW5sYXQgLSB0aGlzLnNpbmxhdDAgKiBjb3NsYXQgKiBNYXRoLmNvcyhkbG9uKSkgKyB0aGlzLnkwO1xuICAgIHJldHVybiBwO1xuICB9XG4gIGVsc2Uge1xuICAgIFggPSAyICogTWF0aC5hdGFuKHRoaXMuc3Nmbl8obGF0LCBzaW5sYXQsIHRoaXMuZSkpIC0gSEFMRl9QSTtcbiAgICBjb3NYID0gTWF0aC5jb3MoWCk7XG4gICAgc2luWCA9IE1hdGguc2luKFgpO1xuICAgIGlmIChNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG4gICAgICB0cyA9IHRzZm56KHRoaXMuZSwgbGF0ICogdGhpcy5jb24sIHRoaXMuY29uICogc2lubGF0KTtcbiAgICAgIHJoID0gMiAqIHRoaXMuYSAqIHRoaXMuazAgKiB0cyAvIHRoaXMuY29ucztcbiAgICAgIHAueCA9IHRoaXMueDAgKyByaCAqIE1hdGguc2luKGxvbiAtIHRoaXMubG9uZzApO1xuICAgICAgcC55ID0gdGhpcy55MCAtIHRoaXMuY29uICogcmggKiBNYXRoLmNvcyhsb24gLSB0aGlzLmxvbmcwKTtcbiAgICAgIC8vdHJhY2UocC50b1N0cmluZygpKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLnNpbmxhdDApIDwgRVBTTE4pIHtcbiAgICAgIC8vRXFcbiAgICAgIC8vdHJhY2UoJ3N0ZXJlOmVxdWF0ZXVyJyk7XG4gICAgICBBID0gMiAqIHRoaXMuYSAqIHRoaXMuazAgLyAoMSArIGNvc1ggKiBNYXRoLmNvcyhkbG9uKSk7XG4gICAgICBwLnkgPSBBICogc2luWDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL290aGVyIGNhc2VcbiAgICAgIC8vdHJhY2UoJ3N0ZXJlOm5vcm1hbCBjYXNlJyk7XG4gICAgICBBID0gMiAqIHRoaXMuYSAqIHRoaXMuazAgKiB0aGlzLm1zMSAvICh0aGlzLmNvc1gwICogKDEgKyB0aGlzLnNpblgwICogc2luWCArIHRoaXMuY29zWDAgKiBjb3NYICogTWF0aC5jb3MoZGxvbikpKTtcbiAgICAgIHAueSA9IEEgKiAodGhpcy5jb3NYMCAqIHNpblggLSB0aGlzLnNpblgwICogY29zWCAqIE1hdGguY29zKGRsb24pKSArIHRoaXMueTA7XG4gICAgfVxuICAgIHAueCA9IEEgKiBjb3NYICogTWF0aC5zaW4oZGxvbikgKyB0aGlzLngwO1xuICB9XG4gIC8vdHJhY2UocC50b1N0cmluZygpKTtcbiAgcmV0dXJuIHA7XG59O1xuXG5cbi8vKiBTdGVyZW9ncmFwaGljIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICBwLnggLT0gdGhpcy54MDtcbiAgcC55IC09IHRoaXMueTA7XG4gIHZhciBsb24sIGxhdCwgdHMsIGNlLCBDaGk7XG4gIHZhciByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICB2YXIgYyA9IDIgKiBNYXRoLmF0YW4ocmggLyAoMC41ICogdGhpcy5hICogdGhpcy5rMCkpO1xuICAgIGxvbiA9IHRoaXMubG9uZzA7XG4gICAgbGF0ID0gdGhpcy5sYXQwO1xuICAgIGlmIChyaCA8PSBFUFNMTikge1xuICAgICAgcC54ID0gbG9uO1xuICAgICAgcC55ID0gbGF0O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGxhdCA9IE1hdGguYXNpbihNYXRoLmNvcyhjKSAqIHRoaXMuc2lubGF0MCArIHAueSAqIE1hdGguc2luKGMpICogdGhpcy5jb3NsYXQwIC8gcmgpO1xuICAgIGlmIChNYXRoLmFicyh0aGlzLmNvc2xhdDApIDwgRVBTTE4pIHtcbiAgICAgIGlmICh0aGlzLmxhdDAgPiAwKSB7XG4gICAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54LCAtIDEgKiBwLnkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgcC55KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLnggKiBNYXRoLnNpbihjKSwgcmggKiB0aGlzLmNvc2xhdDAgKiBNYXRoLmNvcyhjKSAtIHAueSAqIHRoaXMuc2lubGF0MCAqIE1hdGguc2luKGMpKSk7XG4gICAgfVxuICAgIHAueCA9IGxvbjtcbiAgICBwLnkgPSBsYXQ7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuY29zbGF0MCkgPD0gRVBTTE4pIHtcbiAgICAgIGlmIChyaCA8PSBFUFNMTikge1xuICAgICAgICBsYXQgPSB0aGlzLmxhdDA7XG4gICAgICAgIGxvbiA9IHRoaXMubG9uZzA7XG4gICAgICAgIHAueCA9IGxvbjtcbiAgICAgICAgcC55ID0gbGF0O1xuICAgICAgICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfVxuICAgICAgcC54ICo9IHRoaXMuY29uO1xuICAgICAgcC55ICo9IHRoaXMuY29uO1xuICAgICAgdHMgPSByaCAqIHRoaXMuY29ucyAvICgyICogdGhpcy5hICogdGhpcy5rMCk7XG4gICAgICBsYXQgPSB0aGlzLmNvbiAqIHBoaTJ6KHRoaXMuZSwgdHMpO1xuICAgICAgbG9uID0gdGhpcy5jb24gKiBhZGp1c3RfbG9uKHRoaXMuY29uICogdGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54LCAtIDEgKiBwLnkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjZSA9IDIgKiBNYXRoLmF0YW4ocmggKiB0aGlzLmNvc1gwIC8gKDIgKiB0aGlzLmEgKiB0aGlzLmswICogdGhpcy5tczEpKTtcbiAgICAgIGxvbiA9IHRoaXMubG9uZzA7XG4gICAgICBpZiAocmggPD0gRVBTTE4pIHtcbiAgICAgICAgQ2hpID0gdGhpcy5YMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBDaGkgPSBNYXRoLmFzaW4oTWF0aC5jb3MoY2UpICogdGhpcy5zaW5YMCArIHAueSAqIE1hdGguc2luKGNlKSAqIHRoaXMuY29zWDAgLyByaCk7XG4gICAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54ICogTWF0aC5zaW4oY2UpLCByaCAqIHRoaXMuY29zWDAgKiBNYXRoLmNvcyhjZSkgLSBwLnkgKiB0aGlzLnNpblgwICogTWF0aC5zaW4oY2UpKSk7XG4gICAgICB9XG4gICAgICBsYXQgPSAtMSAqIHBoaTJ6KHRoaXMuZSwgTWF0aC50YW4oMC41ICogKEhBTEZfUEkgKyBDaGkpKSk7XG4gICAgfVxuICB9XG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuXG4gIC8vdHJhY2UocC50b1N0cmluZygpKTtcbiAgcmV0dXJuIHA7XG5cbn07XG5leHBvcnRzLm5hbWVzID0gW1wic3RlcmVcIl07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvc3RlcmUuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGdhdXNzID0gcmVxdWlyZSgnLi9nYXVzcycpO1xudmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIGdhdXNzLmluaXQuYXBwbHkodGhpcyk7XG4gIGlmICghdGhpcy5yYykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnNpbmMwID0gTWF0aC5zaW4odGhpcy5waGljMCk7XG4gIHRoaXMuY29zYzAgPSBNYXRoLmNvcyh0aGlzLnBoaWMwKTtcbiAgdGhpcy5SMiA9IDIgKiB0aGlzLnJjO1xuICBpZiAoIXRoaXMudGl0bGUpIHtcbiAgICB0aGlzLnRpdGxlID0gXCJPYmxpcXVlIFN0ZXJlb2dyYXBoaWMgQWx0ZXJuYXRpdmVcIjtcbiAgfVxufTtcblxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgc2luYywgY29zYywgY29zbCwgaztcbiAgcC54ID0gYWRqdXN0X2xvbihwLnggLSB0aGlzLmxvbmcwKTtcbiAgZ2F1c3MuZm9yd2FyZC5hcHBseSh0aGlzLCBbcF0pO1xuICBzaW5jID0gTWF0aC5zaW4ocC55KTtcbiAgY29zYyA9IE1hdGguY29zKHAueSk7XG4gIGNvc2wgPSBNYXRoLmNvcyhwLngpO1xuICBrID0gdGhpcy5rMCAqIHRoaXMuUjIgLyAoMSArIHRoaXMuc2luYzAgKiBzaW5jICsgdGhpcy5jb3NjMCAqIGNvc2MgKiBjb3NsKTtcbiAgcC54ID0gayAqIGNvc2MgKiBNYXRoLnNpbihwLngpO1xuICBwLnkgPSBrICogKHRoaXMuY29zYzAgKiBzaW5jIC0gdGhpcy5zaW5jMCAqIGNvc2MgKiBjb3NsKTtcbiAgcC54ID0gdGhpcy5hICogcC54ICsgdGhpcy54MDtcbiAgcC55ID0gdGhpcy5hICogcC55ICsgdGhpcy55MDtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBzaW5jLCBjb3NjLCBsb24sIGxhdCwgcmhvO1xuICBwLnggPSAocC54IC0gdGhpcy54MCkgLyB0aGlzLmE7XG4gIHAueSA9IChwLnkgLSB0aGlzLnkwKSAvIHRoaXMuYTtcblxuICBwLnggLz0gdGhpcy5rMDtcbiAgcC55IC89IHRoaXMuazA7XG4gIGlmICgocmhvID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSkpKSB7XG4gICAgdmFyIGMgPSAyICogTWF0aC5hdGFuMihyaG8sIHRoaXMuUjIpO1xuICAgIHNpbmMgPSBNYXRoLnNpbihjKTtcbiAgICBjb3NjID0gTWF0aC5jb3MoYyk7XG4gICAgbGF0ID0gTWF0aC5hc2luKGNvc2MgKiB0aGlzLnNpbmMwICsgcC55ICogc2luYyAqIHRoaXMuY29zYzAgLyByaG8pO1xuICAgIGxvbiA9IE1hdGguYXRhbjIocC54ICogc2luYywgcmhvICogdGhpcy5jb3NjMCAqIGNvc2MgLSBwLnkgKiB0aGlzLnNpbmMwICogc2luYyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGF0ID0gdGhpcy5waGljMDtcbiAgICBsb24gPSAwO1xuICB9XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIGdhdXNzLmludmVyc2UuYXBwbHkodGhpcywgW3BdKTtcbiAgcC54ID0gYWRqdXN0X2xvbihwLnggKyB0aGlzLmxvbmcwKTtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLm5hbWVzID0gW1wiU3RlcmVvZ3JhcGhpY19Ob3J0aF9Qb2xlXCIsIFwiT2JsaXF1ZV9TdGVyZW9ncmFwaGljXCIsIFwiUG9sYXJfU3RlcmVvZ3JhcGhpY1wiLCBcInN0ZXJlYVwiLFwiT2JsaXF1ZSBTdGVyZW9ncmFwaGljIEFsdGVybmF0aXZlXCJdO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvc3RlcmVhLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9uc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBlMGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UwZm4nKTtcbnZhciBlMWZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UxZm4nKTtcbnZhciBlMmZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UyZm4nKTtcbnZhciBlM2ZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UzZm4nKTtcbnZhciBtbGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL21sZm4nKTtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBzaWduID0gcmVxdWlyZSgnLi4vY29tbW9uL3NpZ24nKTtcbnZhciBhc2lueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hc2lueicpO1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gIHRoaXMuZTEgPSBlMWZuKHRoaXMuZXMpO1xuICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG4gIHRoaXMubWwwID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDApO1xufTtcblxuLyoqXG4gICAgVHJhbnN2ZXJzZSBNZXJjYXRvciBGb3J3YXJkICAtIGxvbmcvbGF0IHRvIHgveVxuICAgIGxvbmcvbGF0IGluIHJhZGlhbnNcbiAgKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICB2YXIgZGVsdGFfbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIGNvbjtcbiAgdmFyIHgsIHk7XG4gIHZhciBzaW5fcGhpID0gTWF0aC5zaW4obGF0KTtcbiAgdmFyIGNvc19waGkgPSBNYXRoLmNvcyhsYXQpO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHZhciBiID0gY29zX3BoaSAqIE1hdGguc2luKGRlbHRhX2xvbik7XG4gICAgaWYgKChNYXRoLmFicyhNYXRoLmFicyhiKSAtIDEpKSA8IDAuMDAwMDAwMDAwMSkge1xuICAgICAgcmV0dXJuICg5Myk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgeCA9IDAuNSAqIHRoaXMuYSAqIHRoaXMuazAgKiBNYXRoLmxvZygoMSArIGIpIC8gKDEgLSBiKSk7XG4gICAgICBjb24gPSBNYXRoLmFjb3MoY29zX3BoaSAqIE1hdGguY29zKGRlbHRhX2xvbikgLyBNYXRoLnNxcnQoMSAtIGIgKiBiKSk7XG4gICAgICBpZiAobGF0IDwgMCkge1xuICAgICAgICBjb24gPSAtY29uO1xuICAgICAgfVxuICAgICAgeSA9IHRoaXMuYSAqIHRoaXMuazAgKiAoY29uIC0gdGhpcy5sYXQwKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGFsID0gY29zX3BoaSAqIGRlbHRhX2xvbjtcbiAgICB2YXIgYWxzID0gTWF0aC5wb3coYWwsIDIpO1xuICAgIHZhciBjID0gdGhpcy5lcDIgKiBNYXRoLnBvdyhjb3NfcGhpLCAyKTtcbiAgICB2YXIgdHEgPSBNYXRoLnRhbihsYXQpO1xuICAgIHZhciB0ID0gTWF0aC5wb3codHEsIDIpO1xuICAgIGNvbiA9IDEgLSB0aGlzLmVzICogTWF0aC5wb3coc2luX3BoaSwgMik7XG4gICAgdmFyIG4gPSB0aGlzLmEgLyBNYXRoLnNxcnQoY29uKTtcbiAgICB2YXIgbWwgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIGxhdCk7XG5cbiAgICB4ID0gdGhpcy5rMCAqIG4gKiBhbCAqICgxICsgYWxzIC8gNiAqICgxIC0gdCArIGMgKyBhbHMgLyAyMCAqICg1IC0gMTggKiB0ICsgTWF0aC5wb3codCwgMikgKyA3MiAqIGMgLSA1OCAqIHRoaXMuZXAyKSkpICsgdGhpcy54MDtcbiAgICB5ID0gdGhpcy5rMCAqIChtbCAtIHRoaXMubWwwICsgbiAqIHRxICogKGFscyAqICgwLjUgKyBhbHMgLyAyNCAqICg1IC0gdCArIDkgKiBjICsgNCAqIE1hdGgucG93KGMsIDIpICsgYWxzIC8gMzAgKiAoNjEgLSA1OCAqIHQgKyBNYXRoLnBvdyh0LCAyKSArIDYwMCAqIGMgLSAzMzAgKiB0aGlzLmVwMikpKSkpICsgdGhpcy55MDtcblxuICB9XG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuLyoqXG4gICAgVHJhbnN2ZXJzZSBNZXJjYXRvciBJbnZlcnNlICAtICB4L3kgdG8gbG9uZy9sYXRcbiAgKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGNvbiwgcGhpO1xuICB2YXIgZGVsdGFfcGhpO1xuICB2YXIgaTtcbiAgdmFyIG1heF9pdGVyID0gNjtcbiAgdmFyIGxhdCwgbG9uO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHZhciBmID0gTWF0aC5leHAocC54IC8gKHRoaXMuYSAqIHRoaXMuazApKTtcbiAgICB2YXIgZyA9IDAuNSAqIChmIC0gMSAvIGYpO1xuICAgIHZhciB0ZW1wID0gdGhpcy5sYXQwICsgcC55IC8gKHRoaXMuYSAqIHRoaXMuazApO1xuICAgIHZhciBoID0gTWF0aC5jb3ModGVtcCk7XG4gICAgY29uID0gTWF0aC5zcXJ0KCgxIC0gaCAqIGgpIC8gKDEgKyBnICogZykpO1xuICAgIGxhdCA9IGFzaW56KGNvbik7XG4gICAgaWYgKHRlbXAgPCAwKSB7XG4gICAgICBsYXQgPSAtbGF0O1xuICAgIH1cbiAgICBpZiAoKGcgPT09IDApICYmIChoID09PSAwKSkge1xuICAgICAgbG9uID0gdGhpcy5sb25nMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKE1hdGguYXRhbjIoZywgaCkgKyB0aGlzLmxvbmcwKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7IC8vIGVsbGlwc29pZGFsIGZvcm1cbiAgICB2YXIgeCA9IHAueCAtIHRoaXMueDA7XG4gICAgdmFyIHkgPSBwLnkgLSB0aGlzLnkwO1xuXG4gICAgY29uID0gKHRoaXMubWwwICsgeSAvIHRoaXMuazApIC8gdGhpcy5hO1xuICAgIHBoaSA9IGNvbjtcbiAgICBmb3IgKGkgPSAwOyB0cnVlOyBpKyspIHtcbiAgICAgIGRlbHRhX3BoaSA9ICgoY29uICsgdGhpcy5lMSAqIE1hdGguc2luKDIgKiBwaGkpIC0gdGhpcy5lMiAqIE1hdGguc2luKDQgKiBwaGkpICsgdGhpcy5lMyAqIE1hdGguc2luKDYgKiBwaGkpKSAvIHRoaXMuZTApIC0gcGhpO1xuICAgICAgcGhpICs9IGRlbHRhX3BoaTtcbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YV9waGkpIDw9IEVQU0xOKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPj0gbWF4X2l0ZXIpIHtcbiAgICAgICAgcmV0dXJuICg5NSk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IoKVxuICAgIGlmIChNYXRoLmFicyhwaGkpIDwgSEFMRl9QSSkge1xuICAgICAgdmFyIHNpbl9waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgICAgdmFyIGNvc19waGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgICAgdmFyIHRhbl9waGkgPSBNYXRoLnRhbihwaGkpO1xuICAgICAgdmFyIGMgPSB0aGlzLmVwMiAqIE1hdGgucG93KGNvc19waGksIDIpO1xuICAgICAgdmFyIGNzID0gTWF0aC5wb3coYywgMik7XG4gICAgICB2YXIgdCA9IE1hdGgucG93KHRhbl9waGksIDIpO1xuICAgICAgdmFyIHRzID0gTWF0aC5wb3codCwgMik7XG4gICAgICBjb24gPSAxIC0gdGhpcy5lcyAqIE1hdGgucG93KHNpbl9waGksIDIpO1xuICAgICAgdmFyIG4gPSB0aGlzLmEgLyBNYXRoLnNxcnQoY29uKTtcbiAgICAgIHZhciByID0gbiAqICgxIC0gdGhpcy5lcykgLyBjb247XG4gICAgICB2YXIgZCA9IHggLyAobiAqIHRoaXMuazApO1xuICAgICAgdmFyIGRzID0gTWF0aC5wb3coZCwgMik7XG4gICAgICBsYXQgPSBwaGkgLSAobiAqIHRhbl9waGkgKiBkcyAvIHIpICogKDAuNSAtIGRzIC8gMjQgKiAoNSArIDMgKiB0ICsgMTAgKiBjIC0gNCAqIGNzIC0gOSAqIHRoaXMuZXAyIC0gZHMgLyAzMCAqICg2MSArIDkwICogdCArIDI5OCAqIGMgKyA0NSAqIHRzIC0gMjUyICogdGhpcy5lcDIgLSAzICogY3MpKSk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAoZCAqICgxIC0gZHMgLyA2ICogKDEgKyAyICogdCArIGMgLSBkcyAvIDIwICogKDUgLSAyICogYyArIDI4ICogdCAtIDMgKiBjcyArIDggKiB0aGlzLmVwMiArIDI0ICogdHMpKSkgLyBjb3NfcGhpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGF0ID0gSEFMRl9QSSAqIHNpZ24oeSk7XG4gICAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIH1cbiAgfVxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIlRyYW5zdmVyc2VfTWVyY2F0b3JcIiwgXCJUcmFuc3ZlcnNlIE1lcmNhdG9yXCIsIFwidG1lcmNcIl07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy90bWVyYy5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgRDJSID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbnZhciB0bWVyYyA9IHJlcXVpcmUoJy4vdG1lcmMnKTtcbmV4cG9ydHMuZGVwZW5kc09uID0gJ3RtZXJjJztcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuem9uZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhdDAgPSAwO1xuICB0aGlzLmxvbmcwID0gKCg2ICogTWF0aC5hYnModGhpcy56b25lKSkgLSAxODMpICogRDJSO1xuICB0aGlzLngwID0gNTAwMDAwO1xuICB0aGlzLnkwID0gdGhpcy51dG1Tb3V0aCA/IDEwMDAwMDAwIDogMDtcbiAgdGhpcy5rMCA9IDAuOTk5NjtcblxuICB0bWVyYy5pbml0LmFwcGx5KHRoaXMpO1xuICB0aGlzLmZvcndhcmQgPSB0bWVyYy5mb3J3YXJkO1xuICB0aGlzLmludmVyc2UgPSB0bWVyYy5pbnZlcnNlO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJVbml2ZXJzYWwgVHJhbnN2ZXJzZSBNZXJjYXRvciBTeXN0ZW1cIiwgXCJ1dG1cIl07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L2xpYi9wcm9qZWN0aW9ucy91dG0uanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIGFzaW56ID0gcmVxdWlyZSgnLi4vY29tbW9uL2FzaW56Jyk7XG4vKiBJbml0aWFsaXplIHRoZSBWYW4gRGVyIEdyaW50ZW4gcHJvamVjdGlvblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAvL3RoaXMuUiA9IDYzNzA5OTc7IC8vUmFkaXVzIG9mIGVhcnRoXG4gIHRoaXMuUiA9IHRoaXMuYTtcbn07XG5cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcblxuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciB4LCB5O1xuXG4gIGlmIChNYXRoLmFicyhsYXQpIDw9IEVQU0xOKSB7XG4gICAgeCA9IHRoaXMueDAgKyB0aGlzLlIgKiBkbG9uO1xuICAgIHkgPSB0aGlzLnkwO1xuICB9XG4gIHZhciB0aGV0YSA9IGFzaW56KDIgKiBNYXRoLmFicyhsYXQgLyBNYXRoLlBJKSk7XG4gIGlmICgoTWF0aC5hYnMoZGxvbikgPD0gRVBTTE4pIHx8IChNYXRoLmFicyhNYXRoLmFicyhsYXQpIC0gSEFMRl9QSSkgPD0gRVBTTE4pKSB7XG4gICAgeCA9IHRoaXMueDA7XG4gICAgaWYgKGxhdCA+PSAwKSB7XG4gICAgICB5ID0gdGhpcy55MCArIE1hdGguUEkgKiB0aGlzLlIgKiBNYXRoLnRhbigwLjUgKiB0aGV0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgeSA9IHRoaXMueTAgKyBNYXRoLlBJICogdGhpcy5SICogLU1hdGgudGFuKDAuNSAqIHRoZXRhKTtcbiAgICB9XG4gICAgLy8gIHJldHVybihPSyk7XG4gIH1cbiAgdmFyIGFsID0gMC41ICogTWF0aC5hYnMoKE1hdGguUEkgLyBkbG9uKSAtIChkbG9uIC8gTWF0aC5QSSkpO1xuICB2YXIgYXNxID0gYWwgKiBhbDtcbiAgdmFyIHNpbnRoID0gTWF0aC5zaW4odGhldGEpO1xuICB2YXIgY29zdGggPSBNYXRoLmNvcyh0aGV0YSk7XG5cbiAgdmFyIGcgPSBjb3N0aCAvIChzaW50aCArIGNvc3RoIC0gMSk7XG4gIHZhciBnc3EgPSBnICogZztcbiAgdmFyIG0gPSBnICogKDIgLyBzaW50aCAtIDEpO1xuICB2YXIgbXNxID0gbSAqIG07XG4gIHZhciBjb24gPSBNYXRoLlBJICogdGhpcy5SICogKGFsICogKGcgLSBtc3EpICsgTWF0aC5zcXJ0KGFzcSAqIChnIC0gbXNxKSAqIChnIC0gbXNxKSAtIChtc3EgKyBhc3EpICogKGdzcSAtIG1zcSkpKSAvIChtc3EgKyBhc3EpO1xuICBpZiAoZGxvbiA8IDApIHtcbiAgICBjb24gPSAtY29uO1xuICB9XG4gIHggPSB0aGlzLngwICsgY29uO1xuICAvL2NvbiA9IE1hdGguYWJzKGNvbiAvIChNYXRoLlBJICogdGhpcy5SKSk7XG4gIHZhciBxID0gYXNxICsgZztcbiAgY29uID0gTWF0aC5QSSAqIHRoaXMuUiAqIChtICogcSAtIGFsICogTWF0aC5zcXJ0KChtc3EgKyBhc3EpICogKGFzcSArIDEpIC0gcSAqIHEpKSAvIChtc3EgKyBhc3EpO1xuICBpZiAobGF0ID49IDApIHtcbiAgICAvL3kgPSB0aGlzLnkwICsgTWF0aC5QSSAqIHRoaXMuUiAqIE1hdGguc3FydCgxIC0gY29uICogY29uIC0gMiAqIGFsICogY29uKTtcbiAgICB5ID0gdGhpcy55MCArIGNvbjtcbiAgfVxuICBlbHNlIHtcbiAgICAvL3kgPSB0aGlzLnkwIC0gTWF0aC5QSSAqIHRoaXMuUiAqIE1hdGguc3FydCgxIC0gY29uICogY29uIC0gMiAqIGFsICogY29uKTtcbiAgICB5ID0gdGhpcy55MCAtIGNvbjtcbiAgfVxuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn07XG5cbi8qIFZhbiBEZXIgR3JpbnRlbiBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiwgbGF0O1xuICB2YXIgeHgsIHl5LCB4eXMsIGMxLCBjMiwgYzM7XG4gIHZhciBhMTtcbiAgdmFyIG0xO1xuICB2YXIgY29uO1xuICB2YXIgdGgxO1xuICB2YXIgZDtcblxuICAvKiBpbnZlcnNlIGVxdWF0aW9uc1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICBjb24gPSBNYXRoLlBJICogdGhpcy5SO1xuICB4eCA9IHAueCAvIGNvbjtcbiAgeXkgPSBwLnkgLyBjb247XG4gIHh5cyA9IHh4ICogeHggKyB5eSAqIHl5O1xuICBjMSA9IC1NYXRoLmFicyh5eSkgKiAoMSArIHh5cyk7XG4gIGMyID0gYzEgLSAyICogeXkgKiB5eSArIHh4ICogeHg7XG4gIGMzID0gLTIgKiBjMSArIDEgKyAyICogeXkgKiB5eSArIHh5cyAqIHh5cztcbiAgZCA9IHl5ICogeXkgLyBjMyArICgyICogYzIgKiBjMiAqIGMyIC8gYzMgLyBjMyAvIGMzIC0gOSAqIGMxICogYzIgLyBjMyAvIGMzKSAvIDI3O1xuICBhMSA9IChjMSAtIGMyICogYzIgLyAzIC8gYzMpIC8gYzM7XG4gIG0xID0gMiAqIE1hdGguc3FydCgtYTEgLyAzKTtcbiAgY29uID0gKCgzICogZCkgLyBhMSkgLyBtMTtcbiAgaWYgKE1hdGguYWJzKGNvbikgPiAxKSB7XG4gICAgaWYgKGNvbiA+PSAwKSB7XG4gICAgICBjb24gPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbiA9IC0xO1xuICAgIH1cbiAgfVxuICB0aDEgPSBNYXRoLmFjb3MoY29uKSAvIDM7XG4gIGlmIChwLnkgPj0gMCkge1xuICAgIGxhdCA9ICgtbTEgKiBNYXRoLmNvcyh0aDEgKyBNYXRoLlBJIC8gMykgLSBjMiAvIDMgLyBjMykgKiBNYXRoLlBJO1xuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IC0oLW0xICogTWF0aC5jb3ModGgxICsgTWF0aC5QSSAvIDMpIC0gYzIgLyAzIC8gYzMpICogTWF0aC5QSTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh4eCkgPCBFUFNMTikge1xuICAgIGxvbiA9IHRoaXMubG9uZzA7XG4gIH1cbiAgZWxzZSB7XG4gICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5QSSAqICh4eXMgLSAxICsgTWF0aC5zcXJ0KDEgKyAyICogKHh4ICogeHggLSB5eSAqIHl5KSArIHh5cyAqIHh5cykpIC8gMiAvIHh4KTtcbiAgfVxuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiVmFuX2Rlcl9HcmludGVuX0lcIiwgXCJWYW5EZXJHcmludGVuXCIsIFwidmFuZGdcIl07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWIvcHJvamVjdGlvbnMvdmFuZGcuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3Byb2plY3Rpb25zXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEQyUiA9IDAuMDE3NDUzMjkyNTE5OTQzMjk1Nzc7XG52YXIgUjJEID0gNTcuMjk1Nzc5NTEzMDgyMzIwODg7XG52YXIgUEpEXzNQQVJBTSA9IDE7XG52YXIgUEpEXzdQQVJBTSA9IDI7XG52YXIgZGF0dW1fdHJhbnNmb3JtID0gcmVxdWlyZSgnLi9kYXR1bV90cmFuc2Zvcm0nKTtcbnZhciBhZGp1c3RfYXhpcyA9IHJlcXVpcmUoJy4vYWRqdXN0X2F4aXMnKTtcbnZhciBwcm9qID0gcmVxdWlyZSgnLi9Qcm9qJyk7XG52YXIgdG9Qb2ludCA9IHJlcXVpcmUoJy4vY29tbW9uL3RvUG9pbnQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtKHNvdXJjZSwgZGVzdCwgcG9pbnQpIHtcbiAgdmFyIHdnczg0O1xuICBpZiAoQXJyYXkuaXNBcnJheShwb2ludCkpIHtcbiAgICBwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrTm90V0dTKHNvdXJjZSwgZGVzdCkge1xuICAgIHJldHVybiAoKHNvdXJjZS5kYXR1bS5kYXR1bV90eXBlID09PSBQSkRfM1BBUkFNIHx8IHNvdXJjZS5kYXR1bS5kYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSAmJiBkZXN0LmRhdHVtQ29kZSAhPT0gXCJXR1M4NFwiKTtcbiAgfVxuXG4gIC8vIFdvcmthcm91bmQgZm9yIGRhdHVtIHNoaWZ0cyB0b3dnczg0LCBpZiBlaXRoZXIgc291cmNlIG9yIGRlc3RpbmF0aW9uIHByb2plY3Rpb24gaXMgbm90IHdnczg0XG4gIGlmIChzb3VyY2UuZGF0dW0gJiYgZGVzdC5kYXR1bSAmJiAoY2hlY2tOb3RXR1Moc291cmNlLCBkZXN0KSB8fCBjaGVja05vdFdHUyhkZXN0LCBzb3VyY2UpKSkge1xuICAgIHdnczg0ID0gbmV3IHByb2ooJ1dHUzg0Jyk7XG4gICAgdHJhbnNmb3JtKHNvdXJjZSwgd2dzODQsIHBvaW50KTtcbiAgICBzb3VyY2UgPSB3Z3M4NDtcbiAgfVxuICAvLyBER1IsIDIwMTAvMTEvMTJcbiAgaWYgKHNvdXJjZS5heGlzICE9PSBcImVudVwiKSB7XG4gICAgYWRqdXN0X2F4aXMoc291cmNlLCBmYWxzZSwgcG9pbnQpO1xuICB9XG4gIC8vIFRyYW5zZm9ybSBzb3VyY2UgcG9pbnRzIHRvIGxvbmcvbGF0LCBpZiB0aGV5IGFyZW4ndCBhbHJlYWR5LlxuICBpZiAoc291cmNlLnByb2pOYW1lID09PSBcImxvbmdsYXRcIikge1xuICAgIHBvaW50LnggKj0gRDJSOyAvLyBjb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICAgIHBvaW50LnkgKj0gRDJSO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChzb3VyY2UudG9fbWV0ZXIpIHtcbiAgICAgIHBvaW50LnggKj0gc291cmNlLnRvX21ldGVyO1xuICAgICAgcG9pbnQueSAqPSBzb3VyY2UudG9fbWV0ZXI7XG4gICAgfVxuICAgIHNvdXJjZS5pbnZlcnNlKHBvaW50KTsgLy8gQ29udmVydCBDYXJ0ZXNpYW4gdG8gbG9uZ2xhdFxuICB9XG4gIC8vIEFkanVzdCBmb3IgdGhlIHByaW1lIG1lcmlkaWFuIGlmIG5lY2Vzc2FyeVxuICBpZiAoc291cmNlLmZyb21fZ3JlZW53aWNoKSB7XG4gICAgcG9pbnQueCArPSBzb3VyY2UuZnJvbV9ncmVlbndpY2g7XG4gIH1cblxuICAvLyBDb252ZXJ0IGRhdHVtcyBpZiBuZWVkZWQsIGFuZCBpZiBwb3NzaWJsZS5cbiAgcG9pbnQgPSBkYXR1bV90cmFuc2Zvcm0oc291cmNlLmRhdHVtLCBkZXN0LmRhdHVtLCBwb2ludCk7XG5cbiAgLy8gQWRqdXN0IGZvciB0aGUgcHJpbWUgbWVyaWRpYW4gaWYgbmVjZXNzYXJ5XG4gIGlmIChkZXN0LmZyb21fZ3JlZW53aWNoKSB7XG4gICAgcG9pbnQueCAtPSBkZXN0LmZyb21fZ3JlZW53aWNoO1xuICB9XG5cbiAgaWYgKGRlc3QucHJvak5hbWUgPT09IFwibG9uZ2xhdFwiKSB7XG4gICAgLy8gY29udmVydCByYWRpYW5zIHRvIGRlY2ltYWwgZGVncmVlc1xuICAgIHBvaW50LnggKj0gUjJEO1xuICAgIHBvaW50LnkgKj0gUjJEO1xuICB9XG4gIGVsc2UgeyAvLyBlbHNlIHByb2plY3RcbiAgICBkZXN0LmZvcndhcmQocG9pbnQpO1xuICAgIGlmIChkZXN0LnRvX21ldGVyKSB7XG4gICAgICBwb2ludC54IC89IGRlc3QudG9fbWV0ZXI7XG4gICAgICBwb2ludC55IC89IGRlc3QudG9fbWV0ZXI7XG4gICAgfVxuICB9XG5cbiAgLy8gREdSLCAyMDEwLzExLzEyXG4gIGlmIChkZXN0LmF4aXMgIT09IFwiZW51XCIpIHtcbiAgICBhZGp1c3RfYXhpcyhkZXN0LCB0cnVlLCBwb2ludCk7XG4gIH1cblxuICByZXR1cm4gcG9pbnQ7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3RyYW5zZm9ybS5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgRDJSID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuXG5mdW5jdGlvbiBtYXBpdChvYmosIGtleSwgdikge1xuICBvYmpba2V5XSA9IHYubWFwKGZ1bmN0aW9uKGFhKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBzRXhwcihhYSwgbyk7XG4gICAgcmV0dXJuIG87XG4gIH0pLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGV4dGVuZChhLCBiKTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBzRXhwcih2LCBvYmopIHtcbiAgdmFyIGtleTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgb2JqW3ZdID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxzZSB7XG4gICAga2V5ID0gdi5zaGlmdCgpO1xuICAgIGlmIChrZXkgPT09ICdQQVJBTUVURVInKSB7XG4gICAgICBrZXkgPSB2LnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmICh2Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodlswXSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgICAgc0V4cHIodlswXSwgb2JqW2tleV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdlswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIXYubGVuZ3RoKSB7XG4gICAgICBvYmpba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtleSA9PT0gJ1RPV0dTODQnKSB7XG4gICAgICBvYmpba2V5XSA9IHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgIGlmIChbJ1VOSVQnLCAnUFJJTUVNJywgJ1ZFUlRfREFUVU0nXS5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICBvYmpba2V5XSA9IHtcbiAgICAgICAgICBuYW1lOiB2WzBdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgY29udmVydDogdlsxXVxuICAgICAgICB9O1xuICAgICAgICBpZiAodi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICBvYmpba2V5XS5hdXRoID0gdlsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnU1BIRVJPSUQnKSB7XG4gICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgIG5hbWU6IHZbMF0sXG4gICAgICAgICAgYTogdlsxXSxcbiAgICAgICAgICByZjogdlsyXVxuICAgICAgICB9O1xuICAgICAgICBpZiAodi5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICBvYmpba2V5XS5hdXRoID0gdlszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoWydHRU9HQ1MnLCAnR0VPQ0NTJywgJ0RBVFVNJywgJ1ZFUlRfQ1MnLCAnQ09NUERfQ1MnLCAnTE9DQUxfQ1MnLCAnRklUVEVEX0NTJywgJ0xPQ0FMX0RBVFVNJ10uaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgdlswXSA9IFsnbmFtZScsIHZbMF1dO1xuICAgICAgICBtYXBpdChvYmosIGtleSwgdik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2LmV2ZXJ5KGZ1bmN0aW9uKGFhKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFhKTtcbiAgICAgIH0pKSB7XG4gICAgICAgIG1hcGl0KG9iaiwga2V5LCB2KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzRXhwcih2LCBvYmpba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmFtZShvYmosIHBhcmFtcykge1xuICB2YXIgb3V0TmFtZSA9IHBhcmFtc1swXTtcbiAgdmFyIGluTmFtZSA9IHBhcmFtc1sxXTtcbiAgaWYgKCEob3V0TmFtZSBpbiBvYmopICYmIChpbk5hbWUgaW4gb2JqKSkge1xuICAgIG9ialtvdXROYW1lXSA9IG9ialtpbk5hbWVdO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBvYmpbb3V0TmFtZV0gPSBwYXJhbXNbMl0ob2JqW291dE5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZDJyKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCAqIEQyUjtcbn1cblxuZnVuY3Rpb24gY2xlYW5XS1Qod2t0KSB7XG4gIGlmICh3a3QudHlwZSA9PT0gJ0dFT0dDUycpIHtcbiAgICB3a3QucHJvak5hbWUgPSAnbG9uZ2xhdCc7XG4gIH1cbiAgZWxzZSBpZiAod2t0LnR5cGUgPT09ICdMT0NBTF9DUycpIHtcbiAgICB3a3QucHJvak5hbWUgPSAnaWRlbnRpdHknO1xuICAgIHdrdC5sb2NhbCA9IHRydWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHR5cGVvZiB3a3QuUFJPSkVDVElPTiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgd2t0LnByb2pOYW1lID0gT2JqZWN0LmtleXMod2t0LlBST0pFQ1RJT04pWzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdrdC5wcm9qTmFtZSA9IHdrdC5QUk9KRUNUSU9OO1xuICAgIH1cbiAgfVxuICBpZiAod2t0LlVOSVQpIHtcbiAgICB3a3QudW5pdHMgPSB3a3QuVU5JVC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHdrdC51bml0cyA9PT0gJ21ldHJlJykge1xuICAgICAgd2t0LnVuaXRzID0gJ21ldGVyJztcbiAgICB9XG4gICAgaWYgKHdrdC5VTklULmNvbnZlcnQpIHtcbiAgICAgIHdrdC50b19tZXRlciA9IHBhcnNlRmxvYXQod2t0LlVOSVQuY29udmVydCwgMTApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3a3QuR0VPR0NTKSB7XG4gICAgLy9pZih3a3QuR0VPR0NTLlBSSU1FTSYmd2t0LkdFT0dDUy5QUklNRU0uY29udmVydCl7XG4gICAgLy8gIHdrdC5mcm9tX2dyZWVud2ljaD13a3QuR0VPR0NTLlBSSU1FTS5jb252ZXJ0KkQyUjtcbiAgICAvL31cbiAgICBpZiAod2t0LkdFT0dDUy5EQVRVTSkge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IHdrdC5HRU9HQ1MuREFUVU0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuR0VPR0NTLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUuc2xpY2UoMCwgMikgPT09ICdkXycpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuZGF0dW1Db2RlLnNsaWNlKDIpO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZSA9PT0gJ25ld196ZWFsYW5kX2dlb2RldGljX2RhdHVtXzE5NDknIHx8IHdrdC5kYXR1bUNvZGUgPT09ICduZXdfemVhbGFuZF8xOTQ5Jykge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9ICduemdkNDknO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZSA9PT0gXCJ3Z3NfMTk4NFwiKSB7XG4gICAgICBpZiAod2t0LlBST0pFQ1RJT04gPT09ICdNZXJjYXRvcl9BdXhpbGlhcnlfU3BoZXJlJykge1xuICAgICAgICB3a3Quc3BoZXJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdrdC5kYXR1bUNvZGUgPSAnd2dzODQnO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZS5zbGljZSgtNikgPT09ICdfZmVycm8nKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LmRhdHVtQ29kZS5zbGljZSgwLCAtIDYpO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZS5zbGljZSgtOCkgPT09ICdfamFrYXJ0YScpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuZGF0dW1Db2RlLnNsaWNlKDAsIC0gOCk7XG4gICAgfVxuICAgIGlmICh+d2t0LmRhdHVtQ29kZS5pbmRleE9mKCdiZWxnZScpKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gXCJybmI3MlwiO1xuICAgIH1cbiAgICBpZiAod2t0LkdFT0dDUy5EQVRVTSAmJiB3a3QuR0VPR0NTLkRBVFVNLlNQSEVST0lEKSB7XG4gICAgICB3a3QuZWxscHMgPSB3a3QuR0VPR0NTLkRBVFVNLlNQSEVST0lELm5hbWUucmVwbGFjZSgnXzE5JywgJycpLnJlcGxhY2UoL1tDY11sYXJrZVxcXzE4LywgJ2NscmsnKTtcbiAgICAgIGlmICh3a3QuZWxscHMudG9Mb3dlckNhc2UoKS5zbGljZSgwLCAxMykgPT09IFwiaW50ZXJuYXRpb25hbFwiKSB7XG4gICAgICAgIHdrdC5lbGxwcyA9ICdpbnRsJztcbiAgICAgIH1cblxuICAgICAgd2t0LmEgPSB3a3QuR0VPR0NTLkRBVFVNLlNQSEVST0lELmE7XG4gICAgICB3a3QucmYgPSBwYXJzZUZsb2F0KHdrdC5HRU9HQ1MuREFUVU0uU1BIRVJPSUQucmYsIDEwKTtcbiAgICB9XG4gICAgaWYgKH53a3QuZGF0dW1Db2RlLmluZGV4T2YoJ29zZ2JfMTkzNicpKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gXCJvc2diMzZcIjtcbiAgICB9XG4gIH1cbiAgaWYgKHdrdC5iICYmICFpc0Zpbml0ZSh3a3QuYikpIHtcbiAgICB3a3QuYiA9IHdrdC5hO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9NZXRlcihpbnB1dCkge1xuICAgIHZhciByYXRpbyA9IHdrdC50b19tZXRlciB8fCAxO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiByYXRpbztcbiAgfVxuICB2YXIgcmVuYW1lciA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gcmVuYW1lKHdrdCwgYSk7XG4gIH07XG4gIHZhciBsaXN0ID0gW1xuICAgIFsnc3RhbmRhcmRfcGFyYWxsZWxfMScsICdTdGFuZGFyZF9QYXJhbGxlbF8xJ10sXG4gICAgWydzdGFuZGFyZF9wYXJhbGxlbF8yJywgJ1N0YW5kYXJkX1BhcmFsbGVsXzInXSxcbiAgICBbJ2ZhbHNlX2Vhc3RpbmcnLCAnRmFsc2VfRWFzdGluZyddLFxuICAgIFsnZmFsc2Vfbm9ydGhpbmcnLCAnRmFsc2VfTm9ydGhpbmcnXSxcbiAgICBbJ2NlbnRyYWxfbWVyaWRpYW4nLCAnQ2VudHJhbF9NZXJpZGlhbiddLFxuICAgIFsnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgJ0xhdGl0dWRlX09mX09yaWdpbiddLFxuICAgIFsnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgJ0NlbnRyYWxfUGFyYWxsZWwnXSxcbiAgICBbJ3NjYWxlX2ZhY3RvcicsICdTY2FsZV9GYWN0b3InXSxcbiAgICBbJ2swJywgJ3NjYWxlX2ZhY3RvciddLFxuICAgIFsnbGF0aXR1ZGVfb2ZfY2VudGVyJywgJ0xhdGl0dWRlX29mX2NlbnRlciddLFxuICAgIFsnbGF0MCcsICdsYXRpdHVkZV9vZl9jZW50ZXInLCBkMnJdLFxuICAgIFsnbG9uZ2l0dWRlX29mX2NlbnRlcicsICdMb25naXR1ZGVfT2ZfQ2VudGVyJ10sXG4gICAgWydsb25nYycsICdsb25naXR1ZGVfb2ZfY2VudGVyJywgZDJyXSxcbiAgICBbJ3gwJywgJ2ZhbHNlX2Vhc3RpbmcnLCB0b01ldGVyXSxcbiAgICBbJ3kwJywgJ2ZhbHNlX25vcnRoaW5nJywgdG9NZXRlcl0sXG4gICAgWydsb25nMCcsICdjZW50cmFsX21lcmlkaWFuJywgZDJyXSxcbiAgICBbJ2xhdDAnLCAnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgZDJyXSxcbiAgICBbJ2xhdDAnLCAnc3RhbmRhcmRfcGFyYWxsZWxfMScsIGQycl0sXG4gICAgWydsYXQxJywgJ3N0YW5kYXJkX3BhcmFsbGVsXzEnLCBkMnJdLFxuICAgIFsnbGF0MicsICdzdGFuZGFyZF9wYXJhbGxlbF8yJywgZDJyXSxcbiAgICBbJ2FscGhhJywgJ2F6aW11dGgnLCBkMnJdLFxuICAgIFsnc3JzQ29kZScsICduYW1lJ11cbiAgXTtcbiAgbGlzdC5mb3JFYWNoKHJlbmFtZXIpO1xuICBpZiAoIXdrdC5sb25nMCAmJiB3a3QubG9uZ2MgJiYgKHdrdC5QUk9KRUNUSU9OID09PSAnQWxiZXJzX0NvbmljX0VxdWFsX0FyZWEnIHx8IHdrdC5QUk9KRUNUSU9OID09PSBcIkxhbWJlcnRfQXppbXV0aGFsX0VxdWFsX0FyZWFcIikpIHtcbiAgICB3a3QubG9uZzAgPSB3a3QubG9uZ2M7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od2t0LCBzZWxmKSB7XG4gIHZhciBsaXNwID0gSlNPTi5wYXJzZSgoXCIsXCIgKyB3a3QpLnJlcGxhY2UoL1xccypcXCxcXHMqKFtBLVpfMC05XSs/KShcXFspL2csICcsW1wiJDFcIiwnKS5zbGljZSgxKS5yZXBsYWNlKC9cXHMqXFwsXFxzKihbQS1aXzAtOV0rPylcXF0vZywgJyxcIiQxXCJdJykucmVwbGFjZSgvLFxcW1wiVkVSVENTXCIuKy8sJycpKTtcbiAgdmFyIHR5cGUgPSBsaXNwLnNoaWZ0KCk7XG4gIHZhciBuYW1lID0gbGlzcC5zaGlmdCgpO1xuICBsaXNwLnVuc2hpZnQoWyduYW1lJywgbmFtZV0pO1xuICBsaXNwLnVuc2hpZnQoWyd0eXBlJywgdHlwZV0pO1xuICBsaXNwLnVuc2hpZnQoJ291dHB1dCcpO1xuICB2YXIgb2JqID0ge307XG4gIHNFeHByKGxpc3AsIG9iaik7XG4gIGNsZWFuV0tUKG9iai5vdXRwdXQpO1xuICByZXR1cm4gZXh0ZW5kKHNlbGYsIG9iai5vdXRwdXQpO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcHJvajQvbGliL3drdC5qc1wiLFwiL25vZGVfbW9kdWxlcy9wcm9qNC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cblxuXG4vKipcbiAqIFVUTSB6b25lcyBhcmUgZ3JvdXBlZCwgYW5kIGFzc2lnbmVkIHRvIG9uZSBvZiBhIGdyb3VwIG9mIDZcbiAqIHNldHMuXG4gKlxuICoge2ludH0gQHByaXZhdGVcbiAqL1xudmFyIE5VTV8xMDBLX1NFVFMgPSA2O1xuXG4vKipcbiAqIFRoZSBjb2x1bW4gbGV0dGVycyAoZm9yIGVhc3RpbmcpIG9mIHRoZSBsb3dlciBsZWZ0IHZhbHVlLCBwZXJcbiAqIHNldC5cbiAqXG4gKiB7c3RyaW5nfSBAcHJpdmF0ZVxuICovXG52YXIgU0VUX09SSUdJTl9DT0xVTU5fTEVUVEVSUyA9ICdBSlNBSlMnO1xuXG4vKipcbiAqIFRoZSByb3cgbGV0dGVycyAoZm9yIG5vcnRoaW5nKSBvZiB0aGUgbG93ZXIgbGVmdCB2YWx1ZSwgcGVyXG4gKiBzZXQuXG4gKlxuICoge3N0cmluZ30gQHByaXZhdGVcbiAqL1xudmFyIFNFVF9PUklHSU5fUk9XX0xFVFRFUlMgPSAnQUZBRkFGJztcblxudmFyIEEgPSA2NTsgLy8gQVxudmFyIEkgPSA3MzsgLy8gSVxudmFyIE8gPSA3OTsgLy8gT1xudmFyIFYgPSA4NjsgLy8gVlxudmFyIFogPSA5MDsgLy8gWlxuXG4vKipcbiAqIENvbnZlcnNpb24gb2YgbGF0L2xvbiB0byBNR1JTLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBsbCBPYmplY3QgbGl0ZXJhbCB3aXRoIGxhdCBhbmQgbG9uIHByb3BlcnRpZXMgb24gYVxuICogICAgIFdHUzg0IGVsbGlwc29pZC5cbiAqIEBwYXJhbSB7aW50fSBhY2N1cmFjeSBBY2N1cmFjeSBpbiBkaWdpdHMgKDUgZm9yIDEgbSwgNCBmb3IgMTAgbSwgMyBmb3JcbiAqICAgICAgMTAwIG0sIDQgZm9yIDEwMDAgbSBvciA1IGZvciAxMDAwMCBtKS4gT3B0aW9uYWwsIGRlZmF1bHQgaXMgNS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIE1HUlMgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gbG9jYXRpb24gYW5kIGFjY3VyYWN5LlxuICovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihsbCwgYWNjdXJhY3kpIHtcbiAgYWNjdXJhY3kgPSBhY2N1cmFjeSB8fCA1OyAvLyBkZWZhdWx0IGFjY3VyYWN5IDFtXG4gIHJldHVybiBlbmNvZGUoTEx0b1VUTSh7XG4gICAgbGF0OiBsbFsxXSxcbiAgICBsb246IGxsWzBdXG4gIH0pLCBhY2N1cmFjeSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnNpb24gb2YgTUdSUyB0byBsYXQvbG9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZ3JzIE1HUlMgc3RyaW5nLlxuICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IHdpdGggbGVmdCAobG9uZ2l0dWRlKSwgYm90dG9tIChsYXRpdHVkZSksIHJpZ2h0XG4gKiAgICAgKGxvbmdpdHVkZSkgYW5kIHRvcCAobGF0aXR1ZGUpIHZhbHVlcyBpbiBXR1M4NCwgcmVwcmVzZW50aW5nIHRoZVxuICogICAgIGJvdW5kaW5nIGJveCBmb3IgdGhlIHByb3ZpZGVkIE1HUlMgcmVmZXJlbmNlLlxuICovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihtZ3JzKSB7XG4gIHZhciBiYm94ID0gVVRNdG9MTChkZWNvZGUobWdycy50b1VwcGVyQ2FzZSgpKSk7XG4gIHJldHVybiBbYmJveC5sZWZ0LCBiYm94LmJvdHRvbSwgYmJveC5yaWdodCwgYmJveC50b3BdO1xufTtcblxuZXhwb3J0cy50b1BvaW50ID0gZnVuY3Rpb24obWdyc1N0cikge1xuICB2YXIgbGxiYm94ID0gZXhwb3J0cy5pbnZlcnNlKG1ncnNTdHIpO1xuICByZXR1cm4gWyhsbGJib3hbMl0gKyBsbGJib3hbMF0pIC8gMiwgKGxsYmJveFszXSArIGxsYmJveFsxXSkgLyAyXTtcbn07XG4vKipcbiAqIENvbnZlcnNpb24gZnJvbSBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWcgdGhlIGFuZ2xlIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICovXG5mdW5jdGlvbiBkZWdUb1JhZChkZWcpIHtcbiAgcmV0dXJuIChkZWcgKiAoTWF0aC5QSSAvIDE4MC4wKSk7XG59XG5cbi8qKlxuICogQ29udmVyc2lvbiBmcm9tIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFucy5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGFuZ2xlIGluIGRlZ3JlZXMuXG4gKi9cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZCkge1xuICByZXR1cm4gKDE4MC4wICogKHJhZCAvIE1hdGguUEkpKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNldCBvZiBMb25naXR1ZGUgYW5kIExhdGl0dWRlIGNvLW9yZGluYXRlcyB0byBVVE1cbiAqIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBsbCBPYmplY3QgbGl0ZXJhbCB3aXRoIGxhdCBhbmQgbG9uIHByb3BlcnRpZXNcbiAqICAgICByZXByZXNlbnRpbmcgdGhlIFdHUzg0IGNvb3JkaW5hdGUgdG8gYmUgY29udmVydGVkLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIHRoZSBVVE0gdmFsdWUgd2l0aCBlYXN0aW5nLFxuICogICAgIG5vcnRoaW5nLCB6b25lTnVtYmVyIGFuZCB6b25lTGV0dGVyIHByb3BlcnRpZXMsIGFuZCBhbiBvcHRpb25hbFxuICogICAgIGFjY3VyYWN5IHByb3BlcnR5IGluIGRpZ2l0cy4gUmV0dXJucyBudWxsIGlmIHRoZSBjb252ZXJzaW9uIGZhaWxlZC5cbiAqL1xuZnVuY3Rpb24gTEx0b1VUTShsbCkge1xuICB2YXIgTGF0ID0gbGwubGF0O1xuICB2YXIgTG9uZyA9IGxsLmxvbjtcbiAgdmFyIGEgPSA2Mzc4MTM3LjA7IC8vZWxsaXAucmFkaXVzO1xuICB2YXIgZWNjU3F1YXJlZCA9IDAuMDA2Njk0Mzg7IC8vZWxsaXAuZWNjc3E7XG4gIHZhciBrMCA9IDAuOTk5NjtcbiAgdmFyIExvbmdPcmlnaW47XG4gIHZhciBlY2NQcmltZVNxdWFyZWQ7XG4gIHZhciBOLCBULCBDLCBBLCBNO1xuICB2YXIgTGF0UmFkID0gZGVnVG9SYWQoTGF0KTtcbiAgdmFyIExvbmdSYWQgPSBkZWdUb1JhZChMb25nKTtcbiAgdmFyIExvbmdPcmlnaW5SYWQ7XG4gIHZhciBab25lTnVtYmVyO1xuICAvLyAoaW50KVxuICBab25lTnVtYmVyID0gTWF0aC5mbG9vcigoTG9uZyArIDE4MCkgLyA2KSArIDE7XG5cbiAgLy9NYWtlIHN1cmUgdGhlIGxvbmdpdHVkZSAxODAuMDAgaXMgaW4gWm9uZSA2MFxuICBpZiAoTG9uZyA9PT0gMTgwKSB7XG4gICAgWm9uZU51bWJlciA9IDYwO1xuICB9XG5cbiAgLy8gU3BlY2lhbCB6b25lIGZvciBOb3J3YXlcbiAgaWYgKExhdCA+PSA1Ni4wICYmIExhdCA8IDY0LjAgJiYgTG9uZyA+PSAzLjAgJiYgTG9uZyA8IDEyLjApIHtcbiAgICBab25lTnVtYmVyID0gMzI7XG4gIH1cblxuICAvLyBTcGVjaWFsIHpvbmVzIGZvciBTdmFsYmFyZFxuICBpZiAoTGF0ID49IDcyLjAgJiYgTGF0IDwgODQuMCkge1xuICAgIGlmIChMb25nID49IDAuMCAmJiBMb25nIDwgOS4wKSB7XG4gICAgICBab25lTnVtYmVyID0gMzE7XG4gICAgfVxuICAgIGVsc2UgaWYgKExvbmcgPj0gOS4wICYmIExvbmcgPCAyMS4wKSB7XG4gICAgICBab25lTnVtYmVyID0gMzM7XG4gICAgfVxuICAgIGVsc2UgaWYgKExvbmcgPj0gMjEuMCAmJiBMb25nIDwgMzMuMCkge1xuICAgICAgWm9uZU51bWJlciA9IDM1O1xuICAgIH1cbiAgICBlbHNlIGlmIChMb25nID49IDMzLjAgJiYgTG9uZyA8IDQyLjApIHtcbiAgICAgIFpvbmVOdW1iZXIgPSAzNztcbiAgICB9XG4gIH1cblxuICBMb25nT3JpZ2luID0gKFpvbmVOdW1iZXIgLSAxKSAqIDYgLSAxODAgKyAzOyAvLyszIHB1dHMgb3JpZ2luXG4gIC8vIGluIG1pZGRsZSBvZlxuICAvLyB6b25lXG4gIExvbmdPcmlnaW5SYWQgPSBkZWdUb1JhZChMb25nT3JpZ2luKTtcblxuICBlY2NQcmltZVNxdWFyZWQgPSAoZWNjU3F1YXJlZCkgLyAoMSAtIGVjY1NxdWFyZWQpO1xuXG4gIE4gPSBhIC8gTWF0aC5zcXJ0KDEgLSBlY2NTcXVhcmVkICogTWF0aC5zaW4oTGF0UmFkKSAqIE1hdGguc2luKExhdFJhZCkpO1xuICBUID0gTWF0aC50YW4oTGF0UmFkKSAqIE1hdGgudGFuKExhdFJhZCk7XG4gIEMgPSBlY2NQcmltZVNxdWFyZWQgKiBNYXRoLmNvcyhMYXRSYWQpICogTWF0aC5jb3MoTGF0UmFkKTtcbiAgQSA9IE1hdGguY29zKExhdFJhZCkgKiAoTG9uZ1JhZCAtIExvbmdPcmlnaW5SYWQpO1xuXG4gIE0gPSBhICogKCgxIC0gZWNjU3F1YXJlZCAvIDQgLSAzICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyA2NCAtIDUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAyNTYpICogTGF0UmFkIC0gKDMgKiBlY2NTcXVhcmVkIC8gOCArIDMgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAvIDMyICsgNDUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAxMDI0KSAqIE1hdGguc2luKDIgKiBMYXRSYWQpICsgKDE1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAyNTYgKyA0NSAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAvIDEwMjQpICogTWF0aC5zaW4oNCAqIExhdFJhZCkgLSAoMzUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAzMDcyKSAqIE1hdGguc2luKDYgKiBMYXRSYWQpKTtcblxuICB2YXIgVVRNRWFzdGluZyA9IChrMCAqIE4gKiAoQSArICgxIC0gVCArIEMpICogQSAqIEEgKiBBIC8gNi4wICsgKDUgLSAxOCAqIFQgKyBUICogVCArIDcyICogQyAtIDU4ICogZWNjUHJpbWVTcXVhcmVkKSAqIEEgKiBBICogQSAqIEEgKiBBIC8gMTIwLjApICsgNTAwMDAwLjApO1xuXG4gIHZhciBVVE1Ob3J0aGluZyA9IChrMCAqIChNICsgTiAqIE1hdGgudGFuKExhdFJhZCkgKiAoQSAqIEEgLyAyICsgKDUgLSBUICsgOSAqIEMgKyA0ICogQyAqIEMpICogQSAqIEEgKiBBICogQSAvIDI0LjAgKyAoNjEgLSA1OCAqIFQgKyBUICogVCArIDYwMCAqIEMgLSAzMzAgKiBlY2NQcmltZVNxdWFyZWQpICogQSAqIEEgKiBBICogQSAqIEEgKiBBIC8gNzIwLjApKSk7XG4gIGlmIChMYXQgPCAwLjApIHtcbiAgICBVVE1Ob3J0aGluZyArPSAxMDAwMDAwMC4wOyAvLzEwMDAwMDAwIG1ldGVyIG9mZnNldCBmb3JcbiAgICAvLyBzb3V0aGVybiBoZW1pc3BoZXJlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5vcnRoaW5nOiBNYXRoLnJvdW5kKFVUTU5vcnRoaW5nKSxcbiAgICBlYXN0aW5nOiBNYXRoLnJvdW5kKFVUTUVhc3RpbmcpLFxuICAgIHpvbmVOdW1iZXI6IFpvbmVOdW1iZXIsXG4gICAgem9uZUxldHRlcjogZ2V0TGV0dGVyRGVzaWduYXRvcihMYXQpXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgVVRNIGNvb3JkcyB0byBsYXQvbG9uZywgdXNpbmcgdGhlIFdHUzg0IGVsbGlwc29pZC4gVGhpcyBpcyBhIGNvbnZlbmllbmNlXG4gKiBjbGFzcyB3aGVyZSB0aGUgWm9uZSBjYW4gYmUgc3BlY2lmaWVkIGFzIGEgc2luZ2xlIHN0cmluZyBlZy5cIjYwTlwiIHdoaWNoXG4gKiBpcyB0aGVuIGJyb2tlbiBkb3duIGludG8gdGhlIFpvbmVOdW1iZXIgYW5kIFpvbmVMZXR0ZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB1dG0gQW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBub3J0aGluZywgZWFzdGluZywgem9uZU51bWJlclxuICogICAgIGFuZCB6b25lTGV0dGVyIHByb3BlcnRpZXMuIElmIGFuIG9wdGlvbmFsIGFjY3VyYWN5IHByb3BlcnR5IGlzXG4gKiAgICAgcHJvdmlkZWQgKGluIG1ldGVycyksIGEgYm91bmRpbmcgYm94IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZlxuICogICAgIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgZWl0aGVyIGxhdCBhbmQgbG9uIHZhbHVlc1xuICogICAgIChpZiBubyBhY2N1cmFjeSB3YXMgcHJvdmlkZWQpLCBvciB0b3AsIHJpZ2h0LCBib3R0b20gYW5kIGxlZnQgdmFsdWVzXG4gKiAgICAgZm9yIHRoZSBib3VuZGluZyBib3ggY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIGFjY3VyYWN5LlxuICogICAgIFJldHVybnMgbnVsbCBpZiB0aGUgY29udmVyc2lvbiBmYWlsZWQuXG4gKi9cbmZ1bmN0aW9uIFVUTXRvTEwodXRtKSB7XG5cbiAgdmFyIFVUTU5vcnRoaW5nID0gdXRtLm5vcnRoaW5nO1xuICB2YXIgVVRNRWFzdGluZyA9IHV0bS5lYXN0aW5nO1xuICB2YXIgem9uZUxldHRlciA9IHV0bS56b25lTGV0dGVyO1xuICB2YXIgem9uZU51bWJlciA9IHV0bS56b25lTnVtYmVyO1xuICAvLyBjaGVjayB0aGUgWm9uZU51bW1iZXIgaXMgdmFsaWRcbiAgaWYgKHpvbmVOdW1iZXIgPCAwIHx8IHpvbmVOdW1iZXIgPiA2MCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGswID0gMC45OTk2O1xuICB2YXIgYSA9IDYzNzgxMzcuMDsgLy9lbGxpcC5yYWRpdXM7XG4gIHZhciBlY2NTcXVhcmVkID0gMC4wMDY2OTQzODsgLy9lbGxpcC5lY2NzcTtcbiAgdmFyIGVjY1ByaW1lU3F1YXJlZDtcbiAgdmFyIGUxID0gKDEgLSBNYXRoLnNxcnQoMSAtIGVjY1NxdWFyZWQpKSAvICgxICsgTWF0aC5zcXJ0KDEgLSBlY2NTcXVhcmVkKSk7XG4gIHZhciBOMSwgVDEsIEMxLCBSMSwgRCwgTTtcbiAgdmFyIExvbmdPcmlnaW47XG4gIHZhciBtdSwgcGhpMVJhZDtcblxuICAvLyByZW1vdmUgNTAwLDAwMCBtZXRlciBvZmZzZXQgZm9yIGxvbmdpdHVkZVxuICB2YXIgeCA9IFVUTUVhc3RpbmcgLSA1MDAwMDAuMDtcbiAgdmFyIHkgPSBVVE1Ob3J0aGluZztcblxuICAvLyBXZSBtdXN0IGtub3cgc29tZWhvdyBpZiB3ZSBhcmUgaW4gdGhlIE5vcnRoZXJuIG9yIFNvdXRoZXJuXG4gIC8vIGhlbWlzcGhlcmUsIHRoaXMgaXMgdGhlIG9ubHkgdGltZSB3ZSB1c2UgdGhlIGxldHRlciBTbyBldmVuXG4gIC8vIGlmIHRoZSBab25lIGxldHRlciBpc24ndCBleGFjdGx5IGNvcnJlY3QgaXQgc2hvdWxkIGluZGljYXRlXG4gIC8vIHRoZSBoZW1pc3BoZXJlIGNvcnJlY3RseVxuICBpZiAoem9uZUxldHRlciA8ICdOJykge1xuICAgIHkgLT0gMTAwMDAwMDAuMDsgLy8gcmVtb3ZlIDEwLDAwMCwwMDAgbWV0ZXIgb2Zmc2V0IHVzZWRcbiAgICAvLyBmb3Igc291dGhlcm4gaGVtaXNwaGVyZVxuICB9XG5cbiAgLy8gVGhlcmUgYXJlIDYwIHpvbmVzIHdpdGggem9uZSAxIGJlaW5nIGF0IFdlc3QgLTE4MCB0byAtMTc0XG4gIExvbmdPcmlnaW4gPSAoem9uZU51bWJlciAtIDEpICogNiAtIDE4MCArIDM7IC8vICszIHB1dHMgb3JpZ2luXG4gIC8vIGluIG1pZGRsZSBvZlxuICAvLyB6b25lXG5cbiAgZWNjUHJpbWVTcXVhcmVkID0gKGVjY1NxdWFyZWQpIC8gKDEgLSBlY2NTcXVhcmVkKTtcblxuICBNID0geSAvIGswO1xuICBtdSA9IE0gLyAoYSAqICgxIC0gZWNjU3F1YXJlZCAvIDQgLSAzICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyA2NCAtIDUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAyNTYpKTtcblxuICBwaGkxUmFkID0gbXUgKyAoMyAqIGUxIC8gMiAtIDI3ICogZTEgKiBlMSAqIGUxIC8gMzIpICogTWF0aC5zaW4oMiAqIG11KSArICgyMSAqIGUxICogZTEgLyAxNiAtIDU1ICogZTEgKiBlMSAqIGUxICogZTEgLyAzMikgKiBNYXRoLnNpbig0ICogbXUpICsgKDE1MSAqIGUxICogZTEgKiBlMSAvIDk2KSAqIE1hdGguc2luKDYgKiBtdSk7XG4gIC8vIGRvdWJsZSBwaGkxID0gUHJvak1hdGgucmFkVG9EZWcocGhpMVJhZCk7XG5cbiAgTjEgPSBhIC8gTWF0aC5zcXJ0KDEgLSBlY2NTcXVhcmVkICogTWF0aC5zaW4ocGhpMVJhZCkgKiBNYXRoLnNpbihwaGkxUmFkKSk7XG4gIFQxID0gTWF0aC50YW4ocGhpMVJhZCkgKiBNYXRoLnRhbihwaGkxUmFkKTtcbiAgQzEgPSBlY2NQcmltZVNxdWFyZWQgKiBNYXRoLmNvcyhwaGkxUmFkKSAqIE1hdGguY29zKHBoaTFSYWQpO1xuICBSMSA9IGEgKiAoMSAtIGVjY1NxdWFyZWQpIC8gTWF0aC5wb3coMSAtIGVjY1NxdWFyZWQgKiBNYXRoLnNpbihwaGkxUmFkKSAqIE1hdGguc2luKHBoaTFSYWQpLCAxLjUpO1xuICBEID0geCAvIChOMSAqIGswKTtcblxuICB2YXIgbGF0ID0gcGhpMVJhZCAtIChOMSAqIE1hdGgudGFuKHBoaTFSYWQpIC8gUjEpICogKEQgKiBEIC8gMiAtICg1ICsgMyAqIFQxICsgMTAgKiBDMSAtIDQgKiBDMSAqIEMxIC0gOSAqIGVjY1ByaW1lU3F1YXJlZCkgKiBEICogRCAqIEQgKiBEIC8gMjQgKyAoNjEgKyA5MCAqIFQxICsgMjk4ICogQzEgKyA0NSAqIFQxICogVDEgLSAyNTIgKiBlY2NQcmltZVNxdWFyZWQgLSAzICogQzEgKiBDMSkgKiBEICogRCAqIEQgKiBEICogRCAqIEQgLyA3MjApO1xuICBsYXQgPSByYWRUb0RlZyhsYXQpO1xuXG4gIHZhciBsb24gPSAoRCAtICgxICsgMiAqIFQxICsgQzEpICogRCAqIEQgKiBEIC8gNiArICg1IC0gMiAqIEMxICsgMjggKiBUMSAtIDMgKiBDMSAqIEMxICsgOCAqIGVjY1ByaW1lU3F1YXJlZCArIDI0ICogVDEgKiBUMSkgKiBEICogRCAqIEQgKiBEICogRCAvIDEyMCkgLyBNYXRoLmNvcyhwaGkxUmFkKTtcbiAgbG9uID0gTG9uZ09yaWdpbiArIHJhZFRvRGVnKGxvbik7XG5cbiAgdmFyIHJlc3VsdDtcbiAgaWYgKHV0bS5hY2N1cmFjeSkge1xuICAgIHZhciB0b3BSaWdodCA9IFVUTXRvTEwoe1xuICAgICAgbm9ydGhpbmc6IHV0bS5ub3J0aGluZyArIHV0bS5hY2N1cmFjeSxcbiAgICAgIGVhc3Rpbmc6IHV0bS5lYXN0aW5nICsgdXRtLmFjY3VyYWN5LFxuICAgICAgem9uZUxldHRlcjogdXRtLnpvbmVMZXR0ZXIsXG4gICAgICB6b25lTnVtYmVyOiB1dG0uem9uZU51bWJlclxuICAgIH0pO1xuICAgIHJlc3VsdCA9IHtcbiAgICAgIHRvcDogdG9wUmlnaHQubGF0LFxuICAgICAgcmlnaHQ6IHRvcFJpZ2h0LmxvbixcbiAgICAgIGJvdHRvbTogbGF0LFxuICAgICAgbGVmdDogbG9uXG4gICAgfTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXN1bHQgPSB7XG4gICAgICBsYXQ6IGxhdCxcbiAgICAgIGxvbjogbG9uXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIE1HUlMgbGV0dGVyIGRlc2lnbmF0b3IgZm9yIHRoZSBnaXZlbiBsYXRpdHVkZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgaW4gV0dTODQgdG8gZ2V0IHRoZSBsZXR0ZXIgZGVzaWduYXRvclxuICogICAgIGZvci5cbiAqIEByZXR1cm4ge2NoYXJ9IFRoZSBsZXR0ZXIgZGVzaWduYXRvci5cbiAqL1xuZnVuY3Rpb24gZ2V0TGV0dGVyRGVzaWduYXRvcihsYXQpIHtcbiAgLy9UaGlzIGlzIGhlcmUgYXMgYW4gZXJyb3IgZmxhZyB0byBzaG93IHRoYXQgdGhlIExhdGl0dWRlIGlzXG4gIC8vb3V0c2lkZSBNR1JTIGxpbWl0c1xuICB2YXIgTGV0dGVyRGVzaWduYXRvciA9ICdaJztcblxuICBpZiAoKDg0ID49IGxhdCkgJiYgKGxhdCA+PSA3MikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1gnO1xuICB9XG4gIGVsc2UgaWYgKCg3MiA+IGxhdCkgJiYgKGxhdCA+PSA2NCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1cnO1xuICB9XG4gIGVsc2UgaWYgKCg2NCA+IGxhdCkgJiYgKGxhdCA+PSA1NikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1YnO1xuICB9XG4gIGVsc2UgaWYgKCg1NiA+IGxhdCkgJiYgKGxhdCA+PSA0OCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1UnO1xuICB9XG4gIGVsc2UgaWYgKCg0OCA+IGxhdCkgJiYgKGxhdCA+PSA0MCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1QnO1xuICB9XG4gIGVsc2UgaWYgKCg0MCA+IGxhdCkgJiYgKGxhdCA+PSAzMikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1MnO1xuICB9XG4gIGVsc2UgaWYgKCgzMiA+IGxhdCkgJiYgKGxhdCA+PSAyNCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1InO1xuICB9XG4gIGVsc2UgaWYgKCgyNCA+IGxhdCkgJiYgKGxhdCA+PSAxNikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1EnO1xuICB9XG4gIGVsc2UgaWYgKCgxNiA+IGxhdCkgJiYgKGxhdCA+PSA4KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnUCc7XG4gIH1cbiAgZWxzZSBpZiAoKDggPiBsYXQpICYmIChsYXQgPj0gMCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ04nO1xuICB9XG4gIGVsc2UgaWYgKCgwID4gbGF0KSAmJiAobGF0ID49IC04KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnTSc7XG4gIH1cbiAgZWxzZSBpZiAoKC04ID4gbGF0KSAmJiAobGF0ID49IC0xNikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0wnO1xuICB9XG4gIGVsc2UgaWYgKCgtMTYgPiBsYXQpICYmIChsYXQgPj0gLTI0KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnSyc7XG4gIH1cbiAgZWxzZSBpZiAoKC0yNCA+IGxhdCkgJiYgKGxhdCA+PSAtMzIpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdKJztcbiAgfVxuICBlbHNlIGlmICgoLTMyID4gbGF0KSAmJiAobGF0ID49IC00MCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0gnO1xuICB9XG4gIGVsc2UgaWYgKCgtNDAgPiBsYXQpICYmIChsYXQgPj0gLTQ4KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnRyc7XG4gIH1cbiAgZWxzZSBpZiAoKC00OCA+IGxhdCkgJiYgKGxhdCA+PSAtNTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdGJztcbiAgfVxuICBlbHNlIGlmICgoLTU2ID4gbGF0KSAmJiAobGF0ID49IC02NCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0UnO1xuICB9XG4gIGVsc2UgaWYgKCgtNjQgPiBsYXQpICYmIChsYXQgPj0gLTcyKSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnRCc7XG4gIH1cbiAgZWxzZSBpZiAoKC03MiA+IGxhdCkgJiYgKGxhdCA+PSAtODApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdDJztcbiAgfVxuICByZXR1cm4gTGV0dGVyRGVzaWduYXRvcjtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgVVRNIGxvY2F0aW9uIGFzIE1HUlMgc3RyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gdXRtIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggZWFzdGluZywgbm9ydGhpbmcsXG4gKiAgICAgem9uZUxldHRlciwgem9uZU51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGFjY3VyYWN5IEFjY3VyYWN5IGluIGRpZ2l0cyAoMS01KS5cbiAqIEByZXR1cm4ge3N0cmluZ30gTUdSUyBzdHJpbmcgZm9yIHRoZSBnaXZlbiBVVE0gbG9jYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSh1dG0sIGFjY3VyYWN5KSB7XG4gIHZhciBzZWFzdGluZyA9IFwiXCIgKyB1dG0uZWFzdGluZyxcbiAgICBzbm9ydGhpbmcgPSBcIlwiICsgdXRtLm5vcnRoaW5nO1xuXG4gIHJldHVybiB1dG0uem9uZU51bWJlciArIHV0bS56b25lTGV0dGVyICsgZ2V0MTAwa0lEKHV0bS5lYXN0aW5nLCB1dG0ubm9ydGhpbmcsIHV0bS56b25lTnVtYmVyKSArIHNlYXN0aW5nLnN1YnN0cihzZWFzdGluZy5sZW5ndGggLSA1LCBhY2N1cmFjeSkgKyBzbm9ydGhpbmcuc3Vic3RyKHNub3J0aGluZy5sZW5ndGggLSA1LCBhY2N1cmFjeSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0d28gbGV0dGVyIDEwMGsgZGVzaWduYXRvciBmb3IgYSBnaXZlbiBVVE0gZWFzdGluZyxcbiAqIG5vcnRoaW5nIGFuZCB6b25lIG51bWJlciB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGVhc3RpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3J0aGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IHpvbmVOdW1iZXJcbiAqIEByZXR1cm4gdGhlIHR3byBsZXR0ZXIgMTAwayBkZXNpZ25hdG9yIGZvciB0aGUgZ2l2ZW4gVVRNIGxvY2F0aW9uLlxuICovXG5mdW5jdGlvbiBnZXQxMDBrSUQoZWFzdGluZywgbm9ydGhpbmcsIHpvbmVOdW1iZXIpIHtcbiAgdmFyIHNldFBhcm0gPSBnZXQxMDBrU2V0Rm9yWm9uZSh6b25lTnVtYmVyKTtcbiAgdmFyIHNldENvbHVtbiA9IE1hdGguZmxvb3IoZWFzdGluZyAvIDEwMDAwMCk7XG4gIHZhciBzZXRSb3cgPSBNYXRoLmZsb29yKG5vcnRoaW5nIC8gMTAwMDAwKSAlIDIwO1xuICByZXR1cm4gZ2V0TGV0dGVyMTAwa0lEKHNldENvbHVtbiwgc2V0Um93LCBzZXRQYXJtKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFVUTSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgTUdSUyAxMDBLIHNldCBpdCBpcyBpbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGkgQW4gVVRNIHpvbmUgbnVtYmVyLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgMTAwayBzZXQgdGhlIFVUTSB6b25lIGlzIGluLlxuICovXG5mdW5jdGlvbiBnZXQxMDBrU2V0Rm9yWm9uZShpKSB7XG4gIHZhciBzZXRQYXJtID0gaSAlIE5VTV8xMDBLX1NFVFM7XG4gIGlmIChzZXRQYXJtID09PSAwKSB7XG4gICAgc2V0UGFybSA9IE5VTV8xMDBLX1NFVFM7XG4gIH1cblxuICByZXR1cm4gc2V0UGFybTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHR3by1sZXR0ZXIgTUdSUyAxMDBrIGRlc2lnbmF0b3IgZ2l2ZW4gaW5mb3JtYXRpb25cbiAqIHRyYW5zbGF0ZWQgZnJvbSB0aGUgVVRNIG5vcnRoaW5nLCBlYXN0aW5nIGFuZCB6b25lIG51bWJlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiB0aGUgY29sdW1uIGluZGV4IGFzIGl0IHJlbGF0ZXMgdG8gdGhlIE1HUlNcbiAqICAgICAgICAxMDBrIHNldCBzcHJlYWRzaGVldCwgY3JlYXRlZCBmcm9tIHRoZSBVVE0gZWFzdGluZy5cbiAqICAgICAgICBWYWx1ZXMgYXJlIDEtOC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3cgdGhlIHJvdyBpbmRleCBhcyBpdCByZWxhdGVzIHRvIHRoZSBNR1JTIDEwMGsgc2V0XG4gKiAgICAgICAgc3ByZWFkc2hlZXQsIGNyZWF0ZWQgZnJvbSB0aGUgVVRNIG5vcnRoaW5nIHZhbHVlLiBWYWx1ZXNcbiAqICAgICAgICBhcmUgZnJvbSAwLTE5LlxuICogQHBhcmFtIHtudW1iZXJ9IHBhcm0gdGhlIHNldCBibG9jaywgYXMgaXQgcmVsYXRlcyB0byB0aGUgTUdSUyAxMDBrIHNldFxuICogICAgICAgIHNwcmVhZHNoZWV0LCBjcmVhdGVkIGZyb20gdGhlIFVUTSB6b25lLiBWYWx1ZXMgYXJlIGZyb21cbiAqICAgICAgICAxLTYwLlxuICogQHJldHVybiB0d28gbGV0dGVyIE1HUlMgMTAwayBjb2RlLlxuICovXG5mdW5jdGlvbiBnZXRMZXR0ZXIxMDBrSUQoY29sdW1uLCByb3csIHBhcm0pIHtcbiAgLy8gY29sT3JpZ2luIGFuZCByb3dPcmlnaW4gYXJlIHRoZSBsZXR0ZXJzIGF0IHRoZSBvcmlnaW4gb2YgdGhlIHNldFxuICB2YXIgaW5kZXggPSBwYXJtIC0gMTtcbiAgdmFyIGNvbE9yaWdpbiA9IFNFVF9PUklHSU5fQ09MVU1OX0xFVFRFUlMuY2hhckNvZGVBdChpbmRleCk7XG4gIHZhciByb3dPcmlnaW4gPSBTRVRfT1JJR0lOX1JPV19MRVRURVJTLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIC8vIGNvbEludCBhbmQgcm93SW50IGFyZSB0aGUgbGV0dGVycyB0byBidWlsZCB0byByZXR1cm5cbiAgdmFyIGNvbEludCA9IGNvbE9yaWdpbiArIGNvbHVtbiAtIDE7XG4gIHZhciByb3dJbnQgPSByb3dPcmlnaW4gKyByb3c7XG4gIHZhciByb2xsb3ZlciA9IGZhbHNlO1xuXG4gIGlmIChjb2xJbnQgPiBaKSB7XG4gICAgY29sSW50ID0gY29sSW50IC0gWiArIEEgLSAxO1xuICAgIHJvbGxvdmVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjb2xJbnQgPT09IEkgfHwgKGNvbE9yaWdpbiA8IEkgJiYgY29sSW50ID4gSSkgfHwgKChjb2xJbnQgPiBJIHx8IGNvbE9yaWdpbiA8IEkpICYmIHJvbGxvdmVyKSkge1xuICAgIGNvbEludCsrO1xuICB9XG5cbiAgaWYgKGNvbEludCA9PT0gTyB8fCAoY29sT3JpZ2luIDwgTyAmJiBjb2xJbnQgPiBPKSB8fCAoKGNvbEludCA+IE8gfHwgY29sT3JpZ2luIDwgTykgJiYgcm9sbG92ZXIpKSB7XG4gICAgY29sSW50Kys7XG5cbiAgICBpZiAoY29sSW50ID09PSBJKSB7XG4gICAgICBjb2xJbnQrKztcbiAgICB9XG4gIH1cblxuICBpZiAoY29sSW50ID4gWikge1xuICAgIGNvbEludCA9IGNvbEludCAtIFogKyBBIC0gMTtcbiAgfVxuXG4gIGlmIChyb3dJbnQgPiBWKSB7XG4gICAgcm93SW50ID0gcm93SW50IC0gViArIEEgLSAxO1xuICAgIHJvbGxvdmVyID0gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICByb2xsb3ZlciA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCgocm93SW50ID09PSBJKSB8fCAoKHJvd09yaWdpbiA8IEkpICYmIChyb3dJbnQgPiBJKSkpIHx8ICgoKHJvd0ludCA+IEkpIHx8IChyb3dPcmlnaW4gPCBJKSkgJiYgcm9sbG92ZXIpKSB7XG4gICAgcm93SW50Kys7XG4gIH1cblxuICBpZiAoKChyb3dJbnQgPT09IE8pIHx8ICgocm93T3JpZ2luIDwgTykgJiYgKHJvd0ludCA+IE8pKSkgfHwgKCgocm93SW50ID4gTykgfHwgKHJvd09yaWdpbiA8IE8pKSAmJiByb2xsb3ZlcikpIHtcbiAgICByb3dJbnQrKztcblxuICAgIGlmIChyb3dJbnQgPT09IEkpIHtcbiAgICAgIHJvd0ludCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyb3dJbnQgPiBWKSB7XG4gICAgcm93SW50ID0gcm93SW50IC0gViArIEEgLSAxO1xuICB9XG5cbiAgdmFyIHR3b0xldHRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29sSW50KSArIFN0cmluZy5mcm9tQ2hhckNvZGUocm93SW50KTtcbiAgcmV0dXJuIHR3b0xldHRlcjtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIFVUTSBwYXJhbWV0ZXJzIGZyb20gYSBNR1JTIHN0cmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ncnNTdHJpbmcgYW4gVVBQRVJDQVNFIGNvb3JkaW5hdGUgc3RyaW5nIGlzIGV4cGVjdGVkLlxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGVhc3RpbmcsIG5vcnRoaW5nLCB6b25lTGV0dGVyLFxuICogICAgIHpvbmVOdW1iZXIgYW5kIGFjY3VyYWN5IChpbiBtZXRlcnMpIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShtZ3JzU3RyaW5nKSB7XG5cbiAgaWYgKG1ncnNTdHJpbmcgJiYgbWdyc1N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyAoXCJNR1JTUG9pbnQgY292ZXJ0aW5nIGZyb20gbm90aGluZ1wiKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBtZ3JzU3RyaW5nLmxlbmd0aDtcblxuICB2YXIgaHVuSyA9IG51bGw7XG4gIHZhciBzYiA9IFwiXCI7XG4gIHZhciB0ZXN0Q2hhcjtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGdldCBab25lIG51bWJlclxuICB3aGlsZSAoISgvW0EtWl0vKS50ZXN0KHRlc3RDaGFyID0gbWdyc1N0cmluZy5jaGFyQXQoaSkpKSB7XG4gICAgaWYgKGkgPj0gMikge1xuICAgICAgdGhyb3cgKFwiTUdSU1BvaW50IGJhZCBjb252ZXJzaW9uIGZyb206IFwiICsgbWdyc1N0cmluZyk7XG4gICAgfVxuICAgIHNiICs9IHRlc3RDaGFyO1xuICAgIGkrKztcbiAgfVxuXG4gIHZhciB6b25lTnVtYmVyID0gcGFyc2VJbnQoc2IsIDEwKTtcblxuICBpZiAoaSA9PT0gMCB8fCBpICsgMyA+IGxlbmd0aCkge1xuICAgIC8vIEEgZ29vZCBNR1JTIHN0cmluZyBoYXMgdG8gYmUgNC01IGRpZ2l0cyBsb25nLFxuICAgIC8vICMjQUFBLyNBQUEgYXQgbGVhc3QuXG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGJhZCBjb252ZXJzaW9uIGZyb206IFwiICsgbWdyc1N0cmluZyk7XG4gIH1cblxuICB2YXIgem9uZUxldHRlciA9IG1ncnNTdHJpbmcuY2hhckF0KGkrKyk7XG5cbiAgLy8gU2hvdWxkIHdlIGNoZWNrIHRoZSB6b25lIGxldHRlciBoZXJlPyBXaHkgbm90LlxuICBpZiAoem9uZUxldHRlciA8PSAnQScgfHwgem9uZUxldHRlciA9PT0gJ0InIHx8IHpvbmVMZXR0ZXIgPT09ICdZJyB8fCB6b25lTGV0dGVyID49ICdaJyB8fCB6b25lTGV0dGVyID09PSAnSScgfHwgem9uZUxldHRlciA9PT0gJ08nKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IHpvbmUgbGV0dGVyIFwiICsgem9uZUxldHRlciArIFwiIG5vdCBoYW5kbGVkOiBcIiArIG1ncnNTdHJpbmcpO1xuICB9XG5cbiAgaHVuSyA9IG1ncnNTdHJpbmcuc3Vic3RyaW5nKGksIGkgKz0gMik7XG5cbiAgdmFyIHNldCA9IGdldDEwMGtTZXRGb3Jab25lKHpvbmVOdW1iZXIpO1xuXG4gIHZhciBlYXN0MTAwayA9IGdldEVhc3RpbmdGcm9tQ2hhcihodW5LLmNoYXJBdCgwKSwgc2V0KTtcbiAgdmFyIG5vcnRoMTAwayA9IGdldE5vcnRoaW5nRnJvbUNoYXIoaHVuSy5jaGFyQXQoMSksIHNldCk7XG5cbiAgLy8gV2UgaGF2ZSBhIGJ1ZyB3aGVyZSB0aGUgbm9ydGhpbmcgbWF5IGJlIDIwMDAwMDAgdG9vIGxvdy5cbiAgLy8gSG93XG4gIC8vIGRvIHdlIGtub3cgd2hlbiB0byByb2xsIG92ZXI/XG5cbiAgd2hpbGUgKG5vcnRoMTAwayA8IGdldE1pbk5vcnRoaW5nKHpvbmVMZXR0ZXIpKSB7XG4gICAgbm9ydGgxMDBrICs9IDIwMDAwMDA7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIGNoYXIgaW5kZXggZm9yIGVhc3Rpbmcvbm9ydGhpbmcgc2VwYXJhdG9yXG4gIHZhciByZW1haW5kZXIgPSBsZW5ndGggLSBpO1xuXG4gIGlmIChyZW1haW5kZXIgJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGhhcyB0byBoYXZlIGFuIGV2ZW4gbnVtYmVyIFxcbm9mIGRpZ2l0cyBhZnRlciB0aGUgem9uZSBsZXR0ZXIgYW5kIHR3byAxMDBrbSBsZXR0ZXJzIC0gZnJvbnQgXFxuaGFsZiBmb3IgZWFzdGluZyBtZXRlcnMsIHNlY29uZCBoYWxmIGZvciBcXG5ub3J0aGluZyBtZXRlcnNcIiArIG1ncnNTdHJpbmcpO1xuICB9XG5cbiAgdmFyIHNlcCA9IHJlbWFpbmRlciAvIDI7XG5cbiAgdmFyIHNlcEVhc3RpbmcgPSAwLjA7XG4gIHZhciBzZXBOb3J0aGluZyA9IDAuMDtcbiAgdmFyIGFjY3VyYWN5Qm9udXMsIHNlcEVhc3RpbmdTdHJpbmcsIHNlcE5vcnRoaW5nU3RyaW5nLCBlYXN0aW5nLCBub3J0aGluZztcbiAgaWYgKHNlcCA+IDApIHtcbiAgICBhY2N1cmFjeUJvbnVzID0gMTAwMDAwLjAgLyBNYXRoLnBvdygxMCwgc2VwKTtcbiAgICBzZXBFYXN0aW5nU3RyaW5nID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSwgaSArIHNlcCk7XG4gICAgc2VwRWFzdGluZyA9IHBhcnNlRmxvYXQoc2VwRWFzdGluZ1N0cmluZykgKiBhY2N1cmFjeUJvbnVzO1xuICAgIHNlcE5vcnRoaW5nU3RyaW5nID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSArIHNlcCk7XG4gICAgc2VwTm9ydGhpbmcgPSBwYXJzZUZsb2F0KHNlcE5vcnRoaW5nU3RyaW5nKSAqIGFjY3VyYWN5Qm9udXM7XG4gIH1cblxuICBlYXN0aW5nID0gc2VwRWFzdGluZyArIGVhc3QxMDBrO1xuICBub3J0aGluZyA9IHNlcE5vcnRoaW5nICsgbm9ydGgxMDBrO1xuXG4gIHJldHVybiB7XG4gICAgZWFzdGluZzogZWFzdGluZyxcbiAgICBub3J0aGluZzogbm9ydGhpbmcsXG4gICAgem9uZUxldHRlcjogem9uZUxldHRlcixcbiAgICB6b25lTnVtYmVyOiB6b25lTnVtYmVyLFxuICAgIGFjY3VyYWN5OiBhY2N1cmFjeUJvbnVzXG4gIH07XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIGZpcnN0IGxldHRlciBmcm9tIGEgdHdvLWxldHRlciBNR1JTIDEwMGsgem9uZSwgYW5kIGdpdmVuIHRoZVxuICogTUdSUyB0YWJsZSBzZXQgZm9yIHRoZSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgZWFzdGluZyB2YWx1ZSB0aGF0XG4gKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG90aGVyLCBzZWNvbmRhcnkgZWFzdGluZyB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtjaGFyfSBlIFRoZSBmaXJzdCBsZXR0ZXIgZnJvbSBhIHR3by1sZXR0ZXIgTUdSUyAxMDDCtGsgem9uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzZXQgVGhlIE1HUlMgdGFibGUgc2V0IGZvciB0aGUgem9uZSBudW1iZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBlYXN0aW5nIHZhbHVlIGZvciB0aGUgZ2l2ZW4gbGV0dGVyIGFuZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGdldEVhc3RpbmdGcm9tQ2hhcihlLCBzZXQpIHtcbiAgLy8gY29sT3JpZ2luIGlzIHRoZSBsZXR0ZXIgYXQgdGhlIG9yaWdpbiBvZiB0aGUgc2V0IGZvciB0aGVcbiAgLy8gY29sdW1uXG4gIHZhciBjdXJDb2wgPSBTRVRfT1JJR0lOX0NPTFVNTl9MRVRURVJTLmNoYXJDb2RlQXQoc2V0IC0gMSk7XG4gIHZhciBlYXN0aW5nVmFsdWUgPSAxMDAwMDAuMDtcbiAgdmFyIHJld2luZE1hcmtlciA9IGZhbHNlO1xuXG4gIHdoaWxlIChjdXJDb2wgIT09IGUuY2hhckNvZGVBdCgwKSkge1xuICAgIGN1ckNvbCsrO1xuICAgIGlmIChjdXJDb2wgPT09IEkpIHtcbiAgICAgIGN1ckNvbCsrO1xuICAgIH1cbiAgICBpZiAoY3VyQ29sID09PSBPKSB7XG4gICAgICBjdXJDb2wrKztcbiAgICB9XG4gICAgaWYgKGN1ckNvbCA+IFopIHtcbiAgICAgIGlmIChyZXdpbmRNYXJrZXIpIHtcbiAgICAgICAgdGhyb3cgKFwiQmFkIGNoYXJhY3RlcjogXCIgKyBlKTtcbiAgICAgIH1cbiAgICAgIGN1ckNvbCA9IEE7XG4gICAgICByZXdpbmRNYXJrZXIgPSB0cnVlO1xuICAgIH1cbiAgICBlYXN0aW5nVmFsdWUgKz0gMTAwMDAwLjA7XG4gIH1cblxuICByZXR1cm4gZWFzdGluZ1ZhbHVlO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBzZWNvbmQgbGV0dGVyIGZyb20gYSB0d28tbGV0dGVyIE1HUlMgMTAwayB6b25lLCBhbmQgZ2l2ZW4gdGhlXG4gKiBNR1JTIHRhYmxlIHNldCBmb3IgdGhlIHpvbmUgbnVtYmVyLCBmaWd1cmUgb3V0IHRoZSBub3J0aGluZyB2YWx1ZSB0aGF0XG4gKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG90aGVyLCBzZWNvbmRhcnkgbm9ydGhpbmcgdmFsdWUuIFlvdSBoYXZlIHRvXG4gKiByZW1lbWJlciB0aGF0IE5vcnRoaW5ncyBhcmUgZGV0ZXJtaW5lZCBmcm9tIHRoZSBlcXVhdG9yLCBhbmQgdGhlIHZlcnRpY2FsXG4gKiBjeWNsZSBvZiBsZXR0ZXJzIG1lYW4gYSAyMDAwMDAwIGFkZGl0aW9uYWwgbm9ydGhpbmcgbWV0ZXJzLiBUaGlzIGhhcHBlbnNcbiAqIGFwcHJveC4gZXZlcnkgMTggZGVncmVlcyBvZiBsYXRpdHVkZS4gVGhpcyBtZXRob2QgZG9lcyAqTk9UKiBjb3VudCBhbnlcbiAqIGFkZGl0aW9uYWwgbm9ydGhpbmdzLiBZb3UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvdyBtYW55IDIwMDAwMDAgbWV0ZXJzIG5lZWRcbiAqIHRvIGJlIGFkZGVkIGZvciB0aGUgem9uZSBsZXR0ZXIgb2YgdGhlIE1HUlMgY29vcmRpbmF0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtjaGFyfSBuIFNlY29uZCBsZXR0ZXIgb2YgdGhlIE1HUlMgMTAwayB6b25lXG4gKiBAcGFyYW0ge251bWJlcn0gc2V0IFRoZSBNR1JTIHRhYmxlIHNldCBudW1iZXIsIHdoaWNoIGlzIGRlcGVuZGVudCBvbiB0aGVcbiAqICAgICBVVE0gem9uZSBudW1iZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBub3J0aGluZyB2YWx1ZSBmb3IgdGhlIGdpdmVuIGxldHRlciBhbmQgc2V0LlxuICovXG5mdW5jdGlvbiBnZXROb3J0aGluZ0Zyb21DaGFyKG4sIHNldCkge1xuXG4gIGlmIChuID4gJ1YnKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGdpdmVuIGludmFsaWQgTm9ydGhpbmcgXCIgKyBuKTtcbiAgfVxuXG4gIC8vIHJvd09yaWdpbiBpcyB0aGUgbGV0dGVyIGF0IHRoZSBvcmlnaW4gb2YgdGhlIHNldCBmb3IgdGhlXG4gIC8vIGNvbHVtblxuICB2YXIgY3VyUm93ID0gU0VUX09SSUdJTl9ST1dfTEVUVEVSUy5jaGFyQ29kZUF0KHNldCAtIDEpO1xuICB2YXIgbm9ydGhpbmdWYWx1ZSA9IDAuMDtcbiAgdmFyIHJld2luZE1hcmtlciA9IGZhbHNlO1xuXG4gIHdoaWxlIChjdXJSb3cgIT09IG4uY2hhckNvZGVBdCgwKSkge1xuICAgIGN1clJvdysrO1xuICAgIGlmIChjdXJSb3cgPT09IEkpIHtcbiAgICAgIGN1clJvdysrO1xuICAgIH1cbiAgICBpZiAoY3VyUm93ID09PSBPKSB7XG4gICAgICBjdXJSb3crKztcbiAgICB9XG4gICAgLy8gZml4aW5nIGEgYnVnIG1ha2luZyB3aG9sZSBhcHBsaWNhdGlvbiBoYW5nIGluIHRoaXMgbG9vcFxuICAgIC8vIHdoZW4gJ24nIGlzIGEgd3JvbmcgY2hhcmFjdGVyXG4gICAgaWYgKGN1clJvdyA+IFYpIHtcbiAgICAgIGlmIChyZXdpbmRNYXJrZXIpIHsgLy8gbWFraW5nIHN1cmUgdGhhdCB0aGlzIGxvb3AgZW5kc1xuICAgICAgICB0aHJvdyAoXCJCYWQgY2hhcmFjdGVyOiBcIiArIG4pO1xuICAgICAgfVxuICAgICAgY3VyUm93ID0gQTtcbiAgICAgIHJld2luZE1hcmtlciA9IHRydWU7XG4gICAgfVxuICAgIG5vcnRoaW5nVmFsdWUgKz0gMTAwMDAwLjA7XG4gIH1cblxuICByZXR1cm4gbm9ydGhpbmdWYWx1ZTtcbn1cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gZ2V0TWluTm9ydGhpbmcgcmV0dXJucyB0aGUgbWluaW11bSBub3J0aGluZyB2YWx1ZSBvZiBhIE1HUlNcbiAqIHpvbmUuXG4gKlxuICogUG9ydGVkIGZyb20gR2VvdHJhbnMnIGMgTGF0dGl0dWRlX0JhbmRfVmFsdWUgc3RydWN0dXJlIHRhYmxlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2NoYXJ9IHpvbmVMZXR0ZXIgVGhlIE1HUlMgem9uZSB0byBnZXQgdGhlIG1pbiBub3J0aGluZyBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldE1pbk5vcnRoaW5nKHpvbmVMZXR0ZXIpIHtcbiAgdmFyIG5vcnRoaW5nO1xuICBzd2l0Y2ggKHpvbmVMZXR0ZXIpIHtcbiAgY2FzZSAnQyc6XG4gICAgbm9ydGhpbmcgPSAxMTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0QnOlxuICAgIG5vcnRoaW5nID0gMjAwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdFJzpcbiAgICBub3J0aGluZyA9IDI4MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnRic6XG4gICAgbm9ydGhpbmcgPSAzNzAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0cnOlxuICAgIG5vcnRoaW5nID0gNDYwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdIJzpcbiAgICBub3J0aGluZyA9IDU1MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnSic6XG4gICAgbm9ydGhpbmcgPSA2NDAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0snOlxuICAgIG5vcnRoaW5nID0gNzMwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdMJzpcbiAgICBub3J0aGluZyA9IDgyMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnTSc6XG4gICAgbm9ydGhpbmcgPSA5MTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ04nOlxuICAgIG5vcnRoaW5nID0gMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdQJzpcbiAgICBub3J0aGluZyA9IDgwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdRJzpcbiAgICBub3J0aGluZyA9IDE3MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnUic6XG4gICAgbm9ydGhpbmcgPSAyNjAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1MnOlxuICAgIG5vcnRoaW5nID0gMzUwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdUJzpcbiAgICBub3J0aGluZyA9IDQ0MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnVSc6XG4gICAgbm9ydGhpbmcgPSA1MzAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1YnOlxuICAgIG5vcnRoaW5nID0gNjIwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdXJzpcbiAgICBub3J0aGluZyA9IDcwMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnWCc6XG4gICAgbm9ydGhpbmcgPSA3OTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgbm9ydGhpbmcgPSAtMS4wO1xuICB9XG4gIGlmIChub3J0aGluZyA+PSAwLjApIHtcbiAgICByZXR1cm4gbm9ydGhpbmc7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgKFwiSW52YWxpZCB6b25lIGxldHRlcjogXCIgKyB6b25lTGV0dGVyKTtcbiAgfVxuXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3Byb2o0L25vZGVfbW9kdWxlcy9tZ3JzL21ncnMuanNcIixcIi9ub2RlX21vZHVsZXMvcHJvajQvbm9kZV9tb2R1bGVzL21ncnNcIikiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcInByb2o0XCIsXG4gIFwidmVyc2lvblwiOiBcIjIuMy4zXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJQcm9qNGpzIGlzIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IHRvIHRyYW5zZm9ybSBwb2ludCBjb29yZGluYXRlcyBmcm9tIG9uZSBjb29yZGluYXRlIHN5c3RlbSB0byBhbm90aGVyLCBpbmNsdWRpbmcgZGF0dW0gdHJhbnNmb3JtYXRpb25zLlwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJkaXJlY3Rvcmllc1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwidGVzdFwiLFxuICAgIFwiZG9jXCI6IFwiZG9jc1wiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiLi9ub2RlX21vZHVsZXMvaXN0YW5idWwvbGliL2NsaS5qcyB0ZXN0IC4vbm9kZV9tb2R1bGVzL21vY2hhL2Jpbi9fbW9jaGEgdGVzdC90ZXN0LmpzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vcHJvajRqcy9wcm9qNGpzLmdpdFwiXG4gIH0sXG4gIFwiYXV0aG9yXCI6IFwiXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcImphbVwiOiB7XG4gICAgXCJtYWluXCI6IFwiZGlzdC9wcm9qNC5qc1wiLFxuICAgIFwiaW5jbHVkZVwiOiBbXG4gICAgICBcImRpc3QvcHJvajQuanNcIixcbiAgICAgIFwiUkVBRE1FLm1kXCIsXG4gICAgICBcIkFVVEhPUlNcIixcbiAgICAgIFwiTElDRU5TRS5tZFwiXG4gICAgXVxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJncnVudC1jbGlcIjogXCJ+MC4xLjEzXCIsXG4gICAgXCJncnVudFwiOiBcIn4wLjQuMlwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1jb25uZWN0XCI6IFwifjAuNi4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWpzaGludFwiOiBcIn4wLjguMFwiLFxuICAgIFwiY2hhaVwiOiBcIn4xLjguMVwiLFxuICAgIFwibW9jaGFcIjogXCJ+MS4xNy4xXCIsXG4gICAgXCJncnVudC1tb2NoYS1waGFudG9tanNcIjogXCJ+MC40LjBcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCJ+My4yNC41XCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwifjEuMy4wXCIsXG4gICAgXCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIn4wLjMuMlwiLFxuICAgIFwiY3VybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vY3Vqb2pzL2N1cmwuZ2l0XCIsXG4gICAgXCJpc3RhbmJ1bFwiOiBcIn4wLjIuNFwiLFxuICAgIFwidGluXCI6IFwifjAuNC4wXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwibWdyc1wiOiBcIjAuMC4wXCJcbiAgfSxcbiAgXCJjb250cmlidXRvcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIk1pa2UgQWRhaXJcIixcbiAgICAgIFwiZW1haWxcIjogXCJtYWRhaXJAZG1zb2x1dGlvbnMuY2FcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiUmljaGFyZCBHcmVlbndvb2RcIixcbiAgICAgIFwiZW1haWxcIjogXCJyaWNoQGdyZWVud29vZG1hcC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiQ2FsdmluIE1ldGNhbGZcIixcbiAgICAgIFwiZW1haWxcIjogXCJjYWx2aW4ubWV0Y2FsZkBnbWFpbC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiUmljaGFyZCBNYXJzZGVuXCIsXG4gICAgICBcInVybFwiOiBcImh0dHA6Ly93d3cud2lud2FlZC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiVC4gTWl0dGFuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIkQuIFN0ZWlud2FuZFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJTLiBOZWxzb25cIlxuICAgIH1cbiAgXSxcbiAgXCJyZWFkbWVcIjogXCIjUFJPSjRKUyBbIVtCdWlsZCBTdGF0dXNdKGh0dHBzOi8vdHJhdmlzLWNpLm9yZy9wcm9qNGpzL3Byb2o0anMuc3ZnKV0oaHR0cHM6Ly90cmF2aXMtY2kub3JnL3Byb2o0anMvcHJvajRqcylcXG5cXG5Qcm9qNGpzIGlzIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IHRvIHRyYW5zZm9ybSBwb2ludCBjb29yZGluYXRlcyBmcm9tIG9uZSBjb29yZGluYXRlIHN5c3RlbSB0byBhbm90aGVyLCBpbmNsdWRpbmcgZGF0dW0gdHJhbnNmb3JtYXRpb25zLlxcbk9yaWdpbmFsbHkgYSBwb3J0IG9mIFtQUk9KLjRdKGh0dHA6Ly90cmFjLm9zZ2VvLm9yZy9wcm9qLykgYW5kIFtHQ1RDUCBDXShodHRwOi8vZWRjZnRwLmNyLnVzZ3MuZ292L3B1Yi8vc29mdHdhcmUvZ2N0cGMpIGl0IGlzXFxuYSBwYXJ0IG9mIHRoZSBbTWV0YUNSU10oaHR0cDovL3dpa2kub3NnZW8ub3JnL3dpa2kvTWV0YUNSUykgZ3JvdXAgb2YgcHJvamVjdHMuXFxuXFxuIyNJbnN0YWxsaW5nXFxuXFxuRGVwZW5kaW5nIG9uIHlvdXIgcHJlZmVyZW5jZXNcXG5cXG5gYGBiYXNoXFxubnBtIGluc3RhbGwgcHJvajRcXG5ib3dlciBpbnN0YWxsIHByb2o0XFxuamFtIGluc3RhbGwgcHJvajRcXG5jb21wb25lbnQgaW5zdGFsbCBwcm9qNGpzL3Byb2o0anNcXG5gYGBcXG5cXG5vciBqdXN0IG1hbnVhbGx5IGdyYWIgdGhlIGZpbGUgYHByb2o0LmpzYCBmcm9tIHRoZSBbbGF0ZXN0IHJlbGVhc2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9qNGpzL3Byb2o0anMvcmVsZWFzZXMpLlxcblxcbmlmIHlvdSBkbyBub3Qgd2FudCB0byBkb3dubG9hZCBhbnl0aGluZywgUHJvajRqcyBpcyBhbHNvIGhvc3RlZCBvbiBbY2RuanNdKGh0dHA6Ly93d3cuY2RuanMuY29tL2xpYnJhcmllcy9wcm9qNGpzKSBmb3IgZGlyZWN0IHVzZSBpbiB5b3VyIGJyb3dzZXIgYXBwbGljYXRpb25zLlxcblxcbiMjVXNpbmdcXG5cXG50aGUgYmFzaWMgc2lnbmF0dXJlIGlzOlxcblxcbmBgYGphdmFzY3JpcHRcXG5wcm9qNChmcm9tUHJvamVjdGlvblssIHRvUHJvamVjdGlvbjIsIGNvb3JkaW5hdGVzXSlcXG5gYGBcXG5cXG5Qcm9qZWN0aW9ucyBjYW4gYmUgcHJvaiBvciB3a3Qgc3RyaW5ncy5cXG5cXG5Db29yZGluYXRlcyBtYXkgYW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDp4LHk6eX1gIG9yIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbeCx5XWAuXFxuXFxuV2hlbiBhbGwgMyBhcmd1bWVudHMgIGFyZSBnaXZlbiwgdGhlIHJlc3VsdCBpcyB0aGF0IHRoZSBjb29yZGluYXRlcyBhcmUgdHJhbnNmb3JtZWQgZnJvbSBwcm9qZWN0aW9uMSB0byBwcm9qZWN0aW9uIDIuIEFuZCByZXR1cm5lZCBpbiB0aGUgc2FtZSBmb3JtYXQgdGhhdCB0aGV5IHdlcmUgZ2l2ZW4gaW4uXFxuXFxuYGBgamF2YXNjcmlwdFxcbnZhciBmaXJzdFByb2plY3Rpb24gPSAnUFJPSkNTW1xcXCJOQUQ4MyAvIE1hc3NhY2h1c2V0dHMgTWFpbmxhbmRcXFwiLEdFT0dDU1tcXFwiTkFEODNcXFwiLERBVFVNW1xcXCJOb3J0aF9BbWVyaWNhbl9EYXR1bV8xOTgzXFxcIixTUEhFUk9JRFtcXFwiR1JTIDE5ODBcXFwiLDYzNzgxMzcsMjk4LjI1NzIyMjEwMSxBVVRIT1JJVFlbXFxcIkVQU0dcXFwiLFxcXCI3MDE5XFxcIl1dLEFVVEhPUklUWVtcXFwiRVBTR1xcXCIsXFxcIjYyNjlcXFwiXV0sUFJJTUVNW1xcXCJHcmVlbndpY2hcXFwiLDAsQVVUSE9SSVRZW1xcXCJFUFNHXFxcIixcXFwiODkwMVxcXCJdXSxVTklUW1xcXCJkZWdyZWVcXFwiLDAuMDE3NDUzMjkyNTE5OTQzMjgsQVVUSE9SSVRZW1xcXCJFUFNHXFxcIixcXFwiOTEyMlxcXCJdXSxBVVRIT1JJVFlbXFxcIkVQU0dcXFwiLFxcXCI0MjY5XFxcIl1dLFVOSVRbXFxcIm1ldHJlXFxcIiwxLEFVVEhPUklUWVtcXFwiRVBTR1xcXCIsXFxcIjkwMDFcXFwiXV0sUFJPSkVDVElPTltcXFwiTGFtYmVydF9Db25mb3JtYWxfQ29uaWNfMlNQXFxcIl0sUEFSQU1FVEVSW1xcXCJzdGFuZGFyZF9wYXJhbGxlbF8xXFxcIiw0Mi42ODMzMzMzMzMzMzMzM10sUEFSQU1FVEVSW1xcXCJzdGFuZGFyZF9wYXJhbGxlbF8yXFxcIiw0MS43MTY2NjY2NjY2NjY2N10sUEFSQU1FVEVSW1xcXCJsYXRpdHVkZV9vZl9vcmlnaW5cXFwiLDQxXSxQQVJBTUVURVJbXFxcImNlbnRyYWxfbWVyaWRpYW5cXFwiLC03MS41XSxQQVJBTUVURVJbXFxcImZhbHNlX2Vhc3RpbmdcXFwiLDIwMDAwMF0sUEFSQU1FVEVSW1xcXCJmYWxzZV9ub3J0aGluZ1xcXCIsNzUwMDAwXSxBVVRIT1JJVFlbXFxcIkVQU0dcXFwiLFxcXCIyNjk4NlxcXCJdLEFYSVNbXFxcIlhcXFwiLEVBU1RdLEFYSVNbXFxcIllcXFwiLE5PUlRIXV0nO1xcbnZhciBzZWNvbmRQcm9qZWN0aW9uID0gXFxcIitwcm9qPWdub20gK2xhdF8wPTkwICtsb25fMD0wICt4XzA9NjMwMDAwMCAreV8wPTYzMDAwMDAgK2VsbHBzPVdHUzg0ICtkYXR1bT1XR1M4NCArdW5pdHM9bSArbm9fZGVmc1xcXCI7XFxuLy9JJ20gbm90IGdvaW5nIHRvIHJlZGVmaW5lIHRob3NlIHR3byBpbiBsYXR0ZXIgZXhhbXBsZXMuXFxucHJvajQoZmlyc3RQcm9qZWN0aW9uLHNlY29uZFByb2plY3Rpb24sWzIsNV0pO1xcbi8vIFstMjY5MDY2Ni4yOTc3MzQ0NTA1LCAzNjYyNjU5Ljg4NTQ1OTkxOF1cXG5gYGBcXG5cXG5JZiBvbmx5IDEgcHJvamVjdGlvbiBpcyBnaXZlbiB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCBpdCBpcyBiZWluZyBwcm9qZWN0ZWQgKmZyb20qIFdHUzg0IChmcm9tUHJvamVjdGlvbiBpcyBXR1M4NCkuXFxuXFxuYGBgamF2YXNjcmlwdFxcbnByb2o0KGZpcnN0UHJvamVjdGlvbixbLTcxLDQxXSk7XFxuLy8gWzI0MjA3NS4wMDUzNTA1NTM3MiwgNzUwMTIzLjMyMDkwMDQzXVxcbmBgYFxcblxcbklmIG5vIGNvb3JkaW5hdGVzIGFyZSBnaXZlbiBhbiBvYmplY3Qgd2l0aCB0d28gbWV0aG9kcyBpcyByZXR1cm5lZCwgaXRzIG1ldGhvZHMgYXJlIGBmb3J3YXJkYCB3aGljaCBwcm9qZWN0cyBmcm9tIHRoZSBmaXJzdCBwcm9qZWN0aW9uIHRvIHRoZSBzZWNvbmQgYW5kIGBpbnZlcnNlYCB3aGljaCBwcm9qZWN0cyBmcm9tIHRoZSBzZWNvbmQgdG8gdGhlIGZpcnN0LlxcblxcbmBgYGphdmFzY3JpcHRcXG5wcm9qNChmaXJzdFByb2plY3Rpb24sc2Vjb25kUHJvamVjdGlvbikuZm9yd2FyZChbMiw1XSk7XFxuLy8gWy0yNjkwNjY2LjI5NzczNDQ1MDUsIDM2NjI2NTkuODg1NDU5OTE4XVxcbnByb2o0KHNlY29uZFByb2plY3Rpb24sZmlyc3RQcm9qZWN0aW9uKS5pbnZlcnNlKFsyLDVdKTtcXG4vLyBbLTI2OTA2NjYuMjk3NzM0NDUwNSwgMzY2MjY1OS44ODU0NTk5MThdXFxuYGBgXFxuXFxuYW5kIGFzIGFib3ZlIGlmIG9ubHkgb25lIHByb2plY3Rpb24gaXMgZ2l2ZW4sIGl0J3MgYXNzdW1lZCB0byBiZSBjb21pbmcgZnJvbSB3Z3M4NFxcblxcbmBgYGphdmFzY3JpcHRcXG5wcm9qNChmaXJzdFByb2plY3Rpb24pLmZvcndhcmQoWy03MSw0MV0pO1xcbi8vIFsyNDIwNzUuMDA1MzUwNTUzNzIsIDc1MDEyMy4zMjA5MDA0M11cXG5wcm9qNChmaXJzdFByb2plY3Rpb24pLmludmVyc2UoWzI0MjA3NS4wMDUzNTA1NTM3MiwgNzUwMTIzLjMyMDkwMDQzXSk7XFxuLy9bLTcxLCA0MC45OTk5OTk5OTk5OTk4Nl1cXG4vL3RoZSBmbG9hdGluZyBwb2ludHMgdG8gYW5zd2VyIHlvdXIgcXVlc3Rpb25cXG5gYGBcXG5cXG4jIyBOYW1lZCBQcm9qZWN0aW9uc1xcblxcbklmIHlvdSBwcmVmZXIgdG8gZGVmaW5lIGEgcHJvamVjdGlvbiBhcyBhIHN0cmluZyBhbmQgcmVmZXJlbmNlIGl0IHRoYXQgd2F5LCB5b3UgbWF5IHVzZSB0aGUgcHJvajQuZGVmcyBtZXRob2Qgd2hpY2ggY2FuIGJlIGNhbGxlZCAyIHdheXMsIHdpdGggYSBuYW1lIGFuZCBwcm9qZWN0aW9uOlxcblxcbmBgYGpzXFxucHJvajQuZGVmcygnV0dTODQnLCBcXFwiK3RpdGxlPVdHUyA4NCAobG9uZy9sYXQpICtwcm9qPWxvbmdsYXQgK2VsbHBzPVdHUzg0ICtkYXR1bT1XR1M4NCArdW5pdHM9ZGVncmVlc1xcXCIpO1xcbmBgYFxcblxcbm9yIHdpdGggYW4gYXJyYXlcXG5cXG5gYGBqc1xcbnByb2o0LmRlZnMoW1xcbiAgW1xcbiAgICAnRVBTRzo0MzI2JyxcXG4gICAgJyt0aXRsZT1XR1MgODQgKGxvbmcvbGF0KSArcHJvaj1sb25nbGF0ICtlbGxwcz1XR1M4NCArZGF0dW09V0dTODQgK3VuaXRzPWRlZ3JlZXMnXSxcXG4gIFtcXG4gICAgJ0VQU0c6NDI2OScsXFxuICAgICcrdGl0bGU9TkFEODMgKGxvbmcvbGF0KSArcHJvaj1sb25nbGF0ICthPTYzNzgxMzcuMCArYj02MzU2NzUyLjMxNDE0MDM2ICtlbGxwcz1HUlM4MCArZGF0dW09TkFEODMgK3VuaXRzPWRlZ3JlZXMnXFxuICBdXFxuXSk7XFxuYGBgXFxuXFxueW91IGNhbiB0aGVuIGRvIFxcblxcbmBgYGpzXFxucHJvajQoJ0VQU0c6NDMyNicpO1xcbmBgYFxcblxcbmluc3RlYWQgb2Ygd3JpdGluZyBvdXQgdGhlIHdob2xlIHByb2ogZGVmaW5pdGlvbiwgYnkgZGVmYXVsdCBwcm9qNCBoYXMgdGhlIGZvbGxvd2luZyBwcm9qZWN0aW9ucyBwcmVkZWZpbmVkOlxcblxcbi0gJ0VQU0c6NDMyNicsIHdoaWNoIGhhcyB0aGUgZm9sbG93aW5nIGFsaWFzXFxuICAgIC0gJ1dHUzg0J1xcbi0gJ0VQU0c6NDI2OSdcXG4tICdFUFNHOjM4NTcnLCB3aGljaCBoYXMgdGhlIGZvbGxvd2luZyBhbGlhc2VzXFxuICAgIC0gJ0VQU0c6Mzc4NSdcXG4gICAgLSAnR09PR0xFJ1xcbiAgICAtICdFUFNHOjkwMDkxMydcXG4gICAgLSAnRVBTRzoxMDIxMTMnXFxuXFxuZGVmaW5lZCBwcm9qZWN0aW9ucyBjYW4gYWxzbyBiZSBhY2Nlc3NlZCB0aHJvdWdoIHRoZSBwcm9qNC5kZWZzIGZ1bmN0aW9uIChgcHJvajQuZGVmcygnRVBTRzo0MzI2JylgKS5cXG5cXG5wcm9qNC5kZWZzIGNhbiBhbHNvIGJlIHVzZWQgdG8gZGVmaW5lIGEgbmFtZWQgYWxpYXM6XFxuXFxuYGBgamF2YXNjcmlwdFxcbnByb2o0LmRlZnMoJ3Vybjp4LW9nYzpkZWY6Y3JzOkVQU0c6NDMyNicsIHByb2o0LmRlZnMoJ0VQU0c6NDMyNicpKTtcXG5gYGAgXFxuXFxuIyNEZXZlbG9waW5nXFxudG8gc2V0IHVwIGJ1aWxkIHRvb2xzIG1ha2Ugc3VyZSB5b3UgaGF2ZSBub2RlIGFuZCBncnVudC1jbGkgaW5zdGFsbGVkIGFuZCB0aGVuIHJ1biBgbnBtIGluc3RhbGxgXFxuXFxudG8gZG8gdGhlIGNvbXBsZXRlIGJ1aWxkIGFuZCBicm93c2VyIHRlc3RzIHJ1blxcblxcbmBgYGJhc2hcXG5ncnVudFxcbmBgYFxcblxcbnRvIHJ1biBub2RlIHRlc3RzIHJ1blxcblxcbmBgYGJhc2hcXG5ucG0gdGVzdFxcbmBgYFxcblxcbnRvIHJ1biBub2RlIHRlc3RzIHdpdGggY292ZXJhZ2UgcnVuXFxuXFxuYGBgYmFzaFxcbm5vZGUgdGVzdCAtLWNvdmVyYWdlXFxuYGBgXFxuXFxudG8gY3JlYXRlIGEgYnVpbGQgd2l0aCBvbmx5IGRlZmF1bHQgcHJvamVjdGlvbnMgKGxhdGxvbiBhbmQgTWVyY2F0b3IpIHJ1biBcXG5cXG5gYGBiYXNoXFxuZ3J1bnQgYnVpbGRcXG5gYGBcXG5cXG50byBjcmVhdGUgYSBidWlsZCB3aXRoIG9ubHkgY3VzdG9tIHByb2plY3Rpb25zIGluY2x1ZGUgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBwcm9qZWN0aW9ucyBjb2RlcyAodGhlIGZpbGUgbmFtZSBpbiAnbGliL3Byb2plY3Rpb25zJyB3aXRob3V0IHRoZSAnLmpzJykgYWZ0ZXIgYSBjb2xvbiwgZS5nLlxcblxcbmBgYGJhc2hcXG5ncnVudCBidWlsZDp0bWVyY1xcbiNpbmNsdWRlcyB0cmFuc3ZlcnNlIE1lcmNhdG9yXFxuZ3J1bnQgYnVpbGQ6bGNjXFxuI2luY2x1ZGVzIGxhbWJlcnQgY29uZm9ybWFsIGNvbmljXFxuZ3J1bnQgYnVpbGQ6b21lcmMsbW9sbFxcbiNpbmNsdWRlcyBvYmxpcXVlIE1lcmNhdG9yIGFuZCBNb2xsd2VpZGVcXG5gYGBcXG5cIixcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcIlJFQURNRS5tZFwiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3Byb2o0anMvcHJvajRqcy9pc3N1ZXNcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3Byb2o0anMvcHJvajRqc1wiLFxuICBcIl9pZFwiOiBcInByb2o0QDIuMy4zXCIsXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCIxMDYwYmJmNTMyMzVkNjEwYTNmYmY5YzNjMjJlYjAwNmZhZDNmNWI4XCJcbiAgfSxcbiAgXCJfZnJvbVwiOiBcInByb2o0QDIuMy4zXCIsXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvcHJvajQvLS9wcm9qNC0yLjMuMy50Z3pcIlxufVxuIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ3VycmVudGx5IHJlcXVpcmVzIHBvbHlmaWxscyBmb3Jcbi8vIEFycmF5I2ZvckVhY2hcbi8vIE9iamVjdC5rZXlzXG4vLyBTdHJpbmcjdHJpbVxuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnUSddLCBmdW5jdGlvbihRKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeShYTUxIdHRwUmVxdWVzdCwgUSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIC8vIENvbW1vbkpTLCBtYWlubHkgZm9yIHRlc3RpbmdcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnlcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIFEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBmYWN0b3J5KFhNTEh0dHBSZXF1ZXN0LCBRKVxuICAgIH1cbiAgfVxufSkoZnVuY3Rpb24oWEhSLCBRKSB7XG4gIC8vIHNoYWxsb3cgZXh0ZW5kIHdpdGggdmFyYXJnc1xuICBmdW5jdGlvbiBleHRlbmQoZHN0KSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiAmJiBvYmogIT09IGRzdCkge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgZHN0W2tleV0gPSBvYmpba2V5XVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gZHN0XG4gIH1cblxuICBmdW5jdGlvbiBsb3dlcmNhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIChzdHIgfHwgJycpLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdmFyIHBhcnNlZCA9IHt9LCBrZXksIHZhbCwgaVxuXG4gICAgaWYgKCFoZWFkZXJzKSByZXR1cm4gcGFyc2VkXG5cbiAgICBoZWFkZXJzLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKVxuICAgICAga2V5ID0gbG93ZXJjYXNlKGxpbmUuc3Vic3RyKDAsIGkpLnRyaW0oKSlcbiAgICAgIHZhbCA9IGxpbmUuc3Vic3RyKGkgKyAxKS50cmltKClcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBpZiAocGFyc2VkW2tleV0pIHtcbiAgICAgICAgICBwYXJzZWRba2V5XSArPSAnLCAnICsgdmFsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VkW2tleV0gPSB2YWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gcGFyc2VkXG4gIH1cblxuICBmdW5jdGlvbiBoZWFkZXJzR2V0dGVyKGhlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVyc09iaiA9IHR5cGVvZiBoZWFkZXJzID09PSAnb2JqZWN0JyA/IGhlYWRlcnMgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKCFoZWFkZXJzT2JqKSBoZWFkZXJzT2JqID0gcGFyc2VIZWFkZXJzKGhlYWRlcnMpXG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXJzT2JqW2xvd2VyY2FzZShuYW1lKV1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlYWRlcnNPYmpcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAgIGlmICh0eXBlb2YgZm5zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZm5zKGRhdGEsIGhlYWRlcnMpXG4gICAgfVxuXG4gICAgZm5zLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcbiAgICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKVxuICAgIH0pXG5cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdWNjZXNzKHN0YXR1cykge1xuICAgIHJldHVybiAyMDAgPD0gc3RhdHVzICYmIHN0YXR1cyA8IDMwMFxuICB9XG5cbiAgZnVuY3Rpb24gZm9yRWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5KVxuICAgIH0pXG4gICAgcmV0dXJuIGtleXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckVhY2hTb3J0ZWQob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKS5zb3J0KClcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXkpXG4gICAgfSlcbiAgICByZXR1cm4ga2V5c1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRVcmwodXJsLCBwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcykgcmV0dXJuIHVybFxuICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgZm9yRWFjaFNvcnRlZChwYXJhbXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW3ZhbHVlXVxuXG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KVxuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgK1xuICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudCh2KSlcbiAgICAgIH0pXG4gICAgfSlcbiAgICByZXR1cm4gdXJsICsgKCh1cmwuaW5kZXhPZignPycpID09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJ0cy5qb2luKCcmJylcbiAgfVxuXG4gIFEueGhyID0gZnVuY3Rpb24gKHJlcXVlc3RDb25maWcpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSBRLnhoci5kZWZhdWx0cyxcbiAgICBjb25maWcgPSB7XG4gICAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBkZWZhdWx0cy50cmFuc2Zvcm1SZXF1ZXN0LFxuICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6IGRlZmF1bHRzLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgfSxcbiAgICBtZXJnZUhlYWRlcnMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHZhciBkZWZIZWFkZXJzID0gZGVmYXVsdHMuaGVhZGVycyxcbiAgICAgICAgICByZXFIZWFkZXJzID0gZXh0ZW5kKHt9LCBjb25maWcuaGVhZGVycyksXG4gICAgICAgICAgZGVmSGVhZGVyTmFtZSwgbG93ZXJjYXNlRGVmSGVhZGVyTmFtZSwgcmVxSGVhZGVyTmFtZSxcblxuICAgICAgZXhlY0hlYWRlcnMgPSBmdW5jdGlvbihoZWFkZXJzKSB7XG4gICAgICAgIGZvckVhY2goaGVhZGVycywgZnVuY3Rpb24oaGVhZGVyRm4sIGhlYWRlcikge1xuICAgICAgICAgIGlmICh0eXBlb2YgaGVhZGVyRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJDb250ZW50ID0gaGVhZGVyRm4oKVxuICAgICAgICAgICAgaWYgKGhlYWRlckNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBoZWFkZXJzW2hlYWRlcl0gPSBoZWFkZXJDb250ZW50XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgaGVhZGVyc1toZWFkZXJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBkZWZIZWFkZXJzID0gZXh0ZW5kKHt9LCBkZWZIZWFkZXJzLmNvbW1vbiwgZGVmSGVhZGVyc1tsb3dlcmNhc2UoY29uZmlnLm1ldGhvZCldKTtcblxuICAgICAgLy8gZXhlY3V0ZSBpZiBoZWFkZXIgdmFsdWUgaXMgZnVuY3Rpb25cbiAgICAgIGV4ZWNIZWFkZXJzKGRlZkhlYWRlcnMpO1xuICAgICAgZXhlY0hlYWRlcnMocmVxSGVhZGVycyk7XG5cbiAgICAgIC8vIHVzaW5nIGZvci1pbiBpbnN0ZWFkIG9mIGZvckVhY2ggdG8gYXZvaWQgdW5lY2Vzc2FyeSBpdGVyYXRpb24gYWZ0ZXIgaGVhZGVyIGhhcyBiZWVuIGZvdW5kXG4gICAgICBkZWZhdWx0SGVhZGVyc0l0ZXJhdGlvbjpcbiAgICAgIGZvciAoZGVmSGVhZGVyTmFtZSBpbiBkZWZIZWFkZXJzKSB7XG4gICAgICAgIGxvd2VyY2FzZURlZkhlYWRlck5hbWUgPSBsb3dlcmNhc2UoZGVmSGVhZGVyTmFtZSk7XG5cbiAgICAgICAgZm9yIChyZXFIZWFkZXJOYW1lIGluIHJlcUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAobG93ZXJjYXNlKHJlcUhlYWRlck5hbWUpID09PSBsb3dlcmNhc2VEZWZIZWFkZXJOYW1lKSB7XG4gICAgICAgICAgICBjb250aW51ZSBkZWZhdWx0SGVhZGVyc0l0ZXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXFIZWFkZXJzW2RlZkhlYWRlck5hbWVdID0gZGVmSGVhZGVyc1tkZWZIZWFkZXJOYW1lXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcUhlYWRlcnM7XG4gICAgfSxcbiAgICBoZWFkZXJzID0gbWVyZ2VIZWFkZXJzKHJlcXVlc3RDb25maWcpXG5cbiAgICBleHRlbmQoY29uZmlnLCByZXF1ZXN0Q29uZmlnKVxuICAgIGNvbmZpZy5oZWFkZXJzID0gaGVhZGVyc1xuICAgIGNvbmZpZy5tZXRob2QgPSAoY29uZmlnLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuXG4gICAgdmFyIHNlcnZlclJlcXVlc3QgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIGhlYWRlcnMgPSBjb25maWcuaGVhZGVyc1xuICAgICAgdmFyIHJlcURhdGEgPSB0cmFuc2Zvcm1EYXRhKGNvbmZpZy5kYXRhLCBoZWFkZXJzR2V0dGVyKGhlYWRlcnMpLCBjb25maWcudHJhbnNmb3JtUmVxdWVzdClcblxuICAgICAgLy8gc3RyaXAgY29udGVudC10eXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkIFRPRE8gZG9lcyBpdCByZWFsbHkgbWF0dGVyP1xuICAgICAgaWYgKGNvbmZpZy5kYXRhID09IG51bGwpIHtcbiAgICAgICAgZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbih2YWx1ZSwgaGVhZGVyKSB7XG4gICAgICAgICAgaWYgKGxvd2VyY2FzZShoZWFkZXIpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgICAgICBkZWxldGUgaGVhZGVyc1toZWFkZXJdXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLndpdGhDcmVkZW50aWFscyA9PSBudWxsICYmIGRlZmF1bHRzLndpdGhDcmVkZW50aWFscyAhPSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgPSBkZWZhdWx0cy53aXRoQ3JlZGVudGlhbHNcbiAgICAgIH1cblxuICAgICAgLy8gc2VuZCByZXF1ZXN0XG4gICAgICByZXR1cm4gc2VuZFJlcShjb25maWcsIHJlcURhdGEsIGhlYWRlcnMpLnRoZW4odHJhbnNmb3JtUmVzcG9uc2UsIHRyYW5zZm9ybVJlc3BvbnNlKVxuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm1SZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShyZXNwb25zZS5kYXRhLCByZXNwb25zZS5oZWFkZXJzLCBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UpXG4gICAgICByZXR1cm4gaXNTdWNjZXNzKHJlc3BvbnNlLnN0YXR1cykgPyByZXNwb25zZSA6IFEucmVqZWN0KHJlc3BvbnNlKVxuICAgIH0sXG5cbiAgICBwcm9taXNlID0gUS53aGVuKGNvbmZpZylcblxuICAgIC8vIGJ1aWxkIGEgcHJvbWlzZSBjaGFpbiB3aXRoIHJlcXVlc3QgaW50ZXJjZXB0b3JzIGZpcnN0LCB0aGVuIHRoZSByZXF1ZXN0LCBhbmQgcmVzcG9uc2UgaW50ZXJjZXB0b3JzXG4gICAgUS54aHIuaW50ZXJjZXB0b3JzLmZpbHRlcihmdW5jdGlvbihpbnRlcmNlcHRvcikge1xuICAgICAgICByZXR1cm4gISFpbnRlcmNlcHRvci5yZXF1ZXN0IHx8ICEhaW50ZXJjZXB0b3IucmVxdWVzdEVycm9yXG4gICAgICB9KS5tYXAoZnVuY3Rpb24oaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogaW50ZXJjZXB0b3IucmVxdWVzdCwgZmFpbHVyZTogaW50ZXJjZXB0b3IucmVxdWVzdEVycm9yIH1cbiAgICAgIH0pXG4gICAgLmNvbmNhdCh7IHN1Y2Nlc3M6IHNlcnZlclJlcXVlc3QgfSlcbiAgICAuY29uY2F0KFEueGhyLmludGVyY2VwdG9ycy5maWx0ZXIoZnVuY3Rpb24oaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgcmV0dXJuICEhaW50ZXJjZXB0b3IucmVzcG9uc2UgfHwgISFpbnRlcmNlcHRvci5yZXNwb25zZUVycm9yXG4gICAgICB9KS5tYXAoZnVuY3Rpb24oaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogaW50ZXJjZXB0b3IucmVzcG9uc2UsIGZhaWx1cmU6IGludGVyY2VwdG9yLnJlc3BvbnNlRXJyb3IgfVxuICAgICAgfSlcbiAgICApLmZvckVhY2goZnVuY3Rpb24odGhlbikge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbih0aGVuLnN1Y2Nlc3MsIHRoZW4uZmFpbHVyZSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG5cbiAgdmFyIGNvbnRlbnRUeXBlSnNvbiA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnIH1cblxuICBRLnhoci5kZWZhdWx0cyA9IHtcbiAgICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uKGRhdGEsIGhlYWRlcnMpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgKGhlYWRlcnMoJ2NvbnRlbnQtdHlwZScpIHx8ICcnKS5pbmRleE9mKCdqc29uJykgPj0gMCkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XSxcblxuICAgIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gISFkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IEZpbGVdJyA/XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpIDogZGF0YVxuICAgIH1dLFxuXG4gICAgaGVhZGVyczoge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICAgICAgfSxcbiAgICAgIHBvc3Q6ICAgY29udGVudFR5cGVKc29uLFxuICAgICAgcHV0OiAgICBjb250ZW50VHlwZUpzb24sXG4gICAgICBwYXRjaDogIGNvbnRlbnRUeXBlSnNvblxuICAgIH0sXG4gIH1cblxuICBRLnhoci5pbnRlcmNlcHRvcnMgPSBbXVxuICBRLnhoci5wZW5kaW5nUmVxdWVzdHMgPSBbXVxuXG4gIGZ1bmN0aW9uIHNlbmRSZXEoY29uZmlnLCByZXFEYXRhLCByZXFIZWFkZXJzKSB7XG4gICAgdmFyIGRlZmVycmVkID0gUS5kZWZlcigpLFxuICAgICAgICBwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZSxcbiAgICAgICAgdXJsID0gYnVpbGRVcmwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcyksXG4gICAgICAgIHhociA9IG5ldyBYSFIoKSxcbiAgICAgICAgYWJvcnRlZCA9IC0xLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIHRpbWVvdXRJZFxuXG4gICAgUS54aHIucGVuZGluZ1JlcXVlc3RzLnB1c2goY29uZmlnKVxuXG4gICAgeGhyLm9wZW4oY29uZmlnLm1ldGhvZCwgdXJsLCB0cnVlKVxuICAgIGZvckVhY2goY29uZmlnLmhlYWRlcnMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICB2YXIgcmVzcG9uc2UsIHJlc3BvbnNlSGVhZGVyc1xuICAgICAgICBpZiAoc3RhdHVzICE9PSBhYm9ydGVkKSB7XG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgLy8gcmVzcG9uc2VUZXh0IGlzIHRoZSBvbGQtc2Nob29sIHdheSBvZiByZXRyaWV2aW5nIHJlc3BvbnNlIChzdXBwb3J0ZWQgYnkgSUU4ICYgOSlcbiAgICAgICAgICAvLyByZXNwb25zZS9yZXNwb25zZVR5cGUgcHJvcGVydGllcyB3ZXJlIGludHJvZHVjZWQgaW4gWEhSIExldmVsMiBzcGVjIChzdXBwb3J0ZWQgYnkgSUUxMClcbiAgICAgICAgICByZXNwb25zZSA9IHhoci5yZXNwb25zZVR5cGUgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYW5jZWwgdGltZW91dCBhbmQgc3Vic2VxdWVudCB0aW1lb3V0IHByb21pc2UgcmVzb2x1dGlvblxuICAgICAgICB0aW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgICAgc3RhdHVzID0gc3RhdHVzIHx8IHhoci5zdGF0dXNcbiAgICAgICAgeGhyID0gbnVsbFxuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBzdGF0dXMsIGluY2x1ZGluZyBhY2NvdW50aW5nIGZvciBJRSBidWcgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTApXG4gICAgICAgIHN0YXR1cyA9IE1hdGgubWF4KHN0YXR1cyA9PSAxMjIzID8gMjA0IDogc3RhdHVzLCAwKVxuXG4gICAgICAgIHZhciBpZHggPSBRLnhoci5wZW5kaW5nUmVxdWVzdHMuaW5kZXhPZihjb25maWcpXG4gICAgICAgIGlmIChpZHggIT09IC0xKSBRLnhoci5wZW5kaW5nUmVxdWVzdHMuc3BsaWNlKGlkeCwgMSlcblxuICAgICAgICA7KGlzU3VjY2VzcyhzdGF0dXMpID8gZGVmZXJyZWQucmVzb2x2ZSA6IGRlZmVycmVkLnJlamVjdCkoe1xuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlLFxuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNHZXR0ZXIocmVzcG9uc2VIZWFkZXJzKSxcbiAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICBkZWZlcnJlZC5ub3RpZnkocHJvZ3Jlc3MpXG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIHhoci5zZW5kKHJlcURhdGEgfHwgbnVsbClcblxuICAgIGlmIChjb25maWcudGltZW91dCA+IDApIHtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0YXR1cyA9IGFib3J0ZWQ7XG4gICAgICAgIHhociAmJiB4aHIuYWJvcnQoKVxuICAgICAgfSwgY29uZmlnLnRpbWVvdXQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIFsnZ2V0JywgJ2RlbGV0ZScsICdoZWFkJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgUS54aHJbbmFtZV0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIFEueGhyKGV4dGVuZChjb25maWcgfHwge30sIHtcbiAgICAgICAgbWV0aG9kOiBuYW1lLFxuICAgICAgICB1cmw6IHVybFxuICAgICAgfSkpXG4gICAgfVxuICB9KTtcblxuICBbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgUS54aHJbbmFtZV0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIFEueGhyKGV4dGVuZChjb25maWcgfHwge30sIHtcbiAgICAgICAgbWV0aG9kOiBuYW1lLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSkpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBRXG59KVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcS14aHIvcS14aHIuanNcIixcIi9ub2RlX21vZHVsZXMvcS14aHJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyB2aW06dHM9NDpzdHM9NDpzdz00OlxuLyohXG4gKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMiBLcmlzIEtvd2FsIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUXG4gKiBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL3Jhdy9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIFdpdGggcGFydHMgYnkgVHlsZXIgQ2xvc2VcbiAqIENvcHlyaWdodCAyMDA3LTIwMDkgVHlsZXIgQ2xvc2UgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgWCBsaWNlbnNlIGZvdW5kXG4gKiBhdCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLmh0bWxcbiAqIEZvcmtlZCBhdCByZWZfc2VuZC5qcyB2ZXJzaW9uOiAyMDA5LTA1LTExXG4gKlxuICogV2l0aCBwYXJ0cyBieSBNYXJrIE1pbGxlclxuICogQ29weXJpZ2h0IChDKSAyMDExIEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gVGhpcyBmaWxlIHdpbGwgZnVuY3Rpb24gcHJvcGVybHkgYXMgYSA8c2NyaXB0PiB0YWcsIG9yIGEgbW9kdWxlXG4gICAgLy8gdXNpbmcgQ29tbW9uSlMgYW5kIE5vZGVKUyBvciBSZXF1aXJlSlMgbW9kdWxlIGZvcm1hdHMuICBJblxuICAgIC8vIENvbW1vbi9Ob2RlL1JlcXVpcmVKUywgdGhlIG1vZHVsZSBleHBvcnRzIHRoZSBRIEFQSSBhbmQgd2hlblxuICAgIC8vIGV4ZWN1dGVkIGFzIGEgc2ltcGxlIDxzY3JpcHQ+LCBpdCBjcmVhdGVzIGEgUSBnbG9iYWwgaW5zdGVhZC5cblxuICAgIC8vIE1vbnRhZ2UgUmVxdWlyZVxuICAgIGlmICh0eXBlb2YgYm9vdHN0cmFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYm9vdHN0cmFwKFwicHJvbWlzZVwiLCBkZWZpbml0aW9uKTtcblxuICAgIC8vIENvbW1vbkpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuXG4gICAgLy8gUmVxdWlyZUpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG5cbiAgICAvLyBTRVMgKFNlY3VyZSBFY21hU2NyaXB0KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoIXNlcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXMubWFrZVEgPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG5cbiAgICAvLyA8c2NyaXB0PlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2VsZi5RID0gZGVmaW5pdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnZpcm9ubWVudCB3YXMgbm90IGFudGljaWFwdGVkIGJ5IFEuIFBsZWFzZSBmaWxlIGEgYnVnLlwiKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGFzU3RhY2tzID0gZmFsc2U7XG50cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0YWNrcyA9ICEhZS5zdGFjaztcbn1cblxuLy8gQWxsIGNvZGUgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzIHJlcG9ydGVkXG4vLyBieSBRLlxudmFyIHFTdGFydGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xudmFyIHFGaWxlTmFtZTtcblxuLy8gc2hpbXNcblxuLy8gdXNlZCBmb3IgZmFsbGJhY2sgaW4gXCJhbGxSZXNvbHZlZFwiXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG52YXIgbmV4dFRpY2sgPShmdW5jdGlvbiAoKSB7XG4gICAgLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG4gICAgdmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbiAgICB2YXIgdGFpbCA9IGhlYWQ7XG4gICAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgdmFyIHJlcXVlc3RUaWNrID0gdm9pZCAwO1xuICAgIHZhciBpc05vZGVKUyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuXG4gICAgICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICAgICAgICB2YXIgdGFzayA9IGhlYWQudGFzaztcbiAgICAgICAgICAgIGhlYWQudGFzayA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBoZWFkLmRvbWFpbjtcblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGhlYWQuZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhc2soKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBub2RlLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBjb25zaWRlcmVkIGZhdGFsIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBzeW5jaHJvbm91c2x5IHRvIGludGVycnVwdCBmbHVzaGluZyFcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaXMgc3VwcHJlc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgXCJ1bmNhdWdodEV4Y2VwdGlvblwiIGV2ZW50cyAoYXMgZG9tYWlucyBkb2VzKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgaW4gbmV4dCBldmVudCB0byBhdm9pZCB0aWNrIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBhc3luY2hyb25vdXNseSB0byBhdm9pZCBzbG93LWRvd25zLlxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBuZXh0VGljayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIHRhaWwgPSB0YWlsLm5leHQgPSB7XG4gICAgICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICAgICAgZG9tYWluOiBpc05vZGVKUyAmJiBwcm9jZXNzLmRvbWFpbixcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0VGljaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgICAgIC8vIE5vZGUuanMgYmVmb3JlIDAuOS4gTm90ZSB0aGF0IHNvbWUgZmFrZS1Ob2RlIGVudmlyb25tZW50cywgbGlrZSB0aGVcbiAgICAgICAgLy8gTW9jaGEgdGVzdCBydW5uZXIsIGludHJvZHVjZSBhIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCBhIGBuZXh0VGlja2AuXG4gICAgICAgIGlzTm9kZUpTID0gdHJ1ZTtcblxuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gSW4gSUUxMCwgTm9kZS5qcyAwLjkrLCBvciBodHRwczovL2dpdGh1Yi5jb20vTm9ibGVKUy9zZXRJbW1lZGlhdGVcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gc2V0SW1tZWRpYXRlLmJpbmQod2luZG93LCBmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZmx1c2gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIC8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIC8vIEF0IGxlYXN0IFNhZmFyaSBWZXJzaW9uIDYuMC41ICg4NTM2LjMwLjEpIGludGVybWl0dGVudGx5IGNhbm5vdCBjcmVhdGVcbiAgICAgICAgLy8gd29ya2luZyBtZXNzYWdlIHBvcnRzIHRoZSBmaXJzdCB0aW1lIGEgcGFnZSBsb2Fkcy5cbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHJlcXVlc3RQb3J0VGljaztcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVxdWVzdFBvcnRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT3BlcmEgcmVxdWlyZXMgdXMgdG8gcHJvdmlkZSBhIG1lc3NhZ2UgcGF5bG9hZCwgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgLy8gd2hldGhlciB3ZSB1c2UgaXQuXG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgcmVxdWVzdFBvcnRUaWNrKCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbGQgYnJvd3NlcnNcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFRpY2s7XG59KSgpO1xuXG4vLyBBdHRlbXB0IHRvIG1ha2UgZ2VuZXJpY3Mgc2FmZSBpbiB0aGUgZmFjZSBvZiBkb3duc3RyZWFtXG4vLyBtb2RpZmljYXRpb25zLlxuLy8gVGhlcmUgaXMgbm8gc2l0dWF0aW9uIHdoZXJlIHRoaXMgaXMgbmVjZXNzYXJ5LlxuLy8gSWYgeW91IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsIHRoZXNlIHByaW1vcmRpYWxzIG5lZWQgdG8gYmVcbi8vIGRlZXBseSBmcm96ZW4gYW55d2F5LCBhbmQgaWYgeW91IGRvbuKAmXQgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSxcbi8vIHRoaXMgaXMganVzdCBwbGFpbiBwYXJhbm9pZC5cbi8vIEhvd2V2ZXIsIHRoaXMgKiptaWdodCoqIGhhdmUgdGhlIG5pY2Ugc2lkZS1lZmZlY3Qgb2YgcmVkdWNpbmcgdGhlIHNpemUgb2Zcbi8vIHRoZSBtaW5pZmllZCBjb2RlIGJ5IHJlZHVjaW5nIHguY2FsbCgpIHRvIG1lcmVseSB4KClcbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1jb252ZW50aW9uczpzYWZlX21ldGFfcHJvZ3JhbW1pbmdcbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQsIGJ1dCBzbG93ZXI6XG4vLyB1bmN1cnJ5VGhpcyA9IEZ1bmN0aW9uX2JpbmQuYmluZChGdW5jdGlvbl9iaW5kLmNhbGwpO1xuLy8gaHR0cDovL2pzcGVyZi5jb20vdW5jdXJyeXRoaXNcblxudmFyIGFycmF5X3NsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxudmFyIGFycmF5X3JlZHVjZSA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBiYXNpcykge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbmNlcm5pbmcgdGhlIGluaXRpYWwgdmFsdWUsIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNlZWsgdG8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheSwgYWNjb3VudGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGlzIGlzIGEgc3BhcnNlIGFycmF5XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSB0aGlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1Y2VcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgYXJyYXkgaXMgc3BhcnNlXG4gICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGJhc2lzID0gY2FsbGJhY2soYmFzaXMsIHRoaXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2lzO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9pbmRleE9mID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5vdCBhIHZlcnkgZ29vZCBzaGltLCBidXQgZ29vZCBlbm91Z2ggZm9yIG91ciBvbmUgdXNlIG9mIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9tYXAgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICBhcnJheV9yZWR1Y2Uoc2VsZiwgZnVuY3Rpb24gKHVuZGVmaW5lZCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzcCwgdmFsdWUsIGluZGV4LCBzZWxmKSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0O1xuICAgIH1cbik7XG5cbnZhciBvYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gVHlwZSgpIHsgfVxuICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgVHlwZSgpO1xufTtcblxudmFyIG9iamVjdF9oYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG52YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RfaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBvYmplY3RfdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8vIGdlbmVyYXRvciByZWxhdGVkIHNoaW1zXG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG5mdW5jdGlvbiBpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0X3RvU3RyaW5nKGV4Y2VwdGlvbikgPT09IFwiW29iamVjdCBTdG9wSXRlcmF0aW9uXVwiIHx8XG4gICAgICAgIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIFFSZXR1cm5WYWx1ZVxuICAgICk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBoZWxwZXIgYW5kIFEucmV0dXJuIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluXG4vLyBTcGlkZXJNb25rZXkuXG52YXIgUVJldHVyblZhbHVlO1xuaWYgKHR5cGVvZiBSZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFFSZXR1cm5WYWx1ZSA9IFJldHVyblZhbHVlO1xufSBlbHNlIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG59XG5cbi8vIGxvbmcgc3RhY2sgdHJhY2VzXG5cbnZhciBTVEFDS19KVU1QX1NFUEFSQVRPUiA9IFwiRnJvbSBwcmV2aW91cyBldmVudDpcIjtcblxuZnVuY3Rpb24gbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIHRyYW5zZm9ybSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgYnkgcmVtb3ZpbmcgTm9kZSBhbmQgUVxuICAgIC8vIGNydWZ0LCB0aGVuIGNvbmNhdGVuYXRpbmcgd2l0aCB0aGUgc3RhY2sgdHJhY2Ugb2YgYHByb21pc2VgLiBTZWUgIzU3LlxuICAgIGlmIChoYXNTdGFja3MgJiZcbiAgICAgICAgcHJvbWlzZS5zdGFjayAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2sgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2suaW5kZXhPZihTVEFDS19KVU1QX1NFUEFSQVRPUikgPT09IC0xXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IHByb21pc2U7ICEhcDsgcCA9IHAuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFjaykge1xuICAgICAgICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KHAuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbihcIlxcblwiICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyBcIlxcblwiKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBmaWx0ZXJTdGFja1N0cmluZyhjb25jYXRlZFN0YWNrcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKFwiKG1vZHVsZS5qczpcIikgIT09IC0xIHx8XG4gICAgICAgICAgIHN0YWNrTGluZS5pbmRleE9mKFwiKG5vZGUuanM6XCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogXCJhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKVwiXG4gICAgLy8gSW4gSUUxMCBmdW5jdGlvbiBuYW1lIGNhbiBoYXZlIHNwYWNlcyAoXCJBbm9ueW1vdXMgZnVuY3Rpb25cIikgT19vXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiBcImF0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6IFwiZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mykge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG5cbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgIHZhciBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSBxRmlsZU5hbWUgJiZcbiAgICAgICAgbGluZU51bWJlciA+PSBxU3RhcnRpbmdMaW5lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPD0gcUVuZGluZ0xpbmU7XG59XG5cbi8vIGRpc2NvdmVyIG93biBmaWxlIG5hbWUgYW5kIGxpbmUgbnVtYmVyIHJhbmdlIGZvciBmaWx0ZXJpbmcgc3RhY2tcbi8vIHRyYWNlc1xuZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoXCJAXCIpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHFGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShjYWxsYmFjaywgbmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBhbHRlcm5hdGl2ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIiwgbmV3IEVycm9yKFwiXCIpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gZW5kIG9mIHNoaW1zXG4vLyBiZWdpbm5pbmcgb2YgcmVhbCB3b3JrXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UsIHBhc3NlcyBwcm9taXNlcyB0aHJvdWdoLCBvclxuICogY29lcmNlcyBwcm9taXNlcyBmcm9tIGRpZmZlcmVudCBzeXN0ZW1zLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2Ugb3IgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBRKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgUHJvbWlzZSwgcmV0dXJuIGl0IGRpcmVjdGx5LiAgVGhpcyBlbmFibGVzXG4gICAgLy8gdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYm90aCBiZSB1c2VkIHRvIGNyZWF0ZWQgcmVmZXJlbmNlcyBmcm9tIG9iamVjdHMsXG4gICAgLy8gYnV0IHRvIHRvbGVyYWJseSBjb2VyY2Ugbm9uLXByb21pc2VzIHRvIHByb21pc2VzLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGFzc2ltaWxhdGUgdGhlbmFibGVzXG4gICAgaWYgKGlzUHJvbWlzZUFsaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVsZmlsbCh2YWx1ZSk7XG4gICAgfVxufVxuUS5yZXNvbHZlID0gUTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHRhc2sgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2tcbiAqL1xuUS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4vKipcbiAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGxvbmcgc3RhY2sgdHJhY2VzIHdpbGwgYmUgb25cbiAqL1xuUS5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG5cbi8vIGVuYWJsZSBsb25nIHN0YWNrcyBpZiBRX0RFQlVHIGlzIHNldFxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuUV9ERUJVRykge1xuICAgIFEubG9uZ1N0YWNrU3VwcG9ydCA9IHRydWU7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHtwcm9taXNlLCByZXNvbHZlLCByZWplY3R9IG9iamVjdC5cbiAqXG4gKiBgcmVzb2x2ZWAgaXMgYSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBhIG1vcmUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoZVxuICogcHJvbWlzZS4gVG8gZnVsZmlsbCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGFueSB2YWx1ZSB0aGF0IGlzXG4gKiBub3QgYSB0aGVuYWJsZS4gVG8gcmVqZWN0IHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYSByZWplY3RlZFxuICogdGhlbmFibGUsIG9yIGludm9rZSBgcmVqZWN0YCB3aXRoIHRoZSByZWFzb24gZGlyZWN0bHkuIFRvIHJlc29sdmUgdGhlXG4gKiBwcm9taXNlIHRvIGFub3RoZXIgdGhlbmFibGUsIHRodXMgcHV0dGluZyBpdCBpbiB0aGUgc2FtZSBzdGF0ZSwgaW52b2tlXG4gKiBgcmVzb2x2ZWAgd2l0aCB0aGF0IG90aGVyIHRoZW5hYmxlLlxuICovXG5RLmRlZmVyID0gZGVmZXI7XG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgICAvLyBpZiBcIm1lc3NhZ2VzXCIgaXMgYW4gXCJBcnJheVwiLCB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSBwcm9taXNlIGhhcyBub3QgeWV0XG4gICAgLy8gYmVlbiByZXNvbHZlZC4gIElmIGl0IGlzIFwidW5kZWZpbmVkXCIsIGl0IGhhcyBiZWVuIHJlc29sdmVkLiAgRWFjaFxuICAgIC8vIGVsZW1lbnQgb2YgdGhlIG1lc3NhZ2VzIGFycmF5IGlzIGl0c2VsZiBhbiBhcnJheSBvZiBjb21wbGV0ZSBhcmd1bWVudHMgdG9cbiAgICAvLyBmb3J3YXJkIHRvIHRoZSByZXNvbHZlZCBwcm9taXNlLiAgV2UgY29lcmNlIHRoZSByZXNvbHV0aW9uIHZhbHVlIHRvIGFcbiAgICAvLyBwcm9taXNlIHVzaW5nIHRoZSBgcmVzb2x2ZWAgZnVuY3Rpb24gYmVjYXVzZSBpdCBoYW5kbGVzIGJvdGggZnVsbHlcbiAgICAvLyBub24tdGhlbmFibGUgdmFsdWVzIGFuZCBvdGhlciB0aGVuYWJsZXMgZ3JhY2VmdWxseS5cbiAgICB2YXIgbWVzc2FnZXMgPSBbXSwgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXSwgcmVzb2x2ZWRQcm9taXNlO1xuXG4gICAgdmFyIGRlZmVycmVkID0gb2JqZWN0X2NyZWF0ZShkZWZlci5wcm90b3R5cGUpO1xuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgb3BlcmFuZHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goYXJncyk7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwid2hlblwiICYmIG9wZXJhbmRzWzFdKSB7IC8vIHByb2dyZXNzIG9wZXJhbmRcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVycy5wdXNoKG9wZXJhbmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkocmVzb2x2ZWRQcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkXG4gICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWFyZXJWYWx1ZSA9IG5lYXJlcihyZXNvbHZlZFByb21pc2UpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKG5lYXJlclZhbHVlKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmVhcmVyVmFsdWU7IC8vIHNob3J0ZW4gY2hhaW5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVyVmFsdWU7XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInBlbmRpbmdcIiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFByb21pc2UuaW5zcGVjdCgpO1xuICAgIH07XG5cbiAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGRvbid0IHRyeSB0byB1c2UgYEVycm9yLmNhcHR1cmVTdGFja1RyYWNlYCBvciB0cmFuc2ZlciB0aGVcbiAgICAgICAgICAgIC8vIGFjY2Vzc29yIGFyb3VuZDsgdGhhdCBjYXVzZXMgbWVtb3J5IGxlYWtzIGFzIHBlciBHSC0xMTEuIEp1c3RcbiAgICAgICAgICAgIC8vIHJlaWZ5IHRoZSBzdGFjayB0cmFjZSBhcyBhIHN0cmluZyBBU0FQLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUsIGN1dCBvZmYgdGhlIGZpcnN0IGxpbmU7IGl0J3MgYWx3YXlzIGp1c3RcbiAgICAgICAgICAgIC8vIFwiW29iamVjdCBQcm9taXNlXVxcblwiLCBhcyBwZXIgdGhlIGB0b1N0cmluZ2AuXG4gICAgICAgICAgICBwcm9taXNlLnN0YWNrID0gZS5zdGFjay5zdWJzdHJpbmcoZS5zdGFjay5pbmRleE9mKFwiXFxuXCIpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSBkbyB0aGUgY2hlY2tzIGZvciBgcmVzb2x2ZWRQcm9taXNlYCBpbiBlYWNoIG1ldGhvZCwgaW5zdGVhZCBvZlxuICAgIC8vIGNvbnNvbGlkYXRpbmcgdGhlbSBpbnRvIGBiZWNvbWVgLCBzaW5jZSBvdGhlcndpc2Ugd2UnZCBjcmVhdGUgbmV3XG4gICAgLy8gcHJvbWlzZXMgd2l0aCB0aGUgbGluZXMgYGJlY29tZSh3aGF0ZXZlcih2YWx1ZSkpYC4gU2VlIGUuZy4gR0gtMjUyLlxuXG4gICAgZnVuY3Rpb24gYmVjb21lKG5ld1Byb21pc2UpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmV3UHJvbWlzZTtcbiAgICAgICAgcHJvbWlzZS5zb3VyY2UgPSBuZXdQcm9taXNlO1xuXG4gICAgICAgIGFycmF5X3JlZHVjZShtZXNzYWdlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkobmV3UHJvbWlzZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcblxuICAgICAgICBtZXNzYWdlcyA9IHZvaWQgMDtcbiAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoUSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShmdWxmaWxsKHZhbHVlKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShyZWplY3QocmVhc29uKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb2dyZXNzTGlzdGVuZXJzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZFxuICogcHJvbWlzZS5cbiAqIEByZXR1cm5zIGEgbm9kZWJhY2tcbiAqL1xuZGVmZXIucHJvdG90eXBlLm1ha2VOb2RlUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUoYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHJlc29sdmVyIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm90aGluZyBhbmQgYWNjZXB0c1xuICogdGhlIHJlc29sdmUsIHJlamVjdCwgYW5kIG5vdGlmeSBmdW5jdGlvbnMgZm9yIGEgZGVmZXJyZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVzb2x2ZSBhbmQgcmVqZWN0XG4gKiBmdW5jdGlvbnMsIG9yIHJlamVjdGVkIGJ5IGEgdGhyb3duIGV4Y2VwdGlvbiBpbiByZXNvbHZlclxuICovXG5RLlByb21pc2UgPSBwcm9taXNlOyAvLyBFUzZcblEucHJvbWlzZSA9IHByb21pc2U7XG5mdW5jdGlvbiBwcm9taXNlKHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5wcm9taXNlLnJhY2UgPSByYWNlOyAvLyBFUzZcbnByb21pc2UuYWxsID0gYWxsOyAvLyBFUzZcbnByb21pc2UucmVqZWN0ID0gcmVqZWN0OyAvLyBFUzZcbnByb21pc2UucmVzb2x2ZSA9IFE7IC8vIEVTNlxuXG4vLyBYWFggZXhwZXJpbWVudGFsLiAgVGhpcyBtZXRob2QgaXMgYSB3YXkgdG8gZGVub3RlIHRoYXQgYSBsb2NhbCB2YWx1ZSBpc1xuLy8gc2VyaWFsaXphYmxlIGFuZCBzaG91bGQgYmUgaW1tZWRpYXRlbHkgZGlzcGF0Y2hlZCB0byBhIHJlbW90ZSB1cG9uIHJlcXVlc3QsXG4vLyBpbnN0ZWFkIG9mIHBhc3NpbmcgYSByZWZlcmVuY2UuXG5RLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucGFzc0J5Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiB0d28gcHJvbWlzZXMgZXZlbnR1YWxseSBmdWxmaWxsIHRvIHRoZSBzYW1lIHZhbHVlLCBwcm9taXNlcyB0aGF0IHZhbHVlLFxuICogYnV0IG90aGVyd2lzZSByZWplY3RzLlxuICogQHBhcmFtIHgge0FueSp9XG4gKiBAcGFyYW0geSB7QW55Kn1cbiAqIEByZXR1cm5zIHtBbnkqfSBhIHByb21pc2UgZm9yIHggYW5kIHkgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGJ1dCBhIHJlamVjdGlvblxuICogb3RoZXJ3aXNlLlxuICpcbiAqL1xuUS5qb2luID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gUSh4KS5qb2luKHkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgcmV0dXJuIFEoW3RoaXMsIHRoYXRdKS5zcHJlYWQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFwiPT09XCIgc2hvdWxkIGJlIE9iamVjdC5pcyBvciBlcXVpdlxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBqb2luOiBub3QgdGhlIHNhbWU6IFwiICsgeCArIFwiIFwiICsgeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBmaXJzdCBvZiBhbiBhcnJheSBvZiBwcm9taXNlcyB0byBiZWNvbWUgc2V0dGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheVtBbnkqXX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge0FueSp9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIHNldHRsZWRcbiAqL1xuUS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoYW5zd2VyUHMpIHtcbiAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHRoaXMgb25jZSB3ZSBjYW4gYXNzdW1lIGF0IGxlYXN0IEVTNVxuICAgICAgICAvLyBhbnN3ZXJQcy5mb3JFYWNoKGZ1bmN0aW9uKGFuc3dlclApIHtcbiAgICAgICAgLy8gICAgIFEoYW5zd2VyUCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gVXNlIHRoaXMgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbnN3ZXJQcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgUShhbnN3ZXJQc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihRLnJhY2UpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgUHJvbWlzZSB3aXRoIGEgcHJvbWlzZSBkZXNjcmlwdG9yIG9iamVjdCBhbmQgb3B0aW9uYWwgZmFsbGJhY2tcbiAqIGZ1bmN0aW9uLiAgVGhlIGRlc2NyaXB0b3IgY29udGFpbnMgbWV0aG9kcyBsaWtlIHdoZW4ocmVqZWN0ZWQpLCBnZXQobmFtZSksXG4gKiBzZXQobmFtZSwgdmFsdWUpLCBwb3N0KG5hbWUsIGFyZ3MpLCBhbmQgZGVsZXRlKG5hbWUpLCB3aGljaCBhbGxcbiAqIHJldHVybiBlaXRoZXIgYSB2YWx1ZSwgYSBwcm9taXNlIGZvciBhIHZhbHVlLCBvciBhIHJlamVjdGlvbi4gIFRoZSBmYWxsYmFja1xuICogYWNjZXB0cyB0aGUgb3BlcmF0aW9uIG5hbWUsIGEgcmVzb2x2ZXIsIGFuZCBhbnkgZnVydGhlciBhcmd1bWVudHMgdGhhdCB3b3VsZFxuICogaGF2ZSBiZWVuIGZvcndhcmRlZCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIGFib3ZlIGhhZCBhIG1ldGhvZCBiZWVuXG4gKiBwcm92aWRlZCB3aXRoIHRoZSBwcm9wZXIgbmFtZS4gIFRoZSBBUEkgbWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCB0aGUgbmF0dXJlXG4gKiBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LCBhcGFydCBmcm9tIHRoYXQgaXQgaXMgdXNhYmxlIHdoZXJlZXZlciBwcm9taXNlcyBhcmVcbiAqIGJvdWdodCBhbmQgc29sZC5cbiAqL1xuUS5tYWtlUHJvbWlzZSA9IFByb21pc2U7XG5mdW5jdGlvbiBQcm9taXNlKGRlc2NyaXB0b3IsIGZhbGxiYWNrLCBpbnNwZWN0KSB7XG4gICAgaWYgKGZhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUHJvbWlzZSBkb2VzIG5vdCBzdXBwb3J0IG9wZXJhdGlvbjogXCIgKyBvcFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnNwZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdGU6IFwidW5rbm93blwifTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yW29wXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlc2NyaXB0b3Jbb3BdLmFwcGx5KHByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFjay5jYWxsKHByb21pc2UsIG9wLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZCBgdmFsdWVPZmAgYW5kIGBleGNlcHRpb25gIHN1cHBvcnRcbiAgICBpZiAoaW5zcGVjdCkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgIHByb21pc2UuZXhjZXB0aW9uID0gaW5zcGVjdGVkLnJlYXNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInBlbmRpbmdcIiB8fFxuICAgICAgICAgICAgICAgIGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgZG9uZSA9IGZhbHNlOyAgIC8vIGVuc3VyZSB0aGUgdW50cnVzdGVkIHByb21pc2UgbWFrZXMgYXQgbW9zdCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2FsbCB0byBvbmUgb2YgdGhlIGNhbGxiYWNrc1xuXG4gICAgZnVuY3Rpb24gX2Z1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmdWxmaWxsZWQgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bGZpbGxlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVqZWN0ZWQoZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGV4Y2VwdGlvbiwgc2VsZik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RlZChleGNlcHRpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAobmV3RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXdFeGNlcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcHJvZ3Jlc3NlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2dyZXNzZWQgPT09IFwiZnVuY3Rpb25cIiA/IHByb2dyZXNzZWQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfZnVsZmlsbGVkKHZhbHVlKSk7XG4gICAgICAgIH0sIFwid2hlblwiLCBbZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfcmVqZWN0ZWQoZXhjZXB0aW9uKSk7XG4gICAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIC8vIFByb2dyZXNzIHByb3BhZ2F0b3IgbmVlZCB0byBiZSBhdHRhY2hlZCBpbiB0aGUgY3VycmVudCB0aWNrLlxuICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKHZvaWQgMCwgXCJ3aGVuXCIsIFt2b2lkIDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfcHJvZ3Jlc3NlZCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5RLnRhcCA9IGZ1bmN0aW9uIChwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRhcChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFdvcmtzIGFsbW9zdCBsaWtlIFwiZmluYWxseVwiLCBidXQgbm90IGNhbGxlZCBmb3IgcmVqZWN0aW9ucy5cbiAqIE9yaWdpbmFsIHJlc29sdXRpb24gdmFsdWUgaXMgcGFzc2VkIHRocm91Z2ggY2FsbGJhY2sgdW5hZmZlY3RlZC5cbiAqIENhbGxiYWNrIG1heSByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBhd2FpdGVkIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7US5Qcm9taXNlfVxuICogQGV4YW1wbGVcbiAqIGRvU29tZXRoaW5nKClcbiAqICAgLnRoZW4oLi4uKVxuICogICAudGFwKGNvbnNvbGUubG9nKVxuICogICAudGhlbiguLi4pO1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKHZhbHVlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBvYnNlcnZlciBvbiBhIHByb21pc2UuXG4gKlxuICogR3VhcmFudGVlczpcbiAqXG4gKiAxLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLlxuICogMi4gdGhhdCBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBjYWxsYmFjayBvciB0aGUgcmVqZWN0ZWQgY2FsbGJhY2sgd2lsbCBiZVxuICogICAgY2FsbGVkLCBidXQgbm90IGJvdGguXG4gKiAzLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBub3QgYmUgY2FsbGVkIGluIHRoaXMgdHVybi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGZ1bGZpbGxlZCAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogQHBhcmFtIHJlamVjdGVkICAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlamVjdGlvbiBleGNlcHRpb25cbiAqIEBwYXJhbSBwcm9ncmVzc2VkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGludm9rZWQgY2FsbGJhY2tcbiAqL1xuUS53aGVuID0gd2hlbjtcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn07XG5cblEudGhlblJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyByZWFzb247IH0pO1xufTtcblxuUS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZWplY3QocmVhc29uKTtcbn07XG5cbi8qKlxuICogSWYgYW4gb2JqZWN0IGlzIG5vdCBhIHByb21pc2UsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlLlxuICogSWYgYSBwcm9taXNlIGlzIHJlamVjdGVkLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZSB0b28uXG4gKiBJZiBpdOKAmXMgYSBmdWxmaWxsZWQgcHJvbWlzZSwgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5lYXJlci5cbiAqIElmIGl04oCZcyBhIGRlZmVycmVkIHByb21pc2UgYW5kIHRoZSBkZWZlcnJlZCBoYXMgYmVlbiByZXNvbHZlZCwgdGhlXG4gKiByZXNvbHV0aW9uIGlzIFwibmVhcmVyXCIuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBtb3N0IHJlc29sdmVkIChuZWFyZXN0KSBmb3JtIG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vLyBYWFggc2hvdWxkIHdlIHJlLWRvIHRoaXM/XG5RLm5lYXJlciA9IG5lYXJlcjtcbmZ1bmN0aW9uIG5lYXJlcih2YWx1ZSkge1xuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB2YWx1ZS5pbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2UuXG4gKiBPdGhlcndpc2UgaXQgaXMgYSBmdWxmaWxsZWQgdmFsdWUuXG4gKi9cblEuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBQcm9taXNlO1xufVxuXG5RLmlzUHJvbWlzZUFsaWtlID0gaXNQcm9taXNlQWxpa2U7XG5mdW5jdGlvbiBpc1Byb21pc2VBbGlrZShvYmplY3QpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwZW5kaW5nIHByb21pc2UsIG1lYW5pbmcgbm90XG4gKiBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gKi9cblEuaXNQZW5kaW5nID0gaXNQZW5kaW5nO1xuZnVuY3Rpb24gaXNQZW5kaW5nKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHZhbHVlIG9yIGZ1bGZpbGxlZFxuICogcHJvbWlzZS5cbiAqL1xuUS5pc0Z1bGZpbGxlZCA9IGlzRnVsZmlsbGVkO1xuZnVuY3Rpb24gaXNGdWxmaWxsZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuICFpc1Byb21pc2Uob2JqZWN0KSB8fCBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHJlamVjdGVkIHByb21pc2UuXG4gKi9cblEuaXNSZWplY3RlZCA9IGlzUmVqZWN0ZWQ7XG5mdW5jdGlvbiBpc1JlamVjdGVkKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59O1xuXG4vLy8vIEJFR0lOIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLy8gVGhpcyBwcm9taXNlIGxpYnJhcnkgY29uc3VtZXMgZXhjZXB0aW9ucyB0aHJvd24gaW4gaGFuZGxlcnMgc28gdGhleSBjYW4gYmVcbi8vIGhhbmRsZWQgYnkgYSBzdWJzZXF1ZW50IHByb21pc2UuICBUaGUgZXhjZXB0aW9ucyBnZXQgYWRkZWQgdG8gdGhpcyBhcnJheSB3aGVuXG4vLyB0aGV5IGFyZSBjcmVhdGVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZXkgYXJlIGhhbmRsZWQuICBOb3RlIHRoYXQgaW4gRVM2IG9yXG4vLyBzaGltbWVkIGVudmlyb25tZW50cywgdGhpcyB3b3VsZCBuYXR1cmFsbHkgYmUgYSBgU2V0YC5cbnZhciB1bmhhbmRsZWRSZWFzb25zID0gW107XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG5cbmZ1bmN0aW9uIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpIHtcbiAgICB1bmhhbmRsZWRSZWFzb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChyZWFzb24uc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChcIihubyBzdGFjaykgXCIgKyByZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW50cmFja1JlamVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdCA9IGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgaWYgKGF0ICE9PSAtMSkge1xuICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdCwgMSk7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICB9XG59XG5cblEucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zID0gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zO1xuXG5RLmdldFVuaGFuZGxlZFJlYXNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gdGhhdCBjb25zdW1lcnMgY2FuJ3QgaW50ZXJmZXJlIHdpdGggb3VyIGludGVybmFsIHN0YXRlLlxuICAgIHJldHVybiB1bmhhbmRsZWRSZWFzb25zLnNsaWNlKCk7XG59O1xuXG5RLnN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmYWxzZTtcbn07XG5cbnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuXG4vLy8vIEVORCBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHJlamVjdGVkIHByb21pc2UuXG4gKiBAcGFyYW0gcmVhc29uIHZhbHVlIGRlc2NyaWJpbmcgdGhlIGZhaWx1cmVcbiAqL1xuUS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHJlamVjdGlvbiA9IFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhlIGVycm9yIGhhcyBiZWVuIGhhbmRsZWRcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHVudHJhY2tSZWplY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZChyZWFzb24pIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJyZWplY3RlZFwiLCByZWFzb246IHJlYXNvbiB9O1xuICAgIH0pO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSByZWFzb24gaGFzIG5vdCBiZWVuIGhhbmRsZWQuXG4gICAgdHJhY2tSZWplY3Rpb24ocmVqZWN0aW9uLCByZWFzb24pO1xuXG4gICAgcmV0dXJuIHJlamVjdGlvbjtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZnVsZmlsbGVkIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZVxuICovXG5RLmZ1bGZpbGwgPSBmdWxmaWxsO1xuZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJnZXRcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXRcIjogZnVuY3Rpb24gKG5hbWUsIHJocykge1xuICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSByaHM7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9zdFwiOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgICAgICAgICAgLy8gTWFyayBNaWxsZXIgcHJvcG9zZXMgdGhhdCBwb3N0IHdpdGggbm8gbmFtZSBzaG91bGQgYXBwbHkgYVxuICAgICAgICAgICAgLy8gcHJvbWlzZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCB8fCBuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhcHBseVwiOiBmdW5jdGlvbiAodGhpc3AsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzcCwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwia2V5c1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0X2tleXModmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgdm9pZCAwLCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJmdWxmaWxsZWRcIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlbmFibGVzIHRvIFEgcHJvbWlzZXMuXG4gKiBAcGFyYW0gcHJvbWlzZSB0aGVuYWJsZSBwcm9taXNlXG4gKiBAcmV0dXJucyBhIFEgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb2VyY2UocHJvbWlzZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbi8qKlxuICogQW5ub3RhdGVzIGFuIG9iamVjdCBzdWNoIHRoYXQgaXQgd2lsbCBuZXZlciBiZVxuICogdHJhbnNmZXJyZWQgYXdheSBmcm9tIHRoaXMgcHJvY2VzcyBvdmVyIGFueSBwcm9taXNlXG4gKiBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBwcm9taXNlIGEgd3JhcHBpbmcgb2YgdGhhdCBvYmplY3QgdGhhdFxuICogYWRkaXRpb25hbGx5IHJlc3BvbmRzIHRvIHRoZSBcImlzRGVmXCIgbWVzc2FnZVxuICogd2l0aG91dCBhIHJlamVjdGlvbi5cbiAqL1xuUS5tYXN0ZXIgPSBtYXN0ZXI7XG5mdW5jdGlvbiBtYXN0ZXIob2JqZWN0KSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcImlzRGVmXCI6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2sob3AsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFEob2JqZWN0KS5pbnNwZWN0KCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogU3ByZWFkcyB0aGUgdmFsdWVzIG9mIGEgcHJvbWlzZWQgYXJyYXkgb2YgYXJndW1lbnRzIGludG8gdGhlXG4gKiBmdWxmaWxsbWVudCBjYWxsYmFjay5cbiAqIEBwYXJhbSBmdWxmaWxsZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB2YXJpYWRpYyBhcmd1bWVudHMgZnJvbSB0aGVcbiAqIHByb21pc2VkIGFycmF5XG4gKiBAcGFyYW0gcmVqZWN0ZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgZXhjZXB0aW9uIGlmIHRoZSBwcm9taXNlXG4gKiBpcyByZWplY3RlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvciB0aHJvd24gZXhjZXB0aW9uIG9mXG4gKiBlaXRoZXIgY2FsbGJhY2suXG4gKi9cblEuc3ByZWFkID0gc3ByZWFkO1xuZnVuY3Rpb24gc3ByZWFkKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnNwcmVhZChmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hbGwoKS50aGVuKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkLmFwcGx5KHZvaWQgMCwgYXJyYXkpO1xuICAgIH0sIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogVGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGEgZGVjb3JhdG9yIGZvciBnZW5lcmF0b3IgZnVuY3Rpb25zLCB0dXJuaW5nXG4gKiB0aGVtIGludG8gYXN5bmNocm9ub3VzIGdlbmVyYXRvcnMuICBBbHRob3VnaCBnZW5lcmF0b3JzIGFyZSBvbmx5IHBhcnRcbiAqIG9mIHRoZSBuZXdlc3QgRUNNQVNjcmlwdCA2IGRyYWZ0cywgdGhpcyBjb2RlIGRvZXMgbm90IGNhdXNlIHN5bnRheFxuICogZXJyb3JzIGluIG9sZGVyIGVuZ2luZXMuICBUaGlzIGNvZGUgc2hvdWxkIGNvbnRpbnVlIHRvIHdvcmsgYW5kIHdpbGxcbiAqIGluIGZhY3QgaW1wcm92ZSBvdmVyIHRpbWUgYXMgdGhlIGxhbmd1YWdlIGltcHJvdmVzLlxuICpcbiAqIEVTNiBnZW5lcmF0b3JzIGFyZSBjdXJyZW50bHkgcGFydCBvZiBWOCB2ZXJzaW9uIDMuMTkgd2l0aCB0aGVcbiAqIC0taGFybW9ueS1nZW5lcmF0b3JzIHJ1bnRpbWUgZmxhZyBlbmFibGVkLiAgU3BpZGVyTW9ua2V5IGhhcyBoYWQgdGhlbVxuICogZm9yIGxvbmdlciwgYnV0IHVuZGVyIGFuIG9sZGVyIFB5dGhvbi1pbnNwaXJlZCBmb3JtLiAgVGhpcyBmdW5jdGlvblxuICogd29ya3Mgb24gYm90aCBraW5kcyBvZiBnZW5lcmF0b3JzLlxuICpcbiAqIERlY29yYXRlcyBhIGdlbmVyYXRvciBmdW5jdGlvbiBzdWNoIHRoYXQ6XG4gKiAgLSBpdCBtYXkgeWllbGQgcHJvbWlzZXNcbiAqICAtIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHdoZW4gdGhhdCBwcm9taXNlIGlzIGZ1bGZpbGxlZFxuICogIC0gdGhlIHZhbHVlIG9mIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpbGwgYmUgdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogIC0gaXQgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgKHdoZW4gdGhlIGdlbmVyYXRvclxuICogICAgc3RvcHMgaXRlcmF0aW5nKVxuICogIC0gdGhlIGRlY29yYXRlZCBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICogICAgb2YgdGhlIGdlbmVyYXRvciBvciB0aGUgZmlyc3QgcmVqZWN0ZWQgcHJvbWlzZSBhbW9uZyB0aG9zZVxuICogICAgeWllbGRlZC5cbiAqICAtIGlmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgZ2VuZXJhdG9yLCBpdCBwcm9wYWdhdGVzIHRocm91Z2hcbiAqICAgIGV2ZXJ5IGZvbGxvd2luZyB5aWVsZCB1bnRpbCBpdCBpcyBjYXVnaHQsIG9yIHVudGlsIGl0IGVzY2FwZXNcbiAqICAgIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gYWx0b2dldGhlciwgYW5kIGlzIHRyYW5zbGF0ZWQgaW50byBhXG4gKiAgICByZWplY3Rpb24gZm9yIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSBkZWNvcmF0ZWQgZ2VuZXJhdG9yLlxuICovXG5RLmFzeW5jID0gYXN5bmM7XG5mdW5jdGlvbiBhc3luYyhtYWtlR2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwic2VuZFwiLCBhcmcgaXMgYSB2YWx1ZVxuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJ0aHJvd1wiLCBhcmcgaXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRpbnVlcih2ZXJiLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8vIFVudGlsIFY4IDMuMTkgLyBDaHJvbWl1bSAyOSBpcyByZWxlYXNlZCwgU3BpZGVyTW9ua2V5IGlzIHRoZSBvbmx5XG4gICAgICAgICAgICAvLyBlbmdpbmUgdGhhdCBoYXMgYSBkZXBsb3llZCBiYXNlIG9mIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgU00ncyBnZW5lcmF0b3JzIHVzZSB0aGUgUHl0aG9uLWluc3BpcmVkIHNlbWFudGljcyBvZlxuICAgICAgICAgICAgLy8gb3V0ZGF0ZWQgRVM2IGRyYWZ0cy4gIFdlIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBFUzYsIGJ1dCB3ZSdkIGFsc29cbiAgICAgICAgICAgIC8vIGxpa2UgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZ2VuZXJhdG9ycyBpbiBkZXBsb3llZCBicm93c2Vycywgc29cbiAgICAgICAgICAgIC8vIHdlIGFsc28gc3VwcG9ydCBQeXRob24tc3R5bGUgZ2VuZXJhdG9ycy4gIEF0IHNvbWUgcG9pbnQgd2UgY2FuIHJlbW92ZVxuICAgICAgICAgICAgLy8gdGhpcyBibG9jay5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTdG9wSXRlcmF0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRVM2IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQudmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNwaWRlck1vbmtleSBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFJlbW92ZSB0aGlzIGNhc2Ugd2hlbiBTTSBkb2VzIEVTNiBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBRKGV4Y2VwdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IG1ha2VHZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcIm5leHRcIik7XG4gICAgICAgIHZhciBlcnJiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcInRocm93XCIpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzcGF3biBmdW5jdGlvbiBpcyBhIHNtYWxsIHdyYXBwZXIgYXJvdW5kIGFzeW5jIHRoYXQgaW1tZWRpYXRlbHlcbiAqIGNhbGxzIHRoZSBnZW5lcmF0b3IgYW5kIGFsc28gZW5kcyB0aGUgcHJvbWlzZSBjaGFpbiwgc28gdGhhdCBhbnlcbiAqIHVuaGFuZGxlZCBlcnJvcnMgYXJlIHRocm93biBpbnN0ZWFkIG9mIGZvcndhcmRlZCB0byB0aGUgZXJyb3JcbiAqIGhhbmRsZXIuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgaXQncyBleHRyZW1lbHkgY29tbW9uIHRvIHJ1blxuICogZ2VuZXJhdG9ycyBhdCB0aGUgdG9wLWxldmVsIHRvIHdvcmsgd2l0aCBsaWJyYXJpZXMuXG4gKi9cblEuc3Bhd24gPSBzcGF3bjtcbmZ1bmN0aW9uIHNwYXduKG1ha2VHZW5lcmF0b3IpIHtcbiAgICBRLmRvbmUoUS5hc3luYyhtYWtlR2VuZXJhdG9yKSgpKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGludGVyZmFjZSBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG4vKipcbiAqIFRocm93cyBhIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB0byBzdG9wIGFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3IuXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgYSBzdG9wLWdhcCBtZWFzdXJlIHRvIHN1cHBvcnQgZ2VuZXJhdG9yIHJldHVyblxuICogdmFsdWVzIGluIG9sZGVyIEZpcmVmb3gvU3BpZGVyTW9ua2V5LiAgSW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEVTNlxuICogZ2VuZXJhdG9ycyBsaWtlIENocm9taXVtIDI5LCBqdXN0IHVzZSBcInJldHVyblwiIGluIHlvdXIgZ2VuZXJhdG9yXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHRoZSBzdXJyb3VuZGluZyBnZW5lcmF0b3JcbiAqIEB0aHJvd3MgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHdpdGggdGhlIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIC8vIEVTNiBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiogKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICByZXR1cm4gZm9vICsgYmFyO1xuICogfSlcbiAqIC8vIE9sZGVyIFNwaWRlck1vbmtleSBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIFEucmV0dXJuKGZvbyArIGJhcik7XG4gKiB9KVxuICovXG5RW1wicmV0dXJuXCJdID0gX3JldHVybjtcbmZ1bmN0aW9uIF9yZXR1cm4odmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgUVJldHVyblZhbHVlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgcHJvbWlzZWQgZnVuY3Rpb24gZGVjb3JhdG9yIGVuc3VyZXMgdGhhdCBhbnkgcHJvbWlzZSBhcmd1bWVudHNcbiAqIGFyZSBzZXR0bGVkIGFuZCBwYXNzZWQgYXMgdmFsdWVzIChgdGhpc2AgaXMgYWxzbyBzZXR0bGVkIGFuZCBwYXNzZWRcbiAqIGFzIGEgdmFsdWUpLiAgSXQgd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgb2YgYSBmdW5jdGlvbiBpc1xuICogYWx3YXlzIGEgcHJvbWlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGFkZCA9IFEucHJvbWlzZWQoZnVuY3Rpb24gKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqIGFkZChRKGEpLCBRKEIpKTtcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZGVjb3JhdGVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZC5cbiAqL1xuUS5wcm9taXNlZCA9IHByb21pc2VkO1xuZnVuY3Rpb24gcHJvbWlzZWQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3ByZWFkKFt0aGlzLCBhbGwoYXJndW1lbnRzKV0sIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogc2VuZHMgYSBtZXNzYWdlIHRvIGEgdmFsdWUgaW4gYSBmdXR1cmUgdHVyblxuICogQHBhcmFtIG9iamVjdCogdGhlIHJlY2lwaWVudFxuICogQHBhcmFtIG9wIHRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIG9wZXJhdGlvbiwgZS5nLiwgXCJ3aGVuXCIsXG4gKiBAcGFyYW0gYXJncyBmdXJ0aGVyIGFyZ3VtZW50cyB0byBiZSBmb3J3YXJkZWQgdG8gdGhlIG9wZXJhdGlvblxuICogQHJldHVybnMgcmVzdWx0IHtQcm9taXNlfSBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuICovXG5RLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5mdW5jdGlvbiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChvcCwgYXJncyk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKG9wLCBhcmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGRlZmVycmVkLnJlc29sdmUsIG9wLCBhcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBnZXRcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHByb3BlcnR5IHZhbHVlXG4gKi9cblEuZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3Igb2JqZWN0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHZhbHVlICAgICBuZXcgdmFsdWUgb2YgcHJvcGVydHlcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBkZWxldGVcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLmRlbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gdmFsdWUgICAgIGEgdmFsdWUgdG8gcG9zdCwgdHlwaWNhbGx5IGFuIGFycmF5IG9mXG4gKiAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gYXJndW1lbnRzIGZvciBwcm9taXNlcyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgIGFyZSB1bHRpbWF0ZWx5IGJhY2tlZCB3aXRoIGByZXNvbHZlYCB2YWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgIGFzIG9wcG9zZWQgdG8gdGhvc2UgYmFja2VkIHdpdGggVVJMc1xuICogICAgICAgICAgICAgICAgICB3aGVyZWluIHRoZSBwb3N0ZWQgdmFsdWUgY2FuIGJlIGFueVxuICogICAgICAgICAgICAgICAgICBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuLy8gYm91bmQgbG9jYWxseSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgb3RoZXIgbWV0aG9kc1xuUS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBpbnZvY2F0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5RLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEuaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblByb21pc2UucHJvdG90eXBlLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gYXJncyAgICAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZhcHBseSA9IGZ1bmN0aW9uIChvYmplY3QsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RW1widHJ5XCJdID1cblEuZmNhbGwgPSBmdW5jdGlvbiAob2JqZWN0IC8qIC4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzKV0pO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24sIHRyYW5zZm9ybWluZyByZXR1cm4gdmFsdWVzIGludG8gYSBmdWxmaWxsZWRcbiAqIHByb21pc2UgYW5kIHRocm93biBlcnJvcnMgaW50byBhIHJlamVjdGVkIG9uZS5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmJpbmQgPSBmdW5jdGlvbiAob2JqZWN0IC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSBRKG9iamVjdCk7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuZmJpbmQgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBuYW1lcyBvZiB0aGUgb3duZWQgcHJvcGVydGllcyBvZiBhIHByb21pc2VkXG4gKiBvYmplY3QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBrZXlzIG9mIHRoZSBldmVudHVhbGx5IHNldHRsZWQgb2JqZWN0XG4gKi9cblEua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheS4gIElmIGFueSBvZlxuICogdGhlIHByb21pc2VzIGdldHMgcmVqZWN0ZWQsIHRoZSB3aG9sZSBhcnJheSBpcyByZWplY3RlZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QXJyYXkqfSBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICovXG4vLyBCeSBNYXJrIE1pbGxlclxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9c3RyYXdtYW46Y29uY3VycmVuY3kmcmV2PTEzMDg3NzY1MjEjYWxsZnVsZmlsbGVkXG5RLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgdmFyIGNvdW50RG93biA9IDA7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvbWlzZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc1Byb21pc2UocHJvbWlzZSkgJiZcbiAgICAgICAgICAgICAgICAoc25hcHNob3QgPSBwcm9taXNlLmluc3BlY3QoKSkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHNuYXBzaG90LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICArK2NvdW50RG93bjtcbiAgICAgICAgICAgICAgICB3aGVuKFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tY291bnREb3duID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoeyBpbmRleDogaW5kZXgsIHZhbHVlOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIGlmIChjb3VudERvd24gPT09IDApIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogV2FpdHMgZm9yIGFsbCBwcm9taXNlcyB0byBiZSBzZXR0bGVkLCBlaXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZC4gIFRoaXMgaXMgZGlzdGluY3QgZnJvbSBgYWxsYCBzaW5jZSB0aGF0IHdvdWxkIHN0b3BcbiAqIHdhaXRpbmcgYXQgdGhlIGZpcnN0IHJlamVjdGlvbi4gIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5XG4gKiBgYWxsUmVzb2x2ZWRgIHdpbGwgbmV2ZXIgYmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0gcHJvbWlzZXMgYSBwcm9taXNlIGZvciBhbiBhcnJheSAob3IgYW4gYXJyYXkpIG9mIHByb21pc2VzXG4gKiAob3IgdmFsdWVzKVxuICogQHJldHVybiBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHByb21pc2VzXG4gKi9cblEuYWxsUmVzb2x2ZWQgPSBkZXByZWNhdGUoYWxsUmVzb2x2ZWQsIFwiYWxsUmVzb2x2ZWRcIiwgXCJhbGxTZXR0bGVkXCIpO1xuZnVuY3Rpb24gYWxsUmVzb2x2ZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHByb21pc2VzID0gYXJyYXlfbWFwKHByb21pc2VzLCBRKTtcbiAgICAgICAgcmV0dXJuIHdoZW4oYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGVuKHByb21pc2UsIG5vb3AsIG5vb3ApO1xuICAgICAgICB9KSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbFJlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGxSZXNvbHZlZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQHNlZSBQcm9taXNlI2FsbFNldHRsZWRcbiAqL1xuUS5hbGxTZXR0bGVkID0gYWxsU2V0dGxlZDtcbmZ1bmN0aW9uIGFsbFNldHRsZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gUShwcm9taXNlcykuYWxsU2V0dGxlZCgpO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGVpciBzdGF0ZXMgKGFzXG4gKiByZXR1cm5lZCBieSBgaW5zcGVjdGApIHdoZW4gdGhleSBoYXZlIGFsbCBzZXR0bGVkLlxuICogQHBhcmFtIHtBcnJheVtBbnkqXX0gdmFsdWVzIGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIHtBcnJheVtTdGF0ZV19IGFuIGFycmF5IG9mIHN0YXRlcyBmb3IgdGhlIHJlc3BlY3RpdmUgdmFsdWVzLlxuICovXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxTZXR0bGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHJldHVybiBhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFEocHJvbWlzZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZWdhcmRsZXNzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmluc3BlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVnYXJkbGVzcywgcmVnYXJkbGVzcyk7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2FwdHVyZXMgdGhlIGZhaWx1cmUgb2YgYSBwcm9taXNlLCBnaXZpbmcgYW4gb3BvcnR1bml0eSB0byByZWNvdmVyXG4gKiB3aXRoIGEgY2FsbGJhY2suICBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpcyBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICogcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gZnVsZmlsbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpZiB0aGVcbiAqIGdpdmVuIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2tcbiAqL1xuUS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9iamVjdCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgbGlzdGVuZXIgdGhhdCBjYW4gcmVzcG9uZCB0byBwcm9ncmVzcyBub3RpZmljYXRpb25zIGZyb20gYVxuICogcHJvbWlzZSdzIG9yaWdpbmF0aW5nIGRlZmVycmVkLiBUaGlzIGxpc3RlbmVyIHJlY2VpdmVzIHRoZSBleGFjdCBhcmd1bWVudHNcbiAqIHBhc3NlZCB0byBgYGRlZmVycmVkLm5vdGlmeWBgLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIHJlY2VpdmUgYW55IHByb2dyZXNzIG5vdGlmaWNhdGlvbnNcbiAqIEByZXR1cm5zIHRoZSBnaXZlbiBwcm9taXNlLCB1bmNoYW5nZWRcbiAqL1xuUS5wcm9ncmVzcyA9IHByb2dyZXNzO1xuZnVuY3Rpb24gcHJvZ3Jlc3Mob2JqZWN0LCBwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAocHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhbiBvcHBvcnR1bml0eSB0byBvYnNlcnZlIHRoZSBzZXR0bGluZyBvZiBhIHByb21pc2UsXG4gKiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIG9yIHJlamVjdGVkLiAgRm9yd2FyZHNcbiAqIHRoZSByZXNvbHV0aW9uIHRvIHRoZSByZXR1cm5lZCBwcm9taXNlIHdoZW4gdGhlIGNhbGxiYWNrIGlzIGRvbmUuXG4gKiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiBhIHByb21pc2UgdG8gZGVmZXIgY29tcGxldGlvbi5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gb2JzZXJ2ZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW5cbiAqIHByb21pc2UsIHRha2VzIG5vIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2Ugd2hlblxuICogYGBmaW5gYCBpcyBkb25lLlxuICovXG5RLmZpbiA9IC8vIFhYWCBsZWdhY3lcblFbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpW1wiZmluYWxseVwiXShjYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maW4gPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRPRE8gYXR0ZW1wdCB0byByZWN5Y2xlIHRoZSByZWplY3Rpb24gd2l0aCBcInRoaXNcIi5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUZXJtaW5hdGVzIGEgY2hhaW4gb2YgcHJvbWlzZXMsIGZvcmNpbmcgcmVqZWN0aW9ucyB0byBiZVxuICogdGhyb3duIGFzIGV4Y2VwdGlvbnMuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgYXQgdGhlIGVuZCBvZiBhIGNoYWluIG9mIHByb21pc2VzXG4gKiBAcmV0dXJucyBub3RoaW5nXG4gKi9cblEuZG9uZSA9IGZ1bmN0aW9uIChvYmplY3QsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kb25lKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICB2YXIgb25VbmhhbmRsZWRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBmb3J3YXJkIHRvIGEgZnV0dXJlIHR1cm4gc28gdGhhdCBgYHdoZW5gYFxuICAgICAgICAvLyBkb2VzIG5vdCBjYXRjaCBpdCBhbmQgdHVybiBpdCBpbnRvIGEgcmVqZWN0aW9uLlxuICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoUS5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgUS5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBgbmV4dFRpY2tgaW5nIHZpYSBhbiB1bm5lY2Vzc2FyeSBgd2hlbmAuXG4gICAgdmFyIHByb21pc2UgPSBmdWxmaWxsZWQgfHwgcmVqZWN0ZWQgfHwgcHJvZ3Jlc3MgP1xuICAgICAgICB0aGlzLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIDpcbiAgICAgICAgdGhpcztcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICAgIG9uVW5oYW5kbGVkRXJyb3IgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbih2b2lkIDAsIG9uVW5oYW5kbGVkRXJyb3IpO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGlmIGl0IGRvZXMgbm90IGdldCBmdWxmaWxsZWQgYmVmb3JlXG4gKiBzb21lIG1pbGxpc2Vjb25kcyB0aW1lIG91dC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kcyB0aW1lb3V0XG4gKiBAcGFyYW0ge0FueSp9IGN1c3RvbSBlcnJvciBtZXNzYWdlIG9yIEVycm9yIG9iamVjdCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGlmIGl0IGlzXG4gKiBmdWxmaWxsZWQgYmVmb3JlIHRoZSB0aW1lb3V0LCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gKi9cblEudGltZW91dCA9IGZ1bmN0aW9uIChvYmplY3QsIG1zLCBlcnJvcikge1xuICAgIHJldHVybiBRKG9iamVjdCkudGltZW91dChtcywgZXJyb3IpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgZXJyb3IpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlcnJvciB8fCBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yIHx8IFwiVGltZWQgb3V0IGFmdGVyIFwiICsgbXMgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgfSwgbXMpO1xuXG4gICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfSwgZGVmZXJyZWQubm90aWZ5KTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGdpdmVuIHZhbHVlIChvciBwcm9taXNlZCB2YWx1ZSksIHNvbWVcbiAqIG1pbGxpc2Vjb25kcyBhZnRlciBpdCByZXNvbHZlZC4gUGFzc2VzIHJlamVjdGlvbnMgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgYWZ0ZXIgbWlsbGlzZWNvbmRzXG4gKiB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlLlxuICogSWYgdGhlIGdpdmVuIHByb21pc2UgcmVqZWN0cywgdGhhdCBpcyBwYXNzZWQgaW1tZWRpYXRlbHkuXG4gKi9cblEuZGVsYXkgPSBmdW5jdGlvbiAob2JqZWN0LCB0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aW1lb3V0ID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBRKG9iamVjdCkuZGVsYXkodGltZW91dCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBhcyBhbiBhcnJheSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICpcbiAqICAgICAgUS5uZmFwcGx5KEZTLnJlYWRGaWxlLCBbX19maWxlbmFtZV0pXG4gKiAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiAgICAgIH0pXG4gKlxuICovXG5RLm5mYXBwbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGluZGl2aWR1YWxseSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZjYWxsKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKVxuICogLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqIH0pXG4gKlxuICovXG5RLm5mY2FsbCA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogV3JhcHMgYSBOb2RlSlMgY29udGludWF0aW9uIHBhc3NpbmcgZnVuY3Rpb24gYW5kIHJldHVybnMgYW4gZXF1aXZhbGVudFxuICogdmVyc2lvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZiaW5kKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKShcInV0Zi04XCIpXG4gKiAudGhlbihjb25zb2xlLmxvZylcbiAqIC5kb25lKClcbiAqL1xuUS5uZmJpbmQgPVxuUS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBRKGNhbGxiYWNrKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYmluZCA9XG5Qcm9taXNlLnByb3RvdHlwZS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLmRlbm9kZWlmeS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuUS5uYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3AgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzcCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBRKGJvdW5kKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5iaW5kID0gZnVuY3Rpb24gKC8qdGhpc3AsIC4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAwKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEubmJpbmQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjayB3aXRoIGEgZ2l2ZW4gYXJyYXkgb2YgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWQgY2FsbGJhY2suXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFja1xuICogd2lsbCBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5ucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5wb3N0KG5hbWUsIGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5ucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyB8fCBbXSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrLCBmb3J3YXJkaW5nIHRoZSBnaXZlbiB2YXJpYWRpYyBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZFxuICogY2FsbGJhY2sgYXJndW1lbnQuXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0gLi4uYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2sgd2lsbFxuICogYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5RLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblEubmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUHJvbWlzZS5wcm90b3R5cGUubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUHJvbWlzZS5wcm90b3R5cGUubmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIElmIGEgZnVuY3Rpb24gd291bGQgbGlrZSB0byBzdXBwb3J0IGJvdGggTm9kZSBjb250aW51YXRpb24tcGFzc2luZy1zdHlsZSBhbmRcbiAqIHByb21pc2UtcmV0dXJuaW5nLXN0eWxlLCBpdCBjYW4gZW5kIGl0cyBpbnRlcm5hbCBwcm9taXNlIGNoYWluIHdpdGhcbiAqIGBub2RlaWZ5KG5vZGViYWNrKWAsIGZvcndhcmRpbmcgdGhlIG9wdGlvbmFsIG5vZGViYWNrIGFyZ3VtZW50LiAgSWYgdGhlIHVzZXJcbiAqIGVsZWN0cyB0byB1c2UgYSBub2RlYmFjaywgdGhlIHJlc3VsdCB3aWxsIGJlIHNlbnQgdGhlcmUuICBJZiB0aGV5IGRvIG5vdFxuICogcGFzcyBhIG5vZGViYWNrLCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IHByb21pc2UuXG4gKiBAcGFyYW0gb2JqZWN0IGEgcmVzdWx0IChvciBhIHByb21pc2UgZm9yIGEgcmVzdWx0KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbm9kZWJhY2sgYSBOb2RlLmpzLXN0eWxlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyBlaXRoZXIgdGhlIHByb21pc2Ugb3Igbm90aGluZ1xuICovXG5RLm5vZGVpZnkgPSBub2RlaWZ5O1xuZnVuY3Rpb24gbm9kZWlmeShvYmplY3QsIG5vZGViYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ub2RlaWZ5KG5vZGViYWNrKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjaykge1xuICAgIGlmIChub2RlYmFjaykge1xuICAgICAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gQWxsIGNvZGUgYmVmb3JlIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcy5cbnZhciBxRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbnJldHVybiBRO1xuXG59KTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJJclhVc3VcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ub2RlX21vZHVsZXMvcS9xLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3FcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgc2VsZiA9IHNlbGYgfHwge307Ly8gRmlsZTpzcmMvVGhyZWUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbnZhciBUSFJFRSA9IHsgUkVWSVNJT046ICc2OScgfTtcblxuLy8gYnJvd3NlcmlmeSBzdXBwb3J0XG5cbmlmICggdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcblxufVxuXG4vLyBwb2x5ZmlsbHNcblxuaWYgKCBNYXRoLnNpZ24gPT09IHVuZGVmaW5lZCApIHtcblxuXHRNYXRoLnNpZ24gPSBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHRyZXR1cm4gKCB4IDwgMCApID8gLSAxIDogKCB4ID4gMCApID8gMSA6IDA7XG5cblx0fTtcblxufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC5idXR0b25cblxuVEhSRUUuTU9VU0UgPSB7IExFRlQ6IDAsIE1JRERMRTogMSwgUklHSFQ6IDIgfTtcblxuLy8gR0wgU1RBVEUgQ09OU1RBTlRTXG5cblRIUkVFLkN1bGxGYWNlTm9uZSA9IDA7XG5USFJFRS5DdWxsRmFjZUJhY2sgPSAxO1xuVEhSRUUuQ3VsbEZhY2VGcm9udCA9IDI7XG5USFJFRS5DdWxsRmFjZUZyb250QmFjayA9IDM7XG5cblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG5cbi8vIFNIQURPV0lORyBUWVBFU1xuXG5USFJFRS5CYXNpY1NoYWRvd01hcCA9IDA7XG5USFJFRS5QQ0ZTaGFkb3dNYXAgPSAxO1xuVEhSRUUuUENGU29mdFNoYWRvd01hcCA9IDI7XG5cbi8vIE1BVEVSSUFMIENPTlNUQU5UU1xuXG4vLyBzaWRlXG5cblRIUkVFLkZyb250U2lkZSA9IDA7XG5USFJFRS5CYWNrU2lkZSA9IDE7XG5USFJFRS5Eb3VibGVTaWRlID0gMjtcblxuLy8gc2hhZGluZ1xuXG5USFJFRS5Ob1NoYWRpbmcgPSAwO1xuVEhSRUUuRmxhdFNoYWRpbmcgPSAxO1xuVEhSRUUuU21vb3RoU2hhZGluZyA9IDI7XG5cbi8vIGNvbG9yc1xuXG5USFJFRS5Ob0NvbG9ycyA9IDA7XG5USFJFRS5GYWNlQ29sb3JzID0gMTtcblRIUkVFLlZlcnRleENvbG9ycyA9IDI7XG5cbi8vIGJsZW5kaW5nIG1vZGVzXG5cblRIUkVFLk5vQmxlbmRpbmcgPSAwO1xuVEhSRUUuTm9ybWFsQmxlbmRpbmcgPSAxO1xuVEhSRUUuQWRkaXRpdmVCbGVuZGluZyA9IDI7XG5USFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcblRIUkVFLk11bHRpcGx5QmxlbmRpbmcgPSA0O1xuVEhSRUUuQ3VzdG9tQmxlbmRpbmcgPSA1O1xuXG4vLyBjdXN0b20gYmxlbmRpbmcgZXF1YXRpb25zXG4vLyAobnVtYmVycyBzdGFydCBmcm9tIDEwMCBub3QgdG8gY2xhc2ggd2l0aCBvdGhlclxuLy8gIG1hcHBpbmdzIHRvIE9wZW5HTCBjb25zdGFudHMgZGVmaW5lZCBpbiBUZXh0dXJlLmpzKVxuXG5USFJFRS5BZGRFcXVhdGlvbiA9IDEwMDtcblRIUkVFLlN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XG5USFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcblRIUkVFLk1pbkVxdWF0aW9uID0gMTAzO1xuVEhSRUUuTWF4RXF1YXRpb24gPSAxMDQ7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBkZXN0aW5hdGlvbiBmYWN0b3JzXG5cblRIUkVFLlplcm9GYWN0b3IgPSAyMDA7XG5USFJFRS5PbmVGYWN0b3IgPSAyMDE7XG5USFJFRS5TcmNDb2xvckZhY3RvciA9IDIwMjtcblRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XG5USFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcblRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG5USFJFRS5Ec3RBbHBoYUZhY3RvciA9IDIwNjtcblRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBzb3VyY2UgZmFjdG9yc1xuXG4vL1RIUkVFLlplcm9GYWN0b3IgPSAyMDA7XG4vL1RIUkVFLk9uZUZhY3RvciA9IDIwMTtcbi8vVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG4vL1RIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG4vL1RIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xuLy9USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuVEhSRUUuRHN0Q29sb3JGYWN0b3IgPSAyMDg7XG5USFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcblxuXG4vLyBURVhUVVJFIENPTlNUQU5UU1xuXG5USFJFRS5NdWx0aXBseU9wZXJhdGlvbiA9IDA7XG5USFJFRS5NaXhPcGVyYXRpb24gPSAxO1xuVEhSRUUuQWRkT3BlcmF0aW9uID0gMjtcblxuLy8gTWFwcGluZyBtb2Rlc1xuXG5USFJFRS5VVk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxuVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gZnVuY3Rpb24gKCkge307XG5USFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxuVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcblRIUkVFLlNwaGVyaWNhbFJlZnJhY3Rpb25NYXBwaW5nID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFdyYXBwaW5nIG1vZGVzXG5cblRIUkVFLlJlcGVhdFdyYXBwaW5nID0gMTAwMDtcblRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xuVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XG5cbi8vIEZpbHRlcnNcblxuVEhSRUUuTmVhcmVzdEZpbHRlciA9IDEwMDM7XG5USFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5USFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcblRIUkVFLkxpbmVhckZpbHRlciA9IDEwMDY7XG5USFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcblRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XG5cbi8vIERhdGEgdHlwZXNcblxuVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5USFJFRS5CeXRlVHlwZSA9IDEwMTA7XG5USFJFRS5TaG9ydFR5cGUgPSAxMDExO1xuVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuVEhSRUUuSW50VHlwZSA9IDEwMTM7XG5USFJFRS5VbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuVEhSRUUuRmxvYXRUeXBlID0gMTAxNTtcblxuLy8gUGl4ZWwgdHlwZXNcblxuLy9USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcblRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTY7XG5USFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE3O1xuVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE4O1xuXG4vLyBQaXhlbCBmb3JtYXRzXG5cblRIUkVFLkFscGhhRm9ybWF0ID0gMTAxOTtcblRIUkVFLlJHQkZvcm1hdCA9IDEwMjA7XG5USFJFRS5SR0JBRm9ybWF0ID0gMTAyMTtcblRIUkVFLkx1bWluYW5jZUZvcm1hdCA9IDEwMjI7XG5USFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCA9IDEwMjM7XG5cbi8vIEREUyAvIFNUM0MgQ29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcblxuVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xuVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMjtcblRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDIwMDM7XG5USFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xuXG5cbi8vIFBWUlRDIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXG5cblRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMDtcblRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcblRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDI7XG5USFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAzO1xuXG5cbi8vIEZpbGU6c3JjL21hdGgvQ29sb3IuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkNvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRSR0IoIGFyZ3VtZW50c1sgMCBdLCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKTtcblxuXHR9XG5cblx0cmV0dXJuIHRoaXMuc2V0KCBjb2xvciApXG5cbn07XG5cblRIUkVFLkNvbG9yLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQ29sb3IsXG5cblx0cjogMSwgZzogMSwgYjogMSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XG5cblx0XHRcdHRoaXMuY29weSggdmFsdWUgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xuXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0dGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcblxuXHRcdGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xuXG5cdFx0dGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcblx0XHR0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XG5cdFx0dGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0UkdCOiBmdW5jdGlvbiAoIHIsIGcsIGIgKSB7XG5cblx0XHR0aGlzLnIgPSByO1xuXHRcdHRoaXMuZyA9IGc7XG5cdFx0dGhpcy5iID0gYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XG5cblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG5cdFx0aWYgKCBzID09PSAwICkge1xuXG5cdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dmFyIGh1ZTJyZ2IgPSBmdW5jdGlvbiAoIHAsIHEsIHQgKSB7XG5cblx0XHRcdFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcblx0XHRcdFx0aWYgKCB0ID4gMSApIHQgLT0gMTtcblx0XHRcdFx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xuXHRcdFx0XHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xuXHRcdFx0XHRpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XG5cdFx0XHRcdHJldHVybiBwO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xuXHRcdFx0dmFyIHEgPSAoIDIgKiBsICkgLSBwO1xuXG5cdFx0XHR0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcblx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcblx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcblxuXHRcdC8vIHJnYigyNTUsMCwwKVxuXG5cdFx0aWYgKCAvXnJnYlxcKChcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKVxcKSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG5cdFx0XHR2YXIgY29sb3IgPSAvXnJnYlxcKChcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKVxcKSQvaS5leGVjKCBzdHlsZSApO1xuXG5cdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMjU1O1xuXHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcblx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmdiKDEwMCUsMCUsMCUpXG5cblx0XHRpZiAoIC9ecmdiXFwoKFxcZCspXFwlLCA/KFxcZCspXFwlLCA/KFxcZCspXFwlXFwpJC9pLnRlc3QoIHN0eWxlICkgKSB7XG5cblx0XHRcdHZhciBjb2xvciA9IC9ecmdiXFwoKFxcZCspXFwlLCA/KFxcZCspXFwlLCA/KFxcZCspXFwlXFwpJC9pLmV4ZWMoIHN0eWxlICk7XG5cblx0XHRcdHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XG5cdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xuXHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHQvLyAjZmYwMDAwXG5cblx0XHRpZiAoIC9eXFwjKFswLTlhLWZdezZ9KSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG5cdFx0XHR2YXIgY29sb3IgPSAvXlxcIyhbMC05YS1mXXs2fSkkL2kuZXhlYyggc3R5bGUgKTtcblxuXHRcdFx0dGhpcy5zZXRIZXgoIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxNiApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Ly8gI2YwMFxuXG5cdFx0aWYgKCAvXlxcIyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG5cdFx0XHR2YXIgY29sb3IgPSAvXlxcIyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaS5leGVjKCBzdHlsZSApO1xuXG5cdFx0XHR0aGlzLnNldEhleCggcGFyc2VJbnQoIGNvbG9yWyAxIF0gKyBjb2xvclsgMSBdICsgY29sb3JbIDIgXSArIGNvbG9yWyAyIF0gKyBjb2xvclsgMyBdICsgY29sb3JbIDMgXSwgMTYgKSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdC8vIHJlZFxuXG5cdFx0aWYgKCAvXihcXHcrKSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG5cdFx0XHR0aGlzLnNldEhleCggVEhSRUUuQ29sb3JLZXl3b3Jkc1sgc3R5bGUgXSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRcdHRoaXMuciA9IGNvbG9yLnI7XG5cdFx0dGhpcy5nID0gY29sb3IuZztcblx0XHR0aGlzLmIgPSBjb2xvci5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRcdHRoaXMuciA9IGNvbG9yLnIgKiBjb2xvci5yO1xuXHRcdHRoaXMuZyA9IGNvbG9yLmcgKiBjb2xvci5nO1xuXHRcdHRoaXMuYiA9IGNvbG9yLmIgKiBjb2xvci5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRcdHRoaXMuciA9IE1hdGguc3FydCggY29sb3IuciApO1xuXHRcdHRoaXMuZyA9IE1hdGguc3FydCggY29sb3IuZyApO1xuXHRcdHRoaXMuYiA9IE1hdGguc3FydCggY29sb3IuYiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XG5cblx0XHR0aGlzLnIgPSByICogcjtcblx0XHR0aGlzLmcgPSBnICogZztcblx0XHR0aGlzLmIgPSBiICogYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuciA9IE1hdGguc3FydCggdGhpcy5yICk7XG5cdFx0dGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcblx0XHR0aGlzLmIgPSBNYXRoLnNxcnQoIHRoaXMuYiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRIZXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xuXG5cdH0sXG5cblx0Z2V0SGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XG5cblx0fSxcblxuXHRnZXRIU0w6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXG5cdFx0dmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHsgaDogMCwgczogMCwgbDogMCB9O1xuXG5cdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XG5cblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcblx0XHR2YXIgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcblxuXHRcdHZhciBodWUsIHNhdHVyYXRpb247XG5cdFx0dmFyIGxpZ2h0bmVzcyA9ICggbWluICsgbWF4ICkgLyAyLjA7XG5cblx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xuXG5cdFx0XHRodWUgPSAwO1xuXHRcdFx0c2F0dXJhdGlvbiA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cblx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcblxuXHRcdFx0c3dpdGNoICggbWF4ICkge1xuXG5cdFx0XHRcdGNhc2UgcjogaHVlID0gKCBnIC0gYiApIC8gZGVsdGEgKyAoIGcgPCBiID8gNiA6IDAgKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgZzogaHVlID0gKCBiIC0gciApIC8gZGVsdGEgKyAyOyBicmVhaztcblx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGh1ZSAvPSA2O1xuXG5cdFx0fVxuXG5cdFx0aHNsLmggPSBodWU7XG5cdFx0aHNsLnMgPSBzYXR1cmF0aW9uO1xuXHRcdGhzbC5sID0gbGlnaHRuZXNzO1xuXG5cdFx0cmV0dXJuIGhzbDtcblxuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xuXG5cdH0sXG5cblx0b2Zmc2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XG5cblx0XHR2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcblxuXHRcdGhzbC5oICs9IGg7IGhzbC5zICs9IHM7IGhzbC5sICs9IGw7XG5cblx0XHR0aGlzLnNldEhTTCggaHNsLmgsIGhzbC5zLCBoc2wubCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgKz0gY29sb3Iucjtcblx0XHR0aGlzLmcgKz0gY29sb3IuZztcblx0XHR0aGlzLmIgKz0gY29sb3IuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xuXG5cdFx0dGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcblx0XHR0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xuXHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0dGhpcy5yICs9IHM7XG5cdFx0dGhpcy5nICs9IHM7XG5cdFx0dGhpcy5iICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XG5cdFx0dGhpcy5nICo9IGNvbG9yLmc7XG5cdFx0dGhpcy5iICo9IGNvbG9yLmI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnIgKj0gcztcblx0XHR0aGlzLmcgKj0gcztcblx0XHR0aGlzLmIgKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcblx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcblx0XHR0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGMgKSB7XG5cblx0XHRyZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHR0aGlzLnIgPSBhcnJheVsgMCBdO1xuXHRcdHRoaXMuZyA9IGFycmF5WyAxIF07XG5cdFx0dGhpcy5iID0gYXJyYXlbIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIFsgdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiBdO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQ29sb3IoKS5zZXRSR0IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkNvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcbidiZWlnZSc6IDB4RjVGNURDLCAnYmlzcXVlJzogMHhGRkU0QzQsICdibGFjayc6IDB4MDAwMDAwLCAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCwgJ2JsdWUnOiAweDAwMDBGRiwgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcbidicm93bic6IDB4QTUyQTJBLCAnYnVybHl3b29kJzogMHhERUI4ODcsICdjYWRldGJsdWUnOiAweDVGOUVBMCwgJ2NoYXJ0cmV1c2UnOiAweDdGRkYwMCwgJ2Nob2NvbGF0ZSc6IDB4RDI2OTFFLCAnY29yYWwnOiAweEZGN0Y1MCxcbidjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxuJ2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQiwgJ2RhcmtncmF5JzogMHhBOUE5QTksICdkYXJrZ3JlZW4nOiAweDAwNjQwMCwgJ2RhcmtncmV5JzogMHhBOUE5QTksICdkYXJra2hha2knOiAweEJEQjc2QiwgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXG4nZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRiwgJ2RhcmtvcmFuZ2UnOiAweEZGOEMwMCwgJ2RhcmtvcmNoaWQnOiAweDk5MzJDQywgJ2RhcmtyZWQnOiAweDhCMDAwMCwgJ2RhcmtzYWxtb24nOiAweEU5OTY3QSwgJ2RhcmtzZWFncmVlbic6IDB4OEZCQzhGLFxuJ2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcbidkZWVwcGluayc6IDB4RkYxNDkzLCAnZGVlcHNreWJsdWUnOiAweDAwQkZGRiwgJ2RpbWdyYXknOiAweDY5Njk2OSwgJ2RpbWdyZXknOiAweDY5Njk2OSwgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRiwgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxuJ2Zsb3JhbHdoaXRlJzogMHhGRkZBRjAsICdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLCAnZnVjaHNpYSc6IDB4RkYwMEZGLCAnZ2FpbnNib3JvJzogMHhEQ0RDREMsICdnaG9zdHdoaXRlJzogMHhGOEY4RkYsICdnb2xkJzogMHhGRkQ3MDAsXG4nZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXG4naW5kaWFucmVkJzogMHhDRDVDNUMsICdpbmRpZ28nOiAweDRCMDA4MiwgJ2l2b3J5JzogMHhGRkZGRjAsICdraGFraSc6IDB4RjBFNjhDLCAnbGF2ZW5kZXInOiAweEU2RTZGQSwgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSwgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxuJ2xlbW9uY2hpZmZvbic6IDB4RkZGQUNELCAnbGlnaHRibHVlJzogMHhBREQ4RTYsICdsaWdodGNvcmFsJzogMHhGMDgwODAsICdsaWdodGN5YW4nOiAweEUwRkZGRiwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogMHhGQUZBRDIsICdsaWdodGdyYXknOiAweEQzRDNEMyxcbidsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxuJ2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LCAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSwgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsICdsaW1lJzogMHgwMEZGMDAsICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcbidsaW5lbic6IDB4RkFGMEU2LCAnbWFnZW50YSc6IDB4RkYwMEZGLCAnbWFyb29uJzogMHg4MDAwMDAsICdtZWRpdW1hcXVhbWFyaW5lJzogMHg2NkNEQUEsICdtZWRpdW1ibHVlJzogMHgwMDAwQ0QsICdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcbidtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcbidtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSwgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLCAnbWludGNyZWFtJzogMHhGNUZGRkEsICdtaXN0eXJvc2UnOiAweEZGRTRFMSwgJ21vY2Nhc2luJzogMHhGRkU0QjUsICduYXZham93aGl0ZSc6IDB4RkZERUFELFxuJ25hdnknOiAweDAwMDA4MCwgJ29sZGxhY2UnOiAweEZERjVFNiwgJ29saXZlJzogMHg4MDgwMDAsICdvbGl2ZWRyYWInOiAweDZCOEUyMywgJ29yYW5nZSc6IDB4RkZBNTAwLCAnb3JhbmdlcmVkJzogMHhGRjQ1MDAsICdvcmNoaWQnOiAweERBNzBENixcbidwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxuJ3BlcnUnOiAweENEODUzRiwgJ3BpbmsnOiAweEZGQzBDQiwgJ3BsdW0nOiAweEREQTBERCwgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNiwgJ3B1cnBsZSc6IDB4ODAwMDgwLCAncmVkJzogMHhGRjAwMDAsICdyb3N5YnJvd24nOiAweEJDOEY4Rixcbidyb3lhbGJsdWUnOiAweDQxNjlFMSwgJ3NhZGRsZWJyb3duJzogMHg4QjQ1MTMsICdzYWxtb24nOiAweEZBODA3MiwgJ3NhbmR5YnJvd24nOiAweEY0QTQ2MCwgJ3NlYWdyZWVuJzogMHgyRThCNTcsICdzZWFzaGVsbCc6IDB4RkZGNUVFLFxuJ3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXG4nc3ByaW5nZ3JlZW4nOiAweDAwRkY3RiwgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LCAndGFuJzogMHhEMkI0OEMsICd0ZWFsJzogMHgwMDgwODAsICd0aGlzdGxlJzogMHhEOEJGRDgsICd0b21hdG8nOiAweEZGNjM0NywgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuJ3Zpb2xldCc6IDB4RUU4MkVFLCAnd2hlYXQnOiAweEY1REVCMywgJ3doaXRlJzogMHhGRkZGRkYsICd3aGl0ZXNtb2tlJzogMHhGNUY1RjUsICd5ZWxsb3cnOiAweEZGRkYwMCwgJ3llbGxvd2dyZWVuJzogMHg5QUNEMzIgfTtcblxuLy8gRmlsZTpzcmMvbWF0aC9RdWF0ZXJuaW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0dGhpcy5feCA9IHggfHwgMDtcblx0dGhpcy5feSA9IHkgfHwgMDtcblx0dGhpcy5feiA9IHogfHwgMDtcblx0dGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxufTtcblxuVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlF1YXRlcm5pb24sXG5cblx0X3g6IDAsX3k6IDAsIF96OiAwLCBfdzogMCxcblxuXHRnZXQgeCAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9LFxuXG5cdHNldCB4ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeSAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9LFxuXG5cdHNldCB5ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9LFxuXG5cdHNldCB6ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgdyAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdztcblxuXHR9LFxuXG5cdHNldCB3ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl93ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcblxuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XG5cdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XG5cblx0XHRpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblx0XHR9XG5cblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cblx0XHR2YXIgYzEgPSBNYXRoLmNvcyggZXVsZXIuX3ggLyAyICk7XG5cdFx0dmFyIGMyID0gTWF0aC5jb3MoIGV1bGVyLl95IC8gMiApO1xuXHRcdHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcblx0XHR2YXIgczEgPSBNYXRoLnNpbiggZXVsZXIuX3ggLyAyICk7XG5cdFx0dmFyIHMyID0gTWF0aC5zaW4oIGV1bGVyLl95IC8gMiApO1xuXHRcdHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcblxuXHRcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0dmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xuXHRcdHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxuXHRcdFx0cztcblxuXHRcdGlmICggdHJhY2UgPiAwICkge1xuXG5cdFx0XHRzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcblx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcblxuXHRcdH1cblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcblxuXHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG5cdFx0dmFyIHYxLCByO1xuXG5cdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdkZyb20sIHZUbyApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cblx0XHRcdGlmICggciA8IEVQUyApIHtcblxuXHRcdFx0XHRyID0gMDtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG5cdFx0XHRcdFx0djEuc2V0KCAtIHZGcm9tLnksIHZGcm9tLngsIDAgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5feCA9IHYxLng7XG5cdFx0XHR0aGlzLl95ID0gdjEueTtcblx0XHRcdHRoaXMuX3ogPSB2MS56O1xuXHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHRcdHRoaXMubm9ybWFsaXplKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0oKSxcblxuXHRpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuX3ggKj0gLSAxO1xuXHRcdHRoaXMuX3kgKj0gLSAxO1xuXHRcdHRoaXMuX3ogKj0gLSAxO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcblxuXHR9LFxuXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cgKTtcblxuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGwgPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0aWYgKCBsID09PSAwICkge1xuXG5cdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdHRoaXMuX3kgPSAwO1xuXHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHR0aGlzLl93ID0gMTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGwgPSAxIC8gbDtcblxuXHRcdFx0dGhpcy5feCA9IHRoaXMuX3ggKiBsO1xuXHRcdFx0dGhpcy5feSA9IHRoaXMuX3kgKiBsO1xuXHRcdFx0dGhpcy5feiA9IHRoaXMuX3ogKiBsO1xuXHRcdFx0dGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XG5cblx0XHRpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHR2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcblx0XHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG5cdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcblx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xuXG5cdH0sXG5cblx0c2xlcnA6IGZ1bmN0aW9uICggcWIsIHQgKSB7XG5cblx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcblx0XHRpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xuXG5cdFx0dmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuXHRcdHZhciBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xuXHRcdFx0dGhpcy5feCA9IC0gcWIuX3g7XG5cdFx0XHR0aGlzLl95ID0gLSBxYi5feTtcblx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xuXG5cdFx0XHRjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuY29weSggcWIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcblxuXHRcdFx0dGhpcy5fdyA9IHc7XG5cdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0dGhpcy5feiA9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGhhbGZUaGV0YSA9IE1hdGguYWNvcyggY29zSGFsZlRoZXRhICk7XG5cdFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XG5cblx0XHRpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xuXG5cdFx0XHR0aGlzLl93ID0gMC41ICogKCB3ICsgdGhpcy5fdyApO1xuXHRcdFx0dGhpcy5feCA9IDAuNSAqICggeCArIHRoaXMuX3ggKTtcblx0XHRcdHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XG5cdFx0XHR0aGlzLl96ID0gMC41ICogKCB6ICsgdGhpcy5feiApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG5cdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuXHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb24oIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLlF1YXRlcm5pb24uc2xlcnAgPSBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XG5cblx0cmV0dXJuIHFtLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XG5cbn1cblxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICovXG5cblRIUkVFLlZlY3RvcjIgPSBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cblx0dGhpcy54ID0geCB8fCAwO1xuXHR0aGlzLnkgPSB5IHx8IDA7XG5cbn07XG5cblRIUkVFLlZlY3RvcjIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IyLFxuXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0dGhpcy54ICo9IHM7XG5cdFx0dGhpcy55ICo9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0aWYgKCBzY2FsYXIgIT09IDAgKSB7XG5cblx0XHRcdHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xuXG5cdFx0XHR0aGlzLnggKj0gaW52U2NhbGFyO1xuXHRcdFx0dGhpcy55ICo9IGludlNjYWxhcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdGlmICggdGhpcy54ID4gdi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSB2Lng7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueSA+IHYueSApIHtcblxuXHRcdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdGlmICggdGhpcy54IDwgdi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSB2Lng7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueSA8IHYueSApIHtcblxuXHRcdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cblx0XHRpZiAoIHRoaXMueCA8IG1pbi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSBtaW4ueDtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xuXG5cdFx0XHR0aGlzLnggPSBtYXgueDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy55IDwgbWluLnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IG1pbi55O1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IG1heC55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xhbXBTY2FsYXI6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWluID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xuXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cblx0XHR9O1xuXG5cdH0gKSgpLFxuXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VpbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXG5cdH0sXG5cblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGwgKSB7XG5cblx0XHR2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCApIHtcblxuXHRcdFx0dGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHRoaXMueCwgdGhpcy55ICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciAqa2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLlZlY3RvcjMgPSBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0dGhpcy54ID0geCB8fCAwO1xuXHR0aGlzLnkgPSB5IHx8IDA7XG5cdHRoaXMueiA9IHogfHwgMDtcblxufTtcblxuVEhSRUUuVmVjdG9yMy5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjMsXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xuXG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXHRcdHRoaXMueiArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHRoaXMueiA9IGEueiArIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdHRoaXMueiAqPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICogYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseUV1bGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0XHRpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdFx0dGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0YXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBxdWF0ZXJuaW9uO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdHZhciB5ID0gdGhpcy55O1xuXHRcdHZhciB6ID0gdGhpcy56O1xuXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXTtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXTtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlQcm9qZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBwcm9qZWN0aW9uIG1hdHJpeFxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cdFx0dmFyIGQgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApOyAvLyBwZXJzcGVjdGl2ZSBkaXZpZGVcblxuXHRcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF0gKSAqIGQ7XG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXSApICogZDtcblx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiBkO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdHZhciB5ID0gdGhpcy55O1xuXHRcdHZhciB6ID0gdGhpcy56O1xuXG5cdFx0dmFyIHF4ID0gcS54O1xuXHRcdHZhciBxeSA9IHEueTtcblx0XHR2YXIgcXogPSBxLno7XG5cdFx0dmFyIHF3ID0gcS53O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuXHRcdHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG5cdFx0dmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcblx0XHR2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuXHRcdHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuXHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRyaXg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1hdHJpeDtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNmb3JtRGlyZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XG5cdFx0Ly8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXG5cblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xuXG5cdFx0dGhpcy5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggLz0gdi54O1xuXHRcdHRoaXMueSAvPSB2Lnk7XG5cdFx0dGhpcy56IC89IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdGlmICggc2NhbGFyICE9PSAwICkge1xuXG5cdFx0XHR2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcblxuXHRcdFx0dGhpcy54ICo9IGludlNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBpbnZTY2FsYXI7XG5cdFx0XHR0aGlzLnogKj0gaW52U2NhbGFyO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy54ID0gMDtcblx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHR0aGlzLnogPSAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdGlmICggdGhpcy54ID4gdi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSB2Lng7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueSA+IHYueSApIHtcblxuXHRcdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnogPiB2LnogKSB7XG5cblx0XHRcdHRoaXMueiA9IHYuejtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcblxuXHRcdFx0dGhpcy54ID0gdi54O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IHYueTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy56IDwgdi56ICkge1xuXG5cdFx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuXHRcdGlmICggdGhpcy54IDwgbWluLnggKSB7XG5cblx0XHRcdHRoaXMueCA9IG1pbi54O1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XG5cblx0XHRcdHRoaXMueCA9IG1heC54O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcblxuXHRcdFx0dGhpcy55ID0gbWluLnk7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcblxuXHRcdFx0dGhpcy55ID0gbWF4Lnk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueiA8IG1pbi56ICkge1xuXG5cdFx0XHR0aGlzLnogPSBtaW4uejtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueiA+IG1heC56ICkge1xuXG5cdFx0XHR0aGlzLnogPSBtYXguejtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xhbXBTY2FsYXI6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWluID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG5cdFx0fTtcblxuXHR9ICkoKSxcblxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xuXG5cdH0sXG5cblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG5cdFx0dmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggICkge1xuXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNyb3NzOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG5cdFx0dGhpcy54ID0geSAqIHYueiAtIHogKiB2Lnk7XG5cdFx0dGhpcy55ID0geiAqIHYueCAtIHggKiB2Lno7XG5cdFx0dGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dmFyIGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XG5cdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XG5cblx0XHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcblx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEsIGRvdDtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR2MS5jb3B5KCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0ZG90ID0gdGhpcy5kb3QoIHYxICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmNvcHkoIHYxICkubXVsdGlwbHlTY2FsYXIoIGRvdCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0cHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBsYW5lTm9ybWFsICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcblxuXHRcdH1cblxuXHR9KCksXG5cblx0cmVmbGVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0dmFyIHYxO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbm9ybWFsICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG5cdFx0fVxuXG5cdH0oKSxcblxuXHRhbmdsZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCB0aGlzLmxlbmd0aCgpICogdi5sZW5ndGgoKSApO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIGR4ID0gdGhpcy54IC0gdi54O1xuXHRcdHZhciBkeSA9IHRoaXMueSAtIHYueTtcblx0XHR2YXIgZHogPSB0aGlzLnogLSB2Lno7XG5cblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuXG5cdH0sXG5cblx0c2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGluc3RlYWQuJyApO1xuXG5cdH0sXG5cblx0c2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxLCBvcmRlciApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuJyApO1xuXG5cdH0sXG5cblx0Z2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuJyApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICk7XG5cblx0fSxcblxuXHRnZXRTY2FsZUZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS4nICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUoIG0gKTtcblx0fSxcblxuXHRnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBpbmRleCwgbWF0cml4ICk7XG5cblx0fSxcblxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHRoaXMueCA9IG0uZWxlbWVudHNbIDEyIF07XG5cdFx0dGhpcy55ID0gbS5lbGVtZW50c1sgMTMgXTtcblx0XHR0aGlzLnogPSBtLmVsZW1lbnRzWyAxNCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciBzeCA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyAwIF0sIG0uZWxlbWVudHNbIDEgXSwgbS5lbGVtZW50c1sgIDIgXSApLmxlbmd0aCgpO1xuXHRcdHZhciBzeSA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA0IF0sIG0uZWxlbWVudHNbIDUgXSwgbS5lbGVtZW50c1sgIDYgXSApLmxlbmd0aCgpO1xuXHRcdHZhciBzeiA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA4IF0sIG0uZWxlbWVudHNbIDkgXSwgbS5lbGVtZW50c1sgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0dGhpcy54ID0gc3g7XG5cdFx0dGhpcy55ID0gc3k7XG5cdFx0dGhpcy56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cblx0XHR2YXIgb2Zmc2V0ID0gaW5kZXggKiA0O1xuXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gbWVbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IG1lWyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gbWVbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3I0LmpzXG5cbi8qKlxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLlZlY3RvcjQgPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0dGhpcy54ID0geCB8fCAwO1xuXHR0aGlzLnkgPSB5IHx8IDA7XG5cdHRoaXMueiA9IHogfHwgMDtcblx0dGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xuXG59O1xuXG5USFJFRS5WZWN0b3I0LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yNCxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSB6O1xuXHRcdHRoaXMudyA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFc6IGZ1bmN0aW9uICggdyApIHtcblxuXHRcdHRoaXMudyA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAzOiB0aGlzLncgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGNhc2UgMzogcmV0dXJuIHRoaXMudztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblx0XHR0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cdFx0dGhpcy53ICs9IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblx0XHR0aGlzLncgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cdFx0dGhpcy53ID0gYS53ICsgYi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdHRoaXMueiAtPSB2Lno7XG5cdFx0dGhpcy53IC09IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cdFx0dGhpcy53ID0gYS53IC0gYi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcblx0XHR0aGlzLncgKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdHZhciB5ID0gdGhpcy55O1xuXHRcdHZhciB6ID0gdGhpcy56O1xuXHRcdHZhciB3ID0gdGhpcy53O1xuXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSAqIHc7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xuXHRcdHRoaXMudyA9IGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICogdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdGlmICggc2NhbGFyICE9PSAwICkge1xuXG5cdFx0XHR2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcblxuXHRcdFx0dGhpcy54ICo9IGludlNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBpbnZTY2FsYXI7XG5cdFx0XHR0aGlzLnogKj0gaW52U2NhbGFyO1xuXHRcdFx0dGhpcy53ICo9IGludlNjYWxhcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0dGhpcy56ID0gMDtcblx0XHRcdHRoaXMudyA9IDE7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXG5cblx0XHQvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XG5cblx0XHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xuXG5cdFx0aWYgKCBzIDwgMC4wMDAxICkge1xuXG5cdFx0XHQgdGhpcy54ID0gMTtcblx0XHRcdCB0aGlzLnkgPSAwO1xuXHRcdFx0IHRoaXMueiA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQgdGhpcy54ID0gcS54IC8gcztcblx0XHRcdCB0aGlzLnkgPSBxLnkgLyBzO1xuXHRcdFx0IHRoaXMueiA9IHEueiAvIHM7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dmFyIGFuZ2xlLCB4LCB5LCB6LFx0XHQvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxuXHRcdFx0ZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXG5cdFx0XHRlcHNpbG9uMiA9IDAuMSxcdFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcblxuXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcblx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG5cdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKVxuXHRcdCAgICYmICggTWF0aC5hYnMoIG0xMyAtIG0zMSApIDwgZXBzaWxvbiApXG5cdFx0ICAgJiYgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XG5cblx0XHRcdC8vIHNpbmd1bGFyaXR5IGZvdW5kXG5cdFx0XHQvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXG5cdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXG5cblx0XHRcdGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApXG5cdFx0XHQgICAmJiAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yIClcblx0XHRcdCAgICYmICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKVxuXHRcdFx0ICAgJiYgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcblxuXHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcblxuXHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXG5cblx0XHRcdGFuZ2xlID0gTWF0aC5QSTtcblxuXHRcdFx0dmFyIHh4ID0gKCBtMTEgKyAxICkgLyAyO1xuXHRcdFx0dmFyIHl5ID0gKCBtMjIgKyAxICkgLyAyO1xuXHRcdFx0dmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xuXHRcdFx0dmFyIHh5ID0gKCBtMTIgKyBtMjEgKSAvIDQ7XG5cdFx0XHR2YXIgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcblx0XHRcdHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xuXG5cdFx0XHRpZiAoICggeHggPiB5eSApICYmICggeHggPiB6eiApICkgeyAvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG5cdFx0XHRcdGlmICggeHggPCBlcHNpbG9uICkge1xuXG5cdFx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0eCA9IE1hdGguc3FydCggeHggKTtcblx0XHRcdFx0XHR5ID0geHkgLyB4O1xuXHRcdFx0XHRcdHogPSB4eiAvIHg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCB5eSA+IHp6ICkgeyAvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuXG5cdFx0XHRcdGlmICggeXkgPCBlcHNpbG9uICkge1xuXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0eSA9IE1hdGguc3FydCggeXkgKTtcblx0XHRcdFx0XHR4ID0geHkgLyB5O1xuXHRcdFx0XHRcdHogPSB5eiAvIHk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgeyAvLyBtMzMgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybSBzbyBiYXNlIHJlc3VsdCBvbiB0aGlzXG5cblx0XHRcdFx0aWYgKCB6eiA8IGVwc2lsb24gKSB7XG5cblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHogPSAwO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR6ID0gTWF0aC5zcXJ0KCB6eiApO1xuXHRcdFx0XHRcdHggPSB4eiAvIHo7XG5cdFx0XHRcdFx0eSA9IHl6IC8gejtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XG5cblx0XHRcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxuXG5cdFx0fVxuXG5cdFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxuXG5cdFx0dmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApXG5cdFx0XHRcdFx0XHQgICsgKCBtMTMgLSBtMzEgKSAqICggbTEzIC0gbTMxIClcblx0XHRcdFx0XHRcdCAgKyAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxuXG5cdFx0aWYgKCBNYXRoLmFicyggcyApIDwgMC4wMDEgKSBzID0gMTtcblxuXHRcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcblx0XHQvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcblxuXHRcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdHRoaXMueSA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0aWYgKCB0aGlzLnggPiB2LnggKSB7XG5cblx0XHRcdHRoaXMueCA9IHYueDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy55ID4gdi55ICkge1xuXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMueiA+IHYueiApIHtcblxuXHRcdFx0dGhpcy56ID0gdi56O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLncgPiB2LncgKSB7XG5cblx0XHRcdHRoaXMudyA9IHYudztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcblxuXHRcdFx0dGhpcy54ID0gdi54O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IHYueTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy56IDwgdi56ICkge1xuXG5cdFx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMudyA8IHYudyApIHtcblxuXHRcdFx0dGhpcy53ID0gdi53O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cblx0XHRpZiAoIHRoaXMueCA8IG1pbi54ICkge1xuXG5cdFx0XHR0aGlzLnggPSBtaW4ueDtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xuXG5cdFx0XHR0aGlzLnggPSBtYXgueDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy55IDwgbWluLnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IG1pbi55O1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XG5cblx0XHRcdHRoaXMueSA9IG1heC55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnogPCBtaW4ueiApIHtcblxuXHRcdFx0dGhpcy56ID0gbWluLno7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLnogPiBtYXgueiApIHtcblxuXHRcdFx0dGhpcy56ID0gbWF4Lno7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMudyA8IG1pbi53ICkge1xuXG5cdFx0XHR0aGlzLncgPSBtaW4udztcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMudyA+IG1heC53ICkge1xuXG5cdFx0XHR0aGlzLncgPSBtYXgudztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xhbXBTY2FsYXI6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWluID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdH07XG5cblx0fSApKCksXG5cbiAgICBmbG9vcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICAgICAgdGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG4gICAgICAgIHRoaXMudyA9IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuICAgICAgICB0aGlzLncgPSBNYXRoLmNlaWwoIHRoaXMudyApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuICAgICAgICB0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcbiAgICAgICAgdGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgcm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICAgICAgdGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgICAgIHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuICAgICAgICB0aGlzLncgPSAoIHRoaXMudyA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy53ICkgOiBNYXRoLmZsb29yKCB0aGlzLncgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblx0XHR0aGlzLncgPSAtIHRoaXMudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xuXG5cdH0sXG5cblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xuXG5cdFx0dmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggKSB7XG5cblx0XHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXHRcdHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yNCggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0V1bGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuRXVsZXIgPSBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG5cdHRoaXMuX3ggPSB4IHx8IDA7XG5cdHRoaXMuX3kgPSB5IHx8IDA7XG5cdHRoaXMuX3ogPSB6IHx8IDA7XG5cdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyO1xuXG59O1xuXG5USFJFRS5FdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xuXG5USFJFRS5FdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcblxuVEhSRUUuRXVsZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5FdWxlcixcblxuXHRfeDogMCwgX3k6IDAsIF96OiAwLCBfb3JkZXI6IFRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlcixcblxuXHRnZXQgeCAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9LFxuXG5cdHNldCB4ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeSAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9LFxuXG5cdHNldCB5ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgeiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9LFxuXG5cdHNldCB6ICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRnZXQgb3JkZXIgKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xuXG5cdH0sXG5cblx0c2V0IG9yZGVyICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0dGhpcy5feCA9IGV1bGVyLl94O1xuXHRcdHRoaXMuX3kgPSBldWxlci5feTtcblx0XHR0aGlzLl96ID0gZXVsZXIuX3o7XG5cdFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyICkge1xuXG5cdFx0dmFyIGNsYW1wID0gVEhSRUUuTWF0aC5jbGFtcDtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuXHRcdHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xuXHRcdHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0yMiApO1xuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApXG5cblx0XHR9XG5cblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgY2xhbXAgPSBUSFJFRS5NYXRoLmNsYW1wO1xuXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS8yMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9jb250ZW50L1NwaW5DYWxjLm1cblxuXHRcdHZhciBzcXggPSBxLnggKiBxLng7XG5cdFx0dmFyIHNxeSA9IHEueSAqIHEueTtcblx0XHR2YXIgc3F6ID0gcS56ICogcS56O1xuXHRcdHZhciBzcXcgPSBxLncgKiBxLnc7XG5cblx0XHRvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG5cdFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAyICogKCBxLnggKiBxLncgLSBxLnkgKiBxLnogKSwgKCBzcXcgLSBzcXggLSBzcXkgKyBzcXogKSApO1xuXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggIGNsYW1wKCAyICogKCBxLnggKiBxLnogKyBxLnkgKiBxLncgKSwgLSAxLCAxICkgKTtcblx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAyICogKCBxLnogKiBxLncgLSBxLnggKiBxLnkgKSwgKCBzcXcgKyBzcXggLSBzcXkgLSBzcXogKSApO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICAnWVhaJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggIGNsYW1wKCAyICogKCBxLnggKiBxLncgLSBxLnkgKiBxLnogKSwgLSAxLCAxICkgKTtcblx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAyICogKCBxLnggKiBxLnogKyBxLnkgKiBxLncgKSwgKCBzcXcgLSBzcXggLSBzcXkgKyBzcXogKSApO1xuXHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEueSArIHEueiAqIHEudyApLCAoIHNxdyAtIHNxeCArIHNxeSAtIHNxeiApICk7XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oICBjbGFtcCggMiAqICggcS54ICogcS53ICsgcS55ICogcS56ICksIC0gMSwgMSApICk7XG5cdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggMiAqICggcS55ICogcS53IC0gcS56ICogcS54ICksICggc3F3IC0gc3F4IC0gc3F5ICsgc3F6ICkgKTtcblx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAyICogKCBxLnogKiBxLncgLSBxLnggKiBxLnkgKSwgKCBzcXcgLSBzcXggKyBzcXkgLSBzcXogKSApO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggMiAqICggcS54ICogcS53ICsgcS56ICogcS55ICksICggc3F3IC0gc3F4IC0gc3F5ICsgc3F6ICkgKTtcblx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oICBjbGFtcCggMiAqICggcS55ICogcS53IC0gcS54ICogcS56ICksIC0gMSwgMSApICk7XG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggMiAqICggcS54ICogcS55ICsgcS56ICogcS53ICksICggc3F3ICsgc3F4IC0gc3F5IC0gc3F6ICkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEudyAtIHEueiAqIHEueSApLCAoIHNxdyAtIHNxeCArIHNxeSAtIHNxeiApICk7XG5cdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggMiAqICggcS55ICogcS53IC0gcS54ICogcS56ICksICggc3F3ICsgc3F4IC0gc3F5IC0gc3F6ICkgKTtcblx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oICBjbGFtcCggMiAqICggcS54ICogcS55ICsgcS56ICogcS53ICksIC0gMSwgMSApICk7XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAyICogKCBxLnggKiBxLncgKyBxLnkgKiBxLnogKSwgKCBzcXcgLSBzcXggKyBzcXkgLSBzcXogKSApO1xuXHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEueiArIHEueSAqIHEudyApLCAoIHNxdyArIHNxeCAtIHNxeSAtIHNxeiApICk7XG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAgY2xhbXAoIDIgKiAoIHEueiAqIHEudyAtIHEueCAqIHEueSApLCAtIDEsIDEgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUXVhdGVybmlvbigpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyZW9yZGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXG5cblx0XHR2YXIgcSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBuZXdPcmRlciApIHtcblxuXHRcdFx0cS5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcblx0XHRcdHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oIHEsIG5ld09yZGVyICk7XG5cblx0XHR9O1xuXG5cblx0fSgpLFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBbIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyIF07XG5cblx0fSxcblxuXHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5FdWxlciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTGluZTMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5MaW5lMyA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuXHR0aGlzLnN0YXJ0ID0gKCBzdGFydCAhPT0gdW5kZWZpbmVkICkgPyBzdGFydCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcblxuVEhSRUUuTGluZTMucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MaW5lMyxcblxuXHRzZXQ6IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuXHRcdHRoaXMuc3RhcnQuY29weSggc3RhcnQgKTtcblx0XHR0aGlzLmVuZC5jb3B5KCBlbmQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cdFx0dGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9LFxuXG5cdGRlbHRhOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuZW5kICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyggdGhpcy5lbmQgKTtcblxuXHR9LFxuXG5cdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuXHR9LFxuXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBzdGFydFAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBzdGFydEVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUgKSB7XG5cblx0XHRcdHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xuXHRcdFx0c3RhcnRFbmQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcblxuXHRcdFx0dmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcblx0XHRcdHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xuXG5cdFx0XHR2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcblxuXHRcdFx0aWYgKCBjbGFtcFRvTGluZSApIHtcblxuXHRcdFx0XHR0ID0gVEhSRUUuTWF0aC5jbGFtcCggdCwgMCwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0O1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHQgPSB0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApO1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cblx0XHRyZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5MaW5lMygpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQm94Mi5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkJveDIgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjIoIEluZmluaXR5LCBJbmZpbml0eSApO1xuXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IyKCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbn07XG5cblRIUkVFLkJveDIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gyLFxuXG5cdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdIClcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG5cdFx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gSW5maW5pdHk7XG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtIEluZmluaXR5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuXHRcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuXHR9LFxuXG5cdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XG5cdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuXHRcdCAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0aWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXG5cdFx0ICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRcdHJldHVybiByZXN1bHQuc2V0KFxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApXG5cdFx0KTtcblxuXHR9LFxuXG5cdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXG5cdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcblx0XHQgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQm94MigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQm94My5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuQm94MyA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMyggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xuXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbn07XG5cblRIUkVFLkJveDMucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gzLFxuXG5cdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdIClcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBDb21wdXRlcyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBvZiBhbiBvYmplY3QgKGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLFxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW5zJywgd29ybGQgdHJhbnNmb3Jtc1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0b2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRcdG9iamVjdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnk7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRpY2VzWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXNbICdwb3NpdGlvbicgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgcG9zaXRpb25zID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgJ3Bvc2l0aW9uJyBdLmFycmF5O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0djEuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9IEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG5cdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuXHR9LFxuXG5cdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XG5cdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuXHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcblx0XHR0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuXHRcdCAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHxcblx0XHQgICAgIHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxuXHRcdFx0ICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcblx0XHRcdCAoIHRoaXMubWluLnogPD0gYm94Lm1pbi56ICkgJiYgKCBib3gubWF4LnogPD0gdGhpcy5tYXgueiApICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiByZXN1bHQuc2V0KFxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxuXHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXG5cdFx0KTtcblxuXHR9LFxuXG5cdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXG5cdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcblx0XHQgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxuXHRcdCAgICAgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGdldEJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cblx0XHRcdHJlc3VsdC5jZW50ZXIgPSB0aGlzLmNlbnRlcigpO1xuXHRcdFx0cmVzdWx0LnJhZGl1cyA9IHRoaXMuc2l6ZSggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBvaW50cyA9IFtcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpXG5cdFx0XTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0Ly8gTk9URTogSSBhbSB1c2luZyBhIGJpbmFyeSBwYXR0ZXJuIHRvIHNwZWNpZnkgYWxsIDJeMyBjb21iaW5hdGlvbnMgYmVsb3dcblx0XHRcdHBvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuXHRcdFx0cG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXG5cdFx0XHRwb2ludHNbIDIgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTBcblx0XHRcdHBvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuXHRcdFx0cG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXG5cdFx0XHRwb2ludHNbIDUgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDFcblx0XHRcdHBvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuXHRcdFx0cG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgIC8vIDExMVxuXG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQm94MygpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4My5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblxuXHRcdDEsIDAsIDAsXG5cdFx0MCwgMSwgMCxcblx0XHQwLCAwLCAxXG5cblx0XSApO1xuXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5NYXRyaXgzLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4MyxcblxuXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMyBdID0gbjEyOyB0ZVsgNiBdID0gbjEzO1xuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA0IF0gPSBuMjI7IHRlWyA3IF0gPSBuMjM7XG5cdFx0dGVbIDIgXSA9IG4zMTsgdGVbIDUgXSA9IG4zMjsgdGVbIDggXSA9IG4zMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSxcblx0XHRcdG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sXG5cdFx0XHRtZVsgMiBdLCBtZVsgNSBdLCBtZVsgOCBdXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4MyggdGhpcyApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG5cblx0fSxcblxuXHRhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldCwgaWw7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xuXG5cdFx0XHRcdHYxLnggPSBhcnJheVsgaiBdO1xuXHRcdFx0XHR2MS55ID0gYXJyYXlbIGogKyAxIF07XG5cdFx0XHRcdHYxLnogPSBhcnJheVsgaiArIDIgXTtcblxuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblxuXHRcdFx0XHRhcnJheVsgaiBdICAgICA9IHYxLng7XG5cdFx0XHRcdGFycmF5WyBqICsgMSBdID0gdjEueTtcblx0XHRcdFx0YXJyYXlbIGogKyAyIF0gPSB2MS56O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDcgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIGEgPSB0ZVsgMCBdLCBiID0gdGVbIDEgXSwgYyA9IHRlWyAyIF0sXG5cdFx0XHRkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxuXHRcdFx0ZyA9IHRlWyA2IF0sIGggPSB0ZVsgNyBdLCBpID0gdGVbIDggXTtcblxuXHRcdHJldHVybiBhICogZSAqIGkgLSBhICogZiAqIGggLSBiICogZCAqIGkgKyBiICogZiAqIGcgKyBjICogZCAqIGggLSBjICogZSAqIGc7XG5cblx0fSxcblxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG1hdHJpeCwgdGhyb3dPbkludmVydGlibGUgKSB7XG5cblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NFxuXHRcdC8vICggYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYmdsLW1qcy8gKVxuXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gICBtZVsgMTAgXSAqIG1lWyA1IF0gLSBtZVsgNiBdICogbWVbIDkgXTtcblx0XHR0ZVsgMSBdID0gLSBtZVsgMTAgXSAqIG1lWyAxIF0gKyBtZVsgMiBdICogbWVbIDkgXTtcblx0XHR0ZVsgMiBdID0gICBtZVsgNiBdICogbWVbIDEgXSAtIG1lWyAyIF0gKiBtZVsgNSBdO1xuXHRcdHRlWyAzIF0gPSAtIG1lWyAxMCBdICogbWVbIDQgXSArIG1lWyA2IF0gKiBtZVsgOCBdO1xuXHRcdHRlWyA0IF0gPSAgIG1lWyAxMCBdICogbWVbIDAgXSAtIG1lWyAyIF0gKiBtZVsgOCBdO1xuXHRcdHRlWyA1IF0gPSAtIG1lWyA2IF0gKiBtZVsgMCBdICsgbWVbIDIgXSAqIG1lWyA0IF07XG5cdFx0dGVbIDYgXSA9ICAgbWVbIDkgXSAqIG1lWyA0IF0gLSBtZVsgNSBdICogbWVbIDggXTtcblx0XHR0ZVsgNyBdID0gLSBtZVsgOSBdICogbWVbIDAgXSArIG1lWyAxIF0gKiBtZVsgOCBdO1xuXHRcdHRlWyA4IF0gPSAgIG1lWyA1IF0gKiBtZVsgMCBdIC0gbWVbIDEgXSAqIG1lWyA0IF07XG5cblx0XHR2YXIgZGV0ID0gbWVbIDAgXSAqIHRlWyAwIF0gKyBtZVsgMSBdICogdGVbIDMgXSArIG1lWyAyIF0gKiB0ZVsgNiBdO1xuXG5cdFx0Ly8gbm8gaW52ZXJzZVxuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSB7XG5cblx0XHRcdHZhciBtc2cgPSBcIk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cblx0XHRcdGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCAxLjAgLyBkZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGFycmF5WyBvZmZzZXQgICAgIF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XG5cblx0XHR0aGlzLmdldEludmVyc2UoIG0gKS50cmFuc3Bvc2UoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XG5cblx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyWyAwIF0gPSBtWyAwIF07XG5cdFx0clsgMSBdID0gbVsgMyBdO1xuXHRcdHJbIDIgXSA9IG1bIDYgXTtcblx0XHRyWyAzIF0gPSBtWyAxIF07XG5cdFx0clsgNCBdID0gbVsgNCBdO1xuXHRcdHJbIDUgXSA9IG1bIDcgXTtcblx0XHRyWyA2IF0gPSBtWyAyIF07XG5cdFx0clsgNyBdID0gbVsgNSBdO1xuXHRcdHJbIDggXSA9IG1bIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG5cdFx0dGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0dGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSxcblx0XHRcdHRlWyAzIF0sIHRlWyA0IF0sIHRlWyA1IF0sXG5cdFx0XHR0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXG5cdFx0XTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDMoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4NC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cbiAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cblx0XHQxLCAwLCAwLCAwLFxuXHRcdDAsIDEsIDAsIDAsXG5cdFx0MCwgMCwgMSwgMCxcblx0XHQwLCAwLCAwLCAxXG5cblx0XSApO1xuXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5NYXRyaXg0LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4NCxcblxuXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xuXHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIDEsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dGhpcy5lbGVtZW50cy5zZXQoIG0uZWxlbWVudHMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xuXHRcdHJldHVybiB0aGlzLmNvcHlQb3NpdGlvbiggbSApO1xuXG5cdH0sXG5cblx0Y29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuXHRcdHRlWyAxMyBdID0gbWVbIDEzIF07XG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHRcdHZhciBzY2FsZVggPSAxIC8gdjEuc2V0KCBtZVsgMCBdLCBtZVsgMSBdLCBtZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc2NhbGVZID0gMSAvIHYxLnNldCggbWVbIDQgXSwgbWVbIDUgXSwgbWVbIDYgXSApLmxlbmd0aCgpO1xuXHRcdFx0dmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWyA4IF0sIG1lWyA5IF0sIG1lWyAxMCBdICkubGVuZ3RoKCk7XG5cblx0XHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuXHRcdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XG5cdFx0XHR0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcblxuXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG5cdFx0XHR0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcblx0XHRcdHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xuXG5cdFx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcblx0XHRcdHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xuXHRcdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRtYWtlUm90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHRpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdH1cblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcblx0XHR2YXIgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xuXHRcdHZhciBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XG5cdFx0dmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcblxuXHRcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZDtcblxuXHRcdFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuXHRcdFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XG5cblx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhICogZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGI7XG5cblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcblx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gLSBhICogZjtcblx0XHRcdHRlWyA4IF0gPSBkZSArIGNmICogYjtcblxuXHRcdFx0dGVbIDEgXSA9IGNmICsgZGUgKiBiO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBhICogZDtcblx0XHRcdHRlWyA2IF0gPSBiO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcblx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcblxuXHRcdFx0dGVbIDEgXSA9IGMgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuXHRcdFx0dGVbIDEgXSA9IGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiICogZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XG5cdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gZjtcblx0XHRcdHRlWyA4IF0gPSBkICogZTtcblxuXHRcdFx0dGVbIDEgXSA9IGFjICogZiArIGJkO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IGFkICogZiAtIGJjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmMgKiBmIC0gYWQ7XG5cdFx0XHR0ZVsgNiBdID0gYiAqIGU7XG5cdFx0XHR0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuJyApO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHR9LFxuXG5cdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLnc7XG5cdFx0dmFyIHgyID0geCArIHgsIHkyID0geSArIHksIHoyID0geiArIHo7XG5cdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XG5cdFx0dmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG5cdFx0dmFyIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG5cblx0XHR0ZVsgMCBdID0gMSAtICggeXkgKyB6eiApO1xuXHRcdHRlWyA0IF0gPSB4eSAtIHd6O1xuXHRcdHRlWyA4IF0gPSB4eiArIHd5O1xuXG5cdFx0dGVbIDEgXSA9IHh5ICsgd3o7XG5cdFx0dGVbIDUgXSA9IDEgLSAoIHh4ICsgenogKTtcblx0XHR0ZVsgOSBdID0geXogLSB3eDtcblxuXHRcdHRlWyAyIF0gPSB4eiAtIHd5O1xuXHRcdHRlWyA2IF0gPSB5eiArIHd4O1xuXHRcdHRlWyAxMCBdID0gMSAtICggeHggKyB5eSApO1xuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHogPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZXllLCB0YXJnZXQsIHVwICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR6LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdGlmICggei5sZW5ndGgoKSA9PT0gMCApIHtcblxuXHRcdFx0XHR6LnogPSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRpZiAoIHgubGVuZ3RoKCkgPT09IDAgKSB7XG5cblx0XHRcdFx0ei54ICs9IDAuMDAwMTtcblx0XHRcdFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0eS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcblxuXG5cdFx0XHR0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xuXHRcdFx0dGVbIDEgXSA9IHgueTsgdGVbIDUgXSA9IHkueTsgdGVbIDkgXSA9IHoueTtcblx0XHRcdHRlWyAyIF0gPSB4Lno7IHRlWyA2IF0gPSB5Lno7IHRlWyAxMCBdID0gei56O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIG0sIG4gKSB7XG5cblx0XHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dmFyIGFlID0gYS5lbGVtZW50cztcblx0XHR2YXIgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG5cdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xuXHRcdHZhciBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNiBdLCBhMzMgPSBhZVsgMTAgXSwgYTM0ID0gYWVbIDE0IF07XG5cdFx0dmFyIGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuXHRcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcblx0XHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDUgXSwgYjIzID0gYmVbIDkgXSwgYjI0ID0gYmVbIDEzIF07XG5cdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcblx0XHR2YXIgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcblx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0Mztcblx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG5cdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0Mjtcblx0XHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoIGEsIGIsIHIgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICk7XG5cblx0XHRyWyAwIF0gPSB0ZVsgMCBdOyByWyAxIF0gPSB0ZVsgMSBdOyByWyAyIF0gPSB0ZVsgMiBdOyByWyAzIF0gPSB0ZVsgMyBdO1xuXHRcdHJbIDQgXSA9IHRlWyA0IF07IHJbIDUgXSA9IHRlWyA1IF07IHJbIDYgXSA9IHRlWyA2IF07IHJbIDcgXSA9IHRlWyA3IF07XG5cdFx0clsgOCBdICA9IHRlWyA4IF07IHJbIDkgXSAgPSB0ZVsgOSBdOyByWyAxMCBdID0gdGVbIDEwIF07IHJbIDExIF0gPSB0ZVsgMTEgXTtcblx0XHRyWyAxMiBdID0gdGVbIDEyIF07IHJbIDEzIF0gPSB0ZVsgMTMgXTsgclsgMTQgXSA9IHRlWyAxNCBdOyByWyAxNSBdID0gdGVbIDE1IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA4IF0gKj0gczsgdGVbIDEyIF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuXHRcdHRlWyAzIF0gKj0gczsgdGVbIDcgXSAqPSBzOyB0ZVsgMTEgXSAqPSBzOyB0ZVsgMTUgXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBvciB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggdGhpcyApO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlWZWN0b3I0OiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuXHR9LFxuXG5cdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xuXG5cdH0sXG5cblx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQsIGlsOyBpIDwgbGVuZ3RoOyBpICs9IDMsIGogKz0gMyApIHtcblxuXHRcdFx0XHR2MS54ID0gYXJyYXlbIGogXTtcblx0XHRcdFx0djEueSA9IGFycmF5WyBqICsgMSBdO1xuXHRcdFx0XHR2MS56ID0gYXJyYXlbIGogKyAyIF07XG5cblx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cblx0XHRcdFx0YXJyYXlbIGogXSAgICAgPSB2MS54O1xuXHRcdFx0XHRhcnJheVsgaiArIDEgXSA9IHYxLnk7XG5cdFx0XHRcdGFycmF5WyBqICsgMiBdID0gdjEuejtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRyb3RhdGVBeGlzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cblx0XHR2LnRyYW5zZm9ybURpcmVjdGlvbiggdGhpcyApO1xuXG5cdH0sXG5cblx0Y3Jvc3NWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cblx0fSxcblxuXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBuMTEgPSB0ZVsgMCBdLCBuMTIgPSB0ZVsgNCBdLCBuMTMgPSB0ZVsgOCBdLCBuMTQgPSB0ZVsgMTIgXTtcblx0XHR2YXIgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0dmFyIG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcblx0XHR2YXIgbjQxID0gdGVbIDMgXSwgbjQyID0gdGVbIDcgXSwgbjQzID0gdGVbIDExIF0sIG40NCA9IHRlWyAxNSBdO1xuXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcblx0XHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcblxuXHRcdHJldHVybiAoXG5cdFx0XHRuNDEgKiAoXG5cdFx0XHRcdCsgbjE0ICogbjIzICogbjMyXG5cdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTQgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTIgKiBuMjMgKiBuMzRcblx0XHRcdCkgK1xuXHRcdFx0bjQyICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yMyAqIG4zNFxuXHRcdFx0XHQgLSBuMTEgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXG5cdFx0XHRcdCAtIG4xMyAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTMgKiBuMjQgKiBuMzFcblx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40MyAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjExICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xNCAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjE0ICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMiAqIG4yNCAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDQgKiAoXG5cdFx0XHRcdC0gbjEzICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgKyBuMTEgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIxICogbjMyXG5cdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjMgKiBuMzFcblx0XHRcdClcblxuXHRcdCk7XG5cblx0fSxcblxuXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIHRtcDtcblxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0ICAgICBdID0gdGVbIDAgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSAgPSB0ZVsgOCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA5IF0gID0gdGVbIDkgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZ2V0UG9zaXRpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0cmV0dXJuIHYxLnNldCggdGVbIDEyIF0sIHRlWyAxMyBdLCB0ZVsgMTQgXSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMTIgXSA9IHYueDtcblx0XHR0ZVsgMTMgXSA9IHYueTtcblx0XHR0ZVsgMTQgXSA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtLCB0aHJvd09uSW52ZXJ0aWJsZSApIHtcblxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcblxuXHRcdHZhciBuMTEgPSBtZVsgMCBdLCBuMTIgPSBtZVsgNCBdLCBuMTMgPSBtZVsgOCBdLCBuMTQgPSBtZVsgMTIgXTtcblx0XHR2YXIgbjIxID0gbWVbIDEgXSwgbjIyID0gbWVbIDUgXSwgbjIzID0gbWVbIDkgXSwgbjI0ID0gbWVbIDEzIF07XG5cdFx0dmFyIG4zMSA9IG1lWyAyIF0sIG4zMiA9IG1lWyA2IF0sIG4zMyA9IG1lWyAxMCBdLCBuMzQgPSBtZVsgMTQgXTtcblx0XHR2YXIgbjQxID0gbWVbIDMgXSwgbjQyID0gbWVbIDcgXSwgbjQzID0gbWVbIDExIF0sIG40NCA9IG1lWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NDtcblx0XHR0ZVsgNCBdID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0O1xuXHRcdHRlWyA4IF0gPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQ7XG5cdFx0dGVbIDEyIF0gPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XG5cdFx0dGVbIDEgXSA9IG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NDtcblx0XHR0ZVsgNSBdID0gbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0O1xuXHRcdHRlWyA5IF0gPSBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQ7XG5cdFx0dGVbIDEzIF0gPSBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQ7XG5cdFx0dGVbIDIgXSA9IG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NDtcblx0XHR0ZVsgNiBdID0gbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0O1xuXHRcdHRlWyAxMCBdID0gbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0O1xuXHRcdHRlWyAxNCBdID0gbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0O1xuXHRcdHRlWyAzIF0gPSBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDM7XG5cdFx0dGVbIDcgXSA9IG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40Mztcblx0XHR0ZVsgMTEgXSA9IG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40Mztcblx0XHR0ZVsgMTUgXSA9IG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMztcblxuXHRcdHZhciBkZXQgPSBuMTEgKiB0ZVsgMCBdICsgbjIxICogdGVbIDQgXSArIG4zMSAqIHRlWyA4IF0gKyBuNDEgKiB0ZVsgMTIgXTtcblxuXHRcdGlmICggZGV0ID09IDAgKSB7XG5cblx0XHRcdHZhciBtc2cgPSBcIk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XG5cblx0XHRcdGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggMSAvIGRldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9LFxuXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdH0sXG5cblx0cm90YXRlWTogZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fSxcblxuXHRyb3RhdGVaOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVooKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9LFxuXG5cdHJvdGF0ZUJ5QXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xuXG5cdFx0dGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcblx0XHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xuXHRcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xuXHRcdHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRNYXhTY2FsZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcblx0XHR2YXIgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XG5cdFx0dmFyIHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIE1hdGgubWF4KCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApICk7XG5cblx0fSxcblxuXHRtYWtlVHJhbnNsYXRpb246IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCB4LFxuXHRcdFx0MCwgMSwgMCwgeSxcblx0XHRcdDAsIDAsIDEsIHosXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUm90YXRpb25YOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsICAwLCAwLFxuXHRcdFx0MCwgYywgLSBzLCAwLFxuXHRcdFx0MCwgcywgIGMsIDAsXG5cdFx0XHQwLCAwLCAgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uWTogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQgYywgMCwgcywgMCxcblx0XHRcdCAwLCAxLCAwLCAwLFxuXHRcdFx0LSBzLCAwLCBjLCAwLFxuXHRcdFx0IDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0YywgLSBzLCAwLCAwLFxuXHRcdFx0cywgIGMsIDAsIDAsXG5cdFx0XHQwLCAgMCwgMSwgMCxcblx0XHRcdDAsICAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xuXHRcdHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG5cdFx0dmFyIHQgPSAxIC0gYztcblx0XHR2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcblx0XHR2YXIgdHggPSB0ICogeCwgdHkgPSB0ICogeTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHR0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXG5cdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXG5cdFx0XHR0eCAqIHogLSBzICogeSwgdHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGMsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0IHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVNjYWxlOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCwgMCxcblx0XHRcdDAsIHksIDAsIDAsXG5cdFx0XHQwLCAwLCB6LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29tcG9zZTogZnVuY3Rpb24gKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHR0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cdFx0dGhpcy5zY2FsZSggc2NhbGUgKTtcblx0XHR0aGlzLnNldFBvc2l0aW9uKCBwb3NpdGlvbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc3ogPSB2ZWN0b3Iuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuXHRcdFx0dmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRcdGlmICggZGV0IDwgMCApIHtcblx0XHRcdFx0c3ggPSAtIHN4O1xuXHRcdFx0fVxuXG5cdFx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG5cdFx0XHRwb3NpdGlvbi55ID0gdGVbIDEzIF07XG5cdFx0XHRwb3NpdGlvbi56ID0gdGVbIDE0IF07XG5cblx0XHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cblx0XHRcdG1hdHJpeC5lbGVtZW50cy5zZXQoIHRoaXMuZWxlbWVudHMgKTsgLy8gYXQgdGhpcyBwb2ludCBtYXRyaXggaXMgaW5jb21wbGV0ZSBzbyB3ZSBjYW4ndCB1c2UgLmNvcHkoKVxuXG5cdFx0XHR2YXIgaW52U1ggPSAxIC8gc3g7XG5cdFx0XHR2YXIgaW52U1kgPSAxIC8gc3k7XG5cdFx0XHR2YXIgaW52U1ogPSAxIC8gc3o7XG5cblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDIgXSAqPSBpbnZTWDtcblxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNiBdICo9IGludlNZO1xuXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xuXG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRcdHNjYWxlLnggPSBzeDtcblx0XHRcdHNjYWxlLnkgPSBzeTtcblx0XHRcdHNjYWxlLnogPSBzejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRtYWtlRnJ1c3R1bTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0dmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHR2YXIgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG5cdFx0dmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cdFx0dmFyIGQgPSAtIDIgKiBmYXIgKiBuZWFyIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR0ZVsgMCBdID0geDtcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IGE7XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0geTtcdHRlWyA5IF0gPSBiO1x0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7XHR0ZVsgMTQgXSA9IGQ7XG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gLSAxO1x0dGVbIDE1IF0gPSAwO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uICggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuXHRcdHZhciB5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApO1xuXHRcdHZhciB5bWluID0gLSB5bWF4O1xuXHRcdHZhciB4bWluID0geW1pbiAqIGFzcGVjdDtcblx0XHR2YXIgeG1heCA9IHltYXggKiBhc3BlY3Q7XG5cblx0XHRyZXR1cm4gdGhpcy5tYWtlRnJ1c3R1bSggeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgbmVhciwgZmFyICk7XG5cblx0fSxcblxuXHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgdyA9IHJpZ2h0IC0gbGVmdDtcblx0XHR2YXIgaCA9IHRvcCAtIGJvdHRvbTtcblx0XHR2YXIgcCA9IGZhciAtIG5lYXI7XG5cblx0XHR2YXIgeCA9ICggcmlnaHQgKyBsZWZ0ICkgLyB3O1xuXHRcdHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAvIGg7XG5cdFx0dmFyIHogPSAoIGZhciArIG5lYXIgKSAvIHA7XG5cblx0XHR0ZVsgMCBdID0gMiAvIHc7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSAwO1x0dGVbIDEyIF0gPSAtIHg7XG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAvIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IC0gMiAvIHA7XHR0ZVsgMTQgXSA9IC0gejtcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAwO1x0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHR0aGlzLmVsZW1lbnRzLnNldCggYXJyYXkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHJldHVybiBbXG5cdFx0XHR0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLCB0ZVsgMyBdLFxuXHRcdFx0dGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSwgdGVbIDcgXSxcblx0XHRcdHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdLCB0ZVsgMTEgXSxcblx0XHRcdHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0sIHRlWyAxNSBdXG5cdFx0XTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvUmF5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuUmF5ID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuXHR0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcblxuVEhSRUUuUmF5LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUmF5LFxuXG5cdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIG9yaWdpbiApO1xuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cblx0fSxcblxuXHRyZWNhc3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XG5cdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHYxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdFx0Ly8gcG9pbnQgYmVoaW5kIHRoZSByYXlcblxuXHRcdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG8oIHBvaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0djEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cblx0XHRcdHJldHVybiB2MS5kaXN0YW5jZVRvKCBwb2ludCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0ZGlzdGFuY2VTcVRvU2VnbWVudDogZnVuY3Rpb24gKCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcblxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvRGlzdGFuY2UvV201RGlzdFJheTNTZWdtZW50My5jcHBcblx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuXHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXG5cdFx0Ly8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcblx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcblx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XG5cblx0XHR2YXIgc2VnQ2VudGVyID0gdjAuY2xvbmUoKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXHRcdHZhciBzZWdEaXIgPSB2MS5jbG9uZSgpLnN1YiggdjAgKS5ub3JtYWxpemUoKTtcblx0XHR2YXIgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcblx0XHR2YXIgZGlmZiA9IHRoaXMub3JpZ2luLmNsb25lKCkuc3ViKCBzZWdDZW50ZXIgKTtcblx0XHR2YXIgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIHNlZ0RpciApO1xuXHRcdHZhciBiMCA9IGRpZmYuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXHRcdHZhciBiMSA9IC0gZGlmZi5kb3QoIHNlZ0RpciApO1xuXHRcdHZhciBjID0gZGlmZi5sZW5ndGhTcSgpO1xuXHRcdHZhciBkZXQgPSBNYXRoLmFicyggMSAtIGEwMSAqIGEwMSApO1xuXHRcdHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcblxuXHRcdGlmICggZGV0ID49IDAgKSB7XG5cblx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuXHRcdFx0czAgPSBhMDEgKiBiMSAtIGIwO1xuXHRcdFx0czEgPSBhMDEgKiBiMCAtIGIxO1xuXHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG5cdFx0XHRpZiAoIHMwID49IDAgKSB7XG5cblx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcblxuXHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMFxuXHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxuXG5cdFx0XHRcdFx0XHR2YXIgaW52RGV0ID0gMSAvIGRldDtcblx0XHRcdFx0XHRcdHMwICo9IGludkRldDtcblx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gMVxuXG5cdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIHJlZ2lvbiA1XG5cblx0XHRcdFx0XHRzMSA9IC0gc2VnRXh0ZW50O1xuXHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIHMxIDw9IC0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0Ly8gcmVnaW9uIDRcblxuXHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCAtIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcblx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG5cdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XG5cblx0XHRcdFx0XHQvLyByZWdpb24gM1xuXG5cdFx0XHRcdFx0czAgPSAwO1xuXHRcdFx0XHRcdHMxID0gTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcblx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyByZWdpb24gMlxuXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcblx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuXHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBSYXkgYW5kIHNlZ21lbnQgYXJlIHBhcmFsbGVsLlxuXG5cdFx0XHRzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XG5cdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG5cdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XG5cblx0XHRcdG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLmRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzMCApLmFkZCggdGhpcy5vcmlnaW4gKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG5cdFx0XHRvcHRpb25hbFBvaW50T25TZWdtZW50LmNvcHkoIHNlZ0Rpci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzMSApLmFkZCggc2VnQ2VudGVyICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBzcXJEaXN0O1xuXG5cdH0sXG5cblx0aXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gc3BoZXJlLnJhZGl1cztcblxuXHR9LFxuXG5cdGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LnNjcmF0Y2hhcGl4ZWwuY29tL2xlc3NvbnMvM2QtYmFzaWMtbGVzc29ucy9sZXNzb24tNy1pbnRlcnNlY3Rpbmctc2ltcGxlLXNoYXBlcy9yYXktc3BoZXJlLWludGVyc2VjdGlvbi9cblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2MS5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0XHR2YXIgdGNhID0gdjEuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0XHR2YXIgZDIgPSB2MS5kb3QoIHYxICkgLSB0Y2EgKiB0Y2E7XG5cblx0XHRcdHZhciByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cblx0XHRcdGlmICggZDIgPiByYWRpdXMyICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xuXG5cdFx0XHQvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxuXHRcdFx0dmFyIHQwID0gdGNhIC0gdGhjO1xuXG5cdFx0XHQvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG5cdFx0XHR2YXIgdDEgPSB0Y2EgKyB0aGM7XG5cblx0XHRcdC8vIHRlc3QgdG8gc2VlIGlmIGJvdGggdDAgYW5kIHQxIGFyZSBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxuXHRcdFx0aWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdC8vIHRlc3QgdG8gc2VlIGlmIHQwIGlzIGJlaGluZCB0aGUgcmF5OlxuXHRcdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxuXHRcdFx0Ly8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuXHRcdFx0aWYgKCB0MCA8IDAgKSByZXR1cm4gdGhpcy5hdCggdDEsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0XHRcdC8vIGVsc2UgdDAgaXMgaW4gZnJvbnQgb2YgdGhlIHJheSwgc28gcmV0dXJuIHRoZSBmaXJzdCBjb2xsaXNpb24gcG9pbnQgc2NhbGVkIGJ5IHQwIFxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIHQwLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdFx0fVxuXG5cdH0oKSxcblxuXHRpc0ludGVyc2VjdGlvblBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxuXG5cdFx0dmFyIGRpc3RUb1BvaW50ID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0aWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXHRcdGlmICggZGVub21pbmF0b3IgPT0gMCApIHtcblxuXHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0aWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXG5cblx0XHRyZXR1cm4gdCA+PSAwID8gdCA6ICBudWxsO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0UGxhbmU6IGZ1bmN0aW9uICggcGxhbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcblxuXHRcdGlmICggdCA9PT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fSxcblxuXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3goIGJveCwgdiApICE9PSBudWxsO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0aW50ZXJzZWN0Qm94OiBmdW5jdGlvbiAoIGJveCAsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5zY3JhdGNoYXBpeGVsLmNvbS9sZXNzb25zLzNkLWJhc2ljLWxlc3NvbnMvbGVzc29uLTctaW50ZXJzZWN0aW5nLXNpbXBsZS1zaGFwZXMvcmF5LWJveC1pbnRlcnNlY3Rpb24vXG5cblx0XHR2YXIgdG1pbix0bWF4LHR5bWluLHR5bWF4LHR6bWluLHR6bWF4O1xuXG5cdFx0dmFyIGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcblx0XHRcdGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcblx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblxuXHRcdHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcblxuXHRcdGlmICggaW52ZGlyeCA+PSAwICkge1xuXG5cdFx0XHR0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblx0XHRcdHRtYXggPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cdFx0XHR0bWF4ID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblx0XHR9XG5cblx0XHRpZiAoIGludmRpcnkgPj0gMCApIHtcblxuXHRcdFx0dHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXHRcdFx0dHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXHRcdFx0dHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXHRcdH1cblxuXHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cblx0XHQvLyBUaGVzZSBsaW5lcyBhbHNvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0bWluIG9yIHRtYXggaXMgTmFOXG5cdFx0Ly8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxuXG5cdFx0aWYgKCB0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0eW1pbjtcblxuXHRcdGlmICggdHltYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHltYXg7XG5cblx0XHRpZiAoIGludmRpcnogPj0gMCApIHtcblxuXHRcdFx0dHptaW4gPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdFx0dHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdFx0dHptYXggPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdH1cblxuXHRcdGlmICggKCB0bWluID4gdHptYXggKSB8fCAoIHR6bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cblx0XHRpZiAoIHR6bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR6bWluO1xuXG5cdFx0aWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcblxuXHRcdC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcblxuXHRcdGlmICggdG1heCA8IDAgKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9LFxuXG5cdGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cblx0XHR2YXIgZGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIGVkZ2UxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgZWRnZTIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9MaWJNYXRoZW1hdGljcy9JbnRlcnNlY3Rpb24vV201SW50clJheTNUcmlhbmdsZTMuY3BwXG5cblx0XHRcdGVkZ2UxLnN1YlZlY3RvcnMoIGIsIGEgKTtcblx0XHRcdGVkZ2UyLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xuXG5cdFx0XHQvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcblx0XHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcblx0XHRcdC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxuXHRcdFx0Ly8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXG5cdFx0XHQvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxuXHRcdFx0dmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XG5cdFx0XHR2YXIgc2lnbjtcblxuXHRcdFx0aWYgKCBEZE4gPiAwICkge1xuXG5cdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdHNpZ24gPSAxO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xuXG5cdFx0XHRcdHNpZ24gPSAtIDE7XG5cdFx0XHRcdERkTiA9IC0gRGROO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRpZmYuc3ViVmVjdG9ycyggdGhpcy5vcmlnaW4sIGEgKTtcblx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcblxuXHRcdFx0Ly8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cblx0XHRcdGlmICggRGRReEUyIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTEuY3Jvc3MoIGRpZmYgKSApO1xuXG5cdFx0XHQvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0aWYgKCBEZEUxeFEgPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0XHRpZiAoIERkUXhFMiArIERkRTF4USA+IERkTiApIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMaW5lIGludGVyc2VjdHMgdHJpYW5nbGUsIGNoZWNrIGlmIHJheSBkb2VzLlxuXHRcdFx0dmFyIFFkTiA9IC0gc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcblxuXHRcdFx0Ly8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0aWYgKCBRZE4gPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJheSBpbnRlcnNlY3RzIHRyaWFuZ2xlLlxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xuXG5cdFx0dGhpcy5kaXJlY3Rpb24uYWRkKCB0aGlzLm9yaWdpbiApLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuXHRcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuXHRcdHRoaXMuZGlyZWN0aW9uLnN1YiggdGhpcy5vcmlnaW4gKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XG5cblx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5SYXkoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1NwaGVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TcGhlcmUgPSBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG5cdHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xuXG59O1xuXG5USFJFRS5TcGhlcmUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5TcGhlcmUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSAge1xuXG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5jZW50ZXI7XG5cblx0XHRcdGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjZW50ZXIuY29weSggb3B0aW9uYWxDZW50ZXIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRib3guc2V0RnJvbVBvaW50cyggcG9pbnRzICkuY2VudGVyKCBjZW50ZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50c1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiBcdFx0fTtcblxuXHR9KCksXG5cblx0Y29weTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XG5cdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xuXG5cdH0sXG5cblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcblxuXHR9LFxuXG5cdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0dmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcblxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggcmFkaXVzU3VtICogcmFkaXVzU3VtICk7XG5cblx0fSxcblxuXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciBkZWx0YUxlbmd0aFNxID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXN1bHQuY29weSggcG9pbnQgKTtcblxuXHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xuXG5cdFx0XHRyZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fSxcblxuXHRnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuQm94MygpO1xuXG5cdFx0Ym94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XG5cdFx0Ym94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xuXG5cdFx0cmV0dXJuIGJveDtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuXHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuU3BoZXJlKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9GcnVzdHVtLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5GcnVzdHVtID0gZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG5cdHRoaXMucGxhbmVzID0gW1xuXG5cdFx0KCBwMCAhPT0gdW5kZWZpbmVkICkgPyBwMCA6IG5ldyBUSFJFRS5QbGFuZSgpLFxuXHRcdCggcDEgIT09IHVuZGVmaW5lZCApID8gcDEgOiBuZXcgVEhSRUUuUGxhbmUoKSxcblx0XHQoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFRIUkVFLlBsYW5lKCksXG5cdFx0KCBwMyAhPT0gdW5kZWZpbmVkICkgPyBwMyA6IG5ldyBUSFJFRS5QbGFuZSgpLFxuXHRcdCggcDQgIT09IHVuZGVmaW5lZCApID8gcDQgOiBuZXcgVEhSRUUuUGxhbmUoKSxcblx0XHQoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFRIUkVFLlBsYW5lKClcblxuXHRdO1xuXG59O1xuXG5USFJFRS5GcnVzdHVtLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRnJ1c3R1bSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdHBsYW5lc1sgMCBdLmNvcHkoIHAwICk7XG5cdFx0cGxhbmVzWyAxIF0uY29weSggcDEgKTtcblx0XHRwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xuXHRcdHBsYW5lc1sgMyBdLmNvcHkoIHAzICk7XG5cdFx0cGxhbmVzWyA0IF0uY29weSggcDQgKTtcblx0XHRwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIGZydXN0dW0gKSB7XG5cblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRwbGFuZXNbIGkgXS5jb3B5KCBmcnVzdHVtLnBsYW5lc1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXHRcdHZhciBtZTAgPSBtZVsgMCBdLCBtZTEgPSBtZVsgMSBdLCBtZTIgPSBtZVsgMiBdLCBtZTMgPSBtZVsgMyBdO1xuXHRcdHZhciBtZTQgPSBtZVsgNCBdLCBtZTUgPSBtZVsgNSBdLCBtZTYgPSBtZVsgNiBdLCBtZTcgPSBtZVsgNyBdO1xuXHRcdHZhciBtZTggPSBtZVsgOCBdLCBtZTkgPSBtZVsgOSBdLCBtZTEwID0gbWVbIDEwIF0sIG1lMTEgPSBtZVsgMTEgXTtcblx0XHR2YXIgbWUxMiA9IG1lWyAxMiBdLCBtZTEzID0gbWVbIDEzIF0sIG1lMTQgPSBtZVsgMTQgXSwgbWUxNSA9IG1lWyAxNSBdO1xuXG5cdFx0cGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xuXHRcdHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cdFx0dmFyIGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XG5cdFx0dmFyIG5lZ1JhZGl1cyA9IC0gc3BoZXJlLnJhZGl1cztcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdHZhciBkaXN0YW5jZSA9IHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICk7XG5cblx0XHRcdGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNiA7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHBsYW5lID0gcGxhbmVzWyBpIF07XG5cblx0XHRcdFx0cDEueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5taW4ueCA6IGJveC5tYXgueDtcblx0XHRcdFx0cDIueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcblx0XHRcdFx0cDEueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5taW4ueSA6IGJveC5tYXgueTtcblx0XHRcdFx0cDIueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcblx0XHRcdFx0cDEueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5taW4ueiA6IGJveC5tYXguejtcblx0XHRcdFx0cDIueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5tYXgueiA6IGJveC5taW4uejtcblxuXHRcdFx0XHR2YXIgZDEgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAxICk7XG5cdFx0XHRcdHZhciBkMiA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDIgKTtcblxuXHRcdFx0XHQvLyBpZiBib3RoIG91dHNpZGUgcGxhbmUsIG5vIGludGVyc2VjdGlvblxuXG5cdFx0XHRcdGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0fSgpLFxuXG5cblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuRnJ1c3R1bSgpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvUGxhbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5QbGFuZSA9IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcblxuXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cdHRoaXMuY29uc3RhbnQgPSAoIGNvbnN0YW50ICE9PSB1bmRlZmluZWQgKSA/IGNvbnN0YW50IDogMDtcblxufTtcblxuVEhSRUUuUGxhbmUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5QbGFuZSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcblxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XG5cdFx0dGhpcy5jb25zdGFudCA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XG5cblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7XHQvLyBtdXN0IGJlIHRoaXMubm9ybWFsLCBub3Qgbm9ybWFsLCBhcyB0aGlzLm5vcm1hbCBpcyBub3JtYWxpemVkXG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0dmFyIG5vcm1hbCA9IHYxLnN1YlZlY3RvcnMoIGMsIGIgKS5jcm9zcyggdjIuc3ViVmVjdG9ycyggYSwgYiApICkubm9ybWFsaXplKCk7XG5cblx0XHRcdC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XG5cblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cblx0Y29weTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cblxuXHRcdHZhciBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XG5cdFx0dGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIGludmVyc2VOb3JtYWxMZW5ndGggKTtcblx0XHR0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jb25zdGFudCAqPSAtIDE7XG5cdFx0dGhpcy5ub3JtYWwubmVnYXRlKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XG5cblx0fSxcblxuXHRwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMub3J0aG9Qb2ludCggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkuc3ViKCBwb2ludCApLm5lZ2F0ZSgpO1xuXG5cdH0sXG5cblx0b3J0aG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcGVycGVuZGljdWxhck1hZ25pdHVkZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApO1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCBwZXJwZW5kaWN1bGFyTWFnbml0dWRlICk7XG5cblx0fSxcblxuXHRpc0ludGVyc2VjdGlvbkxpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcblxuXHRcdC8vIE5vdGU6IHRoaXMgdGVzdHMgaWYgYSBsaW5lIGludGVyc2VjdHMgdGhlIHBsYW5lLCBub3Qgd2hldGhlciBpdCAob3IgaXRzIGVuZC1wb2ludHMpIGFyZSBjb3BsYW5hciB3aXRoIGl0LlxuXG5cdFx0dmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XG5cdFx0dmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcblxuXHRcdHJldHVybiAoIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgKSB8fCAoIGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDAgKTtcblxuXHR9LFxuXG5cdGludGVyc2VjdExpbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xuXG5cdFx0XHR2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xuXG5cdFx0XHRpZiAoIGRlbm9taW5hdG9yID09IDAgKSB7XG5cblx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0XHRpZiAoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT0gMCApIHtcblxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQuY29weSggbGluZS5zdGFydCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdCA9IC0gKCBsaW5lLnN0YXJ0LmRvdCggdGhpcy5ub3JtYWwgKSArIHRoaXMuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0XHRpZiAoIHQgPCAwIHx8IHQgPiAxICkge1xuXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBkaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggbGluZS5zdGFydCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblxuXHRjb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtIHRoaXMuY29uc3RhbnQgKTtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXgsIG9wdGlvbmFsTm9ybWFsTWF0cml4ICkge1xuXG5cdFx0XHQvLyBjb21wdXRlIG5ldyBub3JtYWwgYmFzZWQgb24gdGhlb3J5IGhlcmU6XG5cdFx0XHQvLyBodHRwOi8vd3d3LnNvbmdoby5jYS9vcGVuZ2wvZ2xfbm9ybWFsdHJhbnNmb3JtLmh0bWxcblx0XHRcdHZhciBub3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBtMS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXHRcdFx0dmFyIG5ld05vcm1hbCA9IHYxLmNvcHkoIHRoaXMubm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKTtcblxuXHRcdFx0dmFyIG5ld0NvcGxhbmFyUG9pbnQgPSB0aGlzLmNvcGxhbmFyUG9pbnQoIHYyICk7XG5cdFx0XHRuZXdDb3BsYW5hclBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5ld05vcm1hbCwgbmV3Q29wbGFuYXJQb2ludCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmNvbnN0YW50ID0gdGhpcy5jb25zdGFudCAtIG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT0gdGhpcy5jb25zdGFudCApO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuUGxhbmUoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL01hdGguanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5NYXRoID0ge1xuXG5cdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5icm9vZmEuY29tL1Rvb2xzL01hdGgudXVpZC5odG1cblxuXHRcdHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoICcnICk7XG5cdFx0dmFyIHV1aWQgPSBuZXcgQXJyYXkoIDM2ICk7XG5cdFx0dmFyIHJuZCA9IDAsIHI7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAzNjsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGkgPT0gOCB8fCBpID09IDEzIHx8IGkgPT0gMTggfHwgaSA9PSAyMyApIHtcblxuXHRcdFx0XHRcdHV1aWRbIGkgXSA9ICctJztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpID09IDE0ICkge1xuXG5cdFx0XHRcdFx0dXVpZFsgaSBdID0gJzQnO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIHJuZCA8PSAweDAyICkgcm5kID0gMHgyMDAwMDAwICsgKCBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwICkgfCAwO1xuXHRcdFx0XHRcdHIgPSBybmQgJiAweGY7XG5cdFx0XHRcdFx0cm5kID0gcm5kID4+IDQ7XG5cdFx0XHRcdFx0dXVpZFsgaSBdID0gY2hhcnNbICggaSA9PSAxOSApID8gKCByICYgMHgzICkgfCAweDggOiByIF07XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdXVpZC5qb2luKCAnJyApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Ly8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGI+XG5cblx0Y2xhbXA6IGZ1bmN0aW9uICggeCwgYSwgYiApIHtcblxuXHRcdHJldHVybiAoIHggPCBhICkgPyBhIDogKCAoIHggPiBiICkgPyBiIDogeCApO1xuXG5cdH0sXG5cblx0Ly8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGluZilcblxuXHRjbGFtcEJvdHRvbTogZnVuY3Rpb24gKCB4LCBhICkge1xuXG5cdFx0cmV0dXJuIHggPCBhID8gYSA6IHg7XG5cblx0fSxcblxuXHQvLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XG5cblx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG5cdFx0cmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XG5cblx0fSxcblxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcblxuXHRzbW9vdGhzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0XHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xuXG5cdH0sXG5cblx0c21vb3RoZXJzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0XHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xuXG5cdH0sXG5cblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPDAsIDE+IHdpdGggMTYgYml0cyBvZiByYW5kb21uZXNzXG5cdC8vIChzdGFuZGFyZCBNYXRoLnJhbmRvbSgpIGNyZWF0ZXMgcmVwZXRpdGl2ZSBwYXR0ZXJucyB3aGVuIGFwcGxpZWQgb3ZlciBsYXJnZXIgc3BhY2UpXG5cblx0cmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIDY1MjgwICogTWF0aC5yYW5kb20oKSArIDI1NSAqIE1hdGgucmFuZG9tKCkgKSAvIDY1NTM1O1xuXG5cdH0sXG5cblx0Ly8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG5cdHJhbmRJbnQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG5cdFx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcblxuXHR9LFxuXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cblx0cmFuZEZsb2F0OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcblxuXHRcdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XG5cblx0fSxcblxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXG5cblx0cmFuZEZsb2F0U3ByZWFkOiBmdW5jdGlvbiAoIHJhbmdlICkge1xuXG5cdFx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XG5cblx0fSxcblxuXHRkZWdUb1JhZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvciA9IE1hdGguUEkgLyAxODA7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkZWdyZWVzICkge1xuXG5cdFx0XHRyZXR1cm4gZGVncmVlcyAqIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvcjtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHJhZFRvRGVnOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcmFkaWFuVG9EZWdyZWVzRmFjdG9yID0gMTgwIC8gTWF0aC5QSTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHJhZGlhbnMgKSB7XG5cblx0XHRcdHJldHVybiByYWRpYW5zICogcmFkaWFuVG9EZWdyZWVzRmFjdG9yO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1NwbGluZS5qc1xuXG4vKipcbiAqIFNwbGluZSBmcm9tIFR3ZWVuLmpzLCBzbGlnaHRseSBvcHRpbWl6ZWQgKGFuZCB0cmFzaGVkKVxuICogaHR0cDovL3NvbGUuZ2l0aHViLmNvbS90d2Vlbi5qcy9leGFtcGxlcy8wNV9zcGxpbmUuaHRtbFxuICpcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwbGluZSA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG5cdHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG5cdHZhciBjID0gW10sIHYzID0geyB4OiAwLCB5OiAwLCB6OiAwIH0sXG5cdHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCB3MiwgdzMsXG5cdHBhLCBwYiwgcGMsIHBkO1xuXG5cdHRoaXMuaW5pdEZyb21BcnJheSA9IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdHRoaXMucG9pbnRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5wb2ludHNbIGkgXSA9IHsgeDogYVsgaSBdWyAwIF0sIHk6IGFbIGkgXVsgMSBdLCB6OiBhWyBpIF1bIDIgXSB9O1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uICggayApIHtcblxuXHRcdHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBrO1xuXHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0XHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG5cdFx0Y1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcblx0XHRjWyAxIF0gPSBpbnRQb2ludDtcblx0XHRjWyAyIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAyID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcblx0XHRjWyAzIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAzID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMjtcblxuXHRcdHBhID0gdGhpcy5wb2ludHNbIGNbIDAgXSBdO1xuXHRcdHBiID0gdGhpcy5wb2ludHNbIGNbIDEgXSBdO1xuXHRcdHBjID0gdGhpcy5wb2ludHNbIGNbIDIgXSBdO1xuXHRcdHBkID0gdGhpcy5wb2ludHNbIGNbIDMgXSBdO1xuXG5cdFx0dzIgPSB3ZWlnaHQgKiB3ZWlnaHQ7XG5cdFx0dzMgPSB3ZWlnaHQgKiB3MjtcblxuXHRcdHYzLnggPSBpbnRlcnBvbGF0ZSggcGEueCwgcGIueCwgcGMueCwgcGQueCwgd2VpZ2h0LCB3MiwgdzMgKTtcblx0XHR2My55ID0gaW50ZXJwb2xhdGUoIHBhLnksIHBiLnksIHBjLnksIHBkLnksIHdlaWdodCwgdzIsIHczICk7XG5cdFx0djMueiA9IGludGVycG9sYXRlKCBwYS56LCBwYi56LCBwYy56LCBwZC56LCB3ZWlnaHQsIHcyLCB3MyApO1xuXG5cdFx0cmV0dXJuIHYzO1xuXG5cdH07XG5cblx0dGhpcy5nZXRDb250cm9sUG9pbnRzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgaSwgcCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aCxcblx0XHRcdGNvb3JkcyA9IFtdO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRwID0gdGhpcy5wb2ludHNbIGkgXTtcblx0XHRcdGNvb3Jkc1sgaSBdID0gWyBwLngsIHAueSwgcC56IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY29vcmRzO1xuXG5cdH07XG5cblx0Ly8gYXBwcm94aW1hdGUgbGVuZ3RoIGJ5IHN1bW1pbmcgbGluZWFyIHNlZ21lbnRzXG5cblx0dGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoIG5TdWJEaXZpc2lvbnMgKSB7XG5cblx0XHR2YXIgaSwgaW5kZXgsIG5TYW1wbGVzLCBwb3NpdGlvbixcblx0XHRcdHBvaW50ID0gMCwgaW50UG9pbnQgPSAwLCBvbGRJbnRQb2ludCA9IDAsXG5cdFx0XHRvbGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0Y2h1bmtMZW5ndGhzID0gW10sXG5cdFx0XHR0b3RhbExlbmd0aCA9IDA7XG5cblx0XHQvLyBmaXJzdCBwb2ludCBoYXMgMCBsZW5ndGhcblxuXHRcdGNodW5rTGVuZ3Roc1sgMCBdID0gMDtcblxuXHRcdGlmICggISBuU3ViRGl2aXNpb25zICkgblN1YkRpdmlzaW9ucyA9IDEwMDtcblxuXHRcdG5TYW1wbGVzID0gdGhpcy5wb2ludHMubGVuZ3RoICogblN1YkRpdmlzaW9ucztcblxuXHRcdG9sZFBvc2l0aW9uLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKTtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgblNhbXBsZXM7IGkgKysgKSB7XG5cblx0XHRcdGluZGV4ID0gaSAvIG5TYW1wbGVzO1xuXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XG5cdFx0XHR0bXBWZWMuY29weSggcG9zaXRpb24gKTtcblxuXHRcdFx0dG90YWxMZW5ndGggKz0gdG1wVmVjLmRpc3RhbmNlVG8oIG9sZFBvc2l0aW9uICk7XG5cblx0XHRcdG9sZFBvc2l0aW9uLmNvcHkoIHBvc2l0aW9uICk7XG5cblx0XHRcdHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBpbmRleDtcblx0XHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblxuXHRcdFx0aWYgKCBpbnRQb2ludCAhPSBvbGRJbnRQb2ludCApIHtcblxuXHRcdFx0XHRjaHVua0xlbmd0aHNbIGludFBvaW50IF0gPSB0b3RhbExlbmd0aDtcblx0XHRcdFx0b2xkSW50UG9pbnQgPSBpbnRQb2ludDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gbGFzdCBwb2ludCBlbmRzIHdpdGggdG90YWwgbGVuZ3RoXG5cblx0XHRjaHVua0xlbmd0aHNbIGNodW5rTGVuZ3Rocy5sZW5ndGggXSA9IHRvdGFsTGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHsgY2h1bmtzOiBjaHVua0xlbmd0aHMsIHRvdGFsOiB0b3RhbExlbmd0aCB9O1xuXG5cdH07XG5cblx0dGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGggPSBmdW5jdGlvbiAoIHNhbXBsaW5nQ29lZiApIHtcblxuXHRcdHZhciBpLCBqLFxuXHRcdFx0aW5kZXgsIGluZGV4Q3VycmVudCwgaW5kZXhOZXh0LFxuXHRcdFx0bGluZWFyRGlzdGFuY2UsIHJlYWxEaXN0YW5jZSxcblx0XHRcdHNhbXBsaW5nLCBwb3NpdGlvbixcblx0XHRcdG5ld3BvaW50cyA9IFtdLFxuXHRcdFx0dG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHNsID0gdGhpcy5nZXRMZW5ndGgoKTtcblxuXHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIDAgXSApLmNsb25lKCkgKTtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHQvL3RtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSAtIDEgXSApO1xuXHRcdFx0Ly9saW5lYXJEaXN0YW5jZSA9IHRtcFZlYy5kaXN0YW5jZVRvKCB0aGlzLnBvaW50c1sgaSBdICk7XG5cblx0XHRcdHJlYWxEaXN0YW5jZSA9IHNsLmNodW5rc1sgaSBdIC0gc2wuY2h1bmtzWyBpIC0gMSBdO1xuXG5cdFx0XHRzYW1wbGluZyA9IE1hdGguY2VpbCggc2FtcGxpbmdDb2VmICogcmVhbERpc3RhbmNlIC8gc2wudG90YWwgKTtcblxuXHRcdFx0aW5kZXhDdXJyZW50ID0gKCBpIC0gMSApIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XG5cdFx0XHRpbmRleE5leHQgPSBpIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XG5cblx0XHRcdGZvciAoIGogPSAxOyBqIDwgc2FtcGxpbmcgLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdGluZGV4ID0gaW5kZXhDdXJyZW50ICsgaiAqICggMSAvIHNhbXBsaW5nICkgKiAoIGluZGV4TmV4dCAtIGluZGV4Q3VycmVudCApO1xuXG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcblx0XHRcdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIF0gKS5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcblxuXHR9O1xuXG5cdC8vIENhdG11bGwtUm9tXG5cblx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XG5cblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcblx0XHRcdHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cblx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuXHR9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1RyaWFuZ2xlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlRyaWFuZ2xlID0gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG5cdHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy5iID0gKCBiICE9PSB1bmRlZmluZWQgKSA/IGIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR0aGlzLmMgPSAoIGMgIT09IHVuZGVmaW5lZCApID8gYyA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbn07XG5cblRIUkVFLlRyaWFuZ2xlLm5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXN1bHQuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcblx0XHRyZXN1bHQuY3Jvc3MoIHYwICk7XG5cblx0XHR2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcblx0XHRpZiAoIHJlc3VsdExlbmd0aFNxID4gMCApIHtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcblxuXHR9O1xuXG59KCk7XG5cbi8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljb29yZGluYXRlc1xuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcblRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHR2MS5zdWJWZWN0b3JzKCBiLCBhICk7XG5cdFx0djIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcblxuXHRcdHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcblx0XHR2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XG5cdFx0dmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xuXHRcdHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcblx0XHR2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XG5cblx0XHR2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdC8vIGNvbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG5cdFx0aWYgKCBkZW5vbSA9PSAwICkge1xuXHRcdFx0Ly8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XG5cdFx0XHQvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLSAyLCAtIDEsIC0gMSApO1xuXHRcdH1cblxuXHRcdHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcblx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xuXHRcdHZhciB2ID0gKCBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMiApICogaW52RGVub207XG5cblx0XHQvLyBiYXJ5Y29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcblx0XHRyZXR1cm4gcmVzdWx0LnNldCggMSAtIHUgLSB2LCB2LCB1ICk7XG5cblx0fTtcblxufSgpO1xuXG5USFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgYSwgYiwgYywgdjEgKTtcblxuXHRcdHJldHVybiAoIHJlc3VsdC54ID49IDAgKSAmJiAoIHJlc3VsdC55ID49IDAgKSAmJiAoICggcmVzdWx0LnggKyByZXN1bHQueSApIDw9IDEgKTtcblxuXHR9O1xuXG59KCk7XG5cblRIUkVFLlRyaWFuZ2xlLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVHJpYW5nbGUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHR0aGlzLmEuY29weSggYSApO1xuXHRcdHRoaXMuYi5jb3B5KCBiICk7XG5cdFx0dGhpcy5jLmNvcHkoIGMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uICggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xuXG5cdFx0dGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xuXHRcdHRoaXMuYi5jb3B5KCBwb2ludHNbIGkxIF0gKTtcblx0XHR0aGlzLmMuY29weSggcG9pbnRzWyBpMiBdICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XG5cblx0XHR0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xuXHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XG5cdFx0dGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXJlYTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0djAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcblx0XHRcdHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XG5cblx0XHRcdHJldHVybiB2MC5jcm9zcyggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdG1pZHBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XG5cblx0fSxcblxuXHRub3JtYWw6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH0sXG5cblx0cGxhbmU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlBsYW5lKCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG5cdH0sXG5cblx0YmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH0sXG5cblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xuXG5cdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVHJpYW5nbGUoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0Nsb2NrLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5DbG9jayA9IGZ1bmN0aW9uICggYXV0b1N0YXJ0ICkge1xuXG5cdHRoaXMuYXV0b1N0YXJ0ID0gKCBhdXRvU3RhcnQgIT09IHVuZGVmaW5lZCApID8gYXV0b1N0YXJ0IDogdHJ1ZTtcblxuXHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdHRoaXMub2xkVGltZSA9IDA7XG5cdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXG5cdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5DbG9jay5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkNsb2NrLFxuXG5cdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnN0YXJ0VGltZSA9IHNlbGYucGVyZm9ybWFuY2UgIT09IHVuZGVmaW5lZCAmJiBzZWxmLnBlcmZvcm1hbmNlLm5vdyAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0ID8gc2VsZi5wZXJmb3JtYW5jZS5ub3coKVxuXHRcdFx0XHRcdCA6IERhdGUubm93KCk7XG5cblx0XHR0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcblx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZ2V0RWxhcHNlZFRpbWUoKTtcblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuXHR9LFxuXG5cdGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmdldERlbHRhKCk7XG5cdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cblx0fSxcblxuXHRnZXREZWx0YTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGRpZmYgPSAwO1xuXG5cdFx0aWYgKCB0aGlzLmF1dG9TdGFydCAmJiAhIHRoaXMucnVubmluZyApIHtcblxuXHRcdFx0dGhpcy5zdGFydCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cblx0XHRcdHZhciBuZXdUaW1lID0gc2VsZi5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHNlbGYucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQgPyBzZWxmLnBlcmZvcm1hbmNlLm5vdygpXG5cdFx0XHRcdFx0IDogRGF0ZS5ub3coKTtcblxuXHRcdFx0ZGlmZiA9IDAuMDAxICogKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICk7XG5cdFx0XHR0aGlzLm9sZFRpbWUgPSBuZXdUaW1lO1xuXG5cdFx0XHR0aGlzLmVsYXBzZWRUaW1lICs9IGRpZmY7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGlmZjtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzXG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXG4gKi9cblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKCkge31cblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRXZlbnREaXNwYXRjaGVyLFxuXG5cdGFwcGx5OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdG9iamVjdC5hZGRFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdG9iamVjdC5oYXNFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNFdmVudExpc3RlbmVyO1xuXHRcdG9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50ID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50O1xuXG5cdH0sXG5cblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cblx0XHR9XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDEgKSB7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XG5cblx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9LFxuXG5cdGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cblx0XHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXSA9IGxpc3RlbmVyQXJyYXlbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL1JheWNhc3Rlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb20vXG4gKiBAYXV0aG9yIHN0ZXBob21pIC8gaHR0cDovL3N0ZXBoYW5lZ2luaWVyLmNvbS9cbiAqL1xuXG4oIGZ1bmN0aW9uICggVEhSRUUgKSB7XG5cblx0VEhSRUUuUmF5Y2FzdGVyID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xuXG5cdFx0dGhpcy5yYXkgPSBuZXcgVEhSRUUuUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHR0aGlzLm5lYXIgPSBuZWFyIHx8IDA7XG5cdFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XG5cblx0XHR0aGlzLnBhcmFtcyA9IHtcblx0XHRcdFNwcml0ZToge30sXG5cdFx0XHRNZXNoOiB7fSxcblx0XHRcdFBvaW50Q2xvdWQ6IHsgdGhyZXNob2xkOiAxIH0sXG5cdFx0XHRMT0Q6IHt9LFxuXHRcdFx0TGluZToge31cblx0XHR9O1xuXG5cdH07XG5cblx0dmFyIGRlc2NTb3J0ID0gZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuXG5cdH07XG5cblx0dmFyIGludGVyc2VjdE9iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aW50ZXJzZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly9cblxuXHRUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLlJheWNhc3RlcixcblxuXHRcdHByZWNpc2lvbjogMC4wMDAxLFxuXHRcdGxpbmVQcmVjaXNpb246IDEsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cblx0XHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblx0XHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0T2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xuXG5cdFx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xuXG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cblx0XHRcdGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcblxuXHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0T2JqZWN0czogZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdHZhciBpbnRlcnNlY3RzID0gW107XG5cblx0XHRcdGlmICggb2JqZWN0cyBpbnN0YW5jZW9mIEFycmF5ID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLlJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzOiBvYmplY3RzIGlzIG5vdCBhbiBBcnJheS4nICk7XG5cdFx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xuXG5cdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHRcdH1cblxuXHR9O1xuXG59KCBUSFJFRSApICk7XG5cbi8vIEZpbGU6c3JjL2NvcmUvT2JqZWN0M0QuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5PYmplY3QzRCA9IGZ1bmN0aW9uICgpIHtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLk9iamVjdDNESWRDb3VudCArKyB9ICk7XG5cblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLm5hbWUgPSAnJztcblx0dGhpcy50eXBlID0gJ09iamVjdDNEJztcblxuXHR0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcblx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXG5cdHRoaXMudXAgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciByb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigpO1xuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cdHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XG5cblx0dmFyIG9uUm90YXRpb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xuXHR9O1xuXG5cdHZhciBvblF1YXRlcm5pb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcblx0fTtcblxuXHRyb3RhdGlvbi5vbkNoYW5nZSggb25Sb3RhdGlvbkNoYW5nZSApO1xuXHRxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0dmFsdWU6IHBvc2l0aW9uXG5cdFx0fSxcblx0XHRyb3RhdGlvbjoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiByb3RhdGlvblxuXHRcdH0sXG5cdFx0cXVhdGVybmlvbjoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBxdWF0ZXJuaW9uXG5cdFx0fSxcblx0XHRzY2FsZToge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBzY2FsZVxuXHRcdH0sXG5cdH0gKTtcblxuXHR0aGlzLnJlbmRlckRlcHRoID0gbnVsbDtcblxuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRydWU7XG5cblx0dGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuXHR0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xuXG5cdHRoaXMudXNlckRhdGEgPSB7fTtcblxufTtcblxuVEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3QzRCxcblxuXHRnZXQgZXVsZXJPcmRlciAoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaGFzIGJlZW4gbW92ZWQgdG8gLnJvdGF0aW9uLm9yZGVyLicgKTtcblxuXHRcdHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xuXG5cdH0sXG5cblx0c2V0IGV1bGVyT3JkZXIgKCB2YWx1ZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBoYXMgYmVlbiBtb3ZlZCB0byAucm90YXRpb24ub3JkZXIuJyApO1xuXG5cdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHZhbHVlO1xuXG5cdH0sXG5cblx0Z2V0IHVzZVF1YXRlcm5pb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xuXG5cdH0sXG5cblx0c2V0IHVzZVF1YXRlcm5pb24gKCB2YWx1ZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdHRoaXMubWF0cml4LmRlY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyLCB0cnVlICk7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XG5cblx0fSxcblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHQvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcblxuXHR9LFxuXG5cdHJvdGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHR2YXIgcTEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRcdHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggcTEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXhpcywgZGlzdGFuY2UgKSB7XG5cblx0XHRcdHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0XHR0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBkaXN0YW5jZSwgYXhpcyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApO1xuXG5cdH0sXG5cblx0dHJhbnNsYXRlWDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNsYXRlWTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNsYXRlWjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0bG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0fSxcblxuXHR3b3JsZFRvTG9jYWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICkgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cblx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0XHRtMS5sb29rQXQoIHZlY3RvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy51cCApO1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0YWRkOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0XHRpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6XCIsIG9iamVjdCwgXCJjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi5cIiApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9iamVjdDNEICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWQnIH0gKTtcblxuXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOlwiLCBvYmplY3QsIFwiaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELlwiICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cblx0XHRcdFx0dGhpcy5yZW1vdmUoIGFyZ3VtZW50c1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAncmVtb3ZlZCcgfSApO1xuXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGdldENoaWxkQnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZ2V0Q2hpbGRCeU5hbWUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRPYmplY3RCeU5hbWUoKS4nICk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lLCByZWN1cnNpdmUgKTtcblxuXHR9LFxuXG5cdGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGlmICggdGhpcy5pZCA9PT0gaWQgKSByZXR1cm4gdGhpcztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuXHRcdFx0dmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5SWQoIGlkLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdH0sXG5cblx0Z2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGlmICggdGhpcy5uYW1lID09PSBuYW1lICkgcmV0dXJuIHRoaXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcblx0XHRcdHZhciBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeU5hbWUoIG5hbWUsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fSxcblxuXHRnZXRXb3JsZFBvc2l0aW9uOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH0sXG5cblx0Z2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCByZXN1bHQsIHNjYWxlICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdGdldFdvcmxkUm90YXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkV1bGVyKCk7XG5cblx0XHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHRoaXMucm90YXRpb24ub3JkZXIsIGZhbHNlICk7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgcmVzdWx0ICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdHJheWNhc3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdHRyYXZlcnNlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0dHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHVwZGF0ZU1hdHJpeDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH0sXG5cblx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRmb3JjZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5jaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb3V0cHV0ID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC4zLFxuXHRcdFx0XHR0eXBlOiAnT2JqZWN0Jyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0RXhwb3J0ZXInXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vXG5cblx0XHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG5cdFx0dmFyIHBhcnNlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRpZiAoIG91dHB1dC5nZW9tZXRyaWVzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0b3V0cHV0Lmdlb21ldHJpZXMgPSBbXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJpZXNbIGdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBqc29uID0gZ2VvbWV0cnkudG9KU09OKCk7XG5cblx0XHRcdFx0ZGVsZXRlIGpzb24ubWV0YWRhdGE7XG5cblx0XHRcdFx0Z2VvbWV0cmllc1sgZ2VvbWV0cnkudXVpZCBdID0ganNvbjtcblxuXHRcdFx0XHRvdXRwdXQuZ2VvbWV0cmllcy5wdXNoKCBqc29uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5LnV1aWQ7XG5cblx0XHR9O1xuXG5cdFx0Ly9cblxuXHRcdHZhciBtYXRlcmlhbHMgPSB7fTtcblxuXHRcdHZhciBwYXJzZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0aWYgKCBvdXRwdXQubWF0ZXJpYWxzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0b3V0cHV0Lm1hdGVyaWFscyA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxzWyBtYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIganNvbiA9IG1hdGVyaWFsLnRvSlNPTigpO1xuXG5cdFx0XHRcdGRlbGV0ZSBqc29uLm1ldGFkYXRhO1xuXG5cdFx0XHRcdG1hdGVyaWFsc1sgbWF0ZXJpYWwudXVpZCBdID0ganNvbjtcblxuXHRcdFx0XHRvdXRwdXQubWF0ZXJpYWxzLnB1c2goIGpzb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWwudXVpZDtcblxuXHRcdH07XG5cblx0XHQvL1xuXG5cdFx0dmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGRhdGEudXVpZCA9IG9iamVjdC51dWlkO1xuXHRcdFx0ZGF0YS50eXBlID0gb2JqZWN0LnR5cGU7XG5cblx0XHRcdGlmICggb2JqZWN0Lm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gb2JqZWN0Lm5hbWU7XG5cdFx0XHRpZiAoIEpTT04uc3RyaW5naWZ5KCBvYmplY3QudXNlckRhdGEgKSAhPT0gJ3t9JyApIGRhdGEudXNlckRhdGEgPSBvYmplY3QudXNlckRhdGE7XG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICE9PSB0cnVlICkgZGF0YS52aXNpYmxlID0gb2JqZWN0LnZpc2libGU7XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0ZGF0YS5mb3YgPSBvYmplY3QuZm92O1xuXHRcdFx0XHRkYXRhLmFzcGVjdCA9IG9iamVjdC5hc3BlY3Q7XG5cdFx0XHRcdGRhdGEubmVhciA9IG9iamVjdC5uZWFyO1xuXHRcdFx0XHRkYXRhLmZhciA9IG9iamVjdC5mYXI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRkYXRhLmxlZnQgPSBvYmplY3QubGVmdDtcblx0XHRcdFx0ZGF0YS5yaWdodCA9IG9iamVjdC5yaWdodDtcblx0XHRcdFx0ZGF0YS50b3AgPSBvYmplY3QudG9wO1xuXHRcdFx0XHRkYXRhLmJvdHRvbSA9IG9iamVjdC5ib3R0b207XG5cdFx0XHRcdGRhdGEubmVhciA9IG9iamVjdC5uZWFyO1xuXHRcdFx0XHRkYXRhLmZhciA9IG9iamVjdC5mYXI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkFtYmllbnRMaWdodCApIHtcblxuXHRcdFx0XHRkYXRhLmNvbG9yID0gb2JqZWN0LmNvbG9yLmdldEhleCgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG5cdFx0XHRcdGRhdGEuY29sb3IgPSBvYmplY3QuY29sb3IuZ2V0SGV4KCk7XG5cdFx0XHRcdGRhdGEuaW50ZW5zaXR5ID0gb2JqZWN0LmludGVuc2l0eTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHRkYXRhLmNvbG9yID0gb2JqZWN0LmNvbG9yLmdldEhleCgpO1xuXHRcdFx0XHRkYXRhLmludGVuc2l0eSA9IG9iamVjdC5pbnRlbnNpdHk7XG5cdFx0XHRcdGRhdGEuZGlzdGFuY2UgPSBvYmplY3QuZGlzdGFuY2U7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcblxuXHRcdFx0XHRkYXRhLmNvbG9yID0gb2JqZWN0LmNvbG9yLmdldEhleCgpO1xuXHRcdFx0XHRkYXRhLmludGVuc2l0eSA9IG9iamVjdC5pbnRlbnNpdHk7XG5cdFx0XHRcdGRhdGEuZGlzdGFuY2UgPSBvYmplY3QuZGlzdGFuY2U7XG5cdFx0XHRcdGRhdGEuYW5nbGUgPSBvYmplY3QuYW5nbGU7XG5cdFx0XHRcdGRhdGEuZXhwb25lbnQgPSBvYmplY3QuZXhwb25lbnQ7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIHtcblxuXHRcdFx0XHRkYXRhLmNvbG9yID0gb2JqZWN0LmNvbG9yLmdldEhleCgpO1xuXHRcdFx0XHRkYXRhLmdyb3VuZENvbG9yID0gb2JqZWN0Lmdyb3VuZENvbG9yLmdldEhleCgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG5cdFx0XHRcdGRhdGEuZ2VvbWV0cnkgPSBwYXJzZUdlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnkgKTtcblx0XHRcdFx0ZGF0YS5tYXRlcmlhbCA9IHBhcnNlTWF0ZXJpYWwoIG9iamVjdC5tYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG5cdFx0XHRcdGRhdGEuZ2VvbWV0cnkgPSBwYXJzZUdlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnkgKTtcblx0XHRcdFx0ZGF0YS5tYXRlcmlhbCA9IHBhcnNlTWF0ZXJpYWwoIG9iamVjdC5tYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUgKSB7XG5cblx0XHRcdFx0ZGF0YS5tYXRlcmlhbCA9IHBhcnNlTWF0ZXJpYWwoIG9iamVjdC5tYXRlcmlhbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRhdGEubWF0cml4ID0gb2JqZWN0Lm1hdHJpeC50b0FycmF5KCk7XG5cblx0XHRcdGlmICggb2JqZWN0LmNoaWxkcmVuLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0ZGF0YS5jaGlsZHJlbiA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRkYXRhLmNoaWxkcmVuLnB1c2goIHBhcnNlT2JqZWN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0b3V0cHV0Lm9iamVjdCA9IHBhcnNlT2JqZWN0KCB0aGlzICk7XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XG5cblx0XHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XG5cblx0XHRvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdG9iamVjdC51cC5jb3B5KCB0aGlzLnVwICk7XG5cblx0XHRvYmplY3QucG9zaXRpb24uY29weSggdGhpcy5wb3NpdGlvbiApO1xuXHRcdG9iamVjdC5xdWF0ZXJuaW9uLmNvcHkoIHRoaXMucXVhdGVybmlvbiApO1xuXHRcdG9iamVjdC5zY2FsZS5jb3B5KCB0aGlzLnNjYWxlICk7XG5cblx0XHRvYmplY3QucmVuZGVyRGVwdGggPSB0aGlzLnJlbmRlckRlcHRoO1xuXG5cdFx0b2JqZWN0LnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRoaXMucm90YXRpb25BdXRvVXBkYXRlO1xuXG5cdFx0b2JqZWN0Lm1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXHRcdG9iamVjdC5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IHRoaXMubWF0cml4QXV0b1VwZGF0ZTtcblx0XHRvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblxuXHRcdG9iamVjdC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG5cdFx0b2JqZWN0LmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG5cdFx0b2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XG5cblx0XHRvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IHRoaXMuZnJ1c3R1bUN1bGxlZDtcblxuXHRcdG9iamVjdC51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRcdG9iamVjdC5hZGQoIGNoaWxkLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iamVjdDtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG5USFJFRS5PYmplY3QzRElkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9jb3JlL1Byb2plY3Rvci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUHJvamVjdG9yID0gZnVuY3Rpb24gKCkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvcmVuZGVyZXJzL1Byb2plY3Rvci5qcy4nICk7XG5cblx0dGhpcy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XG5cdFx0dmVjdG9yLnByb2plY3QoIGNhbWVyYSApO1xuXG5cdH07XG5cblx0dGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUHJvamVjdG9yOiAudW5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci51bnByb2plY3QoKS4nICk7XG5cdFx0dmVjdG9yLnVucHJvamVjdCggY2FtZXJhICk7XG5cblx0fTtcblxuXHR0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvcjogLnBpY2tpbmdSYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2UzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRmFjZTMgPSBmdW5jdGlvbiAoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0dGhpcy5hID0gYTtcblx0dGhpcy5iID0gYjtcblx0dGhpcy5jID0gYztcblxuXHR0aGlzLm5vcm1hbCA9IG5vcm1hbCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR0aGlzLnZlcnRleE5vcm1hbHMgPSBub3JtYWwgaW5zdGFuY2VvZiBBcnJheSA/IG5vcm1hbCA6IFtdO1xuXG5cdHRoaXMuY29sb3IgPSBjb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yID8gY29sb3IgOiBuZXcgVEhSRUUuQ29sb3IoKTtcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBjb2xvciBpbnN0YW5jZW9mIEFycmF5ID8gY29sb3IgOiBbXTtcblxuXHR0aGlzLnZlcnRleFRhbmdlbnRzID0gW107XG5cblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XG5cbn07XG5cblRIUkVFLkZhY2UzLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTMsXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cblx0XHRmYWNlLm5vcm1hbC5jb3B5KCB0aGlzLm5vcm1hbCApO1xuXHRcdGZhY2UuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXG5cdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gdGhpcy5tYXRlcmlhbEluZGV4O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSB0aGlzLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRmYWNlLnZlcnRleENvbG9yc1sgaSBdID0gdGhpcy52ZXJ0ZXhDb2xvcnNbIGkgXS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4VGFuZ2VudHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGZhY2UudmVydGV4VGFuZ2VudHNbIGkgXSA9IHRoaXMudmVydGV4VGFuZ2VudHNbIGkgXS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhY2U7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2U0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5GYWNlNCA9IGZ1bmN0aW9uICggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLicgKVxuXHRyZXR1cm4gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblxuXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSxcblxuXHRnZXQgbGVuZ3RoICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblxuXHR9LFxuXG5cdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG5cdFx0aW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG5cdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICAgICBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAgICAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAgICAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIHRoaXMuYXJyYXkgKSwgdGhpcy5pdGVtU2l6ZSApO1xuXG5cdH1cblxufTtcblxuLy9cblxuVEhSRUUuSW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW50OEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEsIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQ4QXR0cmlidXRlID0gZnVuY3Rpb24gKCBkYXRhLCBpdGVtU2l6ZSApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5VaW50OEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEsIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIGluc3RlYWQuJyApO1xuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggZGF0YSwgaXRlbVNpemUgKTtcblxuXG59O1xuXG5USFJFRS5JbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW50MTZBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkgaW5zdGVhZC4nICk7XG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBkYXRhLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGRhdGEsIGl0ZW1TaXplICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlVpbnQxNkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEsIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkludDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBkYXRhLCBpdGVtU2l6ZSApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5JbnQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEsIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIGluc3RlYWQuJyApO1xuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggZGF0YSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSBpbnN0ZWFkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEsIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGRhdGEsIGl0ZW1TaXplICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkgaW5zdGVhZC4nICk7XG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBkYXRhLCBpdGVtU2l6ZSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xuXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5hdHRyaWJ1dGVzID0ge307XG5cdHRoaXMuYXR0cmlidXRlc0tleXMgPSBbXTtcblxuXHR0aGlzLmRyYXdjYWxscyA9IFtdO1xuXHR0aGlzLm9mZnNldHMgPSB0aGlzLmRyYXdjYWxsczsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cbn07XG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyR2VvbWV0cnksXG5cblx0YWRkQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUsIGF0dHJpYnV0ZSApIHtcblxuXHRcdGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLicgKTtcblxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSB7IGFycmF5OiBhcmd1bWVudHNbIDEgXSwgaXRlbVNpemU6IGFyZ3VtZW50c1sgMiBdIH07XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xuXHRcdHRoaXMuYXR0cmlidXRlc0tleXMgPSBPYmplY3Qua2V5cyggdGhpcy5hdHRyaWJ1dGVzICk7XG5cblx0fSxcblxuXHRnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHR9LFxuXG5cdGFkZERyYXdDYWxsOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgaW5kZXhPZmZzZXQgKSB7XG5cblx0XHR0aGlzLmRyYXdjYWxscy5wdXNoKCB7XG5cblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGNvdW50OiBjb3VudCxcblx0XHRcdGluZGV4OiBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkID8gaW5kZXhPZmZzZXQgOiAwXG5cblx0XHR9ICk7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBwb3NpdGlvbi5hcnJheSApO1xuXHRcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRub3JtYWxNYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggbm9ybWFsLmFycmF5ICk7XG5cdFx0XHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBUT0RPXG5cblx0fSxcblxuXHRmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHNldHRpbmdzICkge1xuXG5cdFx0c2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7ICd2ZXJ0ZXhDb2xvcnMnOiBUSFJFRS5Ob0NvbG9ycyB9O1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG5cdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xuXHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBzZXR0aW5ncy52ZXJ0ZXhDb2xvcnM7XG5cdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IGZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwO1xuXHRcdHZhciBoYXNGYWNlVmVydGV4Tm9ybWFscyA9IGZhY2VzWyAwIF0udmVydGV4Tm9ybWFscy5sZW5ndGggPT0gMztcblxuXHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlcy5sZW5ndGggKiAzICogMyApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXG5cdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlcy5sZW5ndGggKiAzICogMyApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0XHRpZiAoIHZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSB7XG5cblx0XHRcdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlcy5sZW5ndGggKiAzICogMyApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGZhY2VzLmxlbmd0aCAqIDMgKiAyICk7XG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMCwgaTIgPSAwLCBpMyA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKyssIGkyICs9IDYsIGkzICs9IDkgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0dmFyIGEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XG5cdFx0XHR2YXIgYiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcblx0XHRcdHZhciBjID0gdmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRwb3NpdGlvbnNbIGkzICAgICBdID0gYS54O1xuXHRcdFx0cG9zaXRpb25zWyBpMyArIDEgXSA9IGEueTtcblx0XHRcdHBvc2l0aW9uc1sgaTMgKyAyIF0gPSBhLno7XG5cblx0XHRcdHBvc2l0aW9uc1sgaTMgKyAzIF0gPSBiLng7XG5cdFx0XHRwb3NpdGlvbnNbIGkzICsgNCBdID0gYi55O1xuXHRcdFx0cG9zaXRpb25zWyBpMyArIDUgXSA9IGIuejtcblxuXHRcdFx0cG9zaXRpb25zWyBpMyArIDYgXSA9IGMueDtcblx0XHRcdHBvc2l0aW9uc1sgaTMgKyA3IF0gPSBjLnk7XG5cdFx0XHRwb3NpdGlvbnNbIGkzICsgOCBdID0gYy56O1xuXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWxzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHZhciBuYSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdO1xuXHRcdFx0XHR2YXIgbmIgPSBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXTtcblx0XHRcdFx0dmFyIG5jID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF07XG5cblx0XHRcdFx0bm9ybWFsc1sgaTMgICAgIF0gPSBuYS54O1xuXHRcdFx0XHRub3JtYWxzWyBpMyArIDEgXSA9IG5hLnk7XG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgMiBdID0gbmEuejtcblxuXHRcdFx0XHRub3JtYWxzWyBpMyArIDMgXSA9IG5iLng7XG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgNCBdID0gbmIueTtcblx0XHRcdFx0bm9ybWFsc1sgaTMgKyA1IF0gPSBuYi56O1xuXG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgNiBdID0gbmMueDtcblx0XHRcdFx0bm9ybWFsc1sgaTMgKyA3IF0gPSBuYy55O1xuXHRcdFx0XHRub3JtYWxzWyBpMyArIDggXSA9IG5jLno7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIG4gPSBmYWNlLm5vcm1hbDtcblxuXHRcdFx0XHRub3JtYWxzWyBpMyAgICAgXSA9IG4ueDtcblx0XHRcdFx0bm9ybWFsc1sgaTMgKyAxIF0gPSBuLnk7XG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgMiBdID0gbi56O1xuXG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgMyBdID0gbi54O1xuXHRcdFx0XHRub3JtYWxzWyBpMyArIDQgXSA9IG4ueTtcblx0XHRcdFx0bm9ybWFsc1sgaTMgKyA1IF0gPSBuLno7XG5cblx0XHRcdFx0bm9ybWFsc1sgaTMgKyA2IF0gPSBuLng7XG5cdFx0XHRcdG5vcm1hbHNbIGkzICsgNyBdID0gbi55O1xuXHRcdFx0XHRub3JtYWxzWyBpMyArIDggXSA9IG4uejtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZlcnRleENvbG9ycyA9PT0gVEhSRUUuRmFjZUNvbG9ycyApIHtcblxuXHRcdFx0XHR2YXIgZmMgPSBmYWNlLmNvbG9yO1xuXG5cdFx0XHRcdGNvbG9yc1sgaTMgICAgIF0gPSBmYy5yO1xuXHRcdFx0XHRjb2xvcnNbIGkzICsgMSBdID0gZmMuZztcblx0XHRcdFx0Y29sb3JzWyBpMyArIDIgXSA9IGZjLmI7XG5cblx0XHRcdFx0Y29sb3JzWyBpMyArIDMgXSA9IGZjLnI7XG5cdFx0XHRcdGNvbG9yc1sgaTMgKyA0IF0gPSBmYy5nO1xuXHRcdFx0XHRjb2xvcnNbIGkzICsgNSBdID0gZmMuYjtcblxuXHRcdFx0XHRjb2xvcnNbIGkzICsgNiBdID0gZmMucjtcblx0XHRcdFx0Y29sb3JzWyBpMyArIDcgXSA9IGZjLmc7XG5cdFx0XHRcdGNvbG9yc1sgaTMgKyA4IF0gPSBmYy5iO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB2ZXJ0ZXhDb2xvcnMgPT09IFRIUkVFLlZlcnRleENvbG9ycyApIHtcblxuXHRcdFx0XHR2YXIgdmNhID0gZmFjZS52ZXJ0ZXhDb2xvcnNbIDAgXTtcblx0XHRcdFx0dmFyIHZjYiA9IGZhY2UudmVydGV4Q29sb3JzWyAxIF07XG5cdFx0XHRcdHZhciB2Y2MgPSBmYWNlLnZlcnRleENvbG9yc1sgMiBdO1xuXG5cdFx0XHRcdGNvbG9yc1sgaTMgICAgIF0gPSB2Y2Eucjtcblx0XHRcdFx0Y29sb3JzWyBpMyArIDEgXSA9IHZjYS5nO1xuXHRcdFx0XHRjb2xvcnNbIGkzICsgMiBdID0gdmNhLmI7XG5cblx0XHRcdFx0Y29sb3JzWyBpMyArIDMgXSA9IHZjYi5yO1xuXHRcdFx0XHRjb2xvcnNbIGkzICsgNCBdID0gdmNiLmc7XG5cdFx0XHRcdGNvbG9yc1sgaTMgKyA1IF0gPSB2Y2IuYjtcblxuXHRcdFx0XHRjb2xvcnNbIGkzICsgNiBdID0gdmNjLnI7XG5cdFx0XHRcdGNvbG9yc1sgaTMgKyA3IF0gPSB2Y2MuZztcblx0XHRcdFx0Y29sb3JzWyBpMyArIDggXSA9IHZjYy5iO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHZhciB1dmEgPSBmYWNlVmVydGV4VXZzWyAwIF1bIGkgXVsgMCBdO1xuXHRcdFx0XHR2YXIgdXZiID0gZmFjZVZlcnRleFV2c1sgMCBdWyBpIF1bIDEgXTtcblx0XHRcdFx0dmFyIHV2YyA9IGZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdWyAyIF07XG5cblx0XHRcdFx0dXZzWyBpMiAgICAgXSA9IHV2YS54O1xuXHRcdFx0XHR1dnNbIGkyICsgMSBdID0gdXZhLnk7XG5cblx0XHRcdFx0dXZzWyBpMiArIDIgXSA9IHV2Yi54O1xuXHRcdFx0XHR1dnNbIGkyICsgMyBdID0gdXZiLnk7XG5cblx0XHRcdFx0dXZzWyBpMiArIDQgXSA9IHV2Yy54O1xuXHRcdFx0XHR1dnNbIGkyICsgNSBdID0gdXZjLnk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKClcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRpZiAoIHBvc2l0aW9ucyApIHtcblxuXHRcdFx0XHR2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94O1xuXHRcdFx0XHRiYi5tYWtlRW1wdHkoKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2ZWN0b3Iuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcblx0XHRcdFx0XHRiYi5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwb3NpdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3gubWluLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0oKSxcblxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0aWYgKCBwb3NpdGlvbnMgKSB7XG5cblx0XHRcdFx0Ym94Lm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2ZWN0b3Iuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcblx0XHRcdFx0XHRib3guZXhwYW5kQnlQb2ludCggdmVjdG9yICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJveC5jZW50ZXIoIGNlbnRlciApO1xuXG5cdFx0XHRcdC8vIGhvcGluZyB0byBmaW5kIGEgYm91bmRpbmdTcGhlcmUgd2l0aCBhIHJhZGl1cyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogIHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXG5cblx0XHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2ZWN0b3Iuc2V0KCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKTtcblx0XHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB2ZWN0b3IgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyApICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9KCksXG5cblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5cdH0sXG5cblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xuXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cblxuXHRcdFx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSBdID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuXHRcdFx0dmFyIHZBLCB2QiwgdkMsXG5cblx0XHRcdHBBID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHBDID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuXHRcdFx0Y2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0YWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXG5cblx0XHRcdGlmICggYXR0cmlidXRlcy5pbmRleCApIHtcblxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG5cblx0XHRcdFx0dmFyIG9mZnNldHMgPSAoIHRoaXMub2Zmc2V0cy5sZW5ndGggPiAwID8gdGhpcy5vZmZzZXRzIDogWyB7IHN0YXJ0OiAwLCBjb3VudDogaW5kaWNlcy5sZW5ndGgsIGluZGV4OiAwIH0gXSApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBvZmZzZXRzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xuXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gb2Zmc2V0c1sgaiBdLnN0YXJ0O1xuXHRcdFx0XHRcdHZhciBjb3VudCA9IG9mZnNldHNbIGogXS5jb3VudDtcblx0XHRcdFx0XHR2YXIgaW5kZXggPSBvZmZzZXRzWyBqIF0uaW5kZXg7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHR2QSA9ICggaW5kZXggKyBpbmRpY2VzWyBpICAgICBdICkgKiAzO1xuXHRcdFx0XHRcdFx0dkIgPSAoIGluZGV4ICsgaW5kaWNlc1sgaSArIDEgXSApICogMztcblx0XHRcdFx0XHRcdHZDID0gKCBpbmRleCArIGluZGljZXNbIGkgKyAyIF0gKSAqIDM7XG5cblx0XHRcdFx0XHRcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCB2QSApO1xuXHRcdFx0XHRcdFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZCICk7XG5cdFx0XHRcdFx0XHRwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkMgKTtcblxuXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG5cdFx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcblx0XHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QSAgICAgXSArPSBjYi54O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICsgMiBdICs9IGNiLno7XG5cblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCICAgICBdICs9IGNiLng7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QiArIDEgXSArPSBjYi55O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcblxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgICAgIF0gKz0gY2IueDtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDICsgMSBdICs9IGNiLnk7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QyArIDIgXSArPSBjYi56O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XG5cblx0XHRcdFx0XHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuXHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xuXHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgNiApO1xuXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0XHRub3JtYWxzWyBpICAgICBdID0gY2IueDtcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMSBdID0gY2IueTtcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMiBdID0gY2IuejtcblxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA0IF0gPSBjYi55O1xuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA1IF0gPSBjYi56O1xuXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDYgXSA9IGNiLng7XG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDcgXSA9IGNiLnk7XG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xuXG5cdFx0XHRhdHRyaWJ1dGVzLm5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXG5cdFx0Ly8gKHBlciB2ZXJ0ZXggdGFuZ2VudHMpXG5cblx0XHRpZiAoIHRoaXMuYXR0cmlidXRlcy5pbmRleCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQgdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCB0aGlzLmF0dHJpYnV0ZXMudXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnTWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGVzIChpbmRleCwgcG9zaXRpb24sIG5vcm1hbCBvciB1dikgaW4gQnVmZmVyR2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCknICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgaW5kaWNlcyA9IHRoaXMuYXR0cmlidXRlcy5pbmRleC5hcnJheTtcblx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblx0XHR2YXIgdXZzID0gdGhpcy5hdHRyaWJ1dGVzLnV2LmFycmF5O1xuXG5cdFx0dmFyIG5WZXJ0aWNlcyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuXG5cdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3RhbmdlbnQnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCA0ICogblZlcnRpY2VzICksIDQgKSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHRhbmdlbnRzID0gdGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQuYXJyYXk7XG5cblx0XHR2YXIgdGFuMSA9IFtdLCB0YW4yID0gW107XG5cblx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBuVmVydGljZXM7IGsgKysgKSB7XG5cblx0XHRcdHRhbjFbIGsgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR0YW4yWyBrIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHZBID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHZCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHZDID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuXHRcdFx0dXZBID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcblx0XHRcdHV2QiA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG5cdFx0XHR1dkMgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuXG5cdFx0XHR4MSwgeDIsIHkxLCB5MiwgejEsIHoyLFxuXHRcdFx0czEsIHMyLCB0MSwgdDIsIHI7XG5cblx0XHR2YXIgc2RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVHJpYW5nbGUoIGEsIGIsIGMgKSB7XG5cblx0XHRcdHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXHRcdFx0dkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XG5cdFx0XHR2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcblxuXHRcdFx0dXZBLmZyb21BcnJheSggdXZzLCBhICogMiApO1xuXHRcdFx0dXZCLmZyb21BcnJheSggdXZzLCBiICogMiApO1xuXHRcdFx0dXZDLmZyb21BcnJheSggdXZzLCBjICogMiApO1xuXG5cdFx0XHR4MSA9IHZCLnggLSB2QS54O1xuXHRcdFx0eDIgPSB2Qy54IC0gdkEueDtcblxuXHRcdFx0eTEgPSB2Qi55IC0gdkEueTtcblx0XHRcdHkyID0gdkMueSAtIHZBLnk7XG5cblx0XHRcdHoxID0gdkIueiAtIHZBLno7XG5cdFx0XHR6MiA9IHZDLnogLSB2QS56O1xuXG5cdFx0XHRzMSA9IHV2Qi54IC0gdXZBLng7XG5cdFx0XHRzMiA9IHV2Qy54IC0gdXZBLng7XG5cblx0XHRcdHQxID0gdXZCLnkgLSB1dkEueTtcblx0XHRcdHQyID0gdXZDLnkgLSB1dkEueTtcblxuXHRcdFx0ciA9IDEuMCAvICggczEgKiB0MiAtIHMyICogdDEgKTtcblxuXHRcdFx0c2Rpci5zZXQoXG5cdFx0XHRcdCggdDIgKiB4MSAtIHQxICogeDIgKSAqIHIsXG5cdFx0XHRcdCggdDIgKiB5MSAtIHQxICogeTIgKSAqIHIsXG5cdFx0XHRcdCggdDIgKiB6MSAtIHQxICogejIgKSAqIHJcblx0XHRcdCk7XG5cblx0XHRcdHRkaXIuc2V0KFxuXHRcdFx0XHQoIHMxICogeDIgLSBzMiAqIHgxICkgKiByLFxuXHRcdFx0XHQoIHMxICogeTIgLSBzMiAqIHkxICkgKiByLFxuXHRcdFx0XHQoIHMxICogejIgLSBzMiAqIHoxICkgKiByXG5cdFx0XHQpO1xuXG5cdFx0XHR0YW4xWyBhIF0uYWRkKCBzZGlyICk7XG5cdFx0XHR0YW4xWyBiIF0uYWRkKCBzZGlyICk7XG5cdFx0XHR0YW4xWyBjIF0uYWRkKCBzZGlyICk7XG5cblx0XHRcdHRhbjJbIGEgXS5hZGQoIHRkaXIgKTtcblx0XHRcdHRhbjJbIGIgXS5hZGQoIHRkaXIgKTtcblx0XHRcdHRhbjJbIGMgXS5hZGQoIHRkaXIgKTtcblxuXHRcdH1cblxuXHRcdHZhciBpLCBpbDtcblx0XHR2YXIgaiwgamw7XG5cdFx0dmFyIGlBLCBpQiwgaUM7XG5cblx0XHRpZiAoIHRoaXMuZHJhd2NhbGxzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5hZGREcmF3Q2FsbCggMCwgaW5kaWNlcy5sZW5ndGgsIDAgKTtcblxuXHRcdH1cblxuXHRcdHZhciBkcmF3Y2FsbHMgPSB0aGlzLmRyYXdjYWxscztcblxuXHRcdGZvciAoIGogPSAwLCBqbCA9IGRyYXdjYWxscy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcblxuXHRcdFx0dmFyIHN0YXJ0ID0gZHJhd2NhbGxzWyBqIF0uc3RhcnQ7XG5cdFx0XHR2YXIgY291bnQgPSBkcmF3Y2FsbHNbIGogXS5jb3VudDtcblx0XHRcdHZhciBpbmRleCA9IGRyYXdjYWxsc1sgaiBdLmluZGV4O1xuXG5cdFx0XHRmb3IgKCBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0aUEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcblx0XHRcdFx0aUIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XG5cdFx0XHRcdGlDID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMiBdO1xuXG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKCBpQSwgaUIsIGlDICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciB0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0bXAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdywgdCwgdGVzdDtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVZlcnRleCggdiApIHtcblxuXHRcdFx0bi5mcm9tQXJyYXkoIG5vcm1hbHMsIHYgKiAzICk7XG5cdFx0XHRuMi5jb3B5KCBuICk7XG5cblx0XHRcdHQgPSB0YW4xWyB2IF07XG5cblx0XHRcdC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cblx0XHRcdHRtcC5jb3B5KCB0ICk7XG5cdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuXHRcdFx0dG1wMi5jcm9zc1ZlY3RvcnMoIG4yLCB0ICk7XG5cdFx0XHR0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHYgXSApO1xuXHRcdFx0dyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cblx0XHRcdHRhbmdlbnRzWyB2ICogNCAgICAgXSA9IHRtcC54O1xuXHRcdFx0dGFuZ2VudHNbIHYgKiA0ICsgMSBdID0gdG1wLnk7XG5cdFx0XHR0YW5nZW50c1sgdiAqIDQgKyAyIF0gPSB0bXAuejtcblx0XHRcdHRhbmdlbnRzWyB2ICogNCArIDMgXSA9IHc7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBqID0gMCwgamwgPSBkcmF3Y2FsbHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XG5cblx0XHRcdHZhciBzdGFydCA9IGRyYXdjYWxsc1sgaiBdLnN0YXJ0O1xuXHRcdFx0dmFyIGNvdW50ID0gZHJhd2NhbGxzWyBqIF0uY291bnQ7XG5cdFx0XHR2YXIgaW5kZXggPSBkcmF3Y2FsbHNbIGogXS5pbmRleDtcblxuXHRcdFx0Zm9yICggaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGlBID0gaW5kZXggKyBpbmRpY2VzWyBpIF07XG5cdFx0XHRcdGlCID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMSBdO1xuXHRcdFx0XHRpQyA9IGluZGV4ICsgaW5kaWNlc1sgaSArIDIgXTtcblxuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGlBICk7XG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaUIgKTtcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpQyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHQvKlxuXHRcdGNvbXB1dGVPZmZzZXRzXG5cdFx0Q29tcHV0ZSB0aGUgZHJhdyBvZmZzZXQgZm9yIGxhcmdlIG1vZGVscyBieSBjaHVua2luZyB0aGUgaW5kZXggYnVmZmVyIGludG8gY2h1bmtzIG9mIDY1ayBhZGRyZXNzYWJsZSB2ZXJ0aWNlcy5cblx0XHRUaGlzIG1ldGhvZCB3aWxsIGVmZmVjdGl2ZWx5IHJld3JpdGUgdGhlIGluZGV4IGJ1ZmZlciBhbmQgcmVtYXAgYWxsIGF0dHJpYnV0ZXMgdG8gbWF0Y2ggdGhlIG5ldyBpbmRpY2VzLlxuXHRcdFdBUk5JTkc6IFRoaXMgbWV0aG9kIHdpbGwgYWxzbyBleHBhbmQgdGhlIHZlcnRleCBjb3VudCB0byBwcmV2ZW50IHNwcmF3bGVkIHRyaWFuZ2xlcyBhY3Jvc3MgZHJhdyBvZmZzZXRzLlxuXHRcdGluZGV4QnVmZmVyU2l6ZSAtIERlZmF1bHRzIHRvIDY1NTM1LCBidXQgYWxsb3dzIGZvciBsYXJnZXIgb3Igc21hbGxlciBjaHVua3MuXG5cdCovXG5cdGNvbXB1dGVPZmZzZXRzOiBmdW5jdGlvbiAoIGluZGV4QnVmZmVyU2l6ZSApIHtcblxuXHRcdHZhciBzaXplID0gaW5kZXhCdWZmZXJTaXplO1xuXHRcdGlmICggaW5kZXhCdWZmZXJTaXplID09PSB1bmRlZmluZWQgKVxuXHRcdFx0c2l6ZSA9IDY1NTM1OyAvL1dlYkdMIGxpbWl0cyB0eXBlIG9mIGluZGV4IGJ1ZmZlciB2YWx1ZXMgdG8gMTYtYml0LlxuXG5cdFx0dmFyIHMgPSBEYXRlLm5vdygpO1xuXG5cdFx0dmFyIGluZGljZXMgPSB0aGlzLmF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG5cdFx0dmFyIHZlcnRpY2VzID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0dmFyIHZlcnRpY2VzQ291bnQgPSAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKTtcblx0XHR2YXIgZmFjZXNDb3VudCA9ICggaW5kaWNlcy5sZW5ndGggLyAzICk7XG5cblx0XHQvKlxuXHRcdGNvbnNvbGUubG9nKFwiQ29tcHV0aW5nIGJ1ZmZlcnMgaW4gb2Zmc2V0cyBvZiBcIitzaXplK1wiIC0+IGluZGljZXM6XCIraW5kaWNlcy5sZW5ndGgrXCIgdmVydGljZXM6XCIrdmVydGljZXMubGVuZ3RoKTtcblx0XHRjb25zb2xlLmxvZyhcIkZhY2VzIHRvIHByb2Nlc3M6IFwiKyhpbmRpY2VzLmxlbmd0aC8zKSk7XG5cdFx0Y29uc29sZS5sb2coXCJSZW9yZGVyaW5nIFwiK3ZlcnRpY2VzQ291bnQrXCIgdmVydGljZXMuXCIpO1xuXHRcdCovXG5cblx0XHR2YXIgc29ydGVkSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggaW5kaWNlcy5sZW5ndGggKTsgLy8xNi1iaXQgYnVmZmVyc1xuXHRcdHZhciBpbmRleFB0ciA9IDA7XG5cdFx0dmFyIHZlcnRleFB0ciA9IDA7XG5cblx0XHR2YXIgb2Zmc2V0cyA9IFsgeyBzdGFydDowLCBjb3VudDowLCBpbmRleDowIH0gXTtcblx0XHR2YXIgb2Zmc2V0ID0gb2Zmc2V0c1sgMCBdO1xuXG5cdFx0dmFyIGR1cGxpY2F0ZWRWZXJ0aWNlcyA9IDA7XG5cdFx0dmFyIG5ld1ZlcnRpY2VNYXBzID0gMDtcblx0XHR2YXIgZmFjZVZlcnRpY2VzID0gbmV3IEludDMyQXJyYXkoIDYgKTtcblx0XHR2YXIgdmVydGV4TWFwID0gbmV3IEludDMyQXJyYXkoIHZlcnRpY2VzLmxlbmd0aCApO1xuXHRcdHZhciByZXZWZXJ0ZXhNYXAgPSBuZXcgSW50MzJBcnJheSggdmVydGljZXMubGVuZ3RoICk7XG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgdmVydGljZXMubGVuZ3RoOyBqICsrICkgeyB2ZXJ0ZXhNYXBbIGogXSA9IC0gMTsgcmV2VmVydGV4TWFwWyBqIF0gPSAtIDE7IH1cblxuXHRcdC8qXG5cdFx0XHRUcmF2ZXJzZSBldmVyeSBmYWNlIGFuZCByZW9yZGVyIHZlcnRpY2VzIGluIHRoZSBwcm9wZXIgb2Zmc2V0cyBvZiA2NWsuXG5cdFx0XHRXZSBjYW4gaGF2ZSBtb3JlIHRoYW4gNjVrIGVudHJpZXMgaW4gdGhlIGluZGV4IGJ1ZmZlciBwZXIgb2Zmc2V0LCBidXQgb25seSByZWZlcmVuY2UgNjVrIHZhbHVlcy5cblx0XHQqL1xuXHRcdGZvciAoIHZhciBmaW5kZXggPSAwOyBmaW5kZXggPCBmYWNlc0NvdW50OyBmaW5kZXggKysgKSB7XG5cdFx0XHRuZXdWZXJ0aWNlTWFwcyA9IDA7XG5cblx0XHRcdGZvciAoIHZhciB2byA9IDA7IHZvIDwgMzsgdm8gKysgKSB7XG5cdFx0XHRcdHZhciB2aWQgPSBpbmRpY2VzWyBmaW5kZXggKiAzICsgdm8gXTtcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhNYXBbIHZpZCBdID09IC0gMSApIHtcblx0XHRcdFx0XHQvL1VubWFwcGVkIHZlcnRpY2Vcblx0XHRcdFx0XHRmYWNlVmVydGljZXNbIHZvICogMiBdID0gdmlkO1xuXHRcdFx0XHRcdGZhY2VWZXJ0aWNlc1sgdm8gKiAyICsgMSBdID0gLSAxO1xuXHRcdFx0XHRcdG5ld1ZlcnRpY2VNYXBzICsrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB2ZXJ0ZXhNYXBbIHZpZCBdIDwgb2Zmc2V0LmluZGV4ICkge1xuXHRcdFx0XHRcdC8vUmV1c2VkIHZlcnRpY2VzIGZyb20gcHJldmlvdXMgYmxvY2sgKGR1cGxpY2F0ZSlcblx0XHRcdFx0XHRmYWNlVmVydGljZXNbIHZvICogMiBdID0gdmlkO1xuXHRcdFx0XHRcdGZhY2VWZXJ0aWNlc1sgdm8gKiAyICsgMSBdID0gLSAxO1xuXHRcdFx0XHRcdGR1cGxpY2F0ZWRWZXJ0aWNlcyArKztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvL1JldXNlZCB2ZXJ0aWNlIGluIHRoZSBjdXJyZW50IGJsb2NrXG5cdFx0XHRcdFx0ZmFjZVZlcnRpY2VzWyB2byAqIDIgXSA9IHZpZDtcblx0XHRcdFx0XHRmYWNlVmVydGljZXNbIHZvICogMiArIDEgXSA9IHZlcnRleE1hcFsgdmlkIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGZhY2VNYXggPSB2ZXJ0ZXhQdHIgKyBuZXdWZXJ0aWNlTWFwcztcblx0XHRcdGlmICggZmFjZU1heCA+ICggb2Zmc2V0LmluZGV4ICsgc2l6ZSApICkge1xuXHRcdFx0XHR2YXIgbmV3X29mZnNldCA9IHsgc3RhcnQ6aW5kZXhQdHIsIGNvdW50OjAsIGluZGV4OnZlcnRleFB0ciB9O1xuXHRcdFx0XHRvZmZzZXRzLnB1c2goIG5ld19vZmZzZXQgKTtcblx0XHRcdFx0b2Zmc2V0ID0gbmV3X29mZnNldDtcblxuXHRcdFx0XHQvL1JlLWV2YWx1YXRlIHJldXNlZCB2ZXJ0aWNlcyBpbiBsaWdodCBvZiBuZXcgb2Zmc2V0LlxuXHRcdFx0XHRmb3IgKCB2YXIgdiA9IDA7IHYgPCA2OyB2ICs9IDIgKSB7XG5cdFx0XHRcdFx0dmFyIG5ld192aWQgPSBmYWNlVmVydGljZXNbIHYgKyAxIF07XG5cdFx0XHRcdFx0aWYgKCBuZXdfdmlkID4gLSAxICYmIG5ld192aWQgPCBvZmZzZXQuaW5kZXggKVxuXHRcdFx0XHRcdFx0ZmFjZVZlcnRpY2VzWyB2ICsgMSBdID0gLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vUmVpbmRleCB0aGUgZmFjZS5cblx0XHRcdGZvciAoIHZhciB2ID0gMDsgdiA8IDY7IHYgKz0gMiApIHtcblx0XHRcdFx0dmFyIHZpZCA9IGZhY2VWZXJ0aWNlc1sgdiBdO1xuXHRcdFx0XHR2YXIgbmV3X3ZpZCA9IGZhY2VWZXJ0aWNlc1sgdiArIDEgXTtcblxuXHRcdFx0XHRpZiAoIG5ld192aWQgPT09IC0gMSApXG5cdFx0XHRcdFx0bmV3X3ZpZCA9IHZlcnRleFB0ciArKztcblxuXHRcdFx0XHR2ZXJ0ZXhNYXBbIHZpZCBdID0gbmV3X3ZpZDtcblx0XHRcdFx0cmV2VmVydGV4TWFwWyBuZXdfdmlkIF0gPSB2aWQ7XG5cdFx0XHRcdHNvcnRlZEluZGljZXNbIGluZGV4UHRyICsrIF0gPSBuZXdfdmlkIC0gb2Zmc2V0LmluZGV4OyAvL1hYWCBvdmVyZmxvd3MgYXQgMTZiaXRcblx0XHRcdFx0b2Zmc2V0LmNvdW50ICsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qIE1vdmUgYWxsIGF0dHJpYnV0ZSB2YWx1ZXMgdG8gbWFwIHRvIHRoZSBuZXcgY29tcHV0ZWQgaW5kaWNlcyAsIGFsc28gZXhwYW5kIHRoZSB2ZXJ0aWNlIHN0YWNrIHRvIG1hdGNoIG91ciBuZXcgdmVydGV4UHRyLiAqL1xuXHRcdHRoaXMucmVvcmRlckJ1ZmZlcnMoIHNvcnRlZEluZGljZXMsIHJldlZlcnRleE1hcCwgdmVydGV4UHRyICk7XG5cdFx0dGhpcy5vZmZzZXRzID0gb2Zmc2V0cztcblxuXHRcdC8qXG5cdFx0dmFyIG9yZGVyVGltZSA9IERhdGUubm93KCk7XG5cdFx0Y29uc29sZS5sb2coXCJSZW9yZGVyIHRpbWU6IFwiKyhvcmRlclRpbWUtcykrXCJtc1wiKTtcblx0XHRjb25zb2xlLmxvZyhcIkR1cGxpY2F0ZWQgXCIrZHVwbGljYXRlZFZlcnRpY2VzK1wiIHZlcnRpY2VzLlwiKTtcblx0XHRjb25zb2xlLmxvZyhcIkNvbXB1dGUgQnVmZmVycyB0aW1lOiBcIisoRGF0ZS5ub3coKS1zKStcIm1zXCIpO1xuXHRcdGNvbnNvbGUubG9nKFwiRHJhdyBvZmZzZXRzOiBcIitvZmZzZXRzLmxlbmd0aCk7XG5cdFx0Ki9cblxuXHRcdHJldHVybiBvZmZzZXRzO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLmxvZyggJ0J1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IFRPRE8nICk7XG5cblx0fSxcblxuXHRub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cblx0XHR2YXIgeCwgeSwgeiwgbjtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdHggPSBub3JtYWxzWyBpIF07XG5cdFx0XHR5ID0gbm9ybWFsc1sgaSArIDEgXTtcblx0XHRcdHogPSBub3JtYWxzWyBpICsgMiBdO1xuXG5cdFx0XHRuID0gMS4wIC8gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICsgeiAqIHogKTtcblxuXHRcdFx0bm9ybWFsc1sgaSAgICAgXSAqPSBuO1xuXHRcdFx0bm9ybWFsc1sgaSArIDEgXSAqPSBuO1xuXHRcdFx0bm9ybWFsc1sgaSArIDIgXSAqPSBuO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Lypcblx0XHRyZW9kZXJCdWZmZXJzOlxuXHRcdFJlb3JkZXIgYXR0cmlidXRlcyBiYXNlZCBvbiBhIG5ldyBpbmRleEJ1ZmZlciBhbmQgaW5kZXhNYXAuXG5cdFx0aW5kZXhCdWZmZXIgLSBVaW50MTZBcnJheSBvZiB0aGUgbmV3IG9yZGVyZWQgaW5kaWNlcy5cblx0XHRpbmRleE1hcCAtIEludDMyQXJyYXkgd2hlcmUgdGhlIHBvc2l0aW9uIGlzIHRoZSBuZXcgdmVydGV4IElEIGFuZCB0aGUgdmFsdWUgdGhlIG9sZCB2ZXJ0ZXggSUQgZm9yIGVhY2ggdmVydGV4LlxuXHRcdHZlcnRleENvdW50IC0gQW1vdW50IG9mIHRvdGFsIHZlcnRpY2VzIGNvbnNpZGVyZWQgaW4gdGhpcyByZW9yZGVyaW5nIChpbiBjYXNlIHlvdSB3YW50IHRvIGdyb3cgdGhlIHZlcnRpY2Ugc3RhY2spLlxuXHQqL1xuXHRyZW9yZGVyQnVmZmVyczogZnVuY3Rpb24gKCBpbmRleEJ1ZmZlciwgaW5kZXhNYXAsIHZlcnRleENvdW50ICkge1xuXG5cdFx0LyogQ3JlYXRlIGEgY29weSBvZiBhbGwgYXR0cmlidXRlcyBmb3IgcmVvcmRlcmluZy4gKi9cblx0XHR2YXIgc29ydGVkQXR0cmlidXRlcyA9IHt9O1xuXHRcdGZvciAoIHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcyApIHtcblx0XHRcdGlmICggYXR0ciA9PSAnaW5kZXgnIClcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR2YXIgc291cmNlQXJyYXkgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5hcnJheTtcblx0XHRcdHNvcnRlZEF0dHJpYnV0ZXNbIGF0dHIgXSA9IG5ldyBzb3VyY2VBcnJheS5jb25zdHJ1Y3RvciggdGhpcy5hdHRyaWJ1dGVzWyBhdHRyIF0uaXRlbVNpemUgKiB2ZXJ0ZXhDb3VudCApO1xuXHRcdH1cblxuXHRcdC8qIE1vdmUgYXR0cmlidXRlIHBvc2l0aW9ucyBiYXNlZCBvbiB0aGUgbmV3IGluZGV4IG1hcCAqL1xuXHRcdGZvciAoIHZhciBuZXdfdmlkID0gMDsgbmV3X3ZpZCA8IHZlcnRleENvdW50OyBuZXdfdmlkICsrICkge1xuXHRcdFx0dmFyIHZpZCA9IGluZGV4TWFwWyBuZXdfdmlkIF07XG5cdFx0XHRmb3IgKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdGlmICggYXR0ciA9PSAnaW5kZXgnIClcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0dmFyIGF0dHJBcnJheSA9IHRoaXMuYXR0cmlidXRlc1sgYXR0ciBdLmFycmF5O1xuXHRcdFx0XHR2YXIgYXR0clNpemUgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5pdGVtU2l6ZTtcblx0XHRcdFx0dmFyIHNvcnRlZEF0dHIgPSBzb3J0ZWRBdHRyaWJ1dGVzWyBhdHRyIF07XG5cdFx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IGF0dHJTaXplOyBrICsrIClcblx0XHRcdFx0XHRzb3J0ZWRBdHRyWyBuZXdfdmlkICogYXR0clNpemUgKyBrIF0gPSBhdHRyQXJyYXlbIHZpZCAqIGF0dHJTaXplICsgayBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qIENhcnJ5IHRoZSBuZXcgc29ydGVkIGJ1ZmZlcnMgbG9jYWxseSAqL1xuXHRcdHRoaXMuYXR0cmlidXRlc1sgJ2luZGV4JyBdLmFycmF5ID0gaW5kZXhCdWZmZXI7XG5cdFx0Zm9yICggdmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuXHRcdFx0aWYgKCBhdHRyID09ICdpbmRleCcgKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdHRoaXMuYXR0cmlidXRlc1sgYXR0ciBdLmFycmF5ID0gc29ydGVkQXR0cmlidXRlc1sgYXR0ciBdO1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzWyBhdHRyIF0ubnVtSXRlbXMgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5pdGVtU2l6ZSAqIHZlcnRleENvdW50O1xuXHRcdH1cblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBvdXRwdXQgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjAsXG5cdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5RXhwb3J0ZXInXG5cdFx0XHR9LFxuXHRcdFx0dXVpZDogdGhpcy51dWlkLFxuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxuXHRcdFx0ZGF0YToge1xuXHRcdFx0XHRhdHRyaWJ1dGVzOiB7fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblx0XHR2YXIgb2Zmc2V0cyA9IHRoaXMub2Zmc2V0cztcblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG5cblx0XHRcdHZhciBhcnJheSA9IFtdLCB0eXBlQXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHR5cGVBcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0gPSB0eXBlQXJyYXlbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXRwdXQuZGF0YS5hdHRyaWJ1dGVzWyBrZXkgXSA9IHtcblx0XHRcdFx0aXRlbVNpemU6IGF0dHJpYnV0ZS5pdGVtU2l6ZSxcblx0XHRcdFx0dHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRcdGFycmF5OiBhcnJheVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdG91dHB1dC5kYXRhLm9mZnNldHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggb2Zmc2V0cyApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRvdXRwdXQuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcblx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuXHRcdFx0XHRyYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdGZvciAoIHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0dmFyIHNvdXJjZUF0dHIgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXTtcblx0XHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggYXR0ciwgc291cmNlQXR0ci5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5vZmZzZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXRzWyBpIF07XG5cblx0XHRcdGdlb21ldHJ5Lm9mZnNldHMucHVzaCgge1xuXG5cdFx0XHRcdHN0YXJ0OiBvZmZzZXQuc3RhcnQsXG5cdFx0XHRcdGluZGV4OiBvZmZzZXQuaW5kZXgsXG5cdFx0XHRcdGNvdW50OiBvZmZzZXQuY291bnRcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH0sXG5cblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvY29yZS9HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrIH0gKTtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXHR0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xuXG5cdHRoaXMudmVydGljZXMgPSBbXTtcblx0dGhpcy5jb2xvcnMgPSBbXTsgIC8vIG9uZS10by1vbmUgdmVydGV4IGNvbG9ycywgdXNlZCBpbiBQb2ludHMgYW5kIExpbmVcblxuXHR0aGlzLmZhY2VzID0gW107XG5cblx0dGhpcy5mYWNlVmVydGV4VXZzID0gWyBbXSBdO1xuXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gW107XG5cdHRoaXMubW9ycGhDb2xvcnMgPSBbXTtcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcblxuXHR0aGlzLnNraW5XZWlnaHRzID0gW107XG5cdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcblxuXHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0dGhpcy5oYXNUYW5nZW50cyA9IGZhbHNlO1xuXG5cdHRoaXMuZHluYW1pYyA9IHRydWU7IC8vIHRoZSBpbnRlcm1lZGlhdGUgdHlwZWQgYXJyYXlzIHdpbGwgYmUgZGVsZXRlZCB3aGVuIHNldCB0byBmYWxzZVxuXG5cdC8vIHVwZGF0ZSBmbGFnc1xuXG5cdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMudGFuZ2VudHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuR2VvbWV0cnksXG5cblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0dmVydGV4LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCBpbnN0YW5jZW9mIFRIUkVFLkJveDMgKSB7XG5cblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgaW5zdGFuY2VvZiBUSFJFRS5TcGhlcmUgKSB7XG5cblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRmcm9tQnVmZmVyR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblx0XHR2YXIgaW5kaWNlcyA9IGF0dHJpYnV0ZXMuaW5kZXggIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuaW5kZXguYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0dmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0dmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYuYXJyYXkgOiB1bmRlZmluZWQ7XG5cblx0XHR2YXIgdGVtcE5vcm1hbHMgPSBbXTtcblx0XHR2YXIgdGVtcFVWcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAzLCBqICs9IDIgKSB7XG5cblx0XHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgdmVydGljZXNbIGkgKyAyIF0gKSApO1xuXG5cdFx0XHRpZiAoIG5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZW1wTm9ybWFscy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggbm9ybWFsc1sgaSBdLCBub3JtYWxzWyBpICsgMSBdLCBub3JtYWxzWyBpICsgMiBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZW1wVVZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnNbIGogXSwgdXZzWyBqICsgMSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIGFkZEZhY2UgPSBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gbm9ybWFscyAhPT0gdW5kZWZpbmVkID8gWyB0ZW1wTm9ybWFsc1sgYSBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBiIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcblx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBjb2xvcnMgIT09IHVuZGVmaW5lZCA/IFsgc2NvcGUuY29sb3JzWyBhIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBiIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBjIF0uY2xvbmUoKSBdIDogW107XG5cblx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgdmVydGV4Tm9ybWFscywgdmVydGV4Q29sb3JzICkgKTtcblx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXSwgdGVtcFVWc1sgYiBdLCB0ZW1wVVZzWyBjIF0gXSApO1xuXG5cdFx0fTtcblxuXHRcdGlmICggaW5kaWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0YWRkRmFjZSggaSwgaSArIDEsIGkgKyAyICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblx0XHRcblx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0dmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRvZmZzZXQuYWRkVmVjdG9ycyggdGhpcy5ib3VuZGluZ0JveC5taW4sIHRoaXMuYm91bmRpbmdCb3gubWF4ICk7XG5cdFx0b2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCAtIDAuNSApO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeCggbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKSApO1xuXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRyZXR1cm4gb2Zmc2V0O1xuXG5cdH0sXG5cblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0dmFyIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XG5cdFx0XHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcblxuXHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG5cdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRjYi5ub3JtYWxpemUoKTtcblxuXHRcdFx0ZmFjZS5ub3JtYWwuY29weSggY2IgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoIGFyZWFXZWlnaHRlZCApIHtcblxuXHRcdHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xuXG5cdFx0dmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XG5cblx0XHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHR2ZXJ0aWNlc1sgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdH1cblxuXHRcdGlmICggYXJlYVdlaWdodGVkICkge1xuXG5cdFx0XHQvLyB2ZXJ0ZXggbm9ybWFscyB3ZWlnaHRlZCBieSB0cmlhbmdsZSBhcmVhc1xuXHRcdFx0Ly8gaHR0cDovL3d3dy5pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvbm9ybWFscy9ub3JtYWxzLmh0bVxuXG5cdFx0XHR2YXIgdkEsIHZCLCB2QywgdkQ7XG5cdFx0XHR2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdGRiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgZGMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBiYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHR2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuXHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggY2IgKTtcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdID0gdmVydGljZXNbIGZhY2UuYyBdLmNsb25lKCk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlTW9ycGhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgaSwgaWwsIGYsIGZsLCBmYWNlO1xuXG5cdFx0Ly8gc2F2ZSBvcmlnaW5hbCBub3JtYWxzXG5cdFx0Ly8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXG5cdFx0Ly8gICBvdGhlcndpc2UganVzdCBjb3B5IChmb3IgZmFzdGVyIHJlcGVhdGVkIGNhbGxzKVxuXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzICkgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcblxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gdXNlIHRlbXAgZ2VvbWV0cnkgdG8gY29tcHV0ZSBmYWNlIGFuZCB2ZXJ0ZXggbm9ybWFscyBmb3IgZWFjaCBtb3JwaFxuXG5cdFx0dmFyIHRtcEdlbyA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRcdHRtcEdlby5mYWNlcyA9IHRoaXMuZmFjZXM7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Ly8gY3JlYXRlIG9uIGZpcnN0IGFjY2Vzc1xuXG5cdFx0XHRpZiAoICEgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSApIHtcblxuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdID0ge307XG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMgPSBbXTtcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XG5cblx0XHRcdFx0dmFyIGRzdE5vcm1hbHNGYWNlID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscztcblx0XHRcdFx0dmFyIGRzdE5vcm1hbHNWZXJ0ZXggPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHM7XG5cblx0XHRcdFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdGZhY2VOb3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMgPSB7IGE6IG5ldyBUSFJFRS5WZWN0b3IzKCksIGI6IG5ldyBUSFJFRS5WZWN0b3IzKCksIGM6IG5ldyBUSFJFRS5WZWN0b3IzKCkgfTtcblxuXHRcdFx0XHRcdGRzdE5vcm1hbHNGYWNlLnB1c2goIGZhY2VOb3JtYWwgKTtcblx0XHRcdFx0XHRkc3ROb3JtYWxzVmVydGV4LnB1c2goIHZlcnRleE5vcm1hbHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF07XG5cblx0XHRcdC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcblxuXHRcdFx0dG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcblxuXHRcdFx0Ly8gY29tcHV0ZSBtb3JwaCBub3JtYWxzXG5cblx0XHRcdHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0XHRcdHRtcEdlby5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdFx0XHQvLyBzdG9yZSBtb3JwaCBub3JtYWxzXG5cblx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdFx0ZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0gbW9ycGhOb3JtYWxzLnZlcnRleE5vcm1hbHNbIGYgXTtcblxuXHRcdFx0XHRmYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdFx0dmVydGV4Tm9ybWFscy5hLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdICk7XG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmMuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gcmVzdG9yZSBvcmlnaW5hbCBub3JtYWxzXG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRmYWNlLm5vcm1hbCA9IGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWw7XG5cdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMgPSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL3RhbmdlbnQuaHRtbFxuXHRcdC8vIHRhbmdlbnRzIGdvIHRvIHZlcnRpY2VzXG5cblx0XHR2YXIgZiwgZmwsIHYsIHZsLCBpLCBpbCwgdmVydGV4SW5kZXgsXG5cdFx0XHRmYWNlLCB1diwgdkEsIHZCLCB2QywgdXZBLCB1dkIsIHV2Qyxcblx0XHRcdHgxLCB4MiwgeTEsIHkyLCB6MSwgejIsXG5cdFx0XHRzMSwgczIsIHQxLCB0MiwgciwgdCwgdGVzdCxcblx0XHRcdHRhbjEgPSBbXSwgdGFuMiA9IFtdLFxuXHRcdFx0c2RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0dG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdG1wMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdztcblxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdHRhbjFbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR0YW4yWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVHJpYW5nbGUoIGNvbnRleHQsIGEsIGIsIGMsIHVhLCB1YiwgdWMgKSB7XG5cblx0XHRcdHZBID0gY29udGV4dC52ZXJ0aWNlc1sgYSBdO1xuXHRcdFx0dkIgPSBjb250ZXh0LnZlcnRpY2VzWyBiIF07XG5cdFx0XHR2QyA9IGNvbnRleHQudmVydGljZXNbIGMgXTtcblxuXHRcdFx0dXZBID0gdXZbIHVhIF07XG5cdFx0XHR1dkIgPSB1dlsgdWIgXTtcblx0XHRcdHV2QyA9IHV2WyB1YyBdO1xuXG5cdFx0XHR4MSA9IHZCLnggLSB2QS54O1xuXHRcdFx0eDIgPSB2Qy54IC0gdkEueDtcblx0XHRcdHkxID0gdkIueSAtIHZBLnk7XG5cdFx0XHR5MiA9IHZDLnkgLSB2QS55O1xuXHRcdFx0ejEgPSB2Qi56IC0gdkEuejtcblx0XHRcdHoyID0gdkMueiAtIHZBLno7XG5cblx0XHRcdHMxID0gdXZCLnggLSB1dkEueDtcblx0XHRcdHMyID0gdXZDLnggLSB1dkEueDtcblx0XHRcdHQxID0gdXZCLnkgLSB1dkEueTtcblx0XHRcdHQyID0gdXZDLnkgLSB1dkEueTtcblxuXHRcdFx0ciA9IDEuMCAvICggczEgKiB0MiAtIHMyICogdDEgKTtcblx0XHRcdHNkaXIuc2V0KCAoIHQyICogeDEgLSB0MSAqIHgyICkgKiByLFxuXHRcdFx0XHRcdCAgKCB0MiAqIHkxIC0gdDEgKiB5MiApICogcixcblx0XHRcdFx0XHQgICggdDIgKiB6MSAtIHQxICogejIgKSAqIHIgKTtcblx0XHRcdHRkaXIuc2V0KCAoIHMxICogeDIgLSBzMiAqIHgxICkgKiByLFxuXHRcdFx0XHRcdCAgKCBzMSAqIHkyIC0gczIgKiB5MSApICogcixcblx0XHRcdFx0XHQgICggczEgKiB6MiAtIHMyICogejEgKSAqIHIgKTtcblxuXHRcdFx0dGFuMVsgYSBdLmFkZCggc2RpciApO1xuXHRcdFx0dGFuMVsgYiBdLmFkZCggc2RpciApO1xuXHRcdFx0dGFuMVsgYyBdLmFkZCggc2RpciApO1xuXG5cdFx0XHR0YW4yWyBhIF0uYWRkKCB0ZGlyICk7XG5cdFx0XHR0YW4yWyBiIF0uYWRkKCB0ZGlyICk7XG5cdFx0XHR0YW4yWyBjIF0uYWRkKCB0ZGlyICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXHRcdFx0dXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgZiBdOyAvLyB1c2UgVVYgbGF5ZXIgMCBmb3IgdGFuZ2VudHNcblxuXHRcdFx0aGFuZGxlVHJpYW5nbGUoIHRoaXMsIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMsIDAsIDEsIDIgKTtcblxuXHRcdH1cblxuXHRcdHZhciBmYWNlSW5kZXggPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBNYXRoLm1pbiggZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCwgMyApOyBpICsrICkge1xuXG5cdFx0XHRcdG4uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0XHR2ZXJ0ZXhJbmRleCA9IGZhY2VbIGZhY2VJbmRleFsgaSBdIF07XG5cblx0XHRcdFx0dCA9IHRhbjFbIHZlcnRleEluZGV4IF07XG5cblx0XHRcdFx0Ly8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcblxuXHRcdFx0XHR0bXAuY29weSggdCApO1xuXHRcdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHQvLyBDYWxjdWxhdGUgaGFuZGVkbmVzc1xuXG5cdFx0XHRcdHRtcDIuY3Jvc3NWZWN0b3JzKCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSwgdCApO1xuXHRcdFx0XHR0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHZlcnRleEluZGV4IF0gKTtcblx0XHRcdFx0dyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cblx0XHRcdFx0ZmFjZS52ZXJ0ZXhUYW5nZW50c1sgaSBdID0gbmV3IFRIUkVFLlZlY3RvcjQoIHRtcC54LCB0bXAueSwgdG1wLnosIHcgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5oYXNUYW5nZW50cyA9IHRydWU7XG5cblx0fSxcblxuXHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGQgPSAwO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGlmICggaSA+IDAgKSB7XG5cblx0XHRcdFx0ZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5saW5lRGlzdGFuY2VzWyBpIF0gPSBkO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cblx0fSxcblxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHZhciBub3JtYWxNYXRyaXgsXG5cdFx0dmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG5cdFx0dmVydGljZXMxID0gdGhpcy52ZXJ0aWNlcyxcblx0XHR2ZXJ0aWNlczIgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcblx0XHRmYWNlczEgPSB0aGlzLmZhY2VzLFxuXHRcdGZhY2VzMiA9IGdlb21ldHJ5LmZhY2VzLFxuXHRcdHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSxcblx0XHR1dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG5cdFx0aWYgKCBtYXRlcmlhbEluZGV4T2Zmc2V0ID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbEluZGV4T2Zmc2V0ID0gMDtcblxuXHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdH1cblxuXHRcdC8vIHZlcnRpY2VzXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXMyWyBpIF07XG5cblx0XHRcdHZhciB2ZXJ0ZXhDb3B5ID0gdmVydGV4LmNsb25lKCk7XG5cblx0XHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdHZlcnRpY2VzMS5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XG5cblx0XHR9XG5cblx0XHQvLyBmYWNlc1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLCBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcblx0XHRcdGZhY2VWZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLFxuXHRcdFx0ZmFjZVZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0XHRmYWNlQ29weSA9IG5ldyBUSFJFRS5GYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xuXHRcdFx0ZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZmFjZUNvcHkubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdG5vcm1hbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzWyBqIF0uY2xvbmUoKTtcblxuXHRcdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRjb2xvciA9IGZhY2VWZXJ0ZXhDb2xvcnNbIGogXTtcblx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcblxuXHRcdFx0ZmFjZXMxLnB1c2goIGZhY2VDb3B5ICk7XG5cblx0XHR9XG5cblx0XHQvLyB1dnNcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHV2czIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB1diA9IHV2czJbIGkgXSwgdXZDb3B5ID0gW107XG5cblx0XHRcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0dXZDb3B5LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dlsgaiBdLngsIHV2WyBqIF0ueSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dXZzMS5wdXNoKCB1dkNvcHkgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdC8qXG5cdCAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cblx0ICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxuXHQgKiBhbmQgZmFjZXMnIHZlcnRpY2VzIGFyZSB1cGRhdGVkLlxuXHQgKi9cblxuXHRtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxuXHRcdHZhciB1bmlxdWUgPSBbXSwgY2hhbmdlcyA9IFtdO1xuXG5cdFx0dmFyIHYsIGtleTtcblx0XHR2YXIgcHJlY2lzaW9uUG9pbnRzID0gNDsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcblx0XHR2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcblx0XHR2YXIgaSxpbCwgZmFjZTtcblx0XHR2YXIgaW5kaWNlcywgaywgaiwgamwsIHU7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0a2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xuXG5cdFx0XHRpZiAoIHZlcnRpY2VzTWFwWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XG5cdFx0XHRcdHVuaXF1ZS5wdXNoKCB0aGlzLnZlcnRpY2VzWyBpIF0gKTtcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnRHVwbGljYXRlIHZlcnRleCBmb3VuZC4gJywgaSwgJyBjb3VsZCBiZSB1c2luZyAnLCB2ZXJ0aWNlc01hcFtrZXldKTtcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gY2hhbmdlc1sgdmVydGljZXNNYXBbIGtleSBdIF07XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblxuXHRcdC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2Vcblx0XHQvLyBoYXZlIHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlIGdlb21ldHJ5LlxuXHRcdHZhciBmYWNlSW5kaWNlc1RvUmVtb3ZlID0gW107XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG5cdFx0XHRmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcblx0XHRcdGZhY2UuYiA9IGNoYW5nZXNbIGZhY2UuYiBdO1xuXHRcdFx0ZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XG5cblx0XHRcdGluZGljZXMgPSBbIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgXTtcblxuXHRcdFx0dmFyIGR1cEluZGV4ID0gLSAxO1xuXG5cdFx0XHQvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXG5cdFx0XHQvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxuXHRcdFx0Zm9yICggdmFyIG4gPSAwOyBuIDwgMzsgbiArKyApIHtcblx0XHRcdFx0aWYgKCBpbmRpY2VzWyBuIF0gPT0gaW5kaWNlc1sgKCBuICsgMSApICUgMyBdICkge1xuXG5cdFx0XHRcdFx0ZHVwSW5kZXggPSBuO1xuXHRcdFx0XHRcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGkgPSBmYWNlSW5kaWNlc1RvUmVtb3ZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtLSApIHtcblx0XHRcdHZhciBpZHggPSBmYWNlSW5kaWNlc1RvUmVtb3ZlWyBpIF07XG5cblx0XHRcdHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcblxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaiBdLnNwbGljZSggaWR4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIFVzZSB1bmlxdWUgc2V0IG9mIHZlcnRpY2VzXG5cblx0XHR2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcblx0XHR0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xuXHRcdHJldHVybiBkaWZmO1xuXG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb3V0cHV0ID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC4wLFxuXHRcdFx0XHR0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeUV4cG9ydGVyJ1xuXHRcdFx0fSxcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdHR5cGU6IHRoaXMudHlwZVxuXHRcdH07XG5cblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gXCJcIiApIG91dHB1dC5uYW1lID0gdGhpcy5uYW1lO1xuXG5cdFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuXHRcdFx0XHRpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBvdXRwdXRbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdH1cblxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHR9XG5cblx0XHR2YXIgZmFjZXMgPSBbXTtcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdHZhciBub3JtYWxzSGFzaCA9IHt9O1xuXHRcdHZhciBjb2xvcnMgPSBbXTtcblx0XHR2YXIgY29sb3JzSGFzaCA9IHt9O1xuXHRcdHZhciB1dnMgPSBbXTtcblx0XHR2YXIgdXZzSGFzaCA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG5cdFx0XHR2YXIgaGFzTWF0ZXJpYWwgPSBmYWxzZTsgLy8gZmFjZS5tYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQ7XG5cdFx0XHR2YXIgaGFzRmFjZVV2ID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcblx0XHRcdHZhciBoYXNGYWNlVmVydGV4VXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdICE9PSB1bmRlZmluZWQ7XG5cdFx0XHR2YXIgaGFzRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmxlbmd0aCgpID4gMDtcblx0XHRcdHZhciBoYXNGYWNlVmVydGV4Tm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDA7XG5cdFx0XHR2YXIgaGFzRmFjZUNvbG9yID0gZmFjZS5jb2xvci5yICE9PSAxIHx8IGZhY2UuY29sb3IuZyAhPT0gMSB8fCBmYWNlLmNvbG9yLmIgIT09IDE7XG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleENvbG9yID0gZmFjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoID4gMDtcblxuXHRcdFx0dmFyIGZhY2VUeXBlID0gMDtcblxuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAwLCAwICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDEsIGhhc01hdGVyaWFsICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDIsIGhhc0ZhY2VVdiApO1xuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNCwgaGFzRmFjZU5vcm1hbCApO1xuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA1LCBoYXNGYWNlVmVydGV4Tm9ybWFsICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA3LCBoYXNGYWNlVmVydGV4Q29sb3IgKTtcblxuXHRcdFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcblx0XHRcdGZhY2VzLnB1c2goIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgKTtcblxuXG5cdFx0XHQvKlxuXHRcdFx0aWYgKCBoYXNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRmYWNlcy5wdXNoKCBmYWNlLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0fVxuXHRcdFx0Ki9cblxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cblx0XHRcdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG5cdFx0XHRcdGZhY2VzLnB1c2goXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMCBdICksXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMSBdICksXG5cdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMiBdIClcblx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Tm9ybWFsSW5kZXgoIGZhY2Uubm9ybWFsICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cblx0XHRcdFx0ZmFjZXMucHVzaChcblx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMCBdICksXG5cdFx0XHRcdFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDEgXSApLFxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG5cdFx0XHRcdGZhY2VzLnB1c2goIGdldENvbG9ySW5kZXgoIGZhY2UuY29sb3IgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuXHRcdFx0XHRmYWNlcy5wdXNoKFxuXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMCBdICksXG5cdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAxIF0gKSxcblx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDIgXSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldEJpdCggdmFsdWUsIHBvc2l0aW9uLCBlbmFibGVkICkge1xuXG5cdFx0XHRyZXR1cm4gZW5hYmxlZCA/IHZhbHVlIHwgKCAxIDw8IHBvc2l0aW9uICkgOiB2YWx1ZSAmICggfiAoIDEgPDwgcG9zaXRpb24pICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXROb3JtYWxJbmRleCggbm9ybWFsICkge1xuXG5cdFx0XHR2YXIgaGFzaCA9IG5vcm1hbC54LnRvU3RyaW5nKCkgKyBub3JtYWwueS50b1N0cmluZygpICsgbm9ybWFsLnoudG9TdHJpbmcoKTtcblxuXHRcdFx0aWYgKCBub3JtYWxzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XG5cblx0XHRcdH1cblxuXHRcdFx0bm9ybWFsc0hhc2hbIGhhc2ggXSA9IG5vcm1hbHMubGVuZ3RoIC8gMztcblx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvbG9ySW5kZXgoIGNvbG9yICkge1xuXG5cdFx0XHR2YXIgaGFzaCA9IGNvbG9yLnIudG9TdHJpbmcoKSArIGNvbG9yLmcudG9TdHJpbmcoKSArIGNvbG9yLmIudG9TdHJpbmcoKTtcblxuXHRcdFx0aWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XG5cdFx0XHRjb2xvcnMucHVzaCggY29sb3IuZ2V0SGV4KCkgKTtcblxuXHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFV2SW5kZXgoIHV2ICkge1xuXG5cdFx0XHR2YXIgaGFzaCA9IHV2LngudG9TdHJpbmcoKSArIHV2LnkudG9TdHJpbmcoKTtcblxuXHRcdFx0aWYgKCB1dnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHV2c0hhc2hbIGhhc2ggXSA9IHV2cy5sZW5ndGggLyAyO1xuXHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuXHRcdH1cblxuXHRcdG91dHB1dC5kYXRhID0ge307XG5cblx0XHRvdXRwdXQuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuXHRcdG91dHB1dC5kYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xuXHRcdGlmICggY29sb3JzLmxlbmd0aCA+IDAgKSBvdXRwdXQuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XG5cdFx0aWYgKCB1dnMubGVuZ3RoID4gMCApIG91dHB1dC5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRvdXRwdXQuZGF0YS5mYWNlcyA9IGZhY2VzO1xuXG5cdFx0Ly9cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VzWyBpIF0uY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHV2ID0gdXZzWyBpIF0sIHV2Q29weSA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0dXZDb3B5LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dlsgaiBdLngsIHV2WyBqIF0ueSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2Q29weSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH0sXG5cblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuVEhSRUUuR2VvbWV0cnlJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DYW1lcmEuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcblxuXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbn07XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5nZXRXb3JsZERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0fVxuXG59KCk7XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24gKCkge1xuXG5cdC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IGNhbWVyYXMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG5cdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0bTEubG9va0F0KCB0aGlzLnBvc2l0aW9uLCB2ZWN0b3IsIHRoaXMudXAgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XG5cblx0fTtcblxufSgpO1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0aWYgKCBjYW1lcmEgPT09IHVuZGVmaW5lZCApIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgY2FtZXJhICk7XG5cblx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRyZXR1cm4gY2FtZXJhO1xufTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DdWJlQ2FtZXJhLmpzXG5cbi8qKlxuICogQ2FtZXJhIGZvciByZW5kZXJpbmcgY3ViZSBtYXBzXG4gKlx0LSByZW5kZXJzIHNjZW5lIGludG8gYXhpcy1hbGlnbmVkIGN1YmVcbiAqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkN1YmVDYW1lcmEgPSBmdW5jdGlvbiAoIG5lYXIsIGZhciwgY3ViZVJlc29sdXRpb24gKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcblxuXHR2YXIgZm92ID0gOTAsIGFzcGVjdCA9IDE7XG5cblx0dmFyIGNhbWVyYVBYID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdGNhbWVyYVBYLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdGNhbWVyYVBYLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKSApO1xuXHR0aGlzLmFkZCggY2FtZXJhUFggKTtcblxuXHR2YXIgY2FtZXJhTlggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0Y2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0Y2FtZXJhTlgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggLSAxLCAwLCAwICkgKTtcblx0dGhpcy5hZGQoIGNhbWVyYU5YICk7XG5cblx0dmFyIGNhbWVyYVBZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdGNhbWVyYVBZLnVwLnNldCggMCwgMCwgMSApO1xuXHRjYW1lcmFQWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcblx0dGhpcy5hZGQoIGNhbWVyYVBZICk7XG5cblx0dmFyIGNhbWVyYU5ZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgLSAxICk7XG5cdGNhbWVyYU5ZLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApICk7XG5cdHRoaXMuYWRkKCBjYW1lcmFOWSApO1xuXG5cdHZhciBjYW1lcmFQWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRjYW1lcmFQWi51cC5zZXQoIDAsIC0gMSwgMCApO1xuXHRjYW1lcmFQWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICkgKTtcblx0dGhpcy5hZGQoIGNhbWVyYVBaICk7XG5cblx0dmFyIGNhbWVyYU5aID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdGNhbWVyYU5aLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdGNhbWVyYU5aLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApICk7XG5cdHRoaXMuYWRkKCBjYW1lcmFOWiApO1xuXG5cdHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggY3ViZVJlc29sdXRpb24sIGN1YmVSZXNvbHV0aW9uLCB7IGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LCBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIgfSApO1xuXG5cdHRoaXMudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xuXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuXHRcdHZhciBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAxO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDI7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFksIHJlbmRlclRhcmdldCApO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA0O1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgPSBnZW5lcmF0ZU1pcG1hcHM7XG5cblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA1O1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aLCByZW5kZXJUYXJnZXQgKTtcblxuXHR9O1xuXG59O1xuXG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL09ydGhvZ3JhcGhpY0NhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhID0gZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuXHRUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xuXG5cdHRoaXMuem9vbSA9IDE7XG5cblx0dGhpcy5sZWZ0ID0gbGVmdDtcblx0dGhpcy5yaWdodCA9IHJpZ2h0O1xuXHR0aGlzLnRvcCA9IHRvcDtcblx0dGhpcy5ib3R0b20gPSBib3R0b207XG5cblx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XG5cdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMjAwMDtcblxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XG5cdHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XG5cdHZhciBjeCA9ICggdGhpcy5yaWdodCArIHRoaXMubGVmdCApIC8gMjtcblx0dmFyIGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xuXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBjeCAtIGR4LCBjeCArIGR4LCBjeSArIGR5LCBjeSAtIGR5LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbn07XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoKTtcblxuXHRUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGNhbWVyYSApO1xuXG5cdGNhbWVyYS56b29tID0gdGhpcy56b29tO1xuXG5cdGNhbWVyYS5sZWZ0ID0gdGhpcy5sZWZ0O1xuXHRjYW1lcmEucmlnaHQgPSB0aGlzLnJpZ2h0O1xuXHRjYW1lcmEudG9wID0gdGhpcy50b3A7XG5cdGNhbWVyYS5ib3R0b20gPSB0aGlzLmJvdHRvbTtcblxuXHRjYW1lcmEubmVhciA9IHRoaXMubmVhcjtcblx0Y2FtZXJhLmZhciA9IHRoaXMuZmFyO1xuXG5cdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdHJldHVybiBjYW1lcmE7XG59O1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL1BlcnNwZWN0aXZlQ2FtZXJhLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICovXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhID0gZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xuXG5cdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcblxuXHR0aGlzLnpvb20gPSAxO1xuXG5cdHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcblx0dGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XG5cdHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XG5cdHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xuXG5cdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG59O1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XG5cblxuLyoqXG4gKiBVc2VzIEZvY2FsIExlbmd0aCAoaW4gbW0pIHRvIGVzdGltYXRlIGFuZCBzZXQgRk9WXG4gKiAzNW1tIChmdWxsZnJhbWUpIGNhbWVyYSBpcyB1c2VkIGlmIGZyYW1lIHNpemUgaXMgbm90IHNwZWNpZmllZDtcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xuXG5cdGlmICggZnJhbWVIZWlnaHQgPT09IHVuZGVmaW5lZCApIGZyYW1lSGVpZ2h0ID0gMjQ7XG5cblx0dGhpcy5mb3YgPSAyICogVEhSRUUuTWF0aC5yYWRUb0RlZyggTWF0aC5hdGFuKCBmcmFtZUhlaWdodCAvICggZm9jYWxMZW5ndGggKiAyICkgKSApO1xuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufVxuXG5cbi8qKlxuICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxuICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxuICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xuICpcbiAqICAgKy0tLSstLS0rLS0tK1xuICogICB8IEEgfCBCIHwgQyB8XG4gKiAgICstLS0rLS0tKy0tLStcbiAqICAgfCBEIHwgRSB8IEYgfFxuICogICArLS0tKy0tLSstLS0rXG4gKlxuICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xuICpcbiAqICAgdmFyIHcgPSAxOTIwO1xuICogICB2YXIgaCA9IDEwODA7XG4gKiAgIHZhciBmdWxsV2lkdGggPSB3ICogMztcbiAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcbiAqXG4gKiAgIC0tQS0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XG4gKiAgIC0tQi0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XG4gKiAgIC0tQy0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XG4gKiAgIC0tRC0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XG4gKiAgIC0tRS0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XG4gKiAgIC0tRi0tXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XG4gKlxuICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxuICovXG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRWaWV3T2Zmc2V0ID0gZnVuY3Rpb24gKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0dGhpcy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XG5cdHRoaXMuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XG5cdHRoaXMueCA9IHg7XG5cdHRoaXMueSA9IHk7XG5cdHRoaXMud2lkdGggPSB3aWR0aDtcblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn07XG5cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGZvdiA9IFRIUkVFLk1hdGgucmFkVG9EZWcoIDIgKiBNYXRoLmF0YW4oIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aGlzLmZvdiApICogMC41ICkgLyB0aGlzLnpvb20gKSApO1xuXG5cdGlmICggdGhpcy5mdWxsV2lkdGggKSB7XG5cblx0XHR2YXIgYXNwZWN0ID0gdGhpcy5mdWxsV2lkdGggLyB0aGlzLmZ1bGxIZWlnaHQ7XG5cdFx0dmFyIHRvcCA9IE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApICogdGhpcy5uZWFyO1xuXHRcdHZhciBib3R0b20gPSAtIHRvcDtcblx0XHR2YXIgbGVmdCA9IGFzcGVjdCAqIGJvdHRvbTtcblx0XHR2YXIgcmlnaHQgPSBhc3BlY3QgKiB0b3A7XG5cdFx0dmFyIHdpZHRoID0gTWF0aC5hYnMoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdHZhciBoZWlnaHQgPSBNYXRoLmFicyggdG9wIC0gYm90dG9tICk7XG5cblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZUZydXN0dW0oXG5cdFx0XHRsZWZ0ICsgdGhpcy54ICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcblx0XHRcdGxlZnQgKyAoIHRoaXMueCArIHRoaXMud2lkdGggKSAqIHdpZHRoIC8gdGhpcy5mdWxsV2lkdGgsXG5cdFx0XHR0b3AgLSAoIHRoaXMueSArIHRoaXMuaGVpZ2h0ICkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXG5cdFx0XHR0b3AgLSB0aGlzLnkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXG5cdFx0XHR0aGlzLm5lYXIsXG5cdFx0XHR0aGlzLmZhclxuXHRcdCk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoIGZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cblx0VEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBjYW1lcmEgKTtcblxuXHRjYW1lcmEuem9vbSA9IHRoaXMuem9vbTtcblxuXHRjYW1lcmEuZm92ID0gdGhpcy5mb3Y7XG5cdGNhbWVyYS5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcblx0Y2FtZXJhLm5lYXIgPSB0aGlzLm5lYXI7XG5cdGNhbWVyYS5mYXIgPSB0aGlzLmZhcjtcblxuXHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRyZXR1cm4gY2FtZXJhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5MaWdodCA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMaWdodCc7XG5cdFxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuXG59O1xuXG5USFJFRS5MaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBsaWdodCApIHtcblxuXHRpZiAoIGxpZ2h0ID09PSB1bmRlZmluZWQgKSBsaWdodCA9IG5ldyBUSFJFRS5MaWdodCgpO1xuXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBsaWdodCApO1xuXG5cdGxpZ2h0LmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblxuXHRyZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9BbWJpZW50TGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkFtYmllbnRMaWdodCA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuXHR0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcblxufTtcblxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBsaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoKTtcblxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuXHRyZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9BcmVhTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIE1QYW5rbmluIC8gaHR0cDovL3d3dy5yZWRwbGFudC5kZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQXJlYUxpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XG5cblx0dGhpcy50eXBlID0gJ0FyZWFMaWdodCc7XG5cblx0dGhpcy5ub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XG5cdHRoaXMucmlnaHQgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xuXG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcblxuXHR0aGlzLndpZHRoID0gMS4wO1xuXHR0aGlzLmhlaWdodCA9IDEuMDtcblxuXHR0aGlzLmNvbnN0YW50QXR0ZW51YXRpb24gPSAxLjU7XG5cdHRoaXMubGluZWFyQXR0ZW51YXRpb24gPSAwLjU7XG5cdHRoaXMucXVhZHJhdGljQXR0ZW51YXRpb24gPSAwLjE7XG5cbn07XG5cblRIUkVFLkFyZWFMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblxuXG4vLyBGaWxlOnNyYy9saWdodHMvRGlyZWN0aW9uYWxMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuXHR0aGlzLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XG5cblx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHR0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cblx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG5cdHRoaXMub25seVNoYWRvdyA9IGZhbHNlO1xuXG5cdC8vXG5cblx0dGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XG5cdHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gNTAwMDtcblxuXHR0aGlzLnNoYWRvd0NhbWVyYUxlZnQgPSAtIDUwMDtcblx0dGhpcy5zaGFkb3dDYW1lcmFSaWdodCA9IDUwMDtcblx0dGhpcy5zaGFkb3dDYW1lcmFUb3AgPSA1MDA7XG5cdHRoaXMuc2hhZG93Q2FtZXJhQm90dG9tID0gLSA1MDA7XG5cblx0dGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cblx0dGhpcy5zaGFkb3dCaWFzID0gMDtcblx0dGhpcy5zaGFkb3dEYXJrbmVzcyA9IDAuNTtcblxuXHR0aGlzLnNoYWRvd01hcFdpZHRoID0gNTEyO1xuXHR0aGlzLnNoYWRvd01hcEhlaWdodCA9IDUxMjtcblxuXHQvL1xuXG5cdHRoaXMuc2hhZG93Q2FzY2FkZSA9IGZhbHNlO1xuXG5cdHRoaXMuc2hhZG93Q2FzY2FkZU9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtIDEwMDAgKTtcblx0dGhpcy5zaGFkb3dDYXNjYWRlQ291bnQgPSAyO1xuXG5cdHRoaXMuc2hhZG93Q2FzY2FkZUJpYXMgPSBbIDAsIDAsIDAgXTtcblx0dGhpcy5zaGFkb3dDYXNjYWRlV2lkdGggPSBbIDUxMiwgNTEyLCA1MTIgXTtcblx0dGhpcy5zaGFkb3dDYXNjYWRlSGVpZ2h0ID0gWyA1MTIsIDUxMiwgNTEyIF07XG5cblx0dGhpcy5zaGFkb3dDYXNjYWRlTmVhclogPSBbIC0gMS4wMDAsIDAuOTkwLCAwLjk5OCBdO1xuXHR0aGlzLnNoYWRvd0Nhc2NhZGVGYXJaICA9IFsgIDAuOTkwLCAwLjk5OCwgMS4wMDAgXTtcblxuXHR0aGlzLnNoYWRvd0Nhc2NhZGVBcnJheSA9IFtdO1xuXG5cdC8vXG5cblx0dGhpcy5zaGFkb3dNYXAgPSBudWxsO1xuXHR0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xuXHR0aGlzLnNoYWRvd0NhbWVyYSA9IG51bGw7XG5cdHRoaXMuc2hhZG93TWF0cml4ID0gbnVsbDtcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoKTtcblxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuXHRsaWdodC50YXJnZXQgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXG5cdGxpZ2h0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXG5cdGxpZ2h0LmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG5cdGxpZ2h0Lm9ubHlTaGFkb3cgPSB0aGlzLm9ubHlTaGFkb3c7XG5cblx0Ly9cblxuXHRsaWdodC5zaGFkb3dDYW1lcmFOZWFyID0gdGhpcy5zaGFkb3dDYW1lcmFOZWFyO1xuXHRsaWdodC5zaGFkb3dDYW1lcmFGYXIgPSB0aGlzLnNoYWRvd0NhbWVyYUZhcjtcblxuXHRsaWdodC5zaGFkb3dDYW1lcmFMZWZ0ID0gdGhpcy5zaGFkb3dDYW1lcmFMZWZ0O1xuXHRsaWdodC5zaGFkb3dDYW1lcmFSaWdodCA9IHRoaXMuc2hhZG93Q2FtZXJhUmlnaHQ7XG5cdGxpZ2h0LnNoYWRvd0NhbWVyYVRvcCA9IHRoaXMuc2hhZG93Q2FtZXJhVG9wO1xuXHRsaWdodC5zaGFkb3dDYW1lcmFCb3R0b20gPSB0aGlzLnNoYWRvd0NhbWVyYUJvdHRvbTtcblxuXHRsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuXG5cdGxpZ2h0LnNoYWRvd0JpYXMgPSB0aGlzLnNoYWRvd0JpYXM7XG5cdGxpZ2h0LnNoYWRvd0RhcmtuZXNzID0gdGhpcy5zaGFkb3dEYXJrbmVzcztcblxuXHRsaWdodC5zaGFkb3dNYXBXaWR0aCA9IHRoaXMuc2hhZG93TWFwV2lkdGg7XG5cdGxpZ2h0LnNoYWRvd01hcEhlaWdodCA9IHRoaXMuc2hhZG93TWFwSGVpZ2h0O1xuXG5cdC8vXG5cblx0bGlnaHQuc2hhZG93Q2FzY2FkZSA9IHRoaXMuc2hhZG93Q2FzY2FkZTtcblxuXHRsaWdodC5zaGFkb3dDYXNjYWRlT2Zmc2V0LmNvcHkoIHRoaXMuc2hhZG93Q2FzY2FkZU9mZnNldCApO1xuXHRsaWdodC5zaGFkb3dDYXNjYWRlQ291bnQgPSB0aGlzLnNoYWRvd0Nhc2NhZGVDb3VudDtcblxuXHRsaWdodC5zaGFkb3dDYXNjYWRlQmlhcyA9IHRoaXMuc2hhZG93Q2FzY2FkZUJpYXMuc2xpY2UoIDAgKTtcblx0bGlnaHQuc2hhZG93Q2FzY2FkZVdpZHRoID0gdGhpcy5zaGFkb3dDYXNjYWRlV2lkdGguc2xpY2UoIDAgKTtcblx0bGlnaHQuc2hhZG93Q2FzY2FkZUhlaWdodCA9IHRoaXMuc2hhZG93Q2FzY2FkZUhlaWdodC5zbGljZSggMCApO1xuXG5cdGxpZ2h0LnNoYWRvd0Nhc2NhZGVOZWFyWiA9IHRoaXMuc2hhZG93Q2FzY2FkZU5lYXJaLnNsaWNlKCAwICk7XG5cdGxpZ2h0LnNoYWRvd0Nhc2NhZGVGYXJaICA9IHRoaXMuc2hhZG93Q2FzY2FkZUZhclouc2xpY2UoIDAgKTtcblxuXHRyZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9IZW1pc3BoZXJlTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodCA9IGZ1bmN0aW9uICggc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgc2t5Q29sb3IgKTtcblxuXHR0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0JztcblxuXHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMTAwLCAwICk7XG5cblx0dGhpcy5ncm91bmRDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggZ3JvdW5kQ29sb3IgKTtcblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCgpO1xuXG5cdFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBsaWdodCApO1xuXG5cdGxpZ2h0Lmdyb3VuZENvbG9yLmNvcHkoIHRoaXMuZ3JvdW5kQ29sb3IgKTtcblx0bGlnaHQuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cblx0cmV0dXJuIGxpZ2h0O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvUG9pbnRMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuXHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XG5cblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG5cbn07XG5cblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5cblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBsaWdodCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KCk7XG5cblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGxpZ2h0ICk7XG5cblx0bGlnaHQuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cdGxpZ2h0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcblxuXHRyZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9TcG90TGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwb3RMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBleHBvbmVudCApIHtcblxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG5cdHRoaXMudHlwZSA9ICdTcG90TGlnaHQnO1xuXG5cdHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG5cdHRoaXMuYW5nbGUgPSAoIGFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IGFuZ2xlIDogTWF0aC5QSSAvIDM7XG5cdHRoaXMuZXhwb25lbnQgPSAoIGV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSA/IGV4cG9uZW50IDogMTA7XG5cblx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG5cdHRoaXMub25seVNoYWRvdyA9IGZhbHNlO1xuXG5cdC8vXG5cblx0dGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XG5cdHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gNTAwMDtcblx0dGhpcy5zaGFkb3dDYW1lcmFGb3YgPSA1MDtcblxuXHR0aGlzLnNoYWRvd0NhbWVyYVZpc2libGUgPSBmYWxzZTtcblxuXHR0aGlzLnNoYWRvd0JpYXMgPSAwO1xuXHR0aGlzLnNoYWRvd0RhcmtuZXNzID0gMC41O1xuXG5cdHRoaXMuc2hhZG93TWFwV2lkdGggPSA1MTI7XG5cdHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gNTEyO1xuXG5cdC8vXG5cblx0dGhpcy5zaGFkb3dNYXAgPSBudWxsO1xuXHR0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xuXHR0aGlzLnNoYWRvd0NhbWVyYSA9IG51bGw7XG5cdHRoaXMuc2hhZG93TWF0cml4ID0gbnVsbDtcblxufTtcblxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBsaWdodCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoKTtcblxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuXHRsaWdodC50YXJnZXQgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXG5cdGxpZ2h0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXHRsaWdodC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG5cdGxpZ2h0LmFuZ2xlID0gdGhpcy5hbmdsZTtcblx0bGlnaHQuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50O1xuXG5cdGxpZ2h0LmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG5cdGxpZ2h0Lm9ubHlTaGFkb3cgPSB0aGlzLm9ubHlTaGFkb3c7XG5cblx0Ly9cblxuXHRsaWdodC5zaGFkb3dDYW1lcmFOZWFyID0gdGhpcy5zaGFkb3dDYW1lcmFOZWFyO1xuXHRsaWdodC5zaGFkb3dDYW1lcmFGYXIgPSB0aGlzLnNoYWRvd0NhbWVyYUZhcjtcblx0bGlnaHQuc2hhZG93Q2FtZXJhRm92ID0gdGhpcy5zaGFkb3dDYW1lcmFGb3Y7XG5cblx0bGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZTtcblxuXHRsaWdodC5zaGFkb3dCaWFzID0gdGhpcy5zaGFkb3dCaWFzO1xuXHRsaWdodC5zaGFkb3dEYXJrbmVzcyA9IHRoaXMuc2hhZG93RGFya25lc3M7XG5cblx0bGlnaHQuc2hhZG93TWFwV2lkdGggPSB0aGlzLnNoYWRvd01hcFdpZHRoO1xuXHRsaWdodC5zaGFkb3dNYXBIZWlnaHQgPSB0aGlzLnNoYWRvd01hcEhlaWdodDtcblxuXHRyZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ2FjaGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkNhY2hlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuZmlsZXMgPSB7fTtcblxufTtcblxuVEhSRUUuQ2FjaGUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DYWNoZSxcblxuXHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBmaWxlICkge1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xuXG5cdFx0dGhpcy5maWxlc1sga2V5IF0gPSBmaWxlO1xuXG5cdH0sXG5cblx0Z2V0OiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsZXNbIGtleSBdO1xuXG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcblxuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmZpbGVzID0ge31cblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Mb2FkZXIgPSBmdW5jdGlvbiAoIHNob3dTdGF0dXMgKSB7XG5cblx0dGhpcy5zaG93U3RhdHVzID0gc2hvd1N0YXR1cztcblx0dGhpcy5zdGF0dXNEb21FbGVtZW50ID0gc2hvd1N0YXR1cyA/IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuYWRkU3RhdHVzRWxlbWVudCgpIDogbnVsbDtcblxuXHR0aGlzLmltYWdlTG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG5cblx0dGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xuXHR0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XG5cdHRoaXMub25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7fTtcblxufTtcblxuVEhSRUUuTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTG9hZGVyLFxuXG5cdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cblx0YWRkU3RhdHVzRWxlbWVudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXG5cdFx0ZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0ZS5zdHlsZS5yaWdodCA9ICcwcHgnO1xuXHRcdGUuc3R5bGUudG9wID0gJzBweCc7XG5cdFx0ZS5zdHlsZS5mb250U2l6ZSA9ICcwLjhlbSc7XG5cdFx0ZS5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XG5cdFx0ZS5zdHlsZS5iYWNrZ3JvdW5kID0gJ3JnYmEoMCwwLDAsMC4yNSknO1xuXHRcdGUuc3R5bGUuY29sb3IgPSAnI2ZmZic7XG5cdFx0ZS5zdHlsZS53aWR0aCA9ICcxMjBweCc7XG5cdFx0ZS5zdHlsZS5wYWRkaW5nID0gJzAuNWVtIDAuNWVtIDAuNWVtIDAuNWVtJztcblx0XHRlLnN0eWxlLnpJbmRleCA9IDEwMDA7XG5cblx0XHRlLmlubmVySFRNTCA9ICdMb2FkaW5nIC4uLic7XG5cblx0XHRyZXR1cm4gZTtcblxuXHR9LFxuXG5cdHVwZGF0ZVByb2dyZXNzOiBmdW5jdGlvbiAoIHByb2dyZXNzICkge1xuXG5cdFx0dmFyIG1lc3NhZ2UgPSAnTG9hZGVkICc7XG5cblx0XHRpZiAoIHByb2dyZXNzLnRvdGFsICkge1xuXG5cdFx0XHRtZXNzYWdlICs9ICggMTAwICogcHJvZ3Jlc3MubG9hZGVkIC8gcHJvZ3Jlc3MudG90YWwgKS50b0ZpeGVkKCAwICkgKyAnJSc7XG5cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1lc3NhZ2UgKz0gKCBwcm9ncmVzcy5sb2FkZWQgLyAxMDI0ICkudG9GaXhlZCggMiApICsgJyBLQic7XG5cblx0XHR9XG5cblx0XHR0aGlzLnN0YXR1c0RvbUVsZW1lbnQuaW5uZXJIVE1MID0gbWVzc2FnZTtcblxuXHR9LFxuXG5cdGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XG5cblx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xuXG5cdFx0cGFydHMucG9wKCk7XG5cblx0XHRyZXR1cm4gcGFydHMuam9pbiggJy8nICkgKyAnLyc7XG5cblx0fSxcblxuXHRpbml0TWF0ZXJpYWxzOiBmdW5jdGlvbiAoIG1hdGVyaWFscywgdGV4dHVyZVBhdGggKSB7XG5cblx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdGFycmF5WyBpIF0gPSB0aGlzLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbHNbIGkgXSwgdGV4dHVyZVBhdGggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdG5lZWRzVGFuZ2VudHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG0gPSBtYXRlcmlhbHNbIGkgXTtcblxuXHRcdFx0aWYgKCBtIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdGNyZWF0ZU1hdGVyaWFsOiBmdW5jdGlvbiAoIG0sIHRleHR1cmVQYXRoICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIG5lYXJlc3RfcG93MiggbiApIHtcblxuXHRcdFx0dmFyIGwgPSBNYXRoLmxvZyggbiApIC8gTWF0aC5MTjI7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGgucm91bmQoICBsICkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZV90ZXh0dXJlKCB3aGVyZSwgbmFtZSwgc291cmNlRmlsZSwgcmVwZWF0LCBvZmZzZXQsIHdyYXAsIGFuaXNvdHJvcHkgKSB7XG5cblx0XHRcdHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgc291cmNlRmlsZTtcblxuXHRcdFx0dmFyIHRleHR1cmU7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBUSFJFRS5Mb2FkZXIuSGFuZGxlcnMuZ2V0KCBmdWxsUGF0aCApO1xuXG5cdFx0XHRpZiAoIGxvYWRlciAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XG5cblx0XHRcdFx0bG9hZGVyID0gc2NvcGUuaW1hZ2VMb2FkZXI7XG5cdFx0XHRcdGxvYWRlci5jcm9zc09yaWdpbiA9IHNjb3BlLmNyb3NzT3JpZ2luO1xuXHRcdFx0XHRsb2FkZXIubG9hZCggZnVsbFBhdGgsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdFx0IFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB3aWR0aCA9IG5lYXJlc3RfcG93MiggaW1hZ2Uud2lkdGggKTtcblx0XHRcdFx0XHRcdHZhciBoZWlnaHQgPSBuZWFyZXN0X3BvdzIoIGltYWdlLmhlaWdodCApO1xuXG5cdFx0XHRcdFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcblx0XHRcdFx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdFx0XHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSBjYW52YXM7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZS5zb3VyY2VGaWxlID0gc291cmNlRmlsZTtcblxuXHRcdFx0aWYgKCByZXBlYXQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5yZXBlYXQuc2V0KCByZXBlYXRbIDAgXSwgcmVwZWF0WyAxIF0gKTtcblxuXHRcdFx0XHRpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0XHRpZiAoIHJlcGVhdFsgMSBdICE9PSAxICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHRleHR1cmUub2Zmc2V0LnNldCggb2Zmc2V0WyAwIF0sIG9mZnNldFsgMSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3cmFwICkge1xuXG5cdFx0XHRcdHZhciB3cmFwTWFwID0ge1xuXHRcdFx0XHRcdCdyZXBlYXQnOiBUSFJFRS5SZXBlYXRXcmFwcGluZyxcblx0XHRcdFx0XHQnbWlycm9yJzogVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB3cmFwTWFwWyB3cmFwWyAwIF0gXSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS53cmFwUyA9IHdyYXBNYXBbIHdyYXBbIDAgXSBdO1xuXHRcdFx0XHRpZiAoIHdyYXBNYXBbIHdyYXBbIDEgXSBdICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLndyYXBUID0gd3JhcE1hcFsgd3JhcFsgMSBdIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhbmlzb3Ryb3B5ICkge1xuXG5cdFx0XHRcdHRleHR1cmUuYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XG5cblx0XHRcdH1cblxuXHRcdFx0d2hlcmVbIG5hbWUgXSA9IHRleHR1cmU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZ2IyaGV4KCByZ2IgKSB7XG5cblx0XHRcdHJldHVybiAoIHJnYlsgMCBdICogMjU1IDw8IDE2ICkgKyAoIHJnYlsgMSBdICogMjU1IDw8IDggKSArIHJnYlsgMiBdICogMjU1O1xuXG5cdFx0fVxuXG5cdFx0Ly8gZGVmYXVsdHNcblxuXHRcdHZhciBtdHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcblx0XHR2YXIgbXBhcnMgPSB7IGNvbG9yOiAweGVlZWVlZSwgb3BhY2l0eTogMS4wLCBtYXA6IG51bGwsIGxpZ2h0TWFwOiBudWxsLCBub3JtYWxNYXA6IG51bGwsIGJ1bXBNYXA6IG51bGwsIHdpcmVmcmFtZTogZmFsc2UgfTtcblxuXHRcdC8vIHBhcmFtZXRlcnMgZnJvbSBtb2RlbCBmaWxlXG5cblx0XHRpZiAoIG0uc2hhZGluZyApIHtcblxuXHRcdFx0dmFyIHNoYWRpbmcgPSBtLnNoYWRpbmcudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBzaGFkaW5nID09PSAncGhvbmcnICkgbXR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuXHRcdFx0ZWxzZSBpZiAoIHNoYWRpbmcgPT09ICdiYXNpYycgKSBtdHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCAmJiBUSFJFRVsgbS5ibGVuZGluZyBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1wYXJzLmJsZW5kaW5nID0gVEhSRUVbIG0uYmxlbmRpbmcgXTtcblxuXHRcdH1cblxuXHRcdGlmICggbS50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkIHx8IG0ub3BhY2l0eSA8IDEuMCApIHtcblxuXHRcdFx0bXBhcnMudHJhbnNwYXJlbnQgPSBtLnRyYW5zcGFyZW50O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtcGFycy5kZXB0aFRlc3QgPSBtLmRlcHRoVGVzdDtcblxuXHRcdH1cblxuXHRcdGlmICggbS5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1wYXJzLmRlcHRoV3JpdGUgPSBtLmRlcHRoV3JpdGU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0udmlzaWJsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtcGFycy52aXNpYmxlID0gbS52aXNpYmxlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLmZsaXBTaWRlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtcGFycy5zaWRlID0gVEhSRUUuQmFja1NpZGU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0uZG91YmxlU2lkZWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bXBhcnMuc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1wYXJzLndpcmVmcmFtZSA9IG0ud2lyZWZyYW1lO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIG0udmVydGV4Q29sb3JzID09PSAnZmFjZScgKSB7XG5cblx0XHRcdFx0bXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuRmFjZUNvbG9ycztcblxuXHRcdFx0fSBlbHNlIGlmICggbS52ZXJ0ZXhDb2xvcnMgKSB7XG5cblx0XHRcdFx0bXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuVmVydGV4Q29sb3JzO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBjb2xvcnNcblxuXHRcdGlmICggbS5jb2xvckRpZmZ1c2UgKSB7XG5cblx0XHRcdG1wYXJzLmNvbG9yID0gcmdiMmhleCggbS5jb2xvckRpZmZ1c2UgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG0uRGJnQ29sb3IgKSB7XG5cblx0XHRcdG1wYXJzLmNvbG9yID0gbS5EYmdDb2xvcjtcblxuXHRcdH1cblxuXHRcdGlmICggbS5jb2xvclNwZWN1bGFyICkge1xuXG5cdFx0XHRtcGFycy5zcGVjdWxhciA9IHJnYjJoZXgoIG0uY29sb3JTcGVjdWxhciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLmNvbG9yQW1iaWVudCApIHtcblxuXHRcdFx0bXBhcnMuYW1iaWVudCA9IHJnYjJoZXgoIG0uY29sb3JBbWJpZW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG0uY29sb3JFbWlzc2l2ZSApIHtcblxuXHRcdFx0bXBhcnMuZW1pc3NpdmUgPSByZ2IyaGV4KCBtLmNvbG9yRW1pc3NpdmUgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vZGlmaWVyc1xuXG5cdFx0aWYgKCBtLnRyYW5zcGFyZW5jeSApIHtcblxuXHRcdFx0bXBhcnMub3BhY2l0eSA9IG0udHJhbnNwYXJlbmN5O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLnNwZWN1bGFyQ29lZiApIHtcblxuXHRcdFx0bXBhcnMuc2hpbmluZXNzID0gbS5zcGVjdWxhckNvZWY7XG5cblx0XHR9XG5cblx0XHQvLyB0ZXh0dXJlc1xuXG5cdFx0aWYgKCBtLm1hcERpZmZ1c2UgJiYgdGV4dHVyZVBhdGggKSB7XG5cblx0XHRcdGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ21hcCcsIG0ubWFwRGlmZnVzZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbS5tYXBMaWdodCAmJiB0ZXh0dXJlUGF0aCApIHtcblxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbGlnaHRNYXAnLCBtLm1hcExpZ2h0LCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbS5tYXBCdW1wICYmIHRleHR1cmVQYXRoICkge1xuXG5cdFx0XHRjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdidW1wTWFwJywgbS5tYXBCdW1wLCBtLm1hcEJ1bXBSZXBlYXQsIG0ubWFwQnVtcE9mZnNldCwgbS5tYXBCdW1wV3JhcCwgbS5tYXBCdW1wQW5pc290cm9weSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtLm1hcE5vcm1hbCAmJiB0ZXh0dXJlUGF0aCApIHtcblxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnbm9ybWFsTWFwJywgbS5tYXBOb3JtYWwsIG0ubWFwTm9ybWFsUmVwZWF0LCBtLm1hcE5vcm1hbE9mZnNldCwgbS5tYXBOb3JtYWxXcmFwLCBtLm1hcE5vcm1hbEFuaXNvdHJvcHkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbS5tYXBTcGVjdWxhciAmJiB0ZXh0dXJlUGF0aCApIHtcblxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnc3BlY3VsYXJNYXAnLCBtLm1hcFNwZWN1bGFyLCBtLm1hcFNwZWN1bGFyUmVwZWF0LCBtLm1hcFNwZWN1bGFyT2Zmc2V0LCBtLm1hcFNwZWN1bGFyV3JhcCwgbS5tYXBTcGVjdWxhckFuaXNvdHJvcHkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbS5tYXBBbHBoYSAmJiB0ZXh0dXJlUGF0aCApIHtcblxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnYWxwaGFNYXAnLCBtLm1hcEFscGhhLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIG0ubWFwQnVtcFNjYWxlICkge1xuXG5cdFx0XHRtcGFycy5idW1wU2NhbGUgPSBtLm1hcEJ1bXBTY2FsZTtcblxuXHRcdH1cblxuXHRcdC8vIHNwZWNpYWwgY2FzZSBmb3Igbm9ybWFsIG1hcHBlZCBtYXRlcmlhbFxuXG5cdFx0aWYgKCBtLm1hcE5vcm1hbCApIHtcblxuXHRcdFx0dmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgJ25vcm1hbG1hcCcgXTtcblx0XHRcdHZhciB1bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApO1xuXG5cdFx0XHR1bmlmb3Jtc1sgJ3ROb3JtYWwnIF0udmFsdWUgPSBtcGFycy5ub3JtYWxNYXA7XG5cblx0XHRcdGlmICggbS5tYXBOb3JtYWxGYWN0b3IgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXNbICd1Tm9ybWFsU2NhbGUnIF0udmFsdWUuc2V0KCBtLm1hcE5vcm1hbEZhY3RvciwgbS5tYXBOb3JtYWxGYWN0b3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1wYXJzLm1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtc1sgJ3REaWZmdXNlJyBdLnZhbHVlID0gbXBhcnMubWFwO1xuXHRcdFx0XHR1bmlmb3Jtc1sgJ2VuYWJsZURpZmZ1c2UnIF0udmFsdWUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbXBhcnMuc3BlY3VsYXJNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXNbICd0U3BlY3VsYXInIF0udmFsdWUgPSBtcGFycy5zcGVjdWxhck1hcDtcblx0XHRcdFx0dW5pZm9ybXNbICdlbmFibGVTcGVjdWxhcicgXS52YWx1ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtcGFycy5saWdodE1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtc1sgJ3RBTycgXS52YWx1ZSA9IG1wYXJzLmxpZ2h0TWFwO1xuXHRcdFx0XHR1bmlmb3Jtc1sgJ2VuYWJsZUFPJyBdLnZhbHVlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb3IgdGhlIG1vbWVudCBkb24ndCBoYW5kbGUgZGlzcGxhY2VtZW50IHRleHR1cmVcblxuXHRcdFx0dW5pZm9ybXNbICdkaWZmdXNlJyBdLnZhbHVlLnNldEhleCggbXBhcnMuY29sb3IgKTtcblx0XHRcdHVuaWZvcm1zWyAnc3BlY3VsYXInIF0udmFsdWUuc2V0SGV4KCBtcGFycy5zcGVjdWxhciApO1xuXHRcdFx0dW5pZm9ybXNbICdhbWJpZW50JyBdLnZhbHVlLnNldEhleCggbXBhcnMuYW1iaWVudCApO1xuXG5cdFx0XHR1bmlmb3Jtc1sgJ3NoaW5pbmVzcycgXS52YWx1ZSA9IG1wYXJzLnNoaW5pbmVzcztcblxuXHRcdFx0aWYgKCBtcGFycy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXNbICdvcGFjaXR5JyBdLnZhbHVlID0gbXBhcnMub3BhY2l0eTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHsgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogdW5pZm9ybXMsIGxpZ2h0czogdHJ1ZSwgZm9nOiB0cnVlIH07XG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxuXHRcdFx0aWYgKCBtcGFycy50cmFuc3BhcmVudCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRVsgbXR5cGUgXSggbXBhcnMgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbS5EYmdOYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0gbS5EYmdOYW1lO1xuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdH1cblxufTtcblxuVEhSRUUuTG9hZGVyLkhhbmRsZXJzID0ge1xuXG5cdGhhbmRsZXJzOiBbXSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggcmVnZXgsIGxvYWRlciApIHtcblxuXHRcdHRoaXMuaGFuZGxlcnMucHVzaCggcmVnZXgsIGxvYWRlciApO1xuXG5cdH0sXG5cblx0Z2V0OiBmdW5jdGlvbiAoIGZpbGUgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuXHRcdFx0dmFyIHJlZ2V4ID0gdGhpcy5oYW5kbGVyc1sgaSBdO1xuXHRcdFx0dmFyIGxvYWRlciAgPSB0aGlzLmhhbmRsZXJzWyBpICsgMSBdO1xuXG5cdFx0XHRpZiAoIHJlZ2V4LnRlc3QoIGZpbGUgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbG9hZGVyO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvWEhSTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5YSFJMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5jYWNoZSA9IG5ldyBUSFJFRS5DYWNoZSgpO1xuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuWEhSTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuWEhSTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGNhY2hlZCA9IHNjb3BlLmNhY2hlLmdldCggdXJsICk7XG5cblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xuXG5cdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRcdHNjb3BlLmNhY2hlLmFkZCggdXJsLCB0aGlzLnJlc3BvbnNlICk7XG5cblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzLnJlc3BvbnNlICk7XG5cblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHR9LCBmYWxzZSApO1xuXG5cdFx0aWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRvblByb2dyZXNzKCBldmVudCApO1xuXG5cdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvbkVycm9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRvbkVycm9yKCBldmVudCApO1xuXG5cdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblx0XHRpZiAoIHRoaXMucmVzcG9uc2VUeXBlICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuXG5cdFx0cmVxdWVzdC5zZW5kKCBudWxsICk7XG5cblx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0fSxcblxuXHRzZXRSZXNwb25zZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0ltYWdlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5JbWFnZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHR0aGlzLmNhY2hlID0gbmV3IFRIUkVFLkNhY2hlKCk7XG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5JbWFnZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkltYWdlTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGNhY2hlZCA9IHNjb3BlLmNhY2hlLmdldCggdXJsICk7XG5cblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRvbkxvYWQoIGNhY2hlZCApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2ltZycgKTtcblxuXHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRzY29wZS5jYWNoZS5hZGQoIHVybCwgdGhpcyApO1xuXG5cdFx0XHRcdG9uTG9hZCggdGhpcyApO1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRcdFx0b25Qcm9ncmVzcyggZXZlbnQgKTtcblxuXHRcdFx0fSwgZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0XHRcdG9uRXJyb3IoIGV2ZW50ICk7XG5cblx0XHRcdH0sIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblxuXHRcdGltYWdlLnNyYyA9IHVybDtcblxuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdHJldHVybiBpbWFnZTtcblxuXHR9LFxuXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG5cdH1cblxufVxuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0pTT05Mb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5KU09OTG9hZGVyID0gZnVuY3Rpb24gKCBzaG93U3RhdHVzICkge1xuXG5cdFRIUkVFLkxvYWRlci5jYWxsKCB0aGlzLCBzaG93U3RhdHVzICk7XG5cblx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Mb2FkZXIucHJvdG90eXBlICk7XG5cblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoICkge1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0Ly8gdG9kbzogdW5pZnkgbG9hZCBBUEkgdG8gZm9yIGVhc2llciBTY2VuZUxvYWRlciB1c2VcblxuXHR0ZXh0dXJlUGF0aCA9IHRleHR1cmVQYXRoICYmICggdHlwZW9mIHRleHR1cmVQYXRoID09PSAnc3RyaW5nJyApID8gdGV4dHVyZVBhdGggOiB0aGlzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcblxuXHR0aGlzLm9uTG9hZFN0YXJ0KCk7XG5cdHRoaXMubG9hZEFqYXhKU09OKCB0aGlzLCB1cmwsIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCApO1xuXG59O1xuXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5sb2FkQWpheEpTT04gPSBmdW5jdGlvbiAoIGNvbnRleHQsIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoLCBjYWxsYmFja1Byb2dyZXNzICkge1xuXG5cdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHR2YXIgbGVuZ3RoID0gMDtcblxuXHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0geGhyLkRPTkUgKSB7XG5cblx0XHRcdGlmICggeGhyLnN0YXR1cyA9PT0gMjAwIHx8IHhoci5zdGF0dXMgPT09IDAgKSB7XG5cblx0XHRcdFx0aWYgKCB4aHIucmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB4aHIucmVzcG9uc2VUZXh0ICk7XG5cblx0XHRcdFx0XHRpZiAoIGpzb24ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJiBqc29uLm1ldGFkYXRhLnR5cGUgPT09ICdzY2VuZScgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiBcIicgKyB1cmwgKyAnXCIgc2VlbXMgdG8gYmUgYSBTY2VuZS4gVXNlIFRIUkVFLlNjZW5lTG9hZGVyIGluc3RlYWQuJyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XG5cdFx0XHRcdFx0Y2FsbGJhY2soIHJlc3VsdC5nZW9tZXRyeSwgcmVzdWx0Lm1hdGVyaWFscyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogXCInICsgdXJsICsgJ1wiIHNlZW1zIHRvIGJlIHVucmVhY2hhYmxlIG9yIHRoZSBmaWxlIGlzIGVtcHR5LicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaW4gY29udGV4dCBvZiBtb3JlIGNvbXBsZXggYXNzZXQgaW5pdGlhbGl6YXRpb25cblx0XHRcdFx0Ly8gZG8gbm90IGJsb2NrIG9uIHNpbmdsZSBmYWlsZWQgZmlsZVxuXHRcdFx0XHQvLyBtYXliZSBzaG91bGQgZ28gZXZlbiBvbmUgbW9yZSBsZXZlbCB1cFxuXG5cdFx0XHRcdGNvbnRleHQub25Mb2FkQ29tcGxldGUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogQ291bGRuXFwndCBsb2FkIFwiJyArIHVybCArICdcIiAoJyArIHhoci5zdGF0dXMgKyAnKScgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IHhoci5MT0FESU5HICkge1xuXG5cdFx0XHRpZiAoIGNhbGxiYWNrUHJvZ3Jlc3MgKSB7XG5cblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRsZW5ndGggPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoICdDb250ZW50LUxlbmd0aCcgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2tQcm9ncmVzcyggeyB0b3RhbDogbGVuZ3RoLCBsb2FkZWQ6IHhoci5yZXNwb25zZVRleHQubGVuZ3RoIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IHhoci5IRUFERVJTX1JFQ0VJVkVEICkge1xuXG5cdFx0XHRpZiAoIGNhbGxiYWNrUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRsZW5ndGggPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoICdDb250ZW50LUxlbmd0aCcgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0eGhyLm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcblx0eGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXHR4aHIuc2VuZCggbnVsbCApO1xuXG59O1xuXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZVBhdGggKSB7XG5cblx0dmFyIHNjb3BlID0gdGhpcyxcblx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKSxcblx0c2NhbGUgPSAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApID8gMS4wIC8ganNvbi5zY2FsZSA6IDEuMDtcblxuXHRwYXJzZU1vZGVsKCBzY2FsZSApO1xuXG5cdHBhcnNlU2tpbigpO1xuXHRwYXJzZU1vcnBoaW5nKCBzY2FsZSApO1xuXG5cdGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcblxuXHRcdGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XG5cblx0XHRcdHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGksIGosIGZpLFxuXG5cdFx0b2Zmc2V0LCB6TGVuZ3RoLFxuXG5cdFx0Y29sb3JJbmRleCwgbm9ybWFsSW5kZXgsIHV2SW5kZXgsIG1hdGVyaWFsSW5kZXgsXG5cblx0XHR0eXBlLFxuXHRcdGlzUXVhZCxcblx0XHRoYXNNYXRlcmlhbCxcblx0XHRoYXNGYWNlVmVydGV4VXYsXG5cdFx0aGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCxcblx0XHRoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcblxuXHRcdHZlcnRleCwgZmFjZSwgZmFjZUEsIGZhY2VCLCBjb2xvciwgaGV4LCBub3JtYWwsXG5cblx0XHR1dkxheWVyLCB1diwgdSwgdixcblxuXHRcdGZhY2VzID0ganNvbi5mYWNlcyxcblx0XHR2ZXJ0aWNlcyA9IGpzb24udmVydGljZXMsXG5cdFx0bm9ybWFscyA9IGpzb24ubm9ybWFscyxcblx0XHRjb2xvcnMgPSBqc29uLmNvbG9ycyxcblxuXHRcdG5VdkxheWVycyA9IDA7XG5cblx0XHRpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIGRpc3JlZ2FyZCBlbXB0eSBhcnJheXNcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycyArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0b2Zmc2V0ID0gMDtcblx0XHR6TGVuZ3RoID0gdmVydGljZXMubGVuZ3RoO1xuXG5cdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG5cdFx0XHR2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR2ZXJ0ZXgueCA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xuXHRcdFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG5cblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG5cdFx0fVxuXG5cdFx0b2Zmc2V0ID0gMDtcblx0XHR6TGVuZ3RoID0gZmFjZXMubGVuZ3RoO1xuXG5cdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG5cdFx0XHR0eXBlID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG5cblx0XHRcdGlzUXVhZCAgICAgICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMCApO1xuXHRcdFx0aGFzTWF0ZXJpYWwgICAgICAgICA9IGlzQml0U2V0KCB0eXBlLCAxICk7XG5cdFx0XHRoYXNGYWNlVmVydGV4VXYgICAgID0gaXNCaXRTZXQoIHR5cGUsIDMgKTtcblx0XHRcdGhhc0ZhY2VOb3JtYWwgICAgICAgPSBpc0JpdFNldCggdHlwZSwgNCApO1xuXHRcdFx0aGFzRmFjZVZlcnRleE5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA1ICk7XG5cdFx0XHRoYXNGYWNlQ29sb3JcdCAgICAgPSBpc0JpdFNldCggdHlwZSwgNiApO1xuXHRcdFx0aGFzRmFjZVZlcnRleENvbG9yICA9IGlzQml0U2V0KCB0eXBlLCA3ICk7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XG5cblx0XHRcdGlmICggaXNRdWFkICkge1xuXG5cdFx0XHRcdGZhY2VBID0gbmV3IFRIUkVFLkZhY2UzKCk7XG5cdFx0XHRcdGZhY2VBLmEgPSBmYWNlc1sgb2Zmc2V0IF07XG5cdFx0XHRcdGZhY2VBLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuXHRcdFx0XHRmYWNlQS5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcblxuXHRcdFx0XHRmYWNlQiA9IG5ldyBUSFJFRS5GYWNlMygpO1xuXHRcdFx0XHRmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcblx0XHRcdFx0ZmFjZUIuYiA9IGZhY2VzWyBvZmZzZXQgKyAyIF07XG5cdFx0XHRcdGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0XHRcdG9mZnNldCArPSA0O1xuXG5cdFx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdGZhY2VBLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdGZhY2VCLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuXHRcdFx0XHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW11cblxuXHRcdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCA0OyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0XHRcdFx0dSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XG5cdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHR1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqICE9PSAyICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XG5cdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMCApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0ucHVzaCggdXYgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cblx0XHRcdFx0XHRmYWNlQS5ub3JtYWwuc2V0KFxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGZhY2VCLm5vcm1hbC5jb3B5KCBmYWNlQS5ub3JtYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cblx0XHRcdFx0XHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG5cdFx0XHRcdFx0XHQpO1xuXG5cblx0XHRcdFx0XHRcdGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cdFx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG5cdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcblxuXHRcdFx0XHRcdGZhY2VBLmNvbG9yLnNldEhleCggaGV4ICk7XG5cdFx0XHRcdFx0ZmFjZUIuY29sb3Iuc2V0SGV4KCBoZXggKTtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUEgKTtcblx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCk7XG5cdFx0XHRcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0ZmFjZS5iID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRmYWNlLmMgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0aWYgKCBoYXNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXG5cblx0XHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdFx0XHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcblx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cblx0XHRcdFx0XHRmYWNlLm5vcm1hbC5zZXQoXG5cdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuXHRcdFx0XHRcdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuXHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0ZmFjZS5jb2xvci5zZXRIZXgoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBwYXJzZVNraW4oKSB7XG5cdFx0dmFyIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPSAoIGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCAhPT0gdW5kZWZpbmVkICkgPyBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggOiAyO1xuXG5cdFx0aWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuXHRcdFx0XHR2YXIgeCA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbldlaWdodHNbIGkgICAgIF07XG5cdFx0XHRcdHZhciB5ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDEgXSA6IDA7XG5cdFx0XHRcdHZhciB6ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDIgXSA6IDA7XG5cdFx0XHRcdHZhciB3ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDMgXSA6IDA7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2tpbldlaWdodHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIHgsIHksIHosIHcgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24uc2tpbkluZGljZXMgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbkluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xuXG5cdFx0XHRcdHZhciBhID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luSW5kaWNlc1sgaSAgICAgXTtcblx0XHRcdFx0dmFyIGIgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMSBdIDogMDtcblx0XHRcdFx0dmFyIGMgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMiBdIDogMDtcblx0XHRcdFx0dmFyIGQgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMyBdIDogMDtcblxuXHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggYSwgYiwgYywgZCApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcblxuXHRcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcblx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcblxuXHRcdH1cblxuXG5cdFx0Ly8gY291bGQgY2hhbmdlIHRoaXMgdG8ganNvbi5hbmltYXRpb25zWzBdIG9yIHJlbW92ZSBjb21wbGV0ZWx5XG5cblx0XHRnZW9tZXRyeS5hbmltYXRpb24gPSBqc29uLmFuaW1hdGlvbjtcblx0XHRnZW9tZXRyeS5hbmltYXRpb25zID0ganNvbi5hbmltYXRpb25zO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gcGFyc2VNb3JwaGluZyggc2NhbGUgKSB7XG5cblx0XHRpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBpLCBsLCB2LCB2bCwgZHN0VmVydGljZXMsIHNyY1ZlcnRpY2VzO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGpzb24ubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcblxuXHRcdFx0XHRkc3RWZXJ0aWNlcyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXHRcdFx0XHRzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzIFsgaSBdLnZlcnRpY2VzO1xuXG5cdFx0XHRcdGZvciAoIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHNyY1ZlcnRpY2VzWyB2IF0gKiBzY2FsZTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IHNyY1ZlcnRpY2VzWyB2ICsgMSBdICogc2NhbGU7XG5cdFx0XHRcdFx0dmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xuXG5cdFx0XHRcdFx0ZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIGksIGwsIGMsIGNsLCBkc3RDb2xvcnMsIHNyY0NvbG9ycywgY29sb3I7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0ganNvbi5tb3JwaENvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0gPSB7fTtcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5uYW1lID0ganNvbi5tb3JwaENvbG9yc1sgaSBdLm5hbWU7XG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzID0gW107XG5cblx0XHRcdFx0ZHN0Q29sb3JzID0gZ2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5jb2xvcnM7XG5cdFx0XHRcdHNyY0NvbG9ycyA9IGpzb24ubW9ycGhDb2xvcnMgWyBpIF0uY29sb3JzO1xuXG5cdFx0XHRcdGZvciAoIGMgPSAwLCBjbCA9IHNyY0NvbG9ycy5sZW5ndGg7IGMgPCBjbDsgYyArPSAzICkge1xuXG5cdFx0XHRcdFx0Y29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZhYTAwICk7XG5cdFx0XHRcdFx0Y29sb3Iuc2V0UkdCKCBzcmNDb2xvcnNbIGMgXSwgc3JjQ29sb3JzWyBjICsgMSBdLCBzcmNDb2xvcnNbIGMgKyAyIF0gKTtcblx0XHRcdFx0XHRkc3RDb2xvcnMucHVzaCggY29sb3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdGlmICgganNvbi5tYXRlcmlhbHMgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnkgfTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dmFyIG1hdGVyaWFscyA9IHRoaXMuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoICk7XG5cblx0XHRpZiAoIHRoaXMubmVlZHNUYW5nZW50cyggbWF0ZXJpYWxzICkgKSB7XG5cblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgZ2VvbWV0cnk6IGdlb21ldHJ5LCBtYXRlcmlhbHM6IG1hdGVyaWFscyB9O1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkaW5nTWFuYWdlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTG9hZGluZ01hbmFnZXIgPSBmdW5jdGlvbiAoIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciBsb2FkZWQgPSAwLCB0b3RhbCA9IDA7XG5cblx0dGhpcy5vbkxvYWQgPSBvbkxvYWQ7XG5cdHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG5cdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG5cblx0dGhpcy5pdGVtU3RhcnQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdHRvdGFsICsrO1xuXG5cdH07XG5cblx0dGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRsb2FkZWQgKys7XG5cblx0XHRpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c2NvcGUub25Qcm9ncmVzcyggdXJsLCBsb2FkZWQsIHRvdGFsICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGxvYWRlZCA9PT0gdG90YWwgJiYgc2NvcGUub25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHNjb3BlLm9uTG9hZCgpO1xuXG5cdFx0fVxuXG5cdH07XG5cbn07XG5cblRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlcigpO1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0J1ZmZlckdlb21ldHJ5TG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCk7XG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IGpzb24uYXR0cmlidXRlcztcblxuXHRcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXHRcdFx0dmFyIHR5cGVkQXJyYXkgPSBuZXcgc2VsZlsgYXR0cmlidXRlLnR5cGUgXSggYXR0cmlidXRlLmFycmF5ICk7XG5cblx0XHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgga2V5LCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUgKSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldHMgPSBqc29uLm9mZnNldHM7XG5cblx0XHRpZiAoIG9mZnNldHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z2VvbWV0cnkub2Zmc2V0cyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBvZmZzZXRzICkgKTtcblxuXHRcdH1cblxuXHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uYm91bmRpbmdTcGhlcmU7XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvTWF0ZXJpYWxMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1hdGVyaWFsTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5NYXRlcmlhbExvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoKTtcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUVbIGpzb24udHlwZSBdO1xuXG5cdFx0aWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcblx0XHRpZiAoIGpzb24uYW1iaWVudCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW1iaWVudC5zZXRIZXgoIGpzb24uYW1iaWVudCApO1xuXHRcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XG5cdFx0aWYgKCBqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcblx0XHRpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcblx0XHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3Jtcztcblx0XHRpZiAoIGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcblx0XHRpZiAoIGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcdFx0XG5cdFx0aWYgKCBqc29uLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0ganNvbi52ZXJ0ZXhDb2xvcnM7XG5cdFx0aWYgKCBqc29uLnNoYWRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoYWRpbmcgPSBqc29uLnNoYWRpbmc7XG5cdFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XG5cdFx0aWYgKCBqc29uLnNpZGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpZGUgPSBqc29uLnNpZGU7XG5cdFx0aWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XG5cdFx0aWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XG5cblx0XHRpZiAoIGpzb24ubWF0ZXJpYWxzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMucGFyc2UoIGpzb24ubWF0ZXJpYWxzWyBpIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL09iamVjdExvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuT2JqZWN0TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5PYmplY3RMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3RMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdHZhciBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcyApO1xuXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscyApO1xuXHRcdHZhciBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KCBqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICk7XG5cblx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdH0sXG5cblx0cGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5KU09OTG9hZGVyKCk7XG5cdFx0XHR2YXIgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeTtcblx0XHRcdFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggZGF0YS50eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnUGxhbmVHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHNcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQm94R2VvbWV0cnknOlxuXHRcdFx0XHRcdGNhc2UgJ0N1YmVHZW9tZXRyeSc6IC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlXG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXB0aCxcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmRlcHRoU2VnbWVudHNcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQ2lyY2xlR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuc2VnbWVudHNcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQ3lsaW5kZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzVG9wLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1c0JvdHRvbSxcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1NwaGVyZUdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpU3RhcnQsXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhU3RhcnQsXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnSWNvc2FoZWRyb25HZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmRldGFpbFxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdUb3J1c0dlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEudHViZSxcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuYXJjXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnR1YmUsXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEudHVidWxhclNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnAsXG5cdFx0XHRcdFx0XHRcdGRhdGEucSxcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTY2FsZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gYnVmZmVyR2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0dlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YS5kYXRhICkuZ2VvbWV0cnk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xuXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xuXG5cdFx0XHRcdGdlb21ldHJpZXNbIGRhdGEudXVpZCBdID0gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyaWVzO1xuXG5cdH0sXG5cblx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdHZhciBtYXRlcmlhbHMgPSB7fTtcblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLk1hdGVyaWFsTG9hZGVyKCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbG9hZGVyLnBhcnNlKCBkYXRhICk7XG5cblx0XHRcdFx0bWF0ZXJpYWwudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGRhdGEubmFtZTtcblxuXHRcdFx0XHRtYXRlcmlhbHNbIGRhdGEudXVpZCBdID0gbWF0ZXJpYWw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cblx0fSxcblxuXHRwYXJzZU9iamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XG5cblx0XHRcdHZhciBvYmplY3Q7XG5cblx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdTY2VuZSc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdPcnRob2dyYXBoaWNDYW1lcmEnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggZGF0YS5sZWZ0LCBkYXRhLnJpZ2h0LCBkYXRhLnRvcCwgZGF0YS5ib3R0b20sIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0FtYmllbnRMaWdodCc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCBkYXRhLmNvbG9yICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU3BvdExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5hbmdsZSwgZGF0YS5leHBvbmVudCApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuZ3JvdW5kQ29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdNZXNoJzpcblxuXHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGRhdGEuZ2VvbWV0cnkgXTtcblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGRhdGEubWF0ZXJpYWwgXTtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBkYXRhLmdlb21ldHJ5ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgZGF0YS5tYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTGluZSc6XG5cblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBkYXRhLmdlb21ldHJ5IF07XG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbWF0ZXJpYWxzWyBkYXRhLm1hdGVyaWFsIF07XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5JywgZGF0YS5nZW9tZXRyeSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIGRhdGEubWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1Nwcml0ZSc6XG5cblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGRhdGEubWF0ZXJpYWwgXTtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBkYXRhLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU3ByaXRlKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnR3JvdXAnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XG5cblx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcblx0XHRcdGlmICggZGF0YS5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtYXRyaXguZnJvbUFycmF5KCBkYXRhLm1hdHJpeCApO1xuXHRcdFx0XHRtYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcblx0XHRcdFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XG5cdFx0XHRcdGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlzaWJsZSA9IGRhdGEudmlzaWJsZTtcblx0XHRcdGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblxuXHRcdFx0aWYgKCBkYXRhLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGNoaWxkIGluIGRhdGEuY2hpbGRyZW4gKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuYWRkKCB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLmNoaWxkcmVuWyBjaGlsZCBdLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0fVxuXG5cdH0oKVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL1RleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLlRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cblx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlICk7XG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NvbXByZXNzZWRUZXh0dXJlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcbiAqL1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICgpIHtcblxuXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xuXHR0aGlzLl9wYXJzZXIgPSBudWxsO1xuXG59O1xuXG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgaW1hZ2VzID0gW107XG5cblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xuXHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuXHRcdGlmICggdXJsIGluc3RhbmNlb2YgQXJyYXkgKSB7XG5cblx0XHRcdHZhciBsb2FkZWQgPSAwO1xuXG5cdFx0XHR2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIGkgKSB7XG5cblx0XHRcdFx0bG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0aW1hZ2VzWyBpIF0gPSB7XG5cdFx0XHRcdFx0XHR3aWR0aDogdGV4RGF0YXMud2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcblx0XHRcdFx0XHRcdGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxuXHRcdFx0XHRcdFx0bWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRsb2FkZWQgKz0gMTtcblxuXHRcdFx0XHRcdGlmICggbG9hZGVkID09PSA2ICkge1xuXG4gXHRcdFx0XHRcdFx0aWYgKHRleERhdGFzLm1pcG1hcENvdW50ID09IDEpXG4gXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XG5cblx0XHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG5cdFx0XHRcdGlmICggdGV4RGF0YXMuaXNDdWJlbWFwICkge1xuXG5cdFx0XHRcdFx0dmFyIGZhY2VzID0gdGV4RGF0YXMubWlwbWFwcy5sZW5ndGggLyB0ZXhEYXRhcy5taXBtYXBDb3VudDtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRpbWFnZXNbIGYgXSA9IHsgbWlwbWFwcyA6IFtdIH07XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRleERhdGFzLm1pcG1hcENvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggdGV4RGF0YXMubWlwbWFwc1sgZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblx0XHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuTWF0ZXJpYWxJZENvdW50ICsrIH0gKTtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG5cdHRoaXMuc2lkZSA9IFRIUkVFLkZyb250U2lkZTtcblxuXHR0aGlzLm9wYWNpdHkgPSAxO1xuXHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cblx0dGhpcy5ibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xuXG5cdHRoaXMuYmxlbmRTcmMgPSBUSFJFRS5TcmNBbHBoYUZhY3Rvcjtcblx0dGhpcy5ibGVuZERzdCA9IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XG5cdHRoaXMuYmxlbmRFcXVhdGlvbiA9IFRIUkVFLkFkZEVxdWF0aW9uO1xuXG5cdHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcblx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcblxuXHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcblx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcblx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAwO1xuXG5cdHRoaXMuYWxwaGFUZXN0ID0gMDtcblxuXHR0aGlzLm92ZXJkcmF3ID0gMDsgLy8gT3ZlcmRyYXduIHBpeGVscyAodHlwaWNhbGx5IGJldHdlZW4gMCBhbmQgMSkgZm9yIGZpeGluZyBhbnRpYWxpYXNpbmcgZ2FwcyBpbiBDYW52YXNSZW5kZXJlclxuXG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn07XG5cblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWwsXG5cblx0c2V0VmFsdWVzOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcblxuXHRcdGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcblxuXHRcdFx0dmFyIG5ld1ZhbHVlID0gdmFsdWVzWyBrZXkgXTtcblxuXHRcdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBrZXkgaW4gdGhpcyApIHtcblxuXHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gdGhpc1sga2V5IF07XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBrZXkgPT0gJ292ZXJkcmF3JyApIHtcblxuXHRcdFx0XHRcdC8vIGVuc3VyZSBvdmVyZHJhdyBpcyBiYWNrd2FyZHMtY29tcGF0YWJsZSB3aXRoIGxlZ2FjeSBib29sZWFuIHR5cGVcblx0XHRcdFx0XHR0aGlzWyBrZXkgXSA9IE51bWJlciggbmV3VmFsdWUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpc1sga2V5IF0gPSBuZXdWYWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG91dHB1dCA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuMixcblx0XHRcdFx0dHlwZTogJ21hdGVyaWFsJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWxFeHBvcnRlcidcblx0XHRcdH0sXG5cdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG5cdFx0XHR0eXBlOiB0aGlzLnR5cGVcblx0XHR9O1xuXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09IFwiXCIgKSBvdXRwdXQubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdGlmICggdGhpcyBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRvdXRwdXQuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXHRcdFx0aWYgKCB0aGlzLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSBvdXRwdXQudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cdFx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IFRIUkVFLk5vcm1hbEJsZW5kaW5nICkgb3V0cHV0LmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcblx0XHRcdGlmICggdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBvdXRwdXQuc2lkZSA9IHRoaXMuc2lkZTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsICkge1xuXG5cdFx0XHRvdXRwdXQuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXHRcdFx0b3V0cHV0LmFtYmllbnQgPSB0aGlzLmFtYmllbnQuZ2V0SGV4KCk7XG5cdFx0XHRvdXRwdXQuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xuXHRcdFx0aWYgKCB0aGlzLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSBvdXRwdXQudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cdFx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IFRIUkVFLk5vcm1hbEJsZW5kaW5nICkgb3V0cHV0LmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcblx0XHRcdGlmICggdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBvdXRwdXQuc2lkZSA9IHRoaXMuc2lkZTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuXHRcdFx0b3V0cHV0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblx0XHRcdG91dHB1dC5hbWJpZW50ID0gdGhpcy5hbWJpZW50LmdldEhleCgpO1xuXHRcdFx0b3V0cHV0LmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcblx0XHRcdG91dHB1dC5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCk7XG5cdFx0XHRvdXRwdXQuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XG5cdFx0XHRpZiAoIHRoaXMudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIG91dHB1dC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblx0XHRcdGlmICggdGhpcy5ibGVuZGluZyAhPT0gVEhSRUUuTm9ybWFsQmxlbmRpbmcgKSBvdXRwdXQuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuXHRcdFx0aWYgKCB0aGlzLnNpZGUgIT09IFRIUkVFLkZyb250U2lkZSApIG91dHB1dC5zaWRlID0gdGhpcy5zaWRlO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcyBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnNoYWRpbmcgIT09IFRIUkVFLkZsYXRTaGFkaW5nICkgb3V0cHV0LnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG5cdFx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IFRIUkVFLk5vcm1hbEJsZW5kaW5nICkgb3V0cHV0LmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcblx0XHRcdGlmICggdGhpcy5zaWRlICE9PSBUSFJFRS5Gcm9udFNpZGUgKSBvdXRwdXQuc2lkZSA9IHRoaXMuc2lkZTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmJsZW5kaW5nICE9PSBUSFJFRS5Ob3JtYWxCbGVuZGluZyApIG91dHB1dC5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XG5cdFx0XHRpZiAoIHRoaXMuc2lkZSAhPT0gVEhSRUUuRnJvbnRTaWRlICkgb3V0cHV0LnNpZGUgPSB0aGlzLnNpZGU7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdG91dHB1dC51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7XG5cdFx0XHRvdXRwdXQudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XG5cdFx0XHRvdXRwdXQuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcyBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZU1hdGVyaWFsICkge1xuXG5cdFx0XHRvdXRwdXQuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgb3V0cHV0Lm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cdFx0aWYgKCB0aGlzLnRyYW5zcGFyZW50ICE9PSBmYWxzZSApIG91dHB1dC50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZSAhPT0gZmFsc2UgKSBvdXRwdXQud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XG5cblx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NYXRlcmlhbCgpO1xuXG5cdFx0bWF0ZXJpYWwubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdG1hdGVyaWFsLnNpZGUgPSB0aGlzLnNpZGU7XG5cblx0XHRtYXRlcmlhbC5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXHRcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdGhpcy50cmFuc3BhcmVudDtcblxuXHRcdG1hdGVyaWFsLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcblxuXHRcdG1hdGVyaWFsLmJsZW5kU3JjID0gdGhpcy5ibGVuZFNyYztcblx0XHRtYXRlcmlhbC5ibGVuZERzdCA9IHRoaXMuYmxlbmREc3Q7XG5cdFx0bWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiA9IHRoaXMuYmxlbmRFcXVhdGlvbjtcblxuXHRcdG1hdGVyaWFsLmRlcHRoVGVzdCA9IHRoaXMuZGVwdGhUZXN0O1xuXHRcdG1hdGVyaWFsLmRlcHRoV3JpdGUgPSB0aGlzLmRlcHRoV3JpdGU7XG5cblx0XHRtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gdGhpcy5wb2x5Z29uT2Zmc2V0O1xuXHRcdG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I7XG5cdFx0bWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0gdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHM7XG5cblx0XHRtYXRlcmlhbC5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcblxuXHRcdG1hdGVyaWFsLm92ZXJkcmF3ID0gdGhpcy5vdmVyZHJhdztcblxuXHRcdG1hdGVyaWFsLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NYXRlcmlhbElkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gKiAgbGluZWNhcDogXCJyb3VuZFwiLFxuICogIGxpbmVqb2luOiBcInJvdW5kXCIsXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+XG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG5cdHRoaXMubGluZWpvaW4gPSAncm91bmQnO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cblx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XG5cblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXG5cdG1hdGVyaWFsLmxpbmV3aWR0aCA9IHRoaXMubGluZXdpZHRoO1xuXHRtYXRlcmlhbC5saW5lY2FwID0gdGhpcy5saW5lY2FwO1xuXHRtYXRlcmlhbC5saW5lam9pbiA9IHRoaXMubGluZWpvaW47XG5cblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTGluZURhc2hlZE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHNjYWxlOiA8ZmxvYXQ+LFxuICogIGRhc2hTaXplOiA8ZmxvYXQ+LFxuICogIGdhcFNpemU6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+XG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG5cdHRoaXMubGluZXdpZHRoID0gMTtcblxuXHR0aGlzLnNjYWxlID0gMTtcblx0dGhpcy5kYXNoU2l6ZSA9IDM7XG5cdHRoaXMuZ2FwU2l6ZSA9IDE7XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcblxuXHR0aGlzLmZvZyA9IHRydWU7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwoKTtcblxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XG5cblx0bWF0ZXJpYWwubGluZXdpZHRoID0gdGhpcy5saW5ld2lkdGg7XG5cblx0bWF0ZXJpYWwuc2NhbGUgPSB0aGlzLnNjYWxlO1xuXHRtYXRlcmlhbC5kYXNoU2l6ZSA9IHRoaXMuZGFzaFNpemU7XG5cdG1hdGVyaWFsLmdhcFNpemUgPSB0aGlzLmdhcFNpemU7XG5cblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBlbWlzc2l2ZVxuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHR0aGlzLmZvZyA9IHRydWU7XG5cblx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCk7XG5cblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXG5cdG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xuXG5cdG1hdGVyaWFsLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcDtcblxuXHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXA7XG5cblx0bWF0ZXJpYWwuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwO1xuXG5cdG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZW52TWFwO1xuXHRtYXRlcmlhbC5jb21iaW5lID0gdGhpcy5jb21iaW5lO1xuXHRtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcblx0bWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0gdGhpcy5yZWZyYWN0aW9uUmF0aW87XG5cblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cblx0bWF0ZXJpYWwuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcblxuXHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbjtcblxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuXHRtYXRlcmlhbC5za2lubmluZyA9IHRoaXMuc2tpbm5pbmc7XG5cdG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xuXG5cdHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hMYW1iZXJ0TWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBhbWJpZW50OiA8aGV4PixcbiAqICBlbWlzc2l2ZTogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuICpcbiAqICBza2lubmluZzogPGJvb2w+LFxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxuICpcbiAqXHRmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG5cdHRoaXMuYW1iaWVudCA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcblxuXHR0aGlzLndyYXBBcm91bmQgPSBmYWxzZTtcblx0dGhpcy53cmFwUkdCID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKTtcblxuXHR0aGlzLm1hcCA9IG51bGw7XG5cblx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cblx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHR0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCgpO1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblx0bWF0ZXJpYWwuYW1iaWVudC5jb3B5KCB0aGlzLmFtYmllbnQgKTtcblx0bWF0ZXJpYWwuZW1pc3NpdmUuY29weSggdGhpcy5lbWlzc2l2ZSApO1xuXG5cdG1hdGVyaWFsLndyYXBBcm91bmQgPSB0aGlzLndyYXBBcm91bmQ7XG5cdG1hdGVyaWFsLndyYXBSR0IuY29weSggdGhpcy53cmFwUkdCICk7XG5cblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cblx0bWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwO1xuXG5cdG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcDtcblxuXHRtYXRlcmlhbC5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXA7XG5cblx0bWF0ZXJpYWwuZW52TWFwID0gdGhpcy5lbnZNYXA7XG5cdG1hdGVyaWFsLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XG5cdG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5O1xuXHRtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSB0aGlzLnJlZnJhY3Rpb25SYXRpbztcblxuXHRtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuXHRtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IHRoaXMud2lyZWZyYW1lTGluZWNhcDtcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXG5cdG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcblx0bWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XG5cdG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzO1xuXG5cdHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hQaG9uZ01hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgYW1iaWVudDogPGhleD4sXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxuICogIHNwZWN1bGFyOiA8aGV4PixcbiAqICBzaGluaW5lc3M6IDxmbG9hdD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBidW1wU2NhbGU6IDxmbG9hdD4sXG4gKlxuICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICpcdGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXHR0aGlzLmFtYmllbnQgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XG5cdHRoaXMuc3BlY3VsYXIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICk7XG5cdHRoaXMuc2hpbmluZXNzID0gMzA7XG5cblx0dGhpcy5tZXRhbCA9IGZhbHNlO1xuXG5cdHRoaXMud3JhcEFyb3VuZCA9IGZhbHNlO1xuXHR0aGlzLndyYXBSR0IgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApO1xuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblxuXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHR0aGlzLmZvZyA9IHRydWU7XG5cblx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKCk7XG5cblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXHRtYXRlcmlhbC5hbWJpZW50LmNvcHkoIHRoaXMuYW1iaWVudCApO1xuXHRtYXRlcmlhbC5lbWlzc2l2ZS5jb3B5KCB0aGlzLmVtaXNzaXZlICk7XG5cdG1hdGVyaWFsLnNwZWN1bGFyLmNvcHkoIHRoaXMuc3BlY3VsYXIgKTtcblx0bWF0ZXJpYWwuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XG5cblx0bWF0ZXJpYWwubWV0YWwgPSB0aGlzLm1ldGFsO1xuXG5cdG1hdGVyaWFsLndyYXBBcm91bmQgPSB0aGlzLndyYXBBcm91bmQ7XG5cdG1hdGVyaWFsLndyYXBSR0IuY29weSggdGhpcy53cmFwUkdCICk7XG5cblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cblx0bWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwO1xuXG5cdG1hdGVyaWFsLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXA7XG5cdG1hdGVyaWFsLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xuXG5cdG1hdGVyaWFsLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwO1xuXHRtYXRlcmlhbC5ub3JtYWxTY2FsZS5jb3B5KCB0aGlzLm5vcm1hbFNjYWxlICk7XG5cblx0bWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwO1xuXG5cdG1hdGVyaWFsLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcDtcblxuXHRtYXRlcmlhbC5lbnZNYXAgPSB0aGlzLmVudk1hcDtcblx0bWF0ZXJpYWwuY29tYmluZSA9IHRoaXMuY29tYmluZTtcblx0bWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7XG5cdG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyA9IHRoaXMucmVmcmFjdGlvblJhdGlvO1xuXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xuXG5cdG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG5cblx0bWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XG5cblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cblx0bWF0ZXJpYWwuc2tpbm5pbmcgPSB0aGlzLnNraW5uaW5nO1xuXHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cztcblx0bWF0ZXJpYWwubW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHM7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaERlcHRoTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxuICogfVxuICovXG5cblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xuXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCgpO1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRyZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoTm9ybWFsTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTWVzaE5vcm1hbE1hdGVyaWFsJztcblxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5GbGF0U2hhZGluZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCgpO1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG5cdG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG5cblx0bWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuXG5cdHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hGYWNlTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFscyApIHtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMudHlwZSA9ICdNZXNoRmFjZU1hdGVyaWFsJztcblx0XG5cdHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgPyBtYXRlcmlhbHMgOiBbXTtcblxufTtcblxuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwsXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb3V0cHV0ID0ge1xuXHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0dmVyc2lvbjogNC4yLFxuXHRcdFx0XHR0eXBlOiAnbWF0ZXJpYWwnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdNYXRlcmlhbEV4cG9ydGVyJ1xuXHRcdFx0fSxcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcblx0XHRcdHR5cGU6IHRoaXMudHlwZSxcblx0XHRcdG1hdGVyaWFsczogW11cblx0XHR9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0b3V0cHV0Lm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLnRvSlNPTigpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm1hdGVyaWFscy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9Qb2ludENsb3VkTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgc2l6ZTogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUG9pbnRDbG91ZE1hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLnNpemUgPSAxO1xuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuXHR0aGlzLmZvZyA9IHRydWU7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoKTtcblxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XG5cblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cblx0bWF0ZXJpYWwuc2l6ZSA9IHRoaXMuc2l6ZTtcblx0bWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG5cblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cblx0cmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5USFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1NoYWRlck1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXG4gKiAgdW5pZm9ybXM6IHsgXCJwYXJhbWV0ZXIxXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSwgXCJwYXJhbWV0ZXIyXCI6IHsgdHlwZTogXCJpXCIgdmFsdWUyOiAyIH0gfSxcbiAqXG4gKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxuICogIHZlcnRleFNoYWRlcjogPHN0cmluZz4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICBsaWdodHM6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICpcdGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XG5cblx0dGhpcy5kZWZpbmVzID0ge307XG5cdHRoaXMudW5pZm9ybXMgPSB7fTtcblx0dGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcblxuXHR0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xuXHR0aGlzLmZyYWdtZW50U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59JztcblxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG5cdHRoaXMubGluZXdpZHRoID0gMTtcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcblxuXHR0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7IC8vIHNldCB0byB1c2UgXCJjb2xvclwiIGF0dHJpYnV0ZSBzdHJlYW1cblxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcblxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCBub3JtYWxzXG5cblx0Ly8gV2hlbiByZW5kZXJlZCBnZW9tZXRyeSBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgYXR0cmlidXRlcyBidXQgdGhlIG1hdGVyaWFsIGRvZXMsXG5cdC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cblx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuXHRcdCdjb2xvcic6IFsgMSwgMSwgMSBdLFxuXHRcdCd1dic6IFsgMCwgMCBdLFxuXHRcdCd1djInOiBbIDAsIDAgXVxuXHR9O1xuXG5cdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgpO1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG5cdG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcblx0bWF0ZXJpYWwudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XG5cblx0bWF0ZXJpYWwudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCB0aGlzLnVuaWZvcm1zICk7XG5cblx0bWF0ZXJpYWwuYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblx0bWF0ZXJpYWwuZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcblxuXHRtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuXHRtYXRlcmlhbC5saWdodHMgPSB0aGlzLmxpZ2h0cztcblxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuXHRtYXRlcmlhbC5za2lubmluZyA9IHRoaXMuc2tpbm5pbmc7XG5cblx0bWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XG5cdG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzO1xuXG5cdHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1Jhd1NoYWRlck1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRUSFJFRS5TaGFkZXJNYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cblx0dGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcblxufTtcblxuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwoKTtcblxuXHRUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuXHRyZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9TcHJpdGVNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICpcdHV2T2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICpcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdHRoaXMucm90YXRpb24gPSAwO1xuXG5cdHRoaXMuZm9nID0gZmFsc2U7XG5cblx0Ly8gc2V0IHBhcmFtZXRlcnNcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCgpO1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cblx0bWF0ZXJpYWwucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xuXG5cdHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICovXG5cblRIUkVFLlRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5UZXh0dXJlSWRDb3VudCArKyB9ICk7XG5cblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLm5hbWUgPSAnJztcblxuXHR0aGlzLmltYWdlID0gaW1hZ2UgIT09IHVuZGVmaW5lZCA/IGltYWdlIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX0lNQUdFO1xuXHR0aGlzLm1pcG1hcHMgPSBbXTtcblxuXHR0aGlzLm1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkc7XG5cblx0dGhpcy53cmFwUyA9IHdyYXBTICE9PSB1bmRlZmluZWQgPyB3cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdHRoaXMud3JhcFQgPSB3cmFwVCAhPT0gdW5kZWZpbmVkID8gd3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG5cdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cblx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XG5cblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFRIUkVFLlJHQkFGb3JtYXQ7XG5cdHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG5cdHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcblx0dGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG5cdHRoaXMuZmxpcFkgPSB0cnVlO1xuXHR0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7IC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXG5cdHRoaXMuX25lZWRzVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMub25VcGRhdGUgPSBudWxsO1xuXG59O1xuXG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XG5USFJFRS5UZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IG5ldyBUSFJFRS5VVk1hcHBpbmcoKTtcblxuVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXG5cblx0Z2V0IG5lZWRzVXBkYXRlICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZTtcblxuXHR9LFxuXG5cdHNldCBuZWVkc1VwZGF0ZSAoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XG5cblx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuXHRcdGlmICggdGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XG5cblx0XHR0ZXh0dXJlLmltYWdlID0gdGhpcy5pbWFnZTtcblx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0aGlzLm1pcG1hcHMuc2xpY2UoIDAgKTtcblxuXHRcdHRleHR1cmUubWFwcGluZyA9IHRoaXMubWFwcGluZztcblxuXHRcdHRleHR1cmUud3JhcFMgPSB0aGlzLndyYXBTO1xuXHRcdHRleHR1cmUud3JhcFQgPSB0aGlzLndyYXBUO1xuXG5cdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSB0aGlzLm1hZ0ZpbHRlcjtcblx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IHRoaXMubWluRmlsdGVyO1xuXG5cdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gdGhpcy5hbmlzb3Ryb3B5O1xuXG5cdFx0dGV4dHVyZS5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcblx0XHR0ZXh0dXJlLnR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHR0ZXh0dXJlLm9mZnNldC5jb3B5KCB0aGlzLm9mZnNldCApO1xuXHRcdHRleHR1cmUucmVwZWF0LmNvcHkoIHRoaXMucmVwZWF0ICk7XG5cblx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xuXHRcdHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IHRoaXMucHJlbXVsdGlwbHlBbHBoYTtcblx0XHR0ZXh0dXJlLmZsaXBZID0gdGhpcy5mbGlwWTtcblx0XHR0ZXh0dXJlLnVucGFja0FsaWdubWVudCA9IHRoaXMudW5wYWNrQWxpZ25tZW50O1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJyB9ICk7XG5cblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5cblRIUkVFLlRleHR1cmVJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ3ViZVRleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkN1YmVUZXh0dXJlID0gZnVuY3Rpb24gKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuXHRUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0dGhpcy5pbWFnZXMgPSBpbWFnZXM7XG5cbn07XG5cblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5cblRIUkVFLkN1YmVUZXh0dXJlLmNsb25lID0gZnVuY3Rpb24gKCB0ZXh0dXJlICkge1xuXG5cdGlmICggdGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgdGV4dHVyZSA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZSgpO1xuXG5cdFRIUkVFLlRleHR1cmUucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIHRleHR1cmUgKTtcblxuXHR0ZXh0dXJlLmltYWdlcyA9IHRoaXMuaW1hZ2VzO1xuXG5cdHJldHVybiB0ZXh0dXJlO1xuXG59O1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9Db21wcmVzc2VkVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgPSBmdW5jdGlvbiAoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcblxuXHRUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblx0dGhpcy5taXBtYXBzID0gbWlwbWFwcztcblxuXHQvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xuXHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxuXG5cdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuXHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXG5cdC8vIG1pcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiBERFMgZmlsZXNcblxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUoKTtcblxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XG5cblx0cmV0dXJuIHRleHR1cmU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL0RhdGFUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5EYXRhVGV4dHVyZSA9IGZ1bmN0aW9uICggZGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0dGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuXG59O1xuXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoKTtcblxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XG5cblx0cmV0dXJuIHRleHR1cmU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL1ZpZGVvVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuVmlkZW9UZXh0dXJlID0gZnVuY3Rpb24gKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHR2YXIgdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB1cGRhdGUgKTtcblxuXHRcdGlmICggdmlkZW8ucmVhZHlTdGF0ZSA9PT0gdmlkZW8uSEFWRV9FTk9VR0hfREFUQSApIHtcblxuXHRcdFx0c2NvcGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0dyb3VwLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Hcm91cCA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0dyb3VwJztcblxufTtcblxuVEhSRUUuR3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvUG9pbnRDbG91ZC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRDbG91ZCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUG9pbnRDbG91ZCc7XG5cblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxuXHR0aGlzLnNvcnRQYXJ0aWNsZXMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0dmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHR2YXIgb2JqZWN0ID0gdGhpcztcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cdFx0dmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRDbG91ZC50aHJlc2hvbGQ7XG5cblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcblx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCByYXkuaXNJbnRlcnNlY3Rpb25Cb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCAoIHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueiApIC8gMyApO1xuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHR2YXIgdGVzdFBvaW50ID0gZnVuY3Rpb24gKCBwb2ludCwgaW5kZXggKSB7XG5cblx0XHRcdHZhciByYXlQb2ludERpc3RhbmNlID0gcmF5LmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKTtcblxuXHRcdFx0aWYgKCByYXlQb2ludERpc3RhbmNlIDwgbG9jYWxUaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0dmFyIGludGVyc2VjdFBvaW50ID0gcmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50ICk7XG5cdFx0XHRcdGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcblxuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdFx0XHRkaXN0YW5jZVRvUmF5OiByYXlQb2ludERpc3RhbmNlLFxuXHRcdFx0XHRcdHBvaW50OiBpbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxuXHRcdFx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdFx0XHRmYWNlOiBudWxsLFxuXHRcdFx0XHRcdG9iamVjdDogb2JqZWN0XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBhdHRyaWJ1dGVzLmluZGV4LmFycmF5O1xuXHRcdFx0XHR2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cblx0XHRcdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdHZhciBvZmZzZXQgPSB7XG5cdFx0XHRcdFx0XHRzdGFydDogMCxcblx0XHRcdFx0XHRcdGNvdW50OiBpbmRpY2VzLmxlbmd0aCxcblx0XHRcdFx0XHRcdGluZGV4OiAwXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdG9mZnNldHMgPSBbIG9mZnNldCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgb2kgPSAwLCBvbCA9IG9mZnNldHMubGVuZ3RoOyBvaSA8IG9sOyArK29pICkge1xuXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gb2Zmc2V0c1sgb2kgXS5zdGFydDtcblx0XHRcdFx0XHR2YXIgY291bnQgPSBvZmZzZXRzWyBvaSBdLmNvdW50O1xuXHRcdFx0XHRcdHZhciBpbmRleCA9IG9mZnNldHNbIG9pIF0uaW5kZXg7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcblxuXHRcdFx0XHRcdFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG5cblx0XHRcdFx0XHRcdHRlc3RQb2ludCggcG9zaXRpb24sIGEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIHBvaW50Q291bnQgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb2ludENvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0KFxuXHRcdFx0XHRcdFx0cG9zaXRpb25zWyAzICogaSBdLFxuXHRcdFx0XHRcdFx0cG9zaXRpb25zWyAzICogaSArIDEgXSxcblx0XHRcdFx0XHRcdHBvc2l0aW9uc1sgMyAqIGkgKyAyIF1cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgaSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRlc3RQb2ludCggdmVydGljZXNbIGkgXSwgaSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxufSgpICk7XG5cblRIUkVFLlBvaW50Q2xvdWQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludENsb3VkKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XG5cblx0b2JqZWN0LnNvcnRQYXJ0aWNsZXMgPSB0aGlzLnNvcnRQYXJ0aWNsZXM7XG5cblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xuXG5cdHJldHVybiBvYmplY3Q7XG5cbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLlBhcnRpY2xlU3lzdGVtID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludENsb3VkLicgKTtcblx0cmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MaW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MaW5lID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG1vZGUgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMaW5lJztcblxuXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XG5cblx0dGhpcy5tb2RlID0gKCBtb2RlICE9PSB1bmRlZmluZWQgKSA/IG1vZGUgOiBUSFJFRS5MaW5lU3RyaXA7XG5cbn07XG5cblRIUkVFLkxpbmVTdHJpcCA9IDA7XG5USFJFRS5MaW5lUGllY2VzID0gMTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0dmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcblx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHR2YXIgcHJlY2lzaW9uID0gcmF5Y2FzdGVyLmxpbmVQcmVjaXNpb247XG5cdFx0dmFyIHByZWNpc2lvblNxID0gcHJlY2lzaW9uICogcHJlY2lzaW9uO1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0aWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cblx0XHQvKiBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHR9IGVsc2UgKi8gaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHRcdHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuXHRcdFx0dmFyIGludGVyU2VnbWVudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2YXIgaW50ZXJSYXkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmFyIHN0ZXAgPSB0aGlzLm1vZGUgPT09IFRIUkVFLkxpbmVTdHJpcCA/IDEgOiAyO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuYlZlcnRpY2VzIC0gMTsgaSA9IGkgKyBzdGVwICkge1xuXG5cdFx0XHRcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cblx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcblx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG5cdFx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxufSgpICk7XG5cblRIUkVFLkxpbmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5MaW5lKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLCB0aGlzLm1vZGUgKTtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cblx0cmV0dXJuIG9iamVjdDtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9NZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tL1xuICovXG5cblRIUkVFLk1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ01lc2gnO1xuXHRcblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG5cdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cbn07XG5cblRIUkVFLk1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1vcnBoVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcblxuXHRcdHRoaXMubW9ycGhUYXJnZXRCYXNlID0gLSAxO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRGb3JjZWRPcmRlciA9IFtdO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuXHRcdGZvciAoIHZhciBtID0gMCwgbWwgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcblxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xuXHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0aWYgKCB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcblxuXHR9XG5cblx0Y29uc29sZS5sb2coICdUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLicgKTtcblxuXHRyZXR1cm4gMDtcblxufTtcblxuXG5USFJFRS5NZXNoLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHR2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuXHR2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG5cdHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0aWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXG5cblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcblx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCByYXkuaXNJbnRlcnNlY3Rpb25Cb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgIHtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHRcdHZhciBhLCBiLCBjO1xuXHRcdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5wcmVjaXNpb247XG5cblx0XHRcdGlmICggYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleC5hcnJheTtcblx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cdFx0XHRcdHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcblxuXHRcdFx0XHRpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0b2Zmc2V0cyA9IFsgeyBzdGFydDogMCwgY291bnQ6IGluZGljZXMubGVuZ3RoLCBpbmRleDogMCB9IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBvaSA9IDAsIG9sID0gb2Zmc2V0cy5sZW5ndGg7IG9pIDwgb2w7ICsrb2kgKSB7XG5cblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBvZmZzZXRzWyBvaSBdLnN0YXJ0O1xuXHRcdFx0XHRcdHZhciBjb3VudCA9IG9mZnNldHNbIG9pIF0uY291bnQ7XG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gb2Zmc2V0c1sgb2kgXS5pbmRleDtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcblx0XHRcdFx0XHRcdGIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHRjID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMiBdO1xuXG5cdFx0XHRcdFx0XHR2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcblx0XHRcdFx0XHRcdHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuXHRcdFx0XHRcdFx0dkMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGMgKiAzICk7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QywgdkIsIHZBLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QSwgdkIsIHZDLCBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb25Qb2ludCA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb25Qb2ludC5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHByZWNpc2lvbiB8fCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludCxcblx0XHRcdFx0XHRcdFx0ZmFjZTogbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHZBLCB2QiwgdkMgKSApLFxuXHRcdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0XHRcdG9iamVjdDogdGhpc1xuXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMsIGogKz0gOSApIHtcblxuXHRcdFx0XHRcdGEgPSBpO1xuXHRcdFx0XHRcdGIgPSBpICsgMTtcblx0XHRcdFx0XHRjID0gaSArIDI7XG5cblx0XHRcdFx0XHR2QS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaiApO1xuXHRcdFx0XHRcdHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBqICsgMyApO1xuXHRcdFx0XHRcdHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBqICsgNiApO1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QywgdkIsIHZBLCB0cnVlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZBLCB2QiwgdkMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uUG9pbnQgPT09IG51bGwgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGludGVyc2VjdGlvblBvaW50LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuXHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCBwcmVjaXNpb24gfHwgZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRwb2ludDogaW50ZXJzZWN0aW9uUG9pbnQsXG5cdFx0XHRcdFx0XHRmYWNlOiBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdkEsIHZCLCB2QyApICksXG5cdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHRcdHZhciBpc0ZhY2VNYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsO1xuXHRcdFx0dmFyIG9iamVjdE1hdGVyaWFscyA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gdGhpcy5tYXRlcmlhbC5tYXRlcmlhbHMgOiBudWxsO1xuXG5cdFx0XHR2YXIgYSwgYiwgYywgZDtcblx0XHRcdHZhciBwcmVjaXNpb24gPSByYXljYXN0ZXIucHJlY2lzaW9uO1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdHZhciBmYWNlID0gZ2VvbWV0cnkuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG9iamVjdE1hdGVyaWFsc1sgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiB0aGlzLm1hdGVyaWFsO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XG5cdFx0XHRcdGIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XG5cdFx0XHRcdGMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXHRcdFx0XHRcdHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuXHRcdFx0XHRcdHZBLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdHZCLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdHZDLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIHQgPSAwLCB0bCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHQgPCB0bDsgdCArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgdCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHR2YXIgdGFyZ2V0cyA9IG1vcnBoVGFyZ2V0c1sgdCBdLnZlcnRpY2VzO1xuXG5cdFx0XHRcdFx0XHR2QS54ICs9ICggdGFyZ2V0c1sgZmFjZS5hIF0ueCAtIGEueCApICogaW5mbHVlbmNlO1xuXHRcdFx0XHRcdFx0dkEueSArPSAoIHRhcmdldHNbIGZhY2UuYSBdLnkgLSBhLnkgKSAqIGluZmx1ZW5jZTtcblx0XHRcdFx0XHRcdHZBLnogKz0gKCB0YXJnZXRzWyBmYWNlLmEgXS56IC0gYS56ICkgKiBpbmZsdWVuY2U7XG5cblx0XHRcdFx0XHRcdHZCLnggKz0gKCB0YXJnZXRzWyBmYWNlLmIgXS54IC0gYi54ICkgKiBpbmZsdWVuY2U7XG5cdFx0XHRcdFx0XHR2Qi55ICs9ICggdGFyZ2V0c1sgZmFjZS5iIF0ueSAtIGIueSApICogaW5mbHVlbmNlO1xuXHRcdFx0XHRcdFx0dkIueiArPSAoIHRhcmdldHNbIGZhY2UuYiBdLnogLSBiLnogKSAqIGluZmx1ZW5jZTtcblxuXHRcdFx0XHRcdFx0dkMueCArPSAoIHRhcmdldHNbIGZhY2UuYyBdLnggLSBjLnggKSAqIGluZmx1ZW5jZTtcblx0XHRcdFx0XHRcdHZDLnkgKz0gKCB0YXJnZXRzWyBmYWNlLmMgXS55IC0gYy55ICkgKiBpbmZsdWVuY2U7XG5cdFx0XHRcdFx0XHR2Qy56ICs9ICggdGFyZ2V0c1sgZmFjZS5jIF0ueiAtIGMueiApICogaW5mbHVlbmNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dkEuYWRkKCBhICk7XG5cdFx0XHRcdFx0dkIuYWRkKCBiICk7XG5cdFx0XHRcdFx0dkMuYWRkKCBjICk7XG5cblx0XHRcdFx0XHRhID0gdkE7XG5cdFx0XHRcdFx0YiA9IHZCO1xuXHRcdFx0XHRcdGMgPSB2QztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuXHRcdFx0XHRcdHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggYywgYiwgYSwgdHJ1ZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIGEsIGIsIGMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb25Qb2ludCA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGludGVyc2VjdGlvblBvaW50LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50ICk7XG5cblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHByZWNpc2lvbiB8fCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludCxcblx0XHRcdFx0XHRmYWNlOiBmYWNlLFxuXHRcdFx0XHRcdGZhY2VJbmRleDogZixcblx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG59KCkgKTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xuXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xuXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QsIHJlY3Vyc2l2ZSApO1xuXG5cdHJldHVybiBvYmplY3Q7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvQm9uZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuQm9uZSA9IGZ1bmN0aW9uICggYmVsb25nc1RvU2tpbiApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5za2luID0gYmVsb25nc1RvU2tpbjtcblxufTtcblxuVEhSRUUuQm9uZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NrZWxldG9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pY2hhZWwgZ3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tlbGV0b24gPSBmdW5jdGlvbiAoIGJvbmVzLCBib25lSW52ZXJzZXMsIHVzZVZlcnRleFRleHR1cmUgKSB7XG5cblx0dGhpcy51c2VWZXJ0ZXhUZXh0dXJlID0gdXNlVmVydGV4VGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gdXNlVmVydGV4VGV4dHVyZSA6IHRydWU7XG5cblx0dGhpcy5pZGVudGl0eU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0Ly8gY29weSB0aGUgYm9uZSBhcnJheVxuXG5cdGJvbmVzID0gYm9uZXMgfHwgW107XG5cblx0dGhpcy5ib25lcyA9IGJvbmVzLnNsaWNlKCAwICk7XG5cblx0Ly8gY3JlYXRlIGEgYm9uZSB0ZXh0dXJlIG9yIGFuIGFycmF5IG9mIGZsb2F0c1xuXG5cdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdFx0Ly8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxuXHRcdC8vICAgICAgUkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcblx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICAoOCAqIDggIC8gNClcblx0XHQvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICgxNiAqIDE2IC8gNClcblx0XHQvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICgzMiAqIDMyIC8gNClcblx0XHQvLyAgICAgICA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IGJvbmVzICg2NCAqIDY0IC8gNClcblxuXHRcdHZhciBzaXplO1xuXG5cdFx0aWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA+IDI1NiApXG5cdFx0XHRzaXplID0gNjQ7XG5cdFx0ZWxzZSBpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID4gNjQgKVxuXHRcdFx0c2l6ZSA9IDMyO1xuXHRcdGVsc2UgaWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA+IDE2IClcblx0XHRcdHNpemUgPSAxNjtcblx0XHRlbHNlXG5cdFx0XHRzaXplID0gODtcblxuXHRcdHRoaXMuYm9uZVRleHR1cmVXaWR0aCA9IHNpemU7XG5cdFx0dGhpcy5ib25lVGV4dHVyZUhlaWdodCA9IHNpemU7XG5cblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXG5cdFx0dGhpcy5ib25lVGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggdGhpcy5ib25lTWF0cmljZXMsIHRoaXMuYm9uZVRleHR1cmVXaWR0aCwgdGhpcy5ib25lVGV4dHVyZUhlaWdodCwgVEhSRUUuUkdCQUZvcm1hdCwgVEhSRUUuRmxvYXRUeXBlICk7XG5cdFx0dGhpcy5ib25lVGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuXHRcdHRoaXMuYm9uZVRleHR1cmUubWFnRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcblx0XHR0aGlzLmJvbmVUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdHRoaXMuYm9uZVRleHR1cmUuZmxpcFkgPSBmYWxzZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIHRoaXMuYm9uZXMubGVuZ3RoICk7XG5cblx0fVxuXG5cdC8vIHVzZSB0aGUgc3VwcGxpZWQgYm9uZSBpbnZlcnNlcyBvciBjYWxjdWxhdGUgdGhlIGludmVyc2VzXG5cblx0aWYgKCBib25lSW52ZXJzZXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA9PT0gYm9uZUludmVyc2VzLmxlbmd0aCApIHtcblxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXMuc2xpY2UoIDAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uIGJvbkludmVyc2VzIGlzIHRoZSB3cm9uZyBsZW5ndGguJyApO1xuXG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuXHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgVEhSRUUuTWF0cml4NCgpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cbn07XG5cblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5jYWxjdWxhdGVJbnZlcnNlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG5cdFx0dmFyIGludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0aWYgKCB0aGlzLmJvbmVzWyBiIF0gKSB7XG5cblx0XHRcdGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgYm9uZTtcblxuXHQvLyByZWNvdmVyIHRoZSBiaW5kLXRpbWUgd29ybGQgbWF0cmljZXNcblxuXHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuXHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cblx0XHRpZiAoIGJvbmUgKSB7XG5cblx0XHRcdGJvbmUubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xuXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG5cdFx0Ym9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcblxuXHRcdGlmICggYm9uZSApIHtcblxuXHRcdFx0aWYgKCBib25lLnBhcmVudCApIHtcblxuXHRcdFx0XHRib25lLm1hdHJpeC5nZXRJbnZlcnNlKCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBvZmZzZXRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cblx0XHRcdC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtXG5cblx0XHRcdHZhciBtYXRyaXggPSB0aGlzLmJvbmVzWyBiIF0gPyB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgOiB0aGlzLmlkZW50aXR5TWF0cml4O1xuXG5cdFx0XHRvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XG5cdFx0XHRvZmZzZXRNYXRyaXguZmxhdHRlblRvQXJyYXlPZmZzZXQoIHRoaXMuYm9uZU1hdHJpY2VzLCBiICogMTYgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblx0XHRcblx0fTtcblxufSApKCk7XG5cblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Ta2lubmVkTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tpbm5lZE1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XG5cblx0dGhpcy5iaW5kTW9kZSA9IFwiYXR0YWNoZWRcIjtcblx0dGhpcy5iaW5kTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0Ly8gaW5pdCBib25lc1xuXG5cdC8vIFRPRE86IHJlbW92ZSBib25lIGNyZWF0aW9uIGFzIHRoZXJlIGlzIG5vIHJlYXNvbiAob3RoZXIgdGhhblxuXHQvLyBjb252ZW5pZW5jZSkgZm9yIFRIUkVFLlNraW5uZWRNZXNoIHRvIGRvIHRoaXMuXG5cblx0dmFyIGJvbmVzID0gW107XG5cblx0aWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHZhciBib25lLCBnYm9uZSwgcCwgcSwgcztcblxuXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiA8IGJsOyArK2IgKSB7XG5cblx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG5cdFx0XHRwID0gZ2JvbmUucG9zO1xuXHRcdFx0cSA9IGdib25lLnJvdHE7XG5cdFx0XHRzID0gZ2JvbmUuc2NsO1xuXG5cdFx0XHRib25lID0gbmV3IFRIUkVFLkJvbmUoIHRoaXMgKTtcblx0XHRcdGJvbmVzLnB1c2goIGJvbmUgKTtcblxuXHRcdFx0Ym9uZS5uYW1lID0gZ2JvbmUubmFtZTtcblx0XHRcdGJvbmUucG9zaXRpb24uc2V0KCBwWyAwIF0sIHBbIDEgXSwgcFsgMiBdICk7XG5cdFx0XHRib25lLnF1YXRlcm5pb24uc2V0KCBxWyAwIF0sIHFbIDEgXSwgcVsgMiBdLCBxWyAzIF0gKTtcblxuXHRcdFx0aWYgKCBzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ym9uZS5zY2FsZS5zZXQoIHNbIDAgXSwgc1sgMSBdLCBzWyAyIF0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRib25lLnNjYWxlLnNldCggMSwgMSwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKytiICkge1xuXG5cdFx0XHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcblxuXHRcdFx0aWYgKCBnYm9uZS5wYXJlbnQgIT09IC0gMSApIHtcblxuXHRcdFx0XHRib25lc1sgZ2JvbmUucGFyZW50IF0uYWRkKCBib25lc1sgYiBdICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5hZGQoIGJvbmVzWyBiIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG5cblx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXHR0aGlzLmJpbmQoIG5ldyBUSFJFRS5Ta2VsZXRvbiggYm9uZXMsIHVuZGVmaW5lZCwgdXNlVmVydGV4VGV4dHVyZSApICk7XG5cbn07XG5cblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XG5cblx0dGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG5cdGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0YmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0fVxuXG5cdHRoaXMuYmluZE1hdHJpeC5jb3B5KCBiaW5kTWF0cml4ICk7XG5cdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggYmluZE1hdHJpeCApO1xuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLnNrZWxldG9uLnBvc2UoKTtcblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLm5vcm1hbGl6ZVNraW5XZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuXG5cdGlmICggdGhpcy5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBzdyA9IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXTtcblxuXHRcdFx0dmFyIHNjYWxlID0gMS4wIC8gc3cubGVuZ3RoTWFuaGF0dGFuKCk7XG5cblx0XHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xuXG5cdFx0XHRcdHN3Lm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHN3LnNldCggMSApOyAvLyB0aGlzIHdpbGwgYmUgbm9ybWFsaXplZCBieSB0aGUgc2hhZGVyIGFueXdheVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIHNraW5uaW5nIHdlaWdodHMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIGZvciBUSFJFRS5CdWZmZXJHZW9tZXRyeVxuXG5cdH1cblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24oIGZvcmNlICkge1xuXG5cdFRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIHRydWUgKTtcblxuXHRpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiYXR0YWNoZWRcIiApIHtcblxuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09IFwiZGV0YWNoZWRcIiApIHtcblxuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5iaW5kTWF0cml4ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoIHVucmVja29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU2tpbm5lZE1lc2goIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xuXG5cdH1cblxuXHRUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuXHRyZXR1cm4gb2JqZWN0O1xuXG59O1xuXG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTW9ycGhBbmltTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTW9ycGhBbmltTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy50eXBlID0gJ01vcnBoQW5pbU1lc2gnO1xuXG5cdC8vIEFQSVxuXG5cdHRoaXMuZHVyYXRpb24gPSAxMDAwOyAvLyBtaWxsaXNlY29uZHNcblx0dGhpcy5taXJyb3JlZExvb3AgPSBmYWxzZTtcblx0dGhpcy50aW1lID0gMDtcblxuXHQvLyBpbnRlcm5hbHNcblxuXHR0aGlzLmxhc3RLZXlmcmFtZSA9IDA7XG5cdHRoaXMuY3VycmVudEtleWZyYW1lID0gMDtcblxuXHR0aGlzLmRpcmVjdGlvbiA9IDE7XG5cdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cblx0dGhpcy5zZXRGcmFtZVJhbmdlKCAwLCB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggLSAxICk7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RnJhbWVSYW5nZSA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuXHR0aGlzLnN0YXJ0S2V5ZnJhbWUgPSBzdGFydDtcblx0dGhpcy5lbmRLZXlmcmFtZSA9IGVuZDtcblxuXHR0aGlzLmxlbmd0aCA9IHRoaXMuZW5kS2V5ZnJhbWUgLSB0aGlzLnN0YXJ0S2V5ZnJhbWUgKyAxO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXREaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuZGlyZWN0aW9uID0gMTtcblx0dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5kaXJlY3Rpb24gPSAtIDE7XG5cdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGFyc2VBbmltYXRpb25zID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0aWYgKCAhIGdlb21ldHJ5LmFuaW1hdGlvbnMgKSBnZW9tZXRyeS5hbmltYXRpb25zID0ge307XG5cblx0dmFyIGZpcnN0QW5pbWF0aW9uLCBhbmltYXRpb25zID0gZ2VvbWV0cnkuYW5pbWF0aW9ucztcblxuXHR2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XG5cdFx0dmFyIHBhcnRzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xuXG5cdFx0aWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHR2YXIgbGFiZWwgPSBwYXJ0c1sgMSBdO1xuXHRcdFx0dmFyIG51bSA9IHBhcnRzWyAyIF07XG5cblx0XHRcdGlmICggISBhbmltYXRpb25zWyBsYWJlbCBdICkgYW5pbWF0aW9uc1sgbGFiZWwgXSA9IHsgc3RhcnQ6IEluZmluaXR5LCBlbmQ6IC0gSW5maW5pdHkgfTtcblxuXHRcdFx0dmFyIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbIGxhYmVsIF07XG5cblx0XHRcdGlmICggaSA8IGFuaW1hdGlvbi5zdGFydCApIGFuaW1hdGlvbi5zdGFydCA9IGk7XG5cdFx0XHRpZiAoIGkgPiBhbmltYXRpb24uZW5kICkgYW5pbWF0aW9uLmVuZCA9IGk7XG5cblx0XHRcdGlmICggISBmaXJzdEFuaW1hdGlvbiApIGZpcnN0QW5pbWF0aW9uID0gbGFiZWw7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdlb21ldHJ5LmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkxhYmVsID0gZnVuY3Rpb24gKCBsYWJlbCwgc3RhcnQsIGVuZCApIHtcblxuXHRpZiAoICEgdGhpcy5nZW9tZXRyeS5hbmltYXRpb25zICkgdGhpcy5nZW9tZXRyeS5hbmltYXRpb25zID0ge307XG5cblx0dGhpcy5nZW9tZXRyeS5hbmltYXRpb25zWyBsYWJlbCBdID0geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoIGxhYmVsLCBmcHMgKSB7XG5cblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc1sgbGFiZWwgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdHRoaXMuc2V0RnJhbWVSYW5nZSggYW5pbWF0aW9uLnN0YXJ0LCBhbmltYXRpb24uZW5kICk7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IDEwMDAgKiAoICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gZnBzICk7XG5cdFx0dGhpcy50aW1lID0gMDtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnYW5pbWF0aW9uWycgKyBsYWJlbCArICddIHVuZGVmaW5lZCcgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cblx0dmFyIGZyYW1lVGltZSA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLmxlbmd0aDtcblxuXHR0aGlzLnRpbWUgKz0gdGhpcy5kaXJlY3Rpb24gKiBkZWx0YTtcblxuXHRpZiAoIHRoaXMubWlycm9yZWRMb29wICkge1xuXG5cdFx0aWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uIHx8IHRoaXMudGltZSA8IDAgKSB7XG5cblx0XHRcdHRoaXMuZGlyZWN0aW9uICo9IC0gMTtcblxuXHRcdFx0aWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uICkge1xuXG5cdFx0XHRcdHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMudGltZSA8IDAgKSB7XG5cblx0XHRcdFx0dGhpcy50aW1lID0gMDtcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHR0aGlzLnRpbWUgPSB0aGlzLnRpbWUgJSB0aGlzLmR1cmF0aW9uO1xuXG5cdFx0aWYgKCB0aGlzLnRpbWUgPCAwICkgdGhpcy50aW1lICs9IHRoaXMuZHVyYXRpb247XG5cblx0fVxuXG5cdHZhciBrZXlmcmFtZSA9IHRoaXMuc3RhcnRLZXlmcmFtZSArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIHRoaXMudGltZSAvIGZyYW1lVGltZSApLCAwLCB0aGlzLmxlbmd0aCAtIDEgKTtcblxuXHRpZiAoIGtleWZyYW1lICE9PSB0aGlzLmN1cnJlbnRLZXlmcmFtZSApIHtcblxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyB0aGlzLmxhc3RLZXlmcmFtZSBdID0gMDtcblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IDE7XG5cblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XG5cblx0XHR0aGlzLmxhc3RLZXlmcmFtZSA9IHRoaXMuY3VycmVudEtleWZyYW1lO1xuXHRcdHRoaXMuY3VycmVudEtleWZyYW1lID0ga2V5ZnJhbWU7XG5cblx0fVxuXG5cdHZhciBtaXggPSAoIHRoaXMudGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG5cdGlmICggdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgKSB7XG5cblx0XHRtaXggPSAxIC0gbWl4O1xuXG5cdH1cblxuXHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IG1peDtcblx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMubGFzdEtleWZyYW1lIF0gPSAxIC0gbWl4O1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVRhcmdldHMgPSBmdW5jdGlvbiAoIGEsIGIsIHQgKSB7XG5cblx0dmFyIGluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRpbmZsdWVuY2VzWyBpIF0gPSAwO1xuXG5cdH1cblxuXHRpZiAoIGEgPiAtMSApIGluZmx1ZW5jZXNbIGEgXSA9IDEgLSB0O1xuXHRpZiAoIGIgPiAtMSApIGluZmx1ZW5jZXNbIGIgXSA9IHQ7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5Nb3JwaEFuaW1NZXNoKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XG5cblx0b2JqZWN0LmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcblx0b2JqZWN0Lm1pcnJvcmVkTG9vcCA9IHRoaXMubWlycm9yZWRMb29wO1xuXHRvYmplY3QudGltZSA9IHRoaXMudGltZTtcblxuXHRvYmplY3QubGFzdEtleWZyYW1lID0gdGhpcy5sYXN0S2V5ZnJhbWU7XG5cdG9iamVjdC5jdXJyZW50S2V5ZnJhbWUgPSB0aGlzLmN1cnJlbnRLZXlmcmFtZTtcblxuXHRvYmplY3QuZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG5cdG9iamVjdC5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcztcblxuXHRUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuXHRyZXR1cm4gb2JqZWN0O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xPRC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MT0QgPSBmdW5jdGlvbiAoKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMub2JqZWN0cyA9IFtdO1xuXG59O1xuXG5cblRIUkVFLkxPRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5hZGRMZXZlbCA9IGZ1bmN0aW9uICggb2JqZWN0LCBkaXN0YW5jZSApIHtcblxuXHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG5cblx0ZGlzdGFuY2UgPSBNYXRoLmFicyggZGlzdGFuY2UgKTtcblxuXHRmb3IgKCB2YXIgbCA9IDA7IGwgPCB0aGlzLm9iamVjdHMubGVuZ3RoOyBsICsrICkge1xuXG5cdFx0aWYgKCBkaXN0YW5jZSA8IHRoaXMub2JqZWN0c1sgbCBdLmRpc3RhbmNlICkge1xuXG5cdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5vYmplY3RzLnNwbGljZSggbCwgMCwgeyBkaXN0YW5jZTogZGlzdGFuY2UsIG9iamVjdDogb2JqZWN0IH0gKTtcblx0dGhpcy5hZGQoIG9iamVjdCApO1xuXG59O1xuXG5USFJFRS5MT0QucHJvdG90eXBlLmdldE9iamVjdEZvckRpc3RhbmNlID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLm9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGlmICggZGlzdGFuY2UgPCB0aGlzLm9iamVjdHNbIGkgXS5kaXN0YW5jZSApIHtcblxuXHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB0aGlzLm9iamVjdHNbIGkgLSAxIF0ub2JqZWN0O1xuXG59O1xuXG5USFJFRS5MT0QucHJvdG90eXBlLnJheWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggbWF0cml4UG9zaXRpb24gKTtcblxuXHRcdHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0fTtcblxufSgpICk7XG5cblRIUkVFLkxPRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG5cdFx0aWYgKCB0aGlzLm9iamVjdHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0djEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSB2MS5kaXN0YW5jZVRvKCB2MiApO1xuXG5cdFx0XHR0aGlzLm9iamVjdHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IHRoaXMub2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPj0gdGhpcy5vYmplY3RzWyBpIF0uZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm9iamVjdHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLm9iamVjdHNbIGkgICAgIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLm9iamVjdHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxufSgpO1xuXG5USFJFRS5MT0QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5MT0QoKTtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5vYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cdFx0dmFyIHggPSB0aGlzLm9iamVjdHNbIGkgXS5vYmplY3QuY2xvbmUoKTtcblx0XHR4LnZpc2libGUgPSBpID09PSAwO1xuXHRcdG9iamVjdC5hZGRMZXZlbCggeCwgdGhpcy5vYmplY3RzWyBpIF0uZGlzdGFuY2UgKTtcblx0fVxuXG5cdHJldHVybiBvYmplY3Q7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvU3ByaXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3ByaXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMiwgIDAsIDIsIDMgXSApO1xuXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIC0gMC41LCAtIDAuNSwgMCwgICAwLjUsIC0gMC41LCAwLCAgIDAuNSwgMC41LCAwLCAgIC0gMC41LCAwLjUsIDAgXSApO1xuXHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggWyAwLCAwLCAgIDEsIDAsICAgMSwgMSwgICAwLCAxIF0gKTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnaW5kZXgnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcHJpdGUnO1xuXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XG5cblx0fTtcblxufSApKCk7XG5cblRIUkVFLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkuZGlzdGFuY2VUb1BvaW50KCBtYXRyaXhQb3NpdGlvbiApO1xuXG5cdFx0aWYgKCBkaXN0YW5jZSA+IHRoaXMuc2NhbGUueCApIHtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdHBvaW50OiB0aGlzLnBvc2l0aW9uLFxuXHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdG9iamVjdDogdGhpc1xuXG5cdFx0fSApO1xuXG5cdH07XG5cbn0oKSApO1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5TcHJpdGUoIHRoaXMubWF0ZXJpYWwgKTtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cblx0cmV0dXJuIG9iamVjdDtcblxufTtcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuVEhSRUUuUGFydGljbGUgPSBUSFJFRS5TcHJpdGU7XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTGVuc0ZsYXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTGVuc0ZsYXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmxlbnNGbGFyZXMgPSBbXTtcblxuXHR0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHVuZGVmaW5lZDtcblxuXHRpZiggdGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0dGhpcy5hZGQoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuXG4vKlxuICogQWRkOiBhZGRzIGFub3RoZXIgZmxhcmVcbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcblxuXHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAtIDE7XG5cdGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcblx0aWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcblx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cdGlmICggYmxlbmRpbmcgPT09IHVuZGVmaW5lZCApIGJsZW5kaW5nID0gVEhSRUUuTm9ybWFsQmxlbmRpbmc7XG5cblx0ZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XG5cblx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHtcblx0XHR0ZXh0dXJlOiB0ZXh0dXJlLCBcdFx0XHQvLyBUSFJFRS5UZXh0dXJlXG5cdFx0c2l6ZTogc2l6ZSwgXHRcdFx0XHQvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcblx0XHRkaXN0YW5jZTogZGlzdGFuY2UsIFx0XHQvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXG5cdFx0eDogMCwgeTogMCwgejogMCxcdFx0XHQvLyBzY3JlZW4gcG9zaXRpb24gKC0xID0+IDEpIHogPSAwIGlzIG9udG9wIHogPSAxIGlzIGJhY2tcblx0XHRzY2FsZTogMSwgXHRcdFx0XHRcdC8vIHNjYWxlXG5cdFx0cm90YXRpb246IDEsIFx0XHRcdFx0Ly8gcm90YXRpb25cblx0XHRvcGFjaXR5OiBvcGFjaXR5LFx0XHRcdC8vIG9wYWNpdHlcblx0XHRjb2xvcjogY29sb3IsXHRcdFx0XHQvLyBjb2xvclxuXHRcdGJsZW5kaW5nOiBibGVuZGluZ1x0XHRcdC8vIGJsZW5kaW5nXG5cdH0gKTtcblxufTtcblxuLypcbiAqIFVwZGF0ZSBsZW5zIGZsYXJlcyB1cGRhdGUgcG9zaXRpb25zIG9uIGFsbCBmbGFyZXMgYmFzZWQgb24gdGhlIHNjcmVlbiBwb3NpdGlvblxuICogU2V0IG15TGVuc0ZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrIHRvIGFsdGVyIHRoZSBmbGFyZXMgaW4geW91ciBwcm9qZWN0IHNwZWNpZmljIHdheS5cbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLnVwZGF0ZUxlbnNGbGFyZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGYsIGZsID0gdGhpcy5sZW5zRmxhcmVzLmxlbmd0aDtcblx0dmFyIGZsYXJlO1xuXHR2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcblx0dmFyIHZlY1kgPSAtIHRoaXMucG9zaXRpb25TY3JlZW4ueSAqIDI7XG5cblx0Zm9yKCBmID0gMDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0ZmxhcmUgPSB0aGlzLmxlbnNGbGFyZXNbIGYgXTtcblxuXHRcdGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XG5cdFx0ZmxhcmUueSA9IHRoaXMucG9zaXRpb25TY3JlZW4ueSArIHZlY1kgKiBmbGFyZS5kaXN0YW5jZTtcblxuXHRcdGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xuXHRcdGZsYXJlLnJvdGF0aW9uICs9ICggZmxhcmUud2FudGVkUm90YXRpb24gLSBmbGFyZS5yb3RhdGlvbiApICogMC4yNTtcblxuXHR9XG5cbn07XG5cblxuLy8gRmlsZTpzcmMvc2NlbmVzL1NjZW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TY2VuZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1NjZW5lJztcblxuXHR0aGlzLmZvZyA9IG51bGw7XG5cdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cblx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxufTtcblxuVEhSRUUuU2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cblx0aWYgKCB0aGlzLmZvZyAhPT0gbnVsbCApIG9iamVjdC5mb2cgPSB0aGlzLmZvZy5jbG9uZSgpO1xuXHRpZiAoIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIG9iamVjdC5vdmVycmlkZU1hdGVyaWFsID0gdGhpcy5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XG5cblx0b2JqZWN0LmF1dG9VcGRhdGUgPSB0aGlzLmF1dG9VcGRhdGU7XG5cdG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gdGhpcy5tYXRyaXhBdXRvVXBkYXRlO1xuXG5cdHJldHVybiBvYmplY3Q7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2cuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Gb2cgPSBmdW5jdGlvbiAoIGNvbG9yLCBuZWFyLCBmYXIgKSB7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcblxuXHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDE7XG5cdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcblxufTtcblxuVEhSRUUuRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLkZvZyggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9zY2VuZXMvRm9nRXhwMi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkZvZ0V4cDIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZW5zaXR5ICkge1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XG5cdHRoaXMuZGVuc2l0eSA9ICggZGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBkZW5zaXR5IDogMC4wMDAyNTtcblxufTtcblxuVEhSRUUuRm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5Gb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsuanNcblxuVEhSRUUuU2hhZGVyQ2h1bmsgPSB7fTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGF0ZXN0X2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYXRlc3RfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIEFMUEhBVEVTVFxcblxcblx0aWYgKCBnbF9GcmFnQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19sYW1iZXJ0X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfdmVydGV4J10gPSBcInZMaWdodEZyb250ID0gdmVjMyggMC4wICk7XFxuXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0dkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xcblxcbiNlbmRpZlxcblxcbnRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5mb3IoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpICsrICkge1xcblxcblx0dmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XFxuXHR2ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcXG5cXG5cdGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIHRyYW5zZm9ybWVkTm9ybWFsLCBkaXJWZWN0b3IgKTtcXG5cdHZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZyA9IHZlYzMoIG1heCggZG90UHJvZHVjdCwgMC4wICkgKTtcXG5cXG5cdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0dmVjMyBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nQmFjayA9IHZlYzMoIG1heCggLWRvdFByb2R1Y3QsIDAuMCApICk7XFxuXFxuXHRcdCNpZmRlZiBXUkFQX0FST1VORFxcblxcblx0XHRcdHZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGZCYWNrID0gdmVjMyggbWF4KCAtMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHQjZW5kaWZcXG5cXG5cdCNpZmRlZiBXUkFQX0FST1VORFxcblxcblx0XHR2ZWMzIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmID0gdmVjMyggbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1xcblx0XHRkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nID0gbWl4KCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nLCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZiwgd3JhcFJHQiApO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0ZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0JhY2sgPSBtaXgoIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdCYWNrLCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2ssIHdyYXBSR0IgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHQjZW5kaWZcXG5cXG5cdHZMaWdodEZyb250ICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZztcXG5cXG5cdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0dkxpZ2h0QmFjayArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdCYWNrO1xcblxcblx0I2VuZGlmXFxuXFxufVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcXG5cXG5cdFx0ZmxvYXQgbERpc3RhbmNlID0gMS4wO1xcblx0XHRpZiAoIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcXG5cdFx0XHRsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcXG5cXG5cdFx0bFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCB0cmFuc2Zvcm1lZE5vcm1hbCwgbFZlY3RvciApO1xcblxcblx0XHR2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmcgPSB2ZWMzKCBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICk7XFxuXFxuXHRcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdFx0XHR2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmdCYWNrID0gdmVjMyggbWF4KCAtZG90UHJvZHVjdCwgMC4wICkgKTtcXG5cXG5cdFx0XHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cdFx0XHRcdHZlYzMgcG9pbnRMaWdodFdlaWdodGluZ0hhbGZCYWNrID0gdmVjMyggbWF4KCAtMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcXG5cXG5cdFx0XHQjZW5kaWZcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHRcdCNpZmRlZiBXUkFQX0FST1VORFxcblxcblx0XHRcdHZlYzMgcG9pbnRMaWdodFdlaWdodGluZ0hhbGYgPSB2ZWMzKCBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XFxuXHRcdFx0cG9pbnRMaWdodFdlaWdodGluZyA9IG1peCggcG9pbnRMaWdodFdlaWdodGluZywgcG9pbnRMaWdodFdlaWdodGluZ0hhbGYsIHdyYXBSR0IgKTtcXG5cXG5cdFx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0XHRwb2ludExpZ2h0V2VpZ2h0aW5nQmFjayA9IG1peCggcG9pbnRMaWdodFdlaWdodGluZ0JhY2ssIHBvaW50TGlnaHRXZWlnaHRpbmdIYWxmQmFjaywgd3JhcFJHQiApO1xcblxcblx0XHRcdCNlbmRpZlxcblxcblx0XHQjZW5kaWZcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludExpZ2h0V2VpZ2h0aW5nICogbERpc3RhbmNlO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50TGlnaHRXZWlnaHRpbmdCYWNrICogbERpc3RhbmNlO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6IC0gbXZQb3NpdGlvbi54eXo7XFxuXFxuXHRcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0gLSB3b3JsZFBvc2l0aW9uLnh5eiApICk7XFxuXFxuXHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuXHRcdFx0c3BvdEVmZmVjdCA9IG1heCggcG93KCBtYXgoIHNwb3RFZmZlY3QsIDAuMCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICksIDAuMCApO1xcblxcblx0XHRcdGZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcXG5cdFx0XHRpZiAoIHNwb3RMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVxcblx0XHRcdFx0bERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcXG5cXG5cdFx0XHRsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGxWZWN0b3IgKTtcXG5cdFx0XHR2ZWMzIHNwb3RMaWdodFdlaWdodGluZyA9IHZlYzMoIG1heCggZG90UHJvZHVjdCwgMC4wICkgKTtcXG5cXG5cdFx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0XHR2ZWMzIHNwb3RMaWdodFdlaWdodGluZ0JhY2sgPSB2ZWMzKCBtYXgoIC1kb3RQcm9kdWN0LCAwLjAgKSApO1xcblxcblx0XHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXHRcdFx0XHRcdHZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2sgPSB2ZWMzKCBtYXgoIC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1xcblxcblx0XHRcdFx0I2VuZGlmXFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXHRcdFx0XHR2ZWMzIHNwb3RMaWdodFdlaWdodGluZ0hhbGYgPSB2ZWMzKCBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XFxuXHRcdFx0XHRzcG90TGlnaHRXZWlnaHRpbmcgPSBtaXgoIHNwb3RMaWdodFdlaWdodGluZywgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZiwgd3JhcFJHQiApO1xcblxcblx0XHRcdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdFx0XHRzcG90TGlnaHRXZWlnaHRpbmdCYWNrID0gbWl4KCBzcG90TGlnaHRXZWlnaHRpbmdCYWNrLCBzcG90TGlnaHRXZWlnaHRpbmdIYWxmQmFjaywgd3JhcFJHQiApO1xcblxcblx0XHRcdFx0I2VuZGlmXFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdFx0dkxpZ2h0RnJvbnQgKz0gc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3RMaWdodFdlaWdodGluZyAqIGxEaXN0YW5jZSAqIHNwb3RFZmZlY3Q7XFxuXFxuXHRcdFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblx0XHRcdFx0dkxpZ2h0QmFjayArPSBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdExpZ2h0V2VpZ2h0aW5nQmFjayAqIGxEaXN0YW5jZSAqIHNwb3RFZmZlY3Q7XFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdH1cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XFxuXHRcdHZlYzMgbFZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGxWZWN0b3IgKTtcXG5cXG5cdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodEJhY2sgPSAtMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0dkxpZ2h0RnJvbnQgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcblx0XHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdFx0dkxpZ2h0QmFjayArPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0QmFjayApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG52TGlnaHRGcm9udCA9IHZMaWdodEZyb250ICogZGlmZnVzZSArIGFtYmllbnQgKiBhbWJpZW50TGlnaHRDb2xvciArIGVtaXNzaXZlO1xcblxcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cdHZMaWdodEJhY2sgPSB2TGlnaHRCYWNrICogZGlmZnVzZSArIGFtYmllbnQgKiBhbWJpZW50TGlnaHRDb2xvciArIGVtaXNzaXZlO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFydGljbGVfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2RlZmF1bHRfdmVydGV4J10gPSBcInZlYzQgbXZQb3NpdGlvbjtcXG5cXG4jaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogc2tpbm5lZDtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKVxcblxcblx0bXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcbiNlbmRpZlxcblxcbiNpZiAhZGVmaW5lZCggVVNFX1NLSU5OSU5HICkgJiYgISBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTIClcXG5cXG5cdG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuI2VuZGlmXFxuXFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5ub3JtYWxfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcXG5cdHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXG5cdCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXHR2ZWM0IHNraW5uZWROb3JtYWwgPSBza2luTWF0cml4ICogdmVjNCggbW9ycGhlZE5vcm1hbCwgMC4wICk7XFxuXFxuXHQjZWxzZVxcblxcblx0dmVjNCBza2lubmVkTm9ybWFsID0gc2tpbk1hdHJpeCAqIHZlYzQoIG5vcm1hbCwgMC4wICk7XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cdCNlbmRpZlxcblxcblx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX2ZyYWdtZW50J10gPSBcInZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxudmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5cXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRub3JtYWwgPSBub3JtYWwgKiAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCApO1xcblxcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcXG5cXG5cdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR2ZWMzIHBvaW50RGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcblx0dmVjMyBwb2ludFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XFxuXHRcdHZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5cXG5cdFx0ZmxvYXQgbERpc3RhbmNlID0gMS4wO1xcblx0XHRpZiAoIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcXG5cdFx0XHRsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcXG5cXG5cdFx0bFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblx0XHRcdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcXG5cXG5cdFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXHRcdFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXHRcdFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICk7XFxuXFxuXHRcdFx0dmVjMyBwb2ludERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMoIHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XFxuXFxuXHRcdCNlbHNlXFxuXFxuXHRcdFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcXG5cXG5cdFx0I2VuZGlmXFxuXFxuXHRcdHBvaW50RGlmZnVzZSArPSBkaWZmdXNlICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2U7XFxuXFxuXHRcdFx0XHQvLyBzcGVjdWxhclxcblxcblx0XHR2ZWMzIHBvaW50SGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1xcblx0XHRmbG9hdCBwb2ludERvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBwb2ludEhhbGZWZWN0b3IgKSwgMC4wICk7XFxuXHRcdGZsb2F0IHBvaW50U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1xcblxcblx0XHR2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBsVmVjdG9yLCBwb2ludEhhbGZWZWN0b3IgKSwgMC4wICksIDUuMCApO1xcblx0XHRwb2ludFNwZWN1bGFyICs9IHNjaGxpY2sgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50U3BlY3VsYXJXZWlnaHQgKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XFxuXFxuXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdHZlYzMgc3BvdERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcXG5cdHZlYzMgc3BvdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XFxuXFxuXHRcdGZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcXG5cdFx0aWYgKCBzcG90TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcXG5cdFx0XHRsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBzcG90TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1xcblxcblx0XHRsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXHRcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0gLSB2V29ybGRQb3NpdGlvbiApICk7XFxuXFxuXHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuXHRcdFx0c3BvdEVmZmVjdCA9IG1heCggcG93KCBtYXgoIHNwb3RFZmZlY3QsIDAuMCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICksIDAuMCApO1xcblxcblx0XHRcdFx0XHQvLyBkaWZmdXNlXFxuXFxuXHRcdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XFxuXFxuXHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXHRcdFx0XHRmbG9hdCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1xcblx0XHRcdFx0ZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcXG5cXG5cdFx0XHRcdHZlYzMgc3BvdERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMoIHNwb3REaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBzcG90RGlmZnVzZVdlaWdodEhhbGYgKSwgd3JhcFJHQiApO1xcblxcblx0XHRcdCNlbHNlXFxuXFxuXHRcdFx0XHRmbG9hdCBzcG90RGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdFx0c3BvdERpZmZ1c2UgKz0gZGlmZnVzZSAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZSAqIHNwb3RFZmZlY3Q7XFxuXFxuXHRcdFx0XHRcdC8vIHNwZWN1bGFyXFxuXFxuXHRcdFx0dmVjMyBzcG90SGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1xcblx0XHRcdGZsb2F0IHNwb3REb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdEhhbGZWZWN0b3IgKSwgMC4wICk7XFxuXHRcdFx0ZmxvYXQgc3BvdFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBzcG90RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblx0XHRcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XFxuXFxuXHRcdFx0dmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3Rvciwgc3BvdEhhbGZWZWN0b3IgKSwgMC4wICksIDUuMCApO1xcblx0XHRcdHNwb3RTcGVjdWxhciArPSBzY2hsaWNrICogc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3RTcGVjdWxhcldlaWdodCAqIHNwb3REaWZmdXNlV2VpZ2h0ICogbERpc3RhbmNlICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogc3BvdEVmZmVjdDtcXG5cXG5cdFx0fVxcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cdHZlYzMgZGlyRGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcblx0dmVjMyBkaXJTcGVjdWxhciA9IHZlYzMoIDAuMCApO1xcblxcblx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cdFx0dmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XFxuXHRcdHZlYzMgZGlyVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1xcblxcblx0XHRcdFx0Ly8gZGlmZnVzZVxcblxcblx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGRpclZlY3RvciApO1xcblxcblx0XHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cdFx0XHRmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXHRcdFx0ZmxvYXQgZGlyRGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApO1xcblxcblx0XHRcdHZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyRGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggZGlyRGlmZnVzZVdlaWdodEhhbGYgKSwgd3JhcFJHQiApO1xcblxcblx0XHQjZWxzZVxcblxcblx0XHRcdGZsb2F0IGRpckRpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1xcblxcblx0XHQjZW5kaWZcXG5cXG5cdFx0ZGlyRGlmZnVzZSArPSBkaWZmdXNlICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJEaWZmdXNlV2VpZ2h0O1xcblxcblx0XHQvLyBzcGVjdWxhclxcblxcblx0XHR2ZWMzIGRpckhhbGZWZWN0b3IgPSBub3JtYWxpemUoIGRpclZlY3RvciArIHZpZXdQb3NpdGlvbiApO1xcblx0XHRmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcXG5cdFx0ZmxvYXQgZGlyU3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIGRpckRvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcXG5cXG5cdFx0LypcXG5cdFx0Ly8gZnJlc25lbCB0ZXJtIGZyb20gc2tpbiBzaGFkZXJcXG5cdFx0Y29uc3QgZmxvYXQgRjAgPSAwLjEyODtcXG5cXG5cdFx0ZmxvYXQgYmFzZSA9IDEuMCAtIGRvdCggdmlld1Bvc2l0aW9uLCBkaXJIYWxmVmVjdG9yICk7XFxuXHRcdGZsb2F0IGV4cG9uZW50aWFsID0gcG93KCBiYXNlLCA1LjAgKTtcXG5cXG5cdFx0ZmxvYXQgZnJlc25lbCA9IGV4cG9uZW50aWFsICsgRjAgKiAoIDEuMCAtIGV4cG9uZW50aWFsICk7XFxuXHRcdCovXFxuXFxuXHRcdC8qXFxuXHRcdC8vIGZyZXNuZWwgdGVybSBmcm9tIGZyZXNuZWwgc2hhZGVyXFxuXHRcdGNvbnN0IGZsb2F0IG1GcmVzbmVsQmlhcyA9IDAuMDg7XFxuXHRcdGNvbnN0IGZsb2F0IG1GcmVzbmVsU2NhbGUgPSAwLjM7XFxuXHRcdGNvbnN0IGZsb2F0IG1GcmVzbmVsUG93ZXIgPSA1LjA7XFxuXFxuXHRcdGZsb2F0IGZyZXNuZWwgPSBtRnJlc25lbEJpYXMgKyBtRnJlc25lbFNjYWxlICogcG93KCAxLjAgKyBkb3QoIG5vcm1hbGl6ZSggLXZpZXdQb3NpdGlvbiApLCBub3JtYWwgKSwgbUZyZXNuZWxQb3dlciApO1xcblx0XHQqL1xcblxcblx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1xcblxcblx0XHQvLyBcdFx0ZGlyU3BlY3VsYXIgKz0gc3BlY3VsYXIgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqIGZyZXNuZWw7XFxuXFxuXHRcdHZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGRpclZlY3RvciwgZGlySGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XFxuXHRcdGRpclNwZWN1bGFyICs9IHNjaGxpY2sgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcXG5cXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcblx0dmVjMyBoZW1pRGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcblx0dmVjMyBoZW1pU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcXG5cXG5cdGZvciggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcblx0XHR2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1xcblx0XHR2ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XFxuXFxuXHRcdC8vIGRpZmZ1c2VcXG5cXG5cdFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XFxuXHRcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG5cdFx0dmVjMyBoZW1pQ29sb3IgPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFxuXHRcdGhlbWlEaWZmdXNlICs9IGRpZmZ1c2UgKiBoZW1pQ29sb3I7XFxuXFxuXHRcdC8vIHNwZWN1bGFyIChza3kgbGlnaHQpXFxuXFxuXHRcdHZlYzMgaGVtaUhhbGZWZWN0b3JTa3kgPSBub3JtYWxpemUoIGxWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcXG5cdFx0ZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZTa3kgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JTa3kgKSArIDAuNTtcXG5cdFx0ZmxvYXQgaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBtYXgoIGhlbWlEb3ROb3JtYWxIYWxmU2t5LCAwLjAgKSwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblx0XHQvLyBzcGVjdWxhciAoZ3JvdW5kIGxpZ2h0KVxcblxcblx0XHR2ZWMzIGxWZWN0b3JHcm91bmQgPSAtbFZlY3RvcjtcXG5cXG5cdFx0dmVjMyBoZW1pSGFsZlZlY3Rvckdyb3VuZCA9IG5vcm1hbGl6ZSggbFZlY3Rvckdyb3VuZCArIHZpZXdQb3NpdGlvbiApO1xcblx0XHRmbG9hdCBoZW1pRG90Tm9ybWFsSGFsZkdyb3VuZCA9IDAuNSAqIGRvdCggbm9ybWFsLCBoZW1pSGFsZlZlY3Rvckdyb3VuZCApICsgMC41O1xcblx0XHRmbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIG1heCggaGVtaURvdE5vcm1hbEhhbGZHcm91bmQsIDAuMCApLCBzaGluaW5lc3MgKSwgMC4wICk7XFxuXFxuXHRcdGZsb2F0IGRvdFByb2R1Y3RHcm91bmQgPSBkb3QoIG5vcm1hbCwgbFZlY3Rvckdyb3VuZCApO1xcblxcblx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1xcblxcblx0XHR2ZWMzIHNjaGxpY2tTa3kgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBsVmVjdG9yLCBoZW1pSGFsZlZlY3RvclNreSApLCAwLjAgKSwgNS4wICk7XFxuXHRcdHZlYzMgc2NobGlja0dyb3VuZCA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGxWZWN0b3JHcm91bmQsIGhlbWlIYWxmVmVjdG9yR3JvdW5kICksIDAuMCApLCA1LjAgKTtcXG5cdFx0aGVtaVNwZWN1bGFyICs9IGhlbWlDb2xvciAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqICggc2NobGlja1NreSAqIGhlbWlTcGVjdWxhcldlaWdodFNreSAqIG1heCggZG90UHJvZHVjdCwgMC4wICkgKyBzY2hsaWNrR3JvdW5kICogaGVtaVNwZWN1bGFyV2VpZ2h0R3JvdW5kICogbWF4KCBkb3RQcm9kdWN0R3JvdW5kLCAwLjAgKSApO1xcblxcblx0fVxcblxcbiNlbmRpZlxcblxcbnZlYzMgdG90YWxEaWZmdXNlID0gdmVjMyggMC4wICk7XFxudmVjMyB0b3RhbFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0dG90YWxEaWZmdXNlICs9IGRpckRpZmZ1c2U7XFxuXHR0b3RhbFNwZWN1bGFyICs9IGRpclNwZWN1bGFyO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHR0b3RhbERpZmZ1c2UgKz0gaGVtaURpZmZ1c2U7XFxuXHR0b3RhbFNwZWN1bGFyICs9IGhlbWlTcGVjdWxhcjtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cdHRvdGFsRGlmZnVzZSArPSBwb2ludERpZmZ1c2U7XFxuXHR0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cdHRvdGFsRGlmZnVzZSArPSBzcG90RGlmZnVzZTtcXG5cdHRvdGFsU3BlY3VsYXIgKz0gc3BvdFNwZWN1bGFyO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBNRVRBTFxcblxcblx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIGVtaXNzaXZlICsgdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiBhbWJpZW50ICsgdG90YWxTcGVjdWxhciApO1xcblxcbiNlbHNlXFxuXFxuXHRnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggZW1pc3NpdmUgKyB0b3RhbERpZmZ1c2UgKyBhbWJpZW50TGlnaHRDb2xvciAqIGFtYmllbnQgKSArIHRvdGFsU3BlY3VsYXI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2ZvZ19wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcblx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcblx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG5cdFx0dW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGhub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaG5vcm1hbF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdHZlYzMgbW9ycGhlZE5vcm1hbCA9IHZlYzMoIDAuMCApO1xcblxcblx0bW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMCAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHRtb3JwaGVkTm9ybWFsICs9ICggbW9ycGhOb3JtYWwxIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cdG1vcnBoZWROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblx0bW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMyAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuXHRtb3JwaGVkTm9ybWFsICs9IG5vcm1hbDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFxuXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG5cdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xcblx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblx0dW5pZm9ybSBpbnQgY29tYmluZTtcXG5cXG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHRcdHVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1xcblx0XHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfZnJhZ21lbnQnXSA9IFwiI2lmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGKSAmJiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRl9FWFQpXFxuXFxuXHRnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKHZGcmFnRGVwdGgpICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXFxuXHRcdFx0Ly8gUGVyLVBpeGVsIFRhbmdlbnQgU3BhY2UgTm9ybWFsIE1hcHBpbmdcXG5cdFx0XHQvLyBodHRwOi8vaGFja3NvZmxpZmUuYmxvZ3Nwb3QuY2gvMjAwOS8xMS9wZXItcGl4ZWwtdGFuZ2VudC1zcGFjZS1ub3JtYWwtbWFwcGluZy5odG1sXFxuXFxuXHR2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtICkge1xcblxcblx0XHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG5cdFx0dmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxuXHRcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXHRcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXFxuXHRcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXG5cdFx0dmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG5cdFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cXG5cdFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG5cdFx0bWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG5cdFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuXHRcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcXG5cXG5cdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1xcblxcblx0XHR2U2hhZG93Q29vcmRbIGkgXSA9IHNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXG5cdH1cXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX3ZlcnRleCddID0gXCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcblx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdHZlYzQgdGV4ZWxDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VXYgKTtcXG5cXG5cdCNpZmRlZiBHQU1NQV9JTlBVVFxcblxcblx0XHR0ZXhlbENvbG9yLnh5eiAqPSB0ZXhlbENvbG9yLnh5ejtcXG5cXG5cdCNlbmRpZlxcblxcblx0Z2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4ZWxDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodG1hcF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblx0dlV2MiA9IHV2MjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0I2lmZGVmIEdBTU1BX0lOUFVUXFxuXFxuXHRcdHZDb2xvciA9IGNvbG9yICogY29sb3I7XFxuXFxuXHQjZWxzZVxcblxcblx0XHR2Q29sb3IgPSBjb2xvcjtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5uaW5nX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHQjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcblx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcblx0I2Vsc2VcXG5cXG5cdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xcblx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xcblx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxuXHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFxuXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cdHVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpbmVhcl90b19nYW1tYV9mcmFnbWVudCddID0gXCIjaWZkZWYgR0FNTUFfT1VUUFVUXFxuXFxuXHRnbF9GcmFnQ29sb3IueHl6ID0gc3FydCggZ2xfRnJhZ0NvbG9yLnh5eiApO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4J10gPSBcInVuaWZvcm0gdmVjMyBhbWJpZW50O1xcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXG5cXG51bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcblxcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cdHVuaWZvcm0gdmVjMyB3cmFwUkdCO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJzX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG5cdHZlYzMgcmVmbGVjdFZlYztcXG5cXG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHRcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXG5cdFx0Ly8gaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9HTFNMX1Byb2dyYW1taW5nL0FwcGx5aW5nX01hdHJpeF9UcmFuc2Zvcm1hdGlvbnNcXG5cdFx0Ly8gVHJhbnNmb3JtaW5nIE5vcm1hbCBWZWN0b3JzIHdpdGggdGhlIEludmVyc2UgVHJhbnNmb3JtYXRpb25cXG5cXG5cdFx0dmVjMyB3b3JsZE5vcm1hbCA9IG5vcm1hbGl6ZSggdmVjMyggdmVjNCggbm9ybWFsLCAwLjAgKSAqIHZpZXdNYXRyaXggKSApO1xcblxcblx0XHRpZiAoIHVzZVJlZnJhY3QgKSB7XFxuXFxuXHRcdFx0cmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFxuXHRcdH0gZWxzZSB7IFxcblxcblx0XHRcdHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXG5cdFx0fVxcblxcblx0I2Vsc2VcXG5cXG5cdFx0cmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblxcblx0I2VuZGlmXFxuXFxuXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXHRcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1xcblx0XHR2ZWM0IGN1YmVDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGZsaXBOb3JtYWwgKiB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdHZlYzQgY3ViZUNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdCNpZmRlZiBHQU1NQV9JTlBVVFxcblxcblx0XHRjdWJlQ29sb3IueHl6ICo9IGN1YmVDb2xvci54eXo7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdGlmICggY29tYmluZSA9PSAxICkge1xcblxcblx0XHRnbF9GcmFnQ29sb3IueHl6ID0gbWl4KCBnbF9GcmFnQ29sb3IueHl6LCBjdWJlQ29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxuXFxuXHR9IGVsc2UgaWYgKCBjb21iaW5lID09IDIgKSB7XFxuXFxuXHRcdGdsX0ZyYWdDb2xvci54eXogKz0gY3ViZUNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxuXFxuXHR9IGVsc2Uge1xcblxcblx0XHRnbF9GcmFnQ29sb3IueHl6ID0gbWl4KCBnbF9GcmFnQ29sb3IueHl6LCBnbF9GcmFnQ29sb3IueHl6ICogY3ViZUNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcblx0fVxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXG5cdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHRnbF9Qb3NpdGlvbi56ID0gbG9nMihtYXgoMWUtNiwgZ2xfUG9zaXRpb24udyArIDEuMCkpICogbG9nRGVwdGhCdWZGQztcXG5cXG5cdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXHRcdHZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53O1xcblxcbiNlbHNlXFxuXFxuXHRcdGdsX1Bvc2l0aW9uLnogPSAoZ2xfUG9zaXRpb24ueiAtIDEuMCkgKiBnbF9Qb3NpdGlvbi53O1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcblx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcblxcblx0I2Vsc2VcXG5cXG5cdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc3BlY3VsYXJtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX2ZyYWdtZW50J10gPSBcImZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxuXFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcblx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcblxcbiNlbHNlXFxuXFxuXHRzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG5cdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cdCNlbHNlXFxuXFxuXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXHRcdGNvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTtcXG5cdFx0ZmxvYXQgZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7XFxuXHRcdGZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7XFxuXFxuXHQjZWxzZVxcblxcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XFxuXFxuXHQjZW5kaWZcXG5cdFxcblx0Z2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYnVtcG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdidW1wbWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXFxuXHRcdFx0Ly8gRGVyaXZhdGl2ZSBtYXBzIC0gYnVtcCBtYXBwaW5nIHVucGFyYW1ldHJpemVkIHN1cmZhY2VzIGJ5IE1vcnRlbiBNaWtrZWxzZW5cXG5cdFx0XHQvL1x0aHR0cDovL21taWtrZWxzZW4zZC5ibG9nc3BvdC5zay8yMDExLzA3L2Rlcml2YXRpdmUtbWFwcy5odG1sXFxuXFxuXHRcdFx0Ly8gRXZhbHVhdGUgdGhlIGRlcml2YXRpdmUgb2YgdGhlIGhlaWdodCB3LnIudC4gc2NyZWVuLXNwYWNlIHVzaW5nIGZvcndhcmQgZGlmZmVyZW5jaW5nIChsaXN0aW5nIDIpXFxuXFxuXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cXG5cdFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcblx0XHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxuXFxuXHRcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5cdFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuXHRcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcblxcblx0XHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXG5cdH1cXG5cXG5cdHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxuXFxuXHRcdHZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XFxuXHRcdHZlYzMgdk4gPSBzdXJmX25vcm07XHRcdC8vIG5vcm1hbGl6ZWRcXG5cXG5cdFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblx0XHR2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7XFxuXFxuXHRcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICk7XFxuXFxuXHRcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblx0XHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkZWZhdWx0bm9ybWFsX3ZlcnRleCddID0gXCJ2ZWMzIG9iamVjdE5vcm1hbDtcXG5cXG4jaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRvYmplY3ROb3JtYWwgPSBza2lubmVkTm9ybWFsLnh5ejtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmIGRlZmluZWQoIFVTRV9NT1JQSE5PUk1BTFMgKVxcblxcblx0b2JqZWN0Tm9ybWFsID0gbW9ycGhlZE5vcm1hbDtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmICEgZGVmaW5lZCggVVNFX01PUlBITk9STUFMUyApXFxuXFxuXHRvYmplY3ROb3JtYWwgPSBub3JtYWw7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIEZMSVBfU0lERURcXG5cXG5cdG9iamVjdE5vcm1hbCA9IC1vYmplY3ROb3JtYWw7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50J10gPSBcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cdHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxuXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG5cdHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFdSQVBfQVJPVU5EXFxuXFxuXHR1bmlmb3JtIHZlYzMgd3JhcFJHQjtcXG5cXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbmJhc2VfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2luYmFzZV92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblx0bWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxuXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXG5cdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblx0bWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKVxcblxcblx0dlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodG1hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuXHRnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3BhcnNfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHR2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSBtYXQ0IHNoYWRvd01hdHJpeFsgTUFYX1NIQURPV1MgXTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbG9yX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cdGdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHZlYzQoIHZDb2xvciwgMS4wICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuXHR2ZWMzIG1vcnBoZWQgPSB2ZWMzKCAwLjAgKTtcXG5cdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXHRtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblx0bW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG5cdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXHRtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcblx0bW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG5cdG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxuXFxuXHQjZW5kaWZcXG5cXG5cdG1vcnBoZWQgKz0gcG9zaXRpb247XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFxuXHR2ZWMzIHdvcmxkTm9ybWFsID0gbWF0MyggbW9kZWxNYXRyaXhbIDAgXS54eXosIG1vZGVsTWF0cml4WyAxIF0ueHl6LCBtb2RlbE1hdHJpeFsgMiBdLnh5eiApICogb2JqZWN0Tm9ybWFsO1xcblx0d29ybGROb3JtYWwgPSBub3JtYWxpemUoIHdvcmxkTm9ybWFsICk7XFxuXFxuXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFxuXHRpZiAoIHVzZVJlZnJhY3QgKSB7XFxuXFxuXHRcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXG5cdH0gZWxzZSB7XFxuXFxuXHRcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuXHQjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuXHRcdHZlYzMgZnJ1c3R1bUNvbG9yc1szXTtcXG5cdFx0ZnJ1c3R1bUNvbG9yc1swXSA9IHZlYzMoIDEuMCwgMC41LCAwLjAgKTtcXG5cdFx0ZnJ1c3R1bUNvbG9yc1sxXSA9IHZlYzMoIDAuMCwgMS4wLCAwLjggKTtcXG5cdFx0ZnJ1c3R1bUNvbG9yc1syXSA9IHZlYzMoIDAuMCwgMC41LCAxLjAgKTtcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmZGVmIFNIQURPV01BUF9DQVNDQURFXFxuXFxuXHRcdGludCBpbkZydXN0dW1Db3VudCA9IDA7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdGZsb2F0IGZEZXB0aDtcXG5cdHZlYzMgc2hhZG93Q29sb3IgPSB2ZWMzKCAxLjAgKTtcXG5cXG5cdGZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxuXFxuXHRcdHZlYzMgc2hhZG93Q29vcmQgPSB2U2hhZG93Q29vcmRbIGkgXS54eXogLyB2U2hhZG93Q29vcmRbIGkgXS53O1xcblxcblx0XHRcdFx0Ly8gaWYgKCBzb21ldGhpbmcgJiYgc29tZXRoaW5nICkgYnJlYWtzIEFUSSBPcGVuR0wgc2hhZGVyIGNvbXBpbGVyXFxuXHRcdFx0XHQvLyBpZiAoIGFsbCggc29tZXRoaW5nLCBzb21ldGhpbmcgKSApIHVzaW5nIHRoaXMgaW5zdGVhZFxcblxcblx0XHRidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuXHRcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cXG5cdFx0XHRcdC8vIGRvbid0IHNoYWRvdyBwaXhlbHMgb3V0c2lkZSBvZiBsaWdodCBmcnVzdHVtXFxuXHRcdFx0XHQvLyB1c2UganVzdCBmaXJzdCBmcnVzdHVtIChmb3IgY2FzY2FkZXMpXFxuXHRcdFx0XHQvLyBkb24ndCBzaGFkb3cgcGl4ZWxzIGJlaGluZCBmYXIgcGxhbmUgb2YgbGlnaHQgZnJ1c3R1bVxcblxcblx0XHQjaWZkZWYgU0hBRE9XTUFQX0NBU0NBREVcXG5cXG5cdFx0XHRpbkZydXN0dW1Db3VudCArPSBpbnQoIGluRnJ1c3R1bSApO1xcblx0XHRcdGJ2ZWMzIGZydXN0dW1UZXN0VmVjID0gYnZlYzMoIGluRnJ1c3R1bSwgaW5GcnVzdHVtQ291bnQgPT0gMSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcXG5cXG5cdFx0I2Vsc2VcXG5cXG5cdFx0XHRidmVjMiBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMyKCBpbkZydXN0dW0sIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XFxuXFxuXHRcdCNlbmRpZlxcblxcblx0XHRib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcblxcblx0XHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblxcblx0XHRcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcblx0XHRcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblxcblx0XHRcdFx0XHRcdC8vIFBlcmNlbnRhZ2UtY2xvc2UgZmlsdGVyaW5nXFxuXHRcdFx0XHRcdFx0Ly8gKDkgcGl4ZWwga2VybmVsKVxcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1BDRi9cXG5cXG5cdFx0XHRcdGZsb2F0IHNoYWRvdyA9IDAuMDtcXG5cXG5cdFx0LypcXG5cdFx0XHRcdFx0XHQvLyBuZXN0ZWQgbG9vcHMgYnJlYWtzIHNoYWRlciBjb21waWxlciAvIHZhbGlkYXRvciBvbiBzb21lIEFUSSBjYXJkcyB3aGVuIHVzaW5nIE9wZW5HTFxcblx0XHRcdFx0XHRcdC8vIG11c3QgZW5yb2xsIGxvb3AgbWFudWFsbHlcXG5cXG5cdFx0XHRcdGZvciAoIGZsb2F0IHkgPSAtMS4yNTsgeSA8PSAxLjI1OyB5ICs9IDEuMjUgKVxcblx0XHRcdFx0XHRmb3IgKCBmbG9hdCB4ID0gLTEuMjU7IHggPD0gMS4yNTsgeCArPSAxLjI1ICkge1xcblxcblx0XHRcdFx0XHRcdHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKTtcXG5cXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZG9lc24ndCBzZWVtIHRvIHByb2R1Y2UgYW55IG5vdGljZWFibGUgdmlzdWFsIGRpZmZlcmVuY2UgY29tcGFyZWQgdG8gc2ltcGxlIHRleHR1cmUyRCBsb29rdXBcXG5cdFx0XHRcdFx0XHRcdFx0Ly92ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRFByb2ooIHNoYWRvd01hcFsgaSBdLCB2ZWM0KCB2U2hhZG93Q29vcmRbIGkgXS53ICogKCB2ZWMyKCB4ICogeFBpeGVsT2Zmc2V0LCB5ICogeVBpeGVsT2Zmc2V0ICkgKyBzaGFkb3dDb29yZC54eSApLCAwLjA1LCB2U2hhZG93Q29vcmRbIGkgXS53ICkgKTtcXG5cXG5cdFx0XHRcdFx0XHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXFxuXHRcdFx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56IClcXG5cdFx0XHRcdFx0XHRcdHNoYWRvdyArPSAxLjA7XFxuXFxuXHRcdFx0XHR9XFxuXFxuXHRcdFx0XHRzaGFkb3cgLz0gOS4wO1xcblxcblx0XHQqL1xcblxcblx0XHRcdFx0Y29uc3QgZmxvYXQgc2hhZG93RGVsdGEgPSAxLjAgLyA5LjA7XFxuXFxuXHRcdFx0XHRmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG5cdFx0XHRcdGZsb2F0IHlQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS55O1xcblxcblx0XHRcdFx0ZmxvYXQgZHgwID0gLTEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTAgPSAtMS4yNSAqIHlQaXhlbE9mZnNldDtcXG5cdFx0XHRcdGZsb2F0IGR4MSA9IDEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTEgPSAxLjI1ICogeVBpeGVsT2Zmc2V0O1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG5cdFx0XHRcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG5cdFx0XHRcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcblx0XHRcdFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcblx0XHRcdFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuXHRcdFx0XHRzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICogc2hhZG93ICkgKTtcXG5cXG5cdFx0XHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFxuXHRcdFx0XHRcdFx0Ly8gUGVyY2VudGFnZS1jbG9zZSBmaWx0ZXJpbmdcXG5cdFx0XHRcdFx0XHQvLyAoOSBwaXhlbCBrZXJuZWwpXFxuXHRcdFx0XHRcdFx0Ly8gaHR0cDovL2ZhYmllbnNhbmdsYXJkLm5ldC9zaGFkb3dtYXBwaW5nUENGL1xcblxcblx0XHRcdFx0ZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcblx0XHRcdFx0ZmxvYXQgeFBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XFxuXHRcdFx0XHRmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5cXG5cdFx0XHRcdGZsb2F0IGR4MCA9IC0xLjAgKiB4UGl4ZWxPZmZzZXQ7XFxuXHRcdFx0XHRmbG9hdCBkeTAgPSAtMS4wICogeVBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHgxID0gMS4wICogeFBpeGVsT2Zmc2V0O1xcblx0XHRcdFx0ZmxvYXQgZHkxID0gMS4wICogeVBpeGVsT2Zmc2V0O1xcblxcblx0XHRcdFx0bWF0MyBzaGFkb3dLZXJuZWw7XFxuXHRcdFx0XHRtYXQzIGRlcHRoS2VybmVsO1xcblxcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMF1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzBdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFswXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMV1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzFdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzFdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuXHRcdFx0XHRkZXB0aEtlcm5lbFsyXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblx0XHRcdFx0ZGVwdGhLZXJuZWxbMl1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcXG5cdFx0XHRcdGRlcHRoS2VybmVsWzJdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXFxuXHRcdFx0XHR2ZWMzIHNoYWRvd1ogPSB2ZWMzKCBzaGFkb3dDb29yZC56ICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMF0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzBdLCBzaGFkb3daICkpO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzBdICo9IHZlYzMoMC4yNSk7XFxuXFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMV0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzFdLCBzaGFkb3daICkpO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzFdICo9IHZlYzMoMC4yNSk7XFxuXFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMl0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzJdLCBzaGFkb3daICkpO1xcblx0XHRcdFx0c2hhZG93S2VybmVsWzJdICo9IHZlYzMoMC4yNSk7XFxuXFxuXHRcdFx0XHR2ZWMyIGZyYWN0aW9uYWxDb29yZCA9IDEuMCAtIGZyYWN0KCBzaGFkb3dDb29yZC54eSAqIHNoYWRvd01hcFNpemVbaV0ueHkgKTtcXG5cXG5cdFx0XHRcdHNoYWRvd0tlcm5lbFswXSA9IG1peCggc2hhZG93S2VybmVsWzFdLCBzaGFkb3dLZXJuZWxbMF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuXHRcdFx0XHRzaGFkb3dLZXJuZWxbMV0gPSBtaXgoIHNoYWRvd0tlcm5lbFsyXSwgc2hhZG93S2VybmVsWzFdLCBmcmFjdGlvbmFsQ29vcmQueCApO1xcblxcblx0XHRcdFx0dmVjNCBzaGFkb3dWYWx1ZXM7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueCA9IG1peCggc2hhZG93S2VybmVsWzBdWzFdLCBzaGFkb3dLZXJuZWxbMF1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueSA9IG1peCggc2hhZG93S2VybmVsWzBdWzJdLCBzaGFkb3dLZXJuZWxbMF1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMueiA9IG1peCggc2hhZG93S2VybmVsWzFdWzFdLCBzaGFkb3dLZXJuZWxbMV1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXHRcdFx0XHRzaGFkb3dWYWx1ZXMudyA9IG1peCggc2hhZG93S2VybmVsWzFdWzJdLCBzaGFkb3dLZXJuZWxbMV1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuXFxuXHRcdFx0XHRzaGFkb3cgPSBkb3QoIHNoYWRvd1ZhbHVlcywgdmVjNCggMS4wICkgKTtcXG5cXG5cdFx0XHRcdHNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKiBzaGFkb3cgKSApO1xcblxcblx0XHRcdCNlbHNlXFxuXFxuXHRcdFx0XHR2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICk7XFxuXHRcdFx0XHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXFxuXHRcdFx0XHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVxcblxcblx0XHQvLyBzcG90IHdpdGggbXVsdGlwbGUgc2hhZG93cyBpcyBkYXJrZXJcXG5cXG5cdFx0XHRcdFx0c2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKTtcXG5cXG5cdFx0Ly8gc3BvdCB3aXRoIG11bHRpcGxlIHNoYWRvd3MgaGFzIHRoZSBzYW1lIGNvbG9yIGFzIHNpbmdsZSBzaGFkb3cgc3BvdFxcblxcblx0XHQvLyBcdFx0XHRcdFx0c2hhZG93Q29sb3IgPSBtaW4oIHNoYWRvd0NvbG9yLCB2ZWMzKCBzaGFkb3dEYXJrbmVzc1sgaSBdICkgKTtcXG5cXG5cdFx0XHQjZW5kaWZcXG5cXG5cdFx0fVxcblxcblxcblx0XHQjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuXHRcdFx0I2lmZGVmIFNIQURPV01BUF9DQVNDQURFXFxuXFxuXHRcdFx0XHRpZiAoIGluRnJ1c3R1bSAmJiBpbkZydXN0dW1Db3VudCA9PSAxICkgZ2xfRnJhZ0NvbG9yLnh5eiAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XFxuXFxuXHRcdFx0I2Vsc2VcXG5cXG5cdFx0XHRcdGlmICggaW5GcnVzdHVtICkgZ2xfRnJhZ0NvbG9yLnh5eiAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XFxuXFxuXHRcdFx0I2VuZGlmXFxuXFxuXHRcdCNlbmRpZlxcblxcblx0fVxcblxcblx0I2lmZGVmIEdBTU1BX09VVFBVVFxcblxcblx0XHRzaGFkb3dDb2xvciAqPSBzaGFkb3dDb2xvcjtcXG5cXG5cdCNlbmRpZlxcblxcblx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiBzaGFkb3dDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvd29ybGRwb3NfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd3b3JsZHBvc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxuXFxuXHQjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogc2tpbm5lZDtcXG5cXG5cdCNlbmRpZlxcblxcblx0I2lmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKSAmJiAhIGRlZmluZWQoIFVTRV9TS0lOTklORyApXFxuXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggbW9ycGhlZCwgMS4wICk7XFxuXFxuXHQjZW5kaWZcXG5cXG5cdCNpZiAhIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKSAmJiAhIGRlZmluZWQoIFVTRV9TS0lOTklORyApXFxuXFxuXHRcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcblx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblx0dW5pZm9ybSBzYW1wbGVyMkQgc2hhZG93TWFwWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSB2ZWMyIHNoYWRvd01hcFNpemVbIE1BWF9TSEFET1dTIF07XFxuXFxuXHR1bmlmb3JtIGZsb2F0IHNoYWRvd0RhcmtuZXNzWyBNQVhfU0hBRE9XUyBdO1xcblx0dW5pZm9ybSBmbG9hdCBzaGFkb3dCaWFzWyBNQVhfU0hBRE9XUyBdO1xcblxcblx0dmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG5cXG5cdGZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuXFxuXHRcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcXG5cdFx0ZmxvYXQgZGVwdGggPSBkb3QoIHJnYmFfZGVwdGgsIGJpdF9zaGlmdCApO1xcblx0XHRyZXR1cm4gZGVwdGg7XFxuXFxuXHR9XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubmluZ19wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXG5cdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXG5cdCNpZmRlZiBCT05FX1RFWFRVUkVcXG5cXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXHRcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlV2lkdGg7XFxuXHRcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlSGVpZ2h0O1xcblxcblx0XHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuXHRcdFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxuXHRcdFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblx0XHRcdGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cXG5cdFx0XHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICk7XFxuXHRcdFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVIZWlnaHQgKTtcXG5cXG5cdFx0XHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXG5cdFx0XHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuXHRcdFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcblx0XHRcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG5cdFx0XHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFxuXHRcdFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXG5cdFx0XHRyZXR1cm4gYm9uZTtcXG5cXG5cdFx0fVxcblxcblx0I2Vsc2VcXG5cXG5cdFx0dW5pZm9ybSBtYXQ0IGJvbmVHbG9iYWxNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFxuXHRcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG5cdFx0XHRtYXQ0IGJvbmUgPSBib25lR2xvYmFsTWF0cmljZXNbIGludChpKSBdO1xcblx0XHRcdHJldHVybiBib25lO1xcblxcblx0XHR9XFxuXFxuXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblx0XHQjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXFxuXHRcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcblx0Z2xfRnJhZ0NvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdlV2ICkuZztcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFxuXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qc1xuXG4vKipcbiAqIFVuaWZvcm0gVXRpbGl0aWVzXG4gKi9cblxuVEhSRUUuVW5pZm9ybXNVdGlscyA9IHtcblxuXHRtZXJnZTogZnVuY3Rpb24gKCB1bmlmb3JtcyApIHtcblxuXHRcdHZhciBtZXJnZWQgPSB7fTtcblxuXHRcdGZvciAoIHZhciB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcblxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcblxuXHRcdFx0Zm9yICggdmFyIHAgaW4gdG1wICkge1xuXG5cdFx0XHRcdG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBtZXJnZWQ7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCB1bmlmb3Jtc19zcmMgKSB7XG5cblx0XHR2YXIgdW5pZm9ybXNfZHN0ID0ge307XG5cblx0XHRmb3IgKCB2YXIgdSBpbiB1bmlmb3Jtc19zcmMgKSB7XG5cblx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdID0ge307XG5cblx0XHRcdGZvciAoIHZhciBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xuXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcblxuXHRcdFx0XHRpZiAoIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNCB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLmNsb25lKCk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuc2xpY2UoKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5pZm9ybXNfZHN0O1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNMaWIuanNcblxuLyoqXG4gKiBVbmlmb3JtcyBsaWJyYXJ5IGZvciBzaGFyZWQgd2ViZ2wgc2hhZGVyc1xuICovXG5cblRIUkVFLlVuaWZvcm1zTGliID0ge1xuXG5cdGNvbW1vbjoge1xuXG5cdFx0XCJkaWZmdXNlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cblx0XHRcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXG5cblx0XHRcImxpZ2h0TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwic3BlY3VsYXJNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJhbHBoYU1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblxuXHRcdFwiZW52TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwiZmxpcEVudk1hcFwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0gMSB9LFxuXHRcdFwidXNlUmVmcmFjdFwiIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblx0XHRcInJlZmxlY3Rpdml0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFwicmVmcmFjdGlvblJhdGlvXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC45OCB9LFxuXHRcdFwiY29tYmluZVwiIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblxuXHRcdFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMCB9XG5cblx0fSxcblxuXHRidW1wOiB7XG5cblx0XHRcImJ1bXBNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJidW1wU2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH1cblxuXHR9LFxuXG5cdG5vcm1hbG1hcDoge1xuXG5cdFx0XCJub3JtYWxNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJub3JtYWxTY2FsZVwiIDogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApIH1cblx0fSxcblxuXHRmb2cgOiB7XG5cblx0XHRcImZvZ0RlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDI1IH0sXG5cdFx0XCJmb2dOZWFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuXHRcdFwiZm9nRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxuXHRcdFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfVxuXG5cdH0sXG5cblx0bGlnaHRzOiB7XG5cblx0XHRcImFtYmllbnRMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cblx0XHRcImRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcImRpcmVjdGlvbmFsTGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XCJoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcImhlbWlzcGhlcmVMaWdodFNreUNvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XCJoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XCJwb2ludExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcInBvaW50TGlnaHRQb3NpdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwicG9pbnRMaWdodERpc3RhbmNlXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XCJzcG90TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwic3BvdExpZ2h0UG9zaXRpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblx0XHRcInNwb3RMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwic3BvdExpZ2h0RGlzdGFuY2VcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XCJzcG90TGlnaHRBbmdsZUNvc1wiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcblx0XHRcInNwb3RMaWdodEV4cG9uZW50XCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9XG5cblx0fSxcblxuXHRwYXJ0aWNsZToge1xuXG5cdFx0XCJwc0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XCJzaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XCJzY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXG5cdFx0XCJmb2dEZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDAyNSB9LFxuXHRcdFwiZm9nTmVhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblx0XHRcImZvZ0ZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAgfSxcblx0XHRcImZvZ0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cblxuXHR9LFxuXG5cdHNoYWRvd21hcDoge1xuXG5cdFx0XCJzaGFkb3dNYXBcIjogeyB0eXBlOiBcInR2XCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwic2hhZG93TWFwU2l6ZVwiOiB7IHR5cGU6IFwidjJ2XCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XCJzaGFkb3dCaWFzXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXHRcdFwic2hhZG93RGFya25lc3NcIjogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcblxuXHRcdFwic2hhZG93TWF0cml4XCIgOiB7IHR5cGU6IFwibTR2XCIsIHZhbHVlOiBbXSB9XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIuanNcblxuLyoqXG4gKiBXZWJnbCBTaGFkZXIgTGlicmFyeSBmb3IgdGhyZWUuanNcbiAqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKi9cblxuXG5USFJFRS5TaGFkZXJMaWIgPSB7XG5cblx0J2Jhc2ljJzoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXG5cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfRU5WTUFQXCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oXCJcXG5cIilcblxuXHR9LFxuXG5cdCdsYW1iZXJ0Jzoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuXHRcdFx0e1xuXHRcdFx0XHRcImFtYmllbnRcIiAgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcblx0XHRcdFx0XCJ3cmFwUkdCXCIgIDogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApIH1cblx0XHRcdH1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcIiNkZWZpbmUgTEFNQkVSVFwiLFxuXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcIixcblxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cblx0XHRcdFwiXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxuXG5cdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcblxuXHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxuXG5cdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCApLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJcdCNpZmRlZiBET1VCTEVfU0lERURcIixcblxuXHRcdFx0XHRcdC8vXCJmbG9hdCBpc0Zyb250ID0gZmxvYXQoIGdsX0Zyb250RmFjaW5nICk7XCIsXG5cdFx0XHRcdFx0Ly9cImdsX0ZyYWdDb2xvci54eXogKj0gaXNGcm9udCAqIHZMaWdodEZyb250ICsgKCAxLjAgLSBpc0Zyb250ICkgKiB2TGlnaHRCYWNrO1wiLFxuXG5cdFx0XHRcIlx0XHRpZiAoIGdsX0Zyb250RmFjaW5nIClcIixcblx0XHRcdFwiXHRcdFx0Z2xfRnJhZ0NvbG9yLnh5eiAqPSB2TGlnaHRGcm9udDtcIixcblx0XHRcdFwiXHRcdGVsc2VcIixcblx0XHRcdFwiXHRcdFx0Z2xfRnJhZ0NvbG9yLnh5eiAqPSB2TGlnaHRCYWNrO1wiLFxuXG5cdFx0XHRcIlx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0Z2xfRnJhZ0NvbG9yLnh5eiAqPSB2TGlnaHRGcm9udDtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J3Bob25nJzoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImJ1bXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibm9ybWFsbWFwXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuXHRcdFx0e1xuXHRcdFx0XHRcImFtYmllbnRcIiAgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcblx0XHRcdFx0XCJzcGVjdWxhclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKSB9LFxuXHRcdFx0XHRcInNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfSxcblx0XHRcdFx0XCJ3cmFwUkdCXCIgIDogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApIH1cblx0XHRcdH1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcIiNkZWZpbmUgUEhPTkdcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwiXHR2Vmlld1Bvc2l0aW9uID0gLW12UG9zaXRpb24ueHl6O1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oXCJcXG5cIiksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcIiNkZWZpbmUgUEhPTkdcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBhbWJpZW50O1wiLFxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCApLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J3BhcnRpY2xlX2Jhc2ljJzoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwicGFydGljbGVcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXVxuXG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaXplO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIlx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XHRcIlx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cIixcblx0XHRcdFwiXHRcdGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gbGVuZ3RoKCBtdlBvc2l0aW9uLnh5eiApICk7XCIsXG5cdFx0XHRcIlx0I2Vsc2VcIixcblx0XHRcdFwiXHRcdGdsX1BvaW50U2l6ZSA9IHNpemU7XCIsXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgcHNDb2xvcjtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBzQ29sb3IsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J2Rhc2hlZCc6IHtcblxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuXG5cdFx0XHR7XG5cdFx0XHRcdFwic2NhbGVcIiAgICA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cdFx0XHRcdFwiZGFzaFNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cdFx0XHRcdFwidG90YWxTaXplXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyIH1cblx0XHRcdH1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXG5cdFx0XHRcImF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XCIsXG5cblx0XHRcdFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwiXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XCIsXG5cblx0XHRcdFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cdFx0XHRcIlx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1wiLFxuXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwiXHRpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcIixcblxuXHRcdFx0XCJcdFx0ZGlzY2FyZDtcIixcblxuXHRcdFx0XCJcdH1cIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0J2RlcHRoJzoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblxuXHRcdFx0XCJtTmVhclwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XHRcIm1GYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwLjAgfSxcblx0XHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XG5cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1OZWFyO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1GYXI7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXG5cblx0XHRcdFwiXHRcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXG5cblx0XHRcdFwiXHQjZWxzZVwiLFxuXG5cdFx0XHRcIlx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XCJcdGZsb2F0IGNvbG9yID0gMS4wIC0gc21vb3Roc3RlcCggbU5lYXIsIG1GYXIsIGRlcHRoICk7XCIsXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggY29sb3IgKSwgb3BhY2l0eSApO1wiLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpXG5cblx0fSxcblxuXHQnbm9ybWFsJzoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblxuXHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cblxuXHRcdH0sXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdHZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMC41ICogbm9ybWFsaXplKCB2Tm9ybWFsICkgKyAwLjUsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oXCJcXG5cIilcblxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly9cdE5vcm1hbCBtYXAgc2hhZGVyXG5cdC8vXHRcdC0gQmxpbm4tUGhvbmdcblx0Ly9cdFx0LSBub3JtYWwgKyBkaWZmdXNlICsgc3BlY3VsYXIgKyBBTyArIGRpc3BsYWNlbWVudCArIHJlZmxlY3Rpb24gKyBzaGFkb3cgbWFwc1xuXHQvL1x0XHQtIHBvaW50IGFuZCBkaXJlY3Rpb25hbCBsaWdodHMgKHVzZSB3aXRoIFwibGlnaHRzOiB0cnVlXCIgbWF0ZXJpYWwgb3B0aW9uKVxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdCdub3JtYWxtYXAnIDoge1xuXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxuXG5cdFx0XHR7XG5cblx0XHRcdFwiZW5hYmxlQU9cIiAgICAgICAgICA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG5cdFx0XHRcImVuYWJsZURpZmZ1c2VcIiAgICAgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXHRcdFx0XCJlbmFibGVTcGVjdWxhclwiICAgIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblx0XHRcdFwiZW5hYmxlUmVmbGVjdGlvblwiICA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXG5cdFx0XHRcImVuYWJsZURpc3BsYWNlbWVudFwiOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxuXG5cdFx0XHRcInREaXNwbGFjZW1lbnRcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSwgLy8gbXVzdCBnbyBmaXJzdCBhcyB0aGlzIGlzIHZlcnRleCB0ZXh0dXJlXG5cdFx0XHRcInREaWZmdXNlXCIgICAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcdFwidEN1YmVcIiAgICAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0XCJ0Tm9ybWFsXCIgICAgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XHRcInRTcGVjdWxhclwiICAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcdFwidEFPXCIgICAgICAgICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXG5cdFx0XHRcInVOb3JtYWxTY2FsZVwiOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfSxcblxuXHRcdFx0XCJ1RGlzcGxhY2VtZW50Qmlhc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wIH0sXG5cdFx0XHRcInVEaXNwbGFjZW1lbnRTY2FsZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cblx0XHRcdFwiZGlmZnVzZVwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0XHRcInNwZWN1bGFyXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICkgfSxcblx0XHRcdFwiYW1iaWVudFwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXG5cdFx0XHRcInNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfSxcblx0XHRcdFwib3BhY2l0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuXG5cdFx0XHRcInVzZVJlZnJhY3RcIjogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcblx0XHRcdFwicmVmcmFjdGlvblJhdGlvXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjk4IH0sXG5cdFx0XHRcInJlZmxlY3Rpdml0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC41IH0sXG5cblx0XHRcdFwidU9mZnNldFwiIDogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApIH0sXG5cdFx0XHRcInVSZXBlYXRcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9LFxuXG5cdFx0XHRcIndyYXBSR0JcIiA6IHsgdHlwZTogXCJ2M1wiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKSB9XG5cblx0XHRcdH1cblxuXHRcdF0gKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnQ7XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BlY3VsYXI7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZURpZmZ1c2U7XCIsXG5cdFx0XHRcInVuaWZvcm0gYm9vbCBlbmFibGVTcGVjdWxhcjtcIixcblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZUFPO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGJvb2wgZW5hYmxlUmVmbGVjdGlvbjtcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdE5vcm1hbDtcIixcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdFNwZWN1bGFyO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0QU87XCIsXG5cblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdU5vcm1hbFNjYWxlO1wiLFxuXG5cdFx0XHRcInVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XCIsXG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZUYW5nZW50O1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkJpbm9ybWFsO1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XCIsXG5cblx0XHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcIlx0dW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcIixcblx0XHRcdFwiXHR1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcIlx0dW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcblx0XHRcdFwiXHR1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxuXHRcdFx0XCJcdHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxuXG5cdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcIlx0dW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxuXHRcdFx0XCJcdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcblx0XHRcdFwiXHR1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxuXG5cdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxuXHRcdFx0XCJcdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XHRcIlx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XHRcIlx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XHRcIlx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cdFx0XHRcIlx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXG5cblx0XHRcdFwiXHR1bmlmb3JtIHZlYzMgd3JhcFJHQjtcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCApLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFwiXHR2ZWMzIHNwZWN1bGFyVGV4ID0gdmVjMyggMS4wICk7XCIsXG5cblx0XHRcdFwiXHR2ZWMzIG5vcm1hbFRleCA9IHRleHR1cmUyRCggdE5vcm1hbCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1wiLFxuXHRcdFx0XCJcdG5vcm1hbFRleC54eSAqPSB1Tm9ybWFsU2NhbGU7XCIsXG5cdFx0XHRcIlx0bm9ybWFsVGV4ID0gbm9ybWFsaXplKCBub3JtYWxUZXggKTtcIixcblxuXHRcdFx0XCJcdGlmKCBlbmFibGVEaWZmdXNlICkge1wiLFxuXG5cdFx0XHRcIlx0XHQjaWZkZWYgR0FNTUFfSU5QVVRcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcblx0XHRcdFwiXHRcdFx0dGV4ZWxDb2xvci54eXogKj0gdGV4ZWxDb2xvci54eXo7XCIsXG5cblx0XHRcdFwiXHRcdFx0Z2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4ZWxDb2xvcjtcIixcblxuXHRcdFx0XCJcdFx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0XHRnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcblxuXHRcdFx0XCJcdFx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHR9XCIsXG5cblx0XHRcdFwiXHRpZiggZW5hYmxlQU8gKSB7XCIsXG5cblx0XHRcdFwiXHRcdCNpZmRlZiBHQU1NQV9JTlBVVFwiLFxuXG5cdFx0XHRcIlx0XHRcdHZlYzQgYW9Db2xvciA9IHRleHR1cmUyRCggdEFPLCB2VXYgKTtcIixcblx0XHRcdFwiXHRcdFx0YW9Db2xvci54eXogKj0gYW9Db2xvci54eXo7XCIsXG5cblx0XHRcdFwiXHRcdFx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiBhb0NvbG9yLnh5ejtcIixcblxuXHRcdFx0XCJcdFx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0XHRnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqIHRleHR1cmUyRCggdEFPLCB2VXYgKS54eXo7XCIsXG5cblx0XHRcdFwiXHRcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0fVwiLFxuXHRcdFx0XG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIlx0aWYoIGVuYWJsZVNwZWN1bGFyIClcIixcblx0XHRcdFwiXHRcdHNwZWN1bGFyVGV4ID0gdGV4dHVyZTJEKCB0U3BlY3VsYXIsIHZVdiApLnh5ejtcIixcblxuXHRcdFx0XCJcdG1hdDMgdHNiID0gbWF0Myggbm9ybWFsaXplKCB2VGFuZ2VudCApLCBub3JtYWxpemUoIHZCaW5vcm1hbCApLCBub3JtYWxpemUoIHZOb3JtYWwgKSApO1wiLFxuXHRcdFx0XCJcdHZlYzMgZmluYWxOb3JtYWwgPSB0c2IgKiBub3JtYWxUZXg7XCIsXG5cblx0XHRcdFwiXHQjaWZkZWYgRkxJUF9TSURFRFwiLFxuXG5cdFx0XHRcIlx0XHRmaW5hbE5vcm1hbCA9IC1maW5hbE5vcm1hbDtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIGZpbmFsTm9ybWFsICk7XCIsXG5cdFx0XHRcIlx0dmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcIixcblxuXHRcdFx0XHQvLyBwb2ludCBsaWdodHNcblxuXHRcdFx0XCJcdCNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcIlx0XHR2ZWMzIHBvaW50RGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0dmVjMyBwb2ludFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXG5cblx0XHRcdFwiXHRcdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XCIsXG5cblx0XHRcdFwiXHRcdFx0dmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxuXHRcdFx0XCJcdFx0XHR2ZWMzIHBvaW50VmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxuXG5cdFx0XHRcIlx0XHRcdGZsb2F0IHBvaW50RGlzdGFuY2UgPSAxLjA7XCIsXG5cdFx0XHRcIlx0XHRcdGlmICggcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVwiLFxuXHRcdFx0XCJcdFx0XHRcdHBvaW50RGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBwb2ludFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XCIsXG5cblx0XHRcdFwiXHRcdFx0cG9pbnRWZWN0b3IgPSBub3JtYWxpemUoIHBvaW50VmVjdG9yICk7XCIsXG5cblx0XHRcdFx0XHRcdC8vIGRpZmZ1c2VcblxuXHRcdFx0XCJcdFx0XHQjaWZkZWYgV1JBUF9BUk9VTkRcIixcblxuXHRcdFx0XCJcdFx0XHRcdGZsb2F0IHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdCggbm9ybWFsLCBwb2ludFZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0XHRmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3QoIG5vcm1hbCwgcG9pbnRWZWN0b3IgKSArIDAuNSwgMC4wICk7XCIsXG5cblx0XHRcdFwiXHRcdFx0XHR2ZWMzIHBvaW50RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcblxuXHRcdFx0XCJcdFx0XHQjZWxzZVwiLFxuXG5cdFx0XHRcIlx0XHRcdFx0ZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRWZWN0b3IgKSwgMC4wICk7XCIsXG5cblx0XHRcdFwiXHRcdFx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHRcdFx0cG9pbnREaWZmdXNlICs9IHBvaW50RGlzdGFuY2UgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIGRpZmZ1c2UgKiBwb2ludERpZmZ1c2VXZWlnaHQ7XCIsXG5cblx0XHRcdFx0XHRcdC8vIHNwZWN1bGFyXG5cblx0XHRcdFwiXHRcdFx0dmVjMyBwb2ludEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIHBvaW50VmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IHBvaW50RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0ZmxvYXQgcG9pbnRTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggcG9pbnREb3ROb3JtYWxIYWxmLCBzaGluaW5lc3MgKSwgMC4wICk7XCIsXG5cblx0XHRcdFwiXHRcdFx0ZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCBzaGluaW5lc3MgKyAyLjAgKSAvIDguMDtcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBwb2ludFZlY3RvciwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApLCA1LjAgKTtcIixcblx0XHRcdFwiXHRcdFx0cG9pbnRTcGVjdWxhciArPSBzY2hsaWNrICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0ICogcG9pbnREaXN0YW5jZSAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcblxuXHRcdFx0XCJcdFx0fVwiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFx0Ly8gc3BvdCBsaWdodHNcblxuXHRcdFx0XCJcdCNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHRcdHZlYzMgc3BvdERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdHZlYzMgc3BvdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXG5cblx0XHRcdFwiXHRcdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0dmVjMyBzcG90VmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxuXG5cdFx0XHRcIlx0XHRcdGZsb2F0IHNwb3REaXN0YW5jZSA9IDEuMDtcIixcblx0XHRcdFwiXHRcdFx0aWYgKCBzcG90TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcIixcblx0XHRcdFwiXHRcdFx0XHRzcG90RGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBzcG90VmVjdG9yICkgLyBzcG90TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdHNwb3RWZWN0b3IgPSBub3JtYWxpemUoIHNwb3RWZWN0b3IgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBzcG90TGlnaHRQb3NpdGlvblsgaSBdIC0gdldvcmxkUG9zaXRpb24gKSApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XCIsXG5cblx0XHRcdFwiXHRcdFx0XHRzcG90RWZmZWN0ID0gbWF4KCBwb3coIG1heCggc3BvdEVmZmVjdCwgMC4wICksIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSwgMC4wICk7XCIsXG5cblx0XHRcdFx0XHRcdFx0Ly8gZGlmZnVzZVxuXG5cdFx0XHRcIlx0XHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXCIsXG5cblx0XHRcdFwiXHRcdFx0XHRcdGZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90KCBub3JtYWwsIHNwb3RWZWN0b3IgKSwgMC4wICk7XCIsXG5cdFx0XHRcIlx0XHRcdFx0XHRmbG9hdCBzcG90RGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdCggbm9ybWFsLCBzcG90VmVjdG9yICkgKyAwLjUsIDAuMCApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdFx0XHR2ZWMzIHNwb3REaWZmdXNlV2VpZ2h0ID0gbWl4KCB2ZWMzKCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggc3BvdERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRcdCNlbHNlXCIsXG5cblx0XHRcdFwiXHRcdFx0XHRcdGZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApLCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0XHRcdFx0c3BvdERpZmZ1c2UgKz0gc3BvdERpc3RhbmNlICogc3BvdExpZ2h0Q29sb3JbIGkgXSAqIGRpZmZ1c2UgKiBzcG90RGlmZnVzZVdlaWdodCAqIHNwb3RFZmZlY3Q7XCIsXG5cblx0XHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXJcblxuXHRcdFx0XCJcdFx0XHRcdHZlYzMgc3BvdEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIHNwb3RWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcblx0XHRcdFwiXHRcdFx0XHRmbG9hdCBzcG90RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHNwb3RIYWxmVmVjdG9yICksIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0XHRcdGZsb2F0IHNwb3RTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggc3BvdERvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XCIsXG5cblx0XHRcdFwiXHRcdFx0XHR2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBzcG90VmVjdG9yLCBzcG90SGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XCIsXG5cdFx0XHRcIlx0XHRcdFx0c3BvdFNwZWN1bGFyICs9IHNjaGxpY2sgKiBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdFNwZWN1bGFyV2VpZ2h0ICogc3BvdERpZmZ1c2VXZWlnaHQgKiBzcG90RGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb24gKiBzcG90RWZmZWN0O1wiLFxuXG5cdFx0XHRcIlx0XHRcdH1cIixcblxuXHRcdFx0XCJcdFx0fVwiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFx0Ly8gZGlyZWN0aW9uYWwgbGlnaHRzXG5cblx0XHRcdFwiXHQjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHRcdHZlYzMgZGlyRGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0dmVjMyBkaXJTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxuXG5cdFx0XHRcIlx0XHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpKysgKSB7XCIsXG5cblx0XHRcdFwiXHRcdFx0dmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XCIsXG5cdFx0XHRcIlx0XHRcdHZlYzMgZGlyVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1wiLFxuXG5cdFx0XHRcdFx0XHQvLyBkaWZmdXNlXG5cblx0XHRcdFwiXHRcdFx0I2lmZGVmIFdSQVBfQVJPVU5EXCIsXG5cblx0XHRcdFwiXHRcdFx0XHRmbG9hdCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nRnVsbCA9IG1heCggZG90KCBub3JtYWwsIGRpclZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0XHRmbG9hdCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZiA9IG1heCggMC41ICogZG90KCBub3JtYWwsIGRpclZlY3RvciApICsgMC41LCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRcdHZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0Z1bGwgKSwgdmVjMyggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGYgKSwgd3JhcFJHQiApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdCNlbHNlXCIsXG5cblx0XHRcdFwiXHRcdFx0XHRmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlyVmVjdG9yICksIDAuMCApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0XHRcdGRpckRpZmZ1c2UgKz0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaWZmdXNlICogZGlyRGlmZnVzZVdlaWdodDtcIixcblxuXHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXJcblxuXHRcdFx0XCJcdFx0XHR2ZWMzIGRpckhhbGZWZWN0b3IgPSBub3JtYWxpemUoIGRpclZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxuXHRcdFx0XCJcdFx0XHRmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0ZmxvYXQgZGlyU3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIGRpckRvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGRpclZlY3RvciwgZGlySGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XCIsXG5cdFx0XHRcIlx0XHRcdGRpclNwZWN1bGFyICs9IHNjaGxpY2sgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcblxuXHRcdFx0XCJcdFx0fVwiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFx0Ly8gaGVtaXNwaGVyZSBsaWdodHNcblxuXHRcdFx0XCJcdCNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHRcdHZlYzMgaGVtaURpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdHZlYzMgaGVtaVNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIgLFxuXG5cdFx0XHRcIlx0XHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0XHR2ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XCIsXG5cblx0XHRcdFx0XHRcdC8vIGRpZmZ1c2VcblxuXHRcdFx0XCJcdFx0XHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcIixcblx0XHRcdFwiXHRcdFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZlYzMgaGVtaUNvbG9yID0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdGhlbWlEaWZmdXNlICs9IGRpZmZ1c2UgKiBoZW1pQ29sb3I7XCIsXG5cblx0XHRcdFx0XHRcdC8vIHNwZWN1bGFyIChza3kgbGlnaHQpXG5cblxuXHRcdFx0XCJcdFx0XHR2ZWMzIGhlbWlIYWxmVmVjdG9yU2t5ID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IGhlbWlEb3ROb3JtYWxIYWxmU2t5ID0gMC41ICogZG90KCBub3JtYWwsIGhlbWlIYWxmVmVjdG9yU2t5ICkgKyAwLjU7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IGhlbWlTcGVjdWxhcldlaWdodFNreSA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggbWF4KCBoZW1pRG90Tm9ybWFsSGFsZlNreSwgMC4wICksIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcblxuXHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXIgKGdyb3VuZCBsaWdodClcblxuXHRcdFx0XCJcdFx0XHR2ZWMzIGxWZWN0b3JHcm91bmQgPSAtbFZlY3RvcjtcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWMzIGhlbWlIYWxmVmVjdG9yR3JvdW5kID0gbm9ybWFsaXplKCBsVmVjdG9yR3JvdW5kICsgdmlld1Bvc2l0aW9uICk7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IGhlbWlEb3ROb3JtYWxIYWxmR3JvdW5kID0gMC41ICogZG90KCBub3JtYWwsIGhlbWlIYWxmVmVjdG9yR3JvdW5kICkgKyAwLjU7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggbWF4KCBoZW1pRG90Tm9ybWFsSGFsZkdyb3VuZCwgMC4wICksIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRmbG9hdCBkb3RQcm9kdWN0R3JvdW5kID0gZG90KCBub3JtYWwsIGxWZWN0b3JHcm91bmQgKTtcIixcblxuXHRcdFx0XCJcdFx0XHRmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMCApIC8gOC4wO1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZlYzMgc2NobGlja1NreSA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggbWF4KCAxLjAgLSBkb3QoIGxWZWN0b3IsIGhlbWlIYWxmVmVjdG9yU2t5ICksIDAuMCApLCA1LjAgKTtcIixcblx0XHRcdFwiXHRcdFx0dmVjMyBzY2hsaWNrR3JvdW5kID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3Rvckdyb3VuZCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSwgMC4wICksIDUuMCApO1wiLFxuXHRcdFx0XCJcdFx0XHRoZW1pU3BlY3VsYXIgKz0gaGVtaUNvbG9yICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogKCBzY2hsaWNrU2t5ICogaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ICogbWF4KCBkb3RQcm9kdWN0LCAwLjAgKSArIHNjaGxpY2tHcm91bmQgKiBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgKiBtYXgoIGRvdFByb2R1Y3RHcm91bmQsIDAuMCApICk7XCIsXG5cblx0XHRcdFwiXHRcdH1cIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdC8vIGFsbCBsaWdodHMgY29udHJpYnV0aW9uIHN1bW1hdGlvblxuXG5cdFx0XHRcIlx0dmVjMyB0b3RhbERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFwiXHR2ZWMzIHRvdGFsU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcblxuXHRcdFx0XCJcdCNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcblxuXHRcdFx0XCJcdFx0dG90YWxEaWZmdXNlICs9IGRpckRpZmZ1c2U7XCIsXG5cdFx0XHRcIlx0XHR0b3RhbFNwZWN1bGFyICs9IGRpclNwZWN1bGFyO1wiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHQjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxuXG5cdFx0XHRcIlx0XHR0b3RhbERpZmZ1c2UgKz0gaGVtaURpZmZ1c2U7XCIsXG5cdFx0XHRcIlx0XHR0b3RhbFNwZWN1bGFyICs9IGhlbWlTcGVjdWxhcjtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0I2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHRcdHRvdGFsRGlmZnVzZSArPSBwb2ludERpZmZ1c2U7XCIsXG5cdFx0XHRcIlx0XHR0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XCIsXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XCJcdCNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXG5cblx0XHRcdFwiXHRcdHRvdGFsRGlmZnVzZSArPSBzcG90RGlmZnVzZTtcIixcblx0XHRcdFwiXHRcdHRvdGFsU3BlY3VsYXIgKz0gc3BvdFNwZWN1bGFyO1wiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHQjaWZkZWYgTUVUQUxcIixcblxuXHRcdFx0XCJcdFx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIHRvdGFsRGlmZnVzZSArIGFtYmllbnRMaWdodENvbG9yICogYW1iaWVudCArIHRvdGFsU3BlY3VsYXIgKTtcIixcblxuXHRcdFx0XCJcdCNlbHNlXCIsXG5cblx0XHRcdFwiXHRcdGdsX0ZyYWdDb2xvci54eXogPSBnbF9GcmFnQ29sb3IueHl6ICogKCB0b3RhbERpZmZ1c2UgKyBhbWJpZW50TGlnaHRDb2xvciAqIGFtYmllbnQgKSArIHRvdGFsU3BlY3VsYXI7XCIsXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XCJcdGlmICggZW5hYmxlUmVmbGVjdGlvbiApIHtcIixcblxuXHRcdFx0XCJcdFx0dmVjMyB2UmVmbGVjdDtcIixcblx0XHRcdFwiXHRcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcIixcblxuXHRcdFx0XCJcdFx0aWYgKCB1c2VSZWZyYWN0ICkge1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIG5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XCIsXG5cblx0XHRcdFwiXHRcdH0gZWxzZSB7XCIsXG5cblx0XHRcdFwiXHRcdFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgbm9ybWFsICk7XCIsXG5cblx0XHRcdFwiXHRcdH1cIixcblxuXHRcdFx0XCJcdFx0dmVjNCBjdWJlQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIC12UmVmbGVjdC54LCB2UmVmbGVjdC55eiApICk7XCIsXG5cblx0XHRcdFwiXHRcdCNpZmRlZiBHQU1NQV9JTlBVVFwiLFxuXG5cdFx0XHRcIlx0XHRcdGN1YmVDb2xvci54eXogKj0gY3ViZUNvbG9yLnh5ejtcIixcblxuXHRcdFx0XCJcdFx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHRcdGdsX0ZyYWdDb2xvci54eXogPSBtaXgoIGdsX0ZyYWdDb2xvci54eXosIGN1YmVDb2xvci54eXosIHNwZWN1bGFyVGV4LnIgKiByZWZsZWN0aXZpdHkgKTtcIixcblxuXHRcdFx0XCJcdH1cIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFwiYXR0cmlidXRlIHZlYzQgdGFuZ2VudDtcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdU9mZnNldDtcIixcblx0XHRcdFwidW5pZm9ybSB2ZWMyIHVSZXBlYXQ7XCIsXG5cblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZURpc3BsYWNlbWVudDtcIixcblxuXHRcdFx0XCIjaWZkZWYgVkVSVEVYX1RFWFRVUkVTXCIsXG5cblx0XHRcdFwiXHR1bmlmb3JtIHNhbXBsZXIyRCB0RGlzcGxhY2VtZW50O1wiLFxuXHRcdFx0XCJcdHVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudFNjYWxlO1wiLFxuXHRcdFx0XCJcdHVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudEJpYXM7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZUYW5nZW50O1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkJpbm9ybWFsO1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0Ly8gbm9ybWFsLCB0YW5nZW50IGFuZCBiaW5vcm1hbCB2ZWN0b3JzXG5cblx0XHRcdFwiXHQjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXG5cblx0XHRcdFwiXHRcdHZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHNraW5uZWROb3JtYWwueHl6ICk7XCIsXG5cblx0XHRcdFwiXHRcdHZlYzQgc2tpbm5lZFRhbmdlbnQgPSBza2luTWF0cml4ICogdmVjNCggdGFuZ2VudC54eXosIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0dlRhbmdlbnQgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHNraW5uZWRUYW5nZW50Lnh5eiApO1wiLFxuXG5cdFx0XHRcIlx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XCIsXG5cdFx0XHRcIlx0XHR2VGFuZ2VudCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogdGFuZ2VudC54eXogKTtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0dkJpbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggdk5vcm1hbCwgdlRhbmdlbnQgKSAqIHRhbmdlbnQudyApO1wiLFxuXG5cdFx0XHRcIlx0dlV2ID0gdXYgKiB1UmVwZWF0ICsgdU9mZnNldDtcIixcblxuXHRcdFx0XHQvLyBkaXNwbGFjZW1lbnQgbWFwcGluZ1xuXG5cdFx0XHRcIlx0dmVjMyBkaXNwbGFjZWRQb3NpdGlvbjtcIixcblxuXHRcdFx0XCJcdCNpZmRlZiBWRVJURVhfVEVYVFVSRVNcIixcblxuXHRcdFx0XCJcdFx0aWYgKCBlbmFibGVEaXNwbGFjZW1lbnQgKSB7XCIsXG5cblx0XHRcdFwiXHRcdFx0dmVjMyBkdiA9IHRleHR1cmUyRCggdERpc3BsYWNlbWVudCwgdXYgKS54eXo7XCIsXG5cdFx0XHRcIlx0XHRcdGZsb2F0IGRmID0gdURpc3BsYWNlbWVudFNjYWxlICogZHYueCArIHVEaXNwbGFjZW1lbnRCaWFzO1wiLFxuXHRcdFx0XCJcdFx0XHRkaXNwbGFjZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgbm9ybWFsaXplKCBub3JtYWwgKSAqIGRmO1wiLFxuXG5cdFx0XHRcIlx0XHR9IGVsc2Uge1wiLFxuXG5cdFx0XHRcIlx0XHRcdCNpZmRlZiBVU0VfU0tJTk5JTkdcIixcblxuXHRcdFx0XCJcdFx0XHRcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFwiXHRcdFx0XHR2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcIixcblx0XHRcdFwiXHRcdFx0XHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcIixcblx0XHRcdFwiXHRcdFx0XHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcIixcblx0XHRcdFwiXHRcdFx0XHRza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcIixcblx0XHRcdFwiXHRcdFx0XHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcIixcblx0XHRcdFwiXHRcdFx0XHRza2lubmVkICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZDtcIixcblxuXHRcdFx0XCJcdFx0XHRcdGRpc3BsYWNlZFBvc2l0aW9uID0gc2tpbm5lZC54eXo7XCIsXG5cblx0XHRcdFwiXHRcdFx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0XHRcdGRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XCIsXG5cblx0XHRcdFwiXHRcdFx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHRcdH1cIixcblxuXHRcdFx0XCJcdCNlbHNlXCIsXG5cblx0XHRcdFwiXHRcdCNpZmRlZiBVU0VfU0tJTk5JTkdcIixcblxuXHRcdFx0XCJcdFx0XHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1wiLFxuXHRcdFx0XCJcdFx0XHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcIixcblx0XHRcdFwiXHRcdFx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XCIsXG5cdFx0XHRcIlx0XHRcdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1wiLFxuXHRcdFx0XCJcdFx0XHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcIixcblx0XHRcdFwiXHRcdFx0c2tpbm5lZCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQ7XCIsXG5cblx0XHRcdFwiXHRcdFx0ZGlzcGxhY2VkUG9zaXRpb24gPSBza2lubmVkLnh5ejtcIixcblxuXHRcdFx0XCJcdFx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0XHRkaXNwbGFjZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcIlx0XHQjZW5kaWZcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFwiXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBkaXNwbGFjZWRQb3NpdGlvbiwgMS4wICk7XCIsXG5cdFx0XHRcIlx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBkaXNwbGFjZWRQb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XCJcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XCIsXG5cdFx0XHRcIlx0dlZpZXdQb3NpdGlvbiA9IC1tdlBvc2l0aW9uLnh5ejtcIixcblxuXHRcdFx0XHQvLyBzaGFkb3dzXG5cblx0XHRcdFwiXHQjaWZkZWYgVVNFX1NIQURPV01BUFwiLFxuXG5cdFx0XHRcIlx0XHRmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1wiLFxuXG5cdFx0XHRcIlx0XHRcdHZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcIlx0XHR9XCIsXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH0sXG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvL1x0Q3ViZSBtYXAgc2hhZGVyXG5cdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0J2N1YmUnOiB7XG5cblx0XHR1bmlmb3JtczogeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XHRcdFx0XCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH0gfSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXHRcdFx0XCJcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XCIsXG5cblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCB0RmxpcDtcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKFwiXFxuXCIpXG5cblx0fSxcblxuXHQvKiBEZXB0aCBlbmNvZGluZyBpbnRvIFJHQkEgdGV4dHVyZVxuXHQgKlxuXHQgKiBiYXNlZCBvbiBTcGlkZXJHTCBzaGFkb3cgbWFwIGV4YW1wbGVcblx0ICogaHR0cDovL3NwaWRlcmdsLm9yZy9leGFtcGxlLnBocD9pZD02XG5cdCAqXG5cdCAqIG9yaWdpbmFsbHkgZnJvbVxuXHQgKiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzQ0MjEzOC1wYWNraW5nLWEtZmxvYXQtaW50by1hLWE4cjhnOGI4LXRleHR1cmUtc2hhZGVyL3BhZ2VfX3doaWNocGFnZV9fMSUyNUVGJTI1QkYlMjVCRFxuXHQgKlxuXHQgKiBzZWUgYWxzb1xuXHQgKiBodHRwOi8vYXJhcy1wLmluZm8vYmxvZy8yMDA5LzA3LzMwL2VuY29kaW5nLWZsb2F0cy10by1yZ2JhLXRoZS1maW5hbC9cblx0ICovXG5cblx0J2RlcHRoUkdCQSc6IHtcblxuXHRcdHVuaWZvcm1zOiB7fSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZlYzQgcGFja19kZXB0aCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XCIsXG5cblx0XHRcdFwiXHRjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxuXHRcdFx0XCJcdGNvbnN0IHZlYzQgYml0X21hc2sgPSB2ZWM0KCAwLjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAgKTtcIixcblx0XHRcdFwiXHR2ZWM0IHJlcyA9IG1vZCggZGVwdGggKiBiaXRfc2hpZnQgKiB2ZWM0KCAyNTUgKSwgdmVjNCggMjU2ICkgKSAvIHZlYzQoIDI1NSApO1wiLCAvLyBcIlx0dmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRfc2hpZnQgKTtcIixcblx0XHRcdFwiXHRyZXMgLT0gcmVzLnh4eXogKiBiaXRfbWFzaztcIixcblx0XHRcdFwiXHRyZXR1cm4gcmVzO1wiLFxuXG5cdFx0XHRcIn1cIixcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIlx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcIixcblxuXHRcdFx0XCJcdFx0Z2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdEZXB0aEVYVCApO1wiLFxuXG5cdFx0XHRcIlx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0Z2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56ICk7XCIsXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcblx0XHRcdFx0Ly9cImZsb2F0IHogPSAoICggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApIC0gMy4wICkgLyAoIDQwMDAuMCAtIDMuMCApO1wiLFxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIHogKTtcIixcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbihcIlxcblwiKVxuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBUSFJFRS5SRVZJU0lPTiApO1xuXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcblx0X2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXG5cblx0X3ByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCcsXG5cblx0X2FscGhhID0gcGFyYW1ldGVycy5hbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbHBoYSA6IGZhbHNlLFxuXHRfZGVwdGggPSBwYXJhbWV0ZXJzLmRlcHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmRlcHRoIDogdHJ1ZSxcblx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXG5cdF9hbnRpYWxpYXMgPSBwYXJhbWV0ZXJzLmFudGlhbGlhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbnRpYWxpYXMgOiBmYWxzZSxcblx0X3ByZW11bHRpcGxpZWRBbHBoYSA9IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA6IHRydWUsXG5cdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcblx0X2xvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA6IGZhbHNlLFxuXG5cdF9jbGVhckNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApLFxuXHRfY2xlYXJBbHBoYSA9IDA7XG5cblx0dmFyIGxpZ2h0cyA9IFtdO1xuXG5cdHZhciBfd2ViZ2xPYmplY3RzID0ge307XG5cdHZhciBfd2ViZ2xPYmplY3RzSW1tZWRpYXRlID0gW107XG5cblx0dmFyIG9wYXF1ZU9iamVjdHMgPSBbXTtcblx0dmFyIHRyYW5zcGFyZW50T2JqZWN0cyA9IFtdO1xuXG5cdHZhciBzcHJpdGVzID0gW107XG5cdHZhciBsZW5zRmxhcmVzID0gW107XG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXNcblxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuXHR0aGlzLmNvbnRleHQgPSBudWxsO1xuXHR0aGlzLmRldmljZVBpeGVsUmF0aW8gPSBwYXJhbWV0ZXJzLmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQgPyBwYXJhbWV0ZXJzLmRldmljZVBpeGVsUmF0aW9cblx0XHRcdFx0IDogc2VsZi5kZXZpY2VQaXhlbFJhdGlvICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQgPyBzZWxmLmRldmljZVBpeGVsUmF0aW9cblx0XHRcdFx0XHQgOiAxO1xuXG5cdC8vIGNsZWFyaW5nXG5cblx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuXHR0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcblx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG5cdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XG5cblx0Ly8gc2NlbmUgZ3JhcGhcblxuXHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcblxuXHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcblxuXHR0aGlzLmdhbW1hSW5wdXQgPSBmYWxzZTtcblx0dGhpcy5nYW1tYU91dHB1dCA9IGZhbHNlO1xuXG5cdC8vIHNoYWRvdyBtYXBcblxuXHR0aGlzLnNoYWRvd01hcEVuYWJsZWQgPSBmYWxzZTtcblx0dGhpcy5zaGFkb3dNYXBUeXBlID0gVEhSRUUuUENGU2hhZG93TWFwO1xuXHR0aGlzLnNoYWRvd01hcEN1bGxGYWNlID0gVEhSRUUuQ3VsbEZhY2VGcm9udDtcblx0dGhpcy5zaGFkb3dNYXBEZWJ1ZyA9IGZhbHNlO1xuXHR0aGlzLnNoYWRvd01hcENhc2NhZGUgPSBmYWxzZTtcblxuXHQvLyBtb3JwaHNcblxuXHR0aGlzLm1heE1vcnBoVGFyZ2V0cyA9IDg7XG5cdHRoaXMubWF4TW9ycGhOb3JtYWxzID0gNDtcblxuXHQvLyBmbGFnc1xuXG5cdHRoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgPSB0cnVlO1xuXG5cdC8vIGluZm9cblxuXHR0aGlzLmluZm8gPSB7XG5cblx0XHRtZW1vcnk6IHtcblxuXHRcdFx0cHJvZ3JhbXM6IDAsXG5cdFx0XHRnZW9tZXRyaWVzOiAwLFxuXHRcdFx0dGV4dHVyZXM6IDBcblxuXHRcdH0sXG5cblx0XHRyZW5kZXI6IHtcblxuXHRcdFx0Y2FsbHM6IDAsXG5cdFx0XHR2ZXJ0aWNlczogMCxcblx0XHRcdGZhY2VzOiAwLFxuXHRcdFx0cG9pbnRzOiAwXG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXG5cblx0dmFyIF90aGlzID0gdGhpcyxcblxuXHRfcHJvZ3JhbXMgPSBbXSxcblxuXHQvLyBpbnRlcm5hbCBzdGF0ZSBjYWNoZVxuXG5cdF9jdXJyZW50UHJvZ3JhbSA9IG51bGwsXG5cdF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxuXHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDEsXG5cdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtIDEsXG5cdF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcblxuXHRfdXNlZFRleHR1cmVVbml0cyA9IDAsXG5cblx0Ly8gR0wgc3RhdGUgY2FjaGVcblxuXHRfb2xkRG91YmxlU2lkZWQgPSAtIDEsXG5cdF9vbGRGbGlwU2lkZWQgPSAtIDEsXG5cblx0X29sZEJsZW5kaW5nID0gLSAxLFxuXG5cdF9vbGRCbGVuZEVxdWF0aW9uID0gLSAxLFxuXHRfb2xkQmxlbmRTcmMgPSAtIDEsXG5cdF9vbGRCbGVuZERzdCA9IC0gMSxcblxuXHRfb2xkRGVwdGhUZXN0ID0gLSAxLFxuXHRfb2xkRGVwdGhXcml0ZSA9IC0gMSxcblxuXHRfb2xkUG9seWdvbk9mZnNldCA9IG51bGwsXG5cdF9vbGRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbCxcblx0X29sZFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGwsXG5cblx0X29sZExpbmVXaWR0aCA9IG51bGwsXG5cblx0X3ZpZXdwb3J0WCA9IDAsXG5cdF92aWV3cG9ydFkgPSAwLFxuXHRfdmlld3BvcnRXaWR0aCA9IF9jYW52YXMud2lkdGgsXG5cdF92aWV3cG9ydEhlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxuXHRfY3VycmVudFdpZHRoID0gMCxcblx0X2N1cnJlbnRIZWlnaHQgPSAwLFxuXG5cdF9uZXdBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICksXG5cdF9lbmFibGVkQXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApLFxuXG5cdC8vIGZydXN0dW1cblxuXHRfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXG5cblx0IC8vIGNhbWVyYSBtYXRyaWNlcyBjYWNoZVxuXG5cdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcblx0X3Byb2pTY3JlZW5NYXRyaXhQUyA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cblx0X3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG5cdC8vIGxpZ2h0IGFycmF5cyBjYWNoZVxuXG5cdF9kaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG5cdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZSxcblxuXHRfbGlnaHRzID0ge1xuXG5cdFx0YW1iaWVudDogWyAwLCAwLCAwIF0sXG5cdFx0ZGlyZWN0aW9uYWw6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6W10sIHBvc2l0aW9uczogW10gfSxcblx0XHRwb2ludDogeyBsZW5ndGg6IDAsIGNvbG9yczogW10sIHBvc2l0aW9uczogW10sIGRpc3RhbmNlczogW10gfSxcblx0XHRzcG90OiB7IGxlbmd0aDogMCwgY29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSwgZGlzdGFuY2VzOiBbXSwgZGlyZWN0aW9uczogW10sIGFuZ2xlc0NvczogW10sIGV4cG9uZW50czogW10gfSxcblx0XHRoZW1pOiB7IGxlbmd0aDogMCwgc2t5Q29sb3JzOiBbXSwgZ3JvdW5kQ29sb3JzOiBbXSwgcG9zaXRpb25zOiBbXSB9XG5cblx0fTtcblxuXHQvLyBpbml0aWFsaXplXG5cblx0dmFyIF9nbDtcblxuXHR0cnkge1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB7XG5cdFx0XHRhbHBoYTogX2FscGhhLFxuXHRcdFx0ZGVwdGg6IF9kZXB0aCxcblx0XHRcdHN0ZW5jaWw6IF9zdGVuY2lsLFxuXHRcdFx0YW50aWFsaWFzOiBfYW50aWFsaWFzLFxuXHRcdFx0cHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxuXHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyXG5cdFx0fTtcblxuXHRcdF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcblxuXHRcdGlmICggX2dsID09PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJykgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggZXJyb3IgKTtcblxuXHR9XG5cblx0aWYgKCBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQncmFuZ2VNaW4nOiAxLFxuXHRcdFx0XHQncmFuZ2VNYXgnOiAxLFxuXHRcdFx0XHQncHJlY2lzaW9uJzogMVxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHR9XG5cblx0dmFyIGV4dGVuc2lvbnMgPSBuZXcgVEhSRUUuV2ViR0xFeHRlbnNpb25zKCBfZ2wgKTtcblxuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcblx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XG5cblx0aWYgKCBfbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcblxuXHRcdGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICk7XG5cblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gc2V0RGVmYXVsdEdMU3RhdGUoKSB7XG5cblx0XHRfZ2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xuXHRcdF9nbC5jbGVhckRlcHRoKCAxICk7XG5cdFx0X2dsLmNsZWFyU3RlbmNpbCggMCApO1xuXG5cdFx0X2dsLmVuYWJsZSggX2dsLkRFUFRIX1RFU1QgKTtcblx0XHRfZ2wuZGVwdGhGdW5jKCBfZ2wuTEVRVUFMICk7XG5cblx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xuXHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBfZ2wuRlVOQ19BREQgKTtcblx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG5cdFx0X2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XG5cblx0XHRfZ2wuY2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuXHR9XG5cblx0c2V0RGVmYXVsdEdMU3RhdGUoKTtcblxuXHR0aGlzLmNvbnRleHQgPSBfZ2w7XG5cblx0Ly8gR1BVIGNhcGFiaWxpdGllc1xuXG5cdHZhciBfbWF4VGV4dHVyZXMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblx0dmFyIF9tYXhWZXJ0ZXhUZXh0dXJlcyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblx0dmFyIF9tYXhUZXh0dXJlU2l6ZSA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVEVYVFVSRV9TSVpFICk7XG5cdHZhciBfbWF4Q3ViZW1hcFNpemUgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xuXG5cdHZhciBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IF9tYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XG5cdHZhciBfc3VwcG9ydHNCb25lVGV4dHVyZXMgPSBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXG5cdC8vXG5cblx0dmFyIF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25IaWdocEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5ISUdIX0ZMT0FUICk7XG5cdHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5NRURJVU1fRkxPQVQgKTtcblx0dmFyIF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25Mb3dwRmxvYXQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuVkVSVEVYX1NIQURFUiwgX2dsLkxPV19GTE9BVCApO1xuXG5cdHZhciBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25IaWdocEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLkZSQUdNRU5UX1NIQURFUiwgX2dsLkhJR0hfRkxPQVQgKTtcblx0dmFyIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbk1lZGl1bXBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5NRURJVU1fRkxPQVQgKTtcblx0dmFyIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbkxvd3BGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5MT1dfRkxPQVQgKTtcblxuXHR2YXIgZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgYXJyYXk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIGFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGFycmF5ID0gW107XG5cblx0XHRcdGlmICggZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSApIHtcblxuXHRcdFx0XHR2YXIgZm9ybWF0cyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpICsrICl7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHQvLyBjbGFtcCBwcmVjaXNpb24gdG8gbWF4aW11bSBhdmFpbGFibGVcblxuXHR2YXIgaGlnaHBBdmFpbGFibGUgPSBfdmVydGV4U2hhZGVyUHJlY2lzaW9uSGlnaHBGbG9hdC5wcmVjaXNpb24gPiAwICYmIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbkhpZ2hwRmxvYXQucHJlY2lzaW9uID4gMDtcblx0dmFyIG1lZGl1bXBBdmFpbGFibGUgPSBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDAgJiYgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDA7XG5cblx0aWYgKCBfcHJlY2lzaW9uID09PSAnaGlnaHAnICYmICEgaGlnaHBBdmFpbGFibGUgKSB7XG5cblx0XHRpZiAoIG1lZGl1bXBBdmFpbGFibGUgKSB7XG5cblx0XHRcdF9wcmVjaXNpb24gPSAnbWVkaXVtcCc7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBoaWdocCBub3Qgc3VwcG9ydGVkLCB1c2luZyBtZWRpdW1wLicgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9wcmVjaXNpb24gPSAnbG93cCc7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBoaWdocCBhbmQgbWVkaXVtcCBub3Qgc3VwcG9ydGVkLCB1c2luZyBsb3dwLicgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0aWYgKCBfcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgJiYgISBtZWRpdW1wQXZhaWxhYmxlICkge1xuXG5cdFx0X3ByZWNpc2lvbiA9ICdsb3dwJztcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBtZWRpdW1wIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIGxvd3AuJyApO1xuXG5cdH1cblxuXHQvLyBQbHVnaW5zXG5cblx0dmFyIHNoYWRvd01hcFBsdWdpbiA9IG5ldyBUSFJFRS5TaGFkb3dNYXBQbHVnaW4oIHRoaXMsIGxpZ2h0cywgX3dlYmdsT2JqZWN0cywgX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSApO1xuXG5cdHZhciBzcHJpdGVQbHVnaW4gPSBuZXcgVEhSRUUuU3ByaXRlUGx1Z2luKCB0aGlzLCBzcHJpdGVzICk7XG5cdHZhciBsZW5zRmxhcmVQbHVnaW4gPSBuZXcgVEhSRUUuTGVuc0ZsYXJlUGx1Z2luKCB0aGlzLCBsZW5zRmxhcmVzICk7XG5cblx0Ly8gQVBJXG5cblx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIF9nbDtcblxuXHR9O1xuXG5cdHRoaXMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcztcblxuXHR9O1xuXG5cdHRoaXMuc3VwcG9ydHNGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG5cblx0fTtcblxuXHR0aGlzLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcblxuXHR9O1xuXG5cdHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuXHR9O1xuXG5cdHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG5cdH07XG5cblx0dGhpcy5zdXBwb3J0c0JsZW5kTWluTWF4ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0TWF4QW5pc290cm9weSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHZhbHVlO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cblx0XHRcdHZhbHVlID0gZXh0ZW5zaW9uICE9PSBudWxsID8gX2dsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApIDogMDtcblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fVxuXG5cdH0gKSgpO1xuXG5cdHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIF9wcmVjaXNpb247XG5cblx0fTtcblxuXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xuXG5cdFx0X2NhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xuXG5cdFx0aWYgKCB1cGRhdGVTdHlsZSAhPT0gZmFsc2UgKSB7XG5cblx0XHRcdF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0fTtcblxuXHR0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0X3ZpZXdwb3J0WCA9IHggKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XG5cdFx0X3ZpZXdwb3J0WSA9IHkgKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XG5cblx0XHRfdmlld3BvcnRXaWR0aCA9IHdpZHRoICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdF92aWV3cG9ydEhlaWdodCA9IGhlaWdodCAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbztcblxuXHRcdF9nbC52aWV3cG9ydCggX3ZpZXdwb3J0WCwgX3ZpZXdwb3J0WSwgX3ZpZXdwb3J0V2lkdGgsIF92aWV3cG9ydEhlaWdodCApO1xuXG5cdH07XG5cblx0dGhpcy5zZXRTY2lzc29yID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0X2dsLnNjaXNzb3IoXG5cdFx0XHR4ICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvLFxuXHRcdFx0eSAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyxcblx0XHRcdHdpZHRoICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvLFxuXHRcdFx0aGVpZ2h0ICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvXG5cdFx0KTtcblxuXHR9O1xuXG5cdHRoaXMuZW5hYmxlU2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIGVuYWJsZSApIHtcblxuXHRcdGVuYWJsZSA/IF9nbC5lbmFibGUoIF9nbC5TQ0lTU09SX1RFU1QgKSA6IF9nbC5kaXNhYmxlKCBfZ2wuU0NJU1NPUl9URVNUICk7XG5cblx0fTtcblxuXHQvLyBDbGVhcmluZ1xuXG5cdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xuXG5cdFx0X2NsZWFyQ29sb3Iuc2V0KCBjb2xvciApO1xuXHRcdF9jbGVhckFscGhhID0gYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogMTtcblxuXHRcdF9nbC5jbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG5cdH07XG5cblx0dGhpcy5zZXRDbGVhckNvbG9ySGV4ID0gZnVuY3Rpb24gKCBoZXgsIGFscGhhICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNldENsZWFyQ29sb3JIZXgoKSBpcyBiZWluZyByZW1vdmVkLiBVc2UgLnNldENsZWFyQ29sb3IoKSBpbnN0ZWFkLicgKTtcblx0XHR0aGlzLnNldENsZWFyQ29sb3IoIGhleCwgYWxwaGEgKTtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfY2xlYXJDb2xvcjtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBfY2xlYXJBbHBoYTtcblxuXHR9O1xuXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuXHRcdHZhciBiaXRzID0gMDtcblxuXHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCB8fCBjb2xvciApIGJpdHMgfD0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XG5cdFx0aWYgKCBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcblx0XHRpZiAoIHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xuXG5cdFx0X2dsLmNsZWFyKCBiaXRzICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRfZ2wuY2xlYXIoIF9nbC5DT0xPUl9CVUZGRVJfQklUICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRfZ2wuY2xlYXIoIF9nbC5ERVBUSF9CVUZGRVJfQklUICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdF9nbC5jbGVhciggX2dsLlNURU5DSUxfQlVGRkVSX0JJVCApO1xuXG5cdH07XG5cblx0dGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0dGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XG5cblx0fTtcblxuXHQvLyBSZXNldFxuXG5cdHRoaXMucmVzZXRHTFN0YXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcblx0XHRfY3VycmVudENhbWVyYSA9IG51bGw7XG5cblx0XHRfb2xkQmxlbmRpbmcgPSAtIDE7XG5cdFx0X29sZERlcHRoVGVzdCA9IC0gMTtcblx0XHRfb2xkRGVwdGhXcml0ZSA9IC0gMTtcblx0XHRfb2xkRG91YmxlU2lkZWQgPSAtIDE7XG5cdFx0X29sZEZsaXBTaWRlZCA9IC0gMTtcblx0XHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gLSAxO1xuXHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcblxuXHRcdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHR9O1xuXG5cdC8vIEJ1ZmZlciBhbGxvY2F0aW9uXG5cblx0ZnVuY3Rpb24gY3JlYXRlUGFydGljbGVCdWZmZXJzICggZ2VvbWV0cnkgKSB7XG5cblx0XHRnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVMaW5lQnVmZmVycyAoIGdlb21ldHJ5ICkge1xuXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnkuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVNZXNoQnVmZmVycyAoIGdlb21ldHJ5R3JvdXAgKSB7XG5cblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTm9ybWFsQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFRhbmdlbnRCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsVVZCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsVVYyQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHR2YXIgbSwgbWw7XG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzID0gW107XG5cblx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVycy5wdXNoKCBfZ2wuY3JlYXRlQnVmZmVyKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFscyApIHtcblxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVycyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBtID0gMCwgbWwgPSBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFsczsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnMucHVzaCggX2dsLmNyZWF0ZUJ1ZmZlcigpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XG5cblx0fTtcblxuXHQvLyBFdmVudHNcblxuXHR2YXIgb25PYmplY3RSZW1vdmVkID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdHZhciBvYmplY3QgPSBldmVudC50YXJnZXQ7XG5cblx0XHRvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdGNoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZW1vdmUnLCBvbk9iamVjdFJlbW92ZWQgKTtcblxuXHRcdFx0cmVtb3ZlT2JqZWN0KCBjaGlsZCApO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0dmFyIG9uR2VvbWV0cnlEaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcblxuXHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuXHRcdGRlYWxsb2NhdGVHZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHR9O1xuXG5cdHZhciBvblRleHR1cmVEaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdHZhciB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuXHRcdGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XG5cblx0XHRfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyAtLTtcblxuXG5cdH07XG5cblx0dmFyIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0cmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cblx0XHRkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzIC0tO1xuXG5cdH07XG5cblx0dmFyIG9uTWF0ZXJpYWxEaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdHZhciBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHRcdGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHR9O1xuXG5cdC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cblxuXHR2YXIgZGVsZXRlQnVmZmVycyA9IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cdFxuXHRcdHZhciBidWZmZXJzID0gW1xuXHRcdFx0J19fd2ViZ2xWZXJ0ZXhCdWZmZXInLFxuXHRcdFx0J19fd2ViZ2xOb3JtYWxCdWZmZXInLFxuXHRcdFx0J19fd2ViZ2xUYW5nZW50QnVmZmVyJyxcblx0XHRcdCdfX3dlYmdsQ29sb3JCdWZmZXInLFxuXHRcdFx0J19fd2ViZ2xVVkJ1ZmZlcicsXG5cdFx0XHQnX193ZWJnbFVWMkJ1ZmZlcicsXG5cdFx0XHRcblx0XHRcdCdfX3dlYmdsU2tpbkluZGljZXNCdWZmZXInLFxuXHRcdFx0J19fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlcicsXG5cdFx0XHRcblx0XHRcdCdfX3dlYmdsRmFjZUJ1ZmZlcicsXG5cdFx0XHQnX193ZWJnbExpbmVCdWZmZXInLFxuXHRcdFx0XG5cdFx0XHQnX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlcidcblx0XHRdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbmFtZSA9IGJ1ZmZlcnNbIGkgXTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeVsgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlbIG5hbWUgXSApO1xuXG5cdFx0XHRcdGRlbGV0ZSBnZW9tZXRyeVsgbmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBjdXN0b20gYXR0cmlidXRlc1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ICkge1xuXG5cdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdFsgbmFtZSBdLmJ1ZmZlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3Q7XG5cblx0XHR9XG5cblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xuXG5cdH07XG5cblx0dmFyIGRlYWxsb2NhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHRkZWxldGUgZ2VvbWV0cnkuX193ZWJnbEluaXQ7XG5cblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5idWZmZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGF0dHJpYnV0ZS5idWZmZXIgKTtcblxuXHRcdFx0XHRcdGRlbGV0ZSBhdHRyaWJ1dGUuYnVmZmVyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5R3JvdXBzTGlzdCA9IGdlb21ldHJ5R3JvdXBzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5R3JvdXBzTGlzdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCxsID0gZ2VvbWV0cnlHcm91cHNMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5R3JvdXBzTGlzdFsgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHM7IG0gPCBtbDsgbSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyBtIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVycztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaE5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgbSBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkZWxldGVCdWZmZXJzKCBnZW9tZXRyeUdyb3VwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3Vwc1sgZ2VvbWV0cnkuaWQgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkZWxldGVCdWZmZXJzKCBnZW9tZXRyeSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBUT0ZJWDogV29ya2Fyb3VuZCBmb3IgZGVsZXRlZCBnZW9tZXRyeSBiZWluZyBjdXJyZW50bHkgYm91bmRcblxuXHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtIDE7XG5cblx0fTtcblxuXHR2YXIgZGVhbGxvY2F0ZVRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cblx0XHRpZiAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKSB7XG5cblx0XHRcdC8vIGN1YmUgdGV4dHVyZVxuXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuXHRcdFx0ZGVsZXRlIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gMkQgdGV4dHVyZVxuXG5cdFx0XHRpZiAoIHRleHR1cmUuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdFx0ZGVsZXRlIHRleHR1cmUuX193ZWJnbFRleHR1cmU7XG5cdFx0XHRkZWxldGUgdGV4dHVyZS5fX3dlYmdsSW5pdDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHZhciBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRpZiAoICEgcmVuZGVyVGFyZ2V0IHx8IHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0ZGVsZXRlIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZTtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICk7XG5cdFx0XHRcdF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cdFx0XHRfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXI7XG5cdFx0ZGVsZXRlIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyO1xuXG5cdH07XG5cblx0dmFyIGRlYWxsb2NhdGVNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XG5cblx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsLnByb2dyYW0ucHJvZ3JhbTtcblxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHVuZGVmaW5lZDtcblxuXHRcdC8vIG9ubHkgZGVhbGxvY2F0ZSBHTCBwcm9ncmFtIGlmIHRoaXMgd2FzIHRoZSBsYXN0IHVzZSBvZiBzaGFyZWQgcHJvZ3JhbVxuXHRcdC8vIGFzc3VtZWQgdGhlcmUgaXMgb25seSBzaW5nbGUgY29weSBvZiBhbnkgcHJvZ3JhbSBpbiB0aGUgX3Byb2dyYW1zIGxpc3Rcblx0XHQvLyAodGhhdCdzIGhvdyBpdCdzIGNvbnN0cnVjdGVkKVxuXG5cdFx0dmFyIGksIGlsLCBwcm9ncmFtSW5mbztcblx0XHR2YXIgZGVsZXRlUHJvZ3JhbSA9IGZhbHNlO1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gX3Byb2dyYW1zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRwcm9ncmFtSW5mbyA9IF9wcm9ncmFtc1sgaSBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1JbmZvLnByb2dyYW0gPT09IHByb2dyYW0gKSB7XG5cblx0XHRcdFx0cHJvZ3JhbUluZm8udXNlZFRpbWVzIC0tO1xuXG5cdFx0XHRcdGlmICggcHJvZ3JhbUluZm8udXNlZFRpbWVzID09PSAwICkge1xuXG5cdFx0XHRcdFx0ZGVsZXRlUHJvZ3JhbSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGRlbGV0ZVByb2dyYW0gPT09IHRydWUgKSB7XG5cblx0XHRcdC8vIGF2b2lkIHVzaW5nIGFycmF5LnNwbGljZSwgdGhpcyBpcyBjb3N0bGllciB0aGFuIGNyZWF0aW5nIG5ldyBhcnJheSBmcm9tIHNjcmF0Y2hcblxuXHRcdFx0dmFyIG5ld1Byb2dyYW1zID0gW107XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IF9wcm9ncmFtcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRwcm9ncmFtSW5mbyA9IF9wcm9ncmFtc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggcHJvZ3JhbUluZm8ucHJvZ3JhbSAhPT0gcHJvZ3JhbSApIHtcblxuXHRcdFx0XHRcdG5ld1Byb2dyYW1zLnB1c2goIHByb2dyYW1JbmZvICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF9wcm9ncmFtcyA9IG5ld1Byb2dyYW1zO1xuXG5cdFx0XHRfZ2wuZGVsZXRlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG5cdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS5wcm9ncmFtcyAtLTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEJ1ZmZlciBpbml0aWFsaXphdGlvblxuXG5cdGZ1bmN0aW9uIGluaXRDdXN0b21BdHRyaWJ1dGVzICggb2JqZWN0ICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdHZhciBudmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRpZiAoIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ID0gW107XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbWF0ZXJpYWwuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gbWF0ZXJpYWwuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRcdGlmICggISBhdHRyaWJ1dGUuX193ZWJnbEluaXRpYWxpemVkIHx8IGF0dHJpYnV0ZS5jcmVhdGVVbmlxdWVCdWZmZXJzICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLl9fd2ViZ2xJbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHRcdFx0XHR2YXIgc2l6ZSA9IDE7ICAgLy8gXCJmXCIgYW5kIFwiaVwiXG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjInICkgc2l6ZSA9IDI7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjMnICkgc2l6ZSA9IDM7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjQnICkgc2l6ZSA9IDQ7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAnYycgICkgc2l6ZSA9IDM7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuc2l6ZSA9IHNpemU7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiBzaXplICk7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuYnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlID0gbmFtZTtcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdC5wdXNoKCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdFBhcnRpY2xlQnVmZmVycyAoIGdlb21ldHJ5LCBvYmplY3QgKSB7XG5cblx0XHR2YXIgbnZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoO1xuXG5cdFx0Z2VvbWV0cnkuX192ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcblx0XHRnZW9tZXRyeS5fX2NvbG9yQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XG5cblx0XHRnZW9tZXRyeS5fX3NvcnRBcnJheSA9IFtdO1xuXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFBhcnRpY2xlQ291bnQgPSBudmVydGljZXM7XG5cblx0XHRpbml0Q3VzdG9tQXR0cmlidXRlcyggb2JqZWN0ICk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBpbml0TGluZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgb2JqZWN0ICkge1xuXG5cdFx0dmFyIG52ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdGdlb21ldHJ5Ll9fdmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XG5cdFx0Z2VvbWV0cnkuX19jb2xvckFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xuXHRcdGdlb21ldHJ5Ll9fbGluZURpc3RhbmNlQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAxICk7XG5cblx0XHRnZW9tZXRyeS5fX3dlYmdsTGluZUNvdW50ID0gbnZlcnRpY2VzO1xuXG5cdFx0aW5pdEN1c3RvbUF0dHJpYnV0ZXMoIG9iamVjdCApO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdE1lc2hCdWZmZXJzICggZ2VvbWV0cnlHcm91cCwgb2JqZWN0ICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LFxuXHRcdFx0ZmFjZXMzID0gZ2VvbWV0cnlHcm91cC5mYWNlczMsXG5cblx0XHRcdG52ZXJ0aWNlcyA9IGZhY2VzMy5sZW5ndGggKiAzLFxuXHRcdFx0bnRyaXMgICAgID0gZmFjZXMzLmxlbmd0aCAqIDEsXG5cdFx0XHRubGluZXMgICAgPSBmYWNlczMubGVuZ3RoICogMyxcblxuXHRcdFx0bWF0ZXJpYWwgPSBnZXRCdWZmZXJNYXRlcmlhbCggb2JqZWN0LCBnZW9tZXRyeUdyb3VwICk7XG5cblx0XHRnZW9tZXRyeUdyb3VwLl9fdmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX25vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xuXHRcdGdlb21ldHJ5R3JvdXAuX19jb2xvckFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xuXHRcdGdlb21ldHJ5R3JvdXAuX191dkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMiApO1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5mYWNlVmVydGV4VXZzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdGdlb21ldHJ5R3JvdXAuX191djJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuaGFzVGFuZ2VudHMgKSB7XG5cblx0XHRcdGdlb21ldHJ5R3JvdXAuX190YW5nZW50QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiA0ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggJiYgb2JqZWN0Lmdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCApIHtcblxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3NraW5JbmRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogNCApO1xuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3NraW5XZWlnaHRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDQgKTtcblxuXHRcdH1cblxuXHRcdHZhciBVaW50QXJyYXkgPSBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgIT09IG51bGwgJiYgbnRyaXMgPiAyMTg0NSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7IC8vIDY1NTM1IC8gM1xuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3R5cGVBcnJheSA9IFVpbnRBcnJheTtcblx0XHRnZW9tZXRyeUdyb3VwLl9fZmFjZUFycmF5ID0gbmV3IFVpbnRBcnJheSggbnRyaXMgKiAzICk7XG5cdFx0Z2VvbWV0cnlHcm91cC5fX2xpbmVBcnJheSA9IG5ldyBVaW50QXJyYXkoIG5saW5lcyAqIDIgKTtcblxuXHRcdHZhciBtLCBtbDtcblxuXHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdGdlb21ldHJ5R3JvdXAuX19tb3JwaFRhcmdldHNBcnJheXMgPSBbXTtcblxuXHRcdFx0Zm9yICggbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHM7IG0gPCBtbDsgbSArKyApIHtcblxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhUYXJnZXRzQXJyYXlzLnB1c2goIG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzICkge1xuXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhOb3JtYWxzQXJyYXlzID0gW107XG5cblx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX21vcnBoTm9ybWFsc0FycmF5cy5wdXNoKCBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50ID0gbnRyaXMgKiAzO1xuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVDb3VudCA9IG5saW5lcyAqIDI7XG5cblxuXHRcdC8vIGN1c3RvbSBhdHRyaWJ1dGVzXG5cblx0XHRpZiAoIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gRG8gYSBzaGFsbG93IGNvcHkgb2YgdGhlIGF0dHJpYnV0ZSBvYmplY3Qgc28gZGlmZmVyZW50IGdlb21ldHJ5R3JvdXAgY2h1bmtzIHVzZSBkaWZmZXJlbnRcblx0XHRcdFx0Ly8gYXR0cmlidXRlIGJ1ZmZlcnMgd2hpY2ggYXJlIGNvcnJlY3RseSBpbmRleGVkIGluIHRoZSBzZXRNZXNoQnVmZmVycyBmdW5jdGlvblxuXG5cdFx0XHRcdHZhciBvcmlnaW5hbEF0dHJpYnV0ZSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0ge307XG5cblx0XHRcdFx0Zm9yICggdmFyIHByb3BlcnR5IGluIG9yaWdpbmFsQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlWyBwcm9wZXJ0eSBdID0gb3JpZ2luYWxBdHRyaWJ1dGVbIHByb3BlcnR5IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISBhdHRyaWJ1dGUuX193ZWJnbEluaXRpYWxpemVkIHx8IGF0dHJpYnV0ZS5jcmVhdGVVbmlxdWVCdWZmZXJzICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlLl9fd2ViZ2xJbml0aWFsaXplZCA9IHRydWU7XG5cblx0XHRcdFx0XHR2YXIgc2l6ZSA9IDE7ICAgLy8gXCJmXCIgYW5kIFwiaVwiXG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjInICkgc2l6ZSA9IDI7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjMnICkgc2l6ZSA9IDM7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAndjQnICkgc2l6ZSA9IDQ7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSAnYycgICkgc2l6ZSA9IDM7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuc2l6ZSA9IHNpemU7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiBzaXplICk7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuYnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlID0gbmFtZTtcblxuXHRcdFx0XHRcdG9yaWdpbmFsQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUuX19vcmlnaW5hbCA9IG9yaWdpbmFsQXR0cmlidXRlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdC5wdXNoKCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnlHcm91cC5fX2luaXR0ZWRBcnJheXMgPSB0cnVlO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0QnVmZmVyTWF0ZXJpYWwoIG9iamVjdCwgZ2VvbWV0cnlHcm91cCApIHtcblxuXHRcdHJldHVybiBvYmplY3QubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsXG5cdFx0XHQgPyBvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzWyBnZW9tZXRyeUdyb3VwLm1hdGVyaWFsSW5kZXggXVxuXHRcdFx0IDogb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gbWF0ZXJpYWxOZWVkc1Ntb290aE5vcm1hbHMgKCBtYXRlcmlhbCApIHtcblxuXHRcdHJldHVybiBtYXRlcmlhbCAmJiBtYXRlcmlhbC5zaGFkaW5nICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHR9O1xuXG5cdC8vIEJ1ZmZlciBzZXR0aW5nXG5cblx0ZnVuY3Rpb24gc2V0UGFydGljbGVCdWZmZXJzICggZ2VvbWV0cnksIGhpbnQsIG9iamVjdCApIHtcblxuXHRcdHZhciB2LCBjLCB2ZXJ0ZXgsIG9mZnNldCwgaW5kZXgsIGNvbG9yLFxuXG5cdFx0dmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcblx0XHR2bCA9IHZlcnRpY2VzLmxlbmd0aCxcblxuXHRcdGNvbG9ycyA9IGdlb21ldHJ5LmNvbG9ycyxcblx0XHRjbCA9IGNvbG9ycy5sZW5ndGgsXG5cblx0XHR2ZXJ0ZXhBcnJheSA9IGdlb21ldHJ5Ll9fdmVydGV4QXJyYXksXG5cdFx0Y29sb3JBcnJheSA9IGdlb21ldHJ5Ll9fY29sb3JBcnJheSxcblxuXHRcdHNvcnRBcnJheSA9IGdlb21ldHJ5Ll9fc29ydEFycmF5LFxuXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eUVsZW1lbnRzID0gZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlLFxuXHRcdGRpcnR5Q29sb3JzID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSxcblxuXHRcdGN1c3RvbUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QsXG5cdFx0aSwgaWwsXG5cdFx0YSwgY2EsIGNhbCwgdmFsdWUsXG5cdFx0Y3VzdG9tQXR0cmlidXRlO1xuXG5cdFx0aWYgKCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcblxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXhQUy5jb3B5KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXhQUy5tdWx0aXBseSggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdFx0dmVydGV4ID0gdmVydGljZXNbIHYgXTtcblxuXHRcdFx0XHRfdmVjdG9yMy5jb3B5KCB2ZXJ0ZXggKTtcblx0XHRcdFx0X3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeFBTICk7XG5cblx0XHRcdFx0c29ydEFycmF5WyB2IF0gPSBbIF92ZWN0b3IzLnosIHYgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzb3J0QXJyYXkuc29ydCggbnVtZXJpY2FsU29ydCApO1xuXG5cdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyBzb3J0QXJyYXlbIHYgXVsgMSBdIF07XG5cblx0XHRcdFx0b2Zmc2V0ID0gdiAqIDM7XG5cblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHZlcnRleC54O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdmVydGV4Lnk7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2ZXJ0ZXguejtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBjID0gMDsgYyA8IGNsOyBjICsrICkge1xuXG5cdFx0XHRcdG9mZnNldCA9IGMgKiAzO1xuXG5cdFx0XHRcdGNvbG9yID0gY29sb3JzWyBzb3J0QXJyYXlbIGMgXVsgMSBdIF07XG5cblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3Iucjtcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZztcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggISAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICd2ZXJ0aWNlcycgKSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0b2Zmc2V0ID0gMDtcblxuXHRcdFx0XHRcdGNhbCA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZS5sZW5ndGg7XG5cblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpbmRleCA9IHNvcnRBcnJheVsgY2EgXVsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgaW5kZXggXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XG5cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSAgID0gdmFsdWUueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS55O1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSAyO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUudHlwZSA9PT0gJ2MnICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSBzb3J0QXJyYXlbIGNhIF1bIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSAgICAgPSB2YWx1ZS5yO1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUuZztcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XG5cblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IHNvcnRBcnJheVsgY2EgXVsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgPSB2YWx1ZS54O1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XG5cblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpbmRleCA9IHNvcnRBcnJheVsgY2EgXVsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICAgICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSAgXSA9IHZhbHVlLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMiAgXSA9IHZhbHVlLno7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMyAgXSA9IHZhbHVlLnc7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDQ7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggZGlydHlWZXJ0aWNlcyApIHtcblxuXHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHRcdFx0dmVydGV4ID0gdmVydGljZXNbIHYgXTtcblxuXHRcdFx0XHRcdG9mZnNldCA9IHYgKiAzO1xuXG5cdFx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHZlcnRleC54O1xuXHRcdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAxIF0gPSB2ZXJ0ZXgueTtcblx0XHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMiBdID0gdmVydGV4Lno7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGlydHlDb2xvcnMgKSB7XG5cblx0XHRcdFx0Zm9yICggYyA9IDA7IGMgPCBjbDsgYyArKyApIHtcblxuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JzWyBjIF07XG5cblx0XHRcdFx0XHRvZmZzZXQgPSBjICogMztcblxuXHRcdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCBdICAgICA9IGNvbG9yLnI7XG5cdFx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZztcblx0XHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLm5lZWRzVXBkYXRlICYmXG5cdFx0XHRcdFx0XHQgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdFx0XHRcdCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gJ3ZlcnRpY2VzJyApICkge1xuXG5cdFx0XHRcdFx0XHRjYWwgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWUubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSAwO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBjYSBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS55O1xuXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDI7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSAnYycgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICA9IHZhbHVlLnI7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICAgICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxICBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgIF0gPSB2YWx1ZS56O1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMyAgXSA9IHZhbHVlLnc7XG5cblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlWZXJ0aWNlcyB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yQXJyYXksIGhpbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY3VzdG9tQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUgPSBjdXN0b21BdHRyaWJ1dGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUubmVlZHNVcGRhdGUgfHwgb2JqZWN0LnNvcnRQYXJ0aWNsZXMgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmJ1ZmZlciApO1xuXHRcdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYXJyYXksIGhpbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0TGluZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgaGludCApIHtcblxuXHRcdHZhciB2LCBjLCBkLCB2ZXJ0ZXgsIG9mZnNldCwgY29sb3IsXG5cblx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLFxuXHRcdGNvbG9ycyA9IGdlb21ldHJ5LmNvbG9ycyxcblx0XHRsaW5lRGlzdGFuY2VzID0gZ2VvbWV0cnkubGluZURpc3RhbmNlcyxcblxuXHRcdHZsID0gdmVydGljZXMubGVuZ3RoLFxuXHRcdGNsID0gY29sb3JzLmxlbmd0aCxcblx0XHRkbCA9IGxpbmVEaXN0YW5jZXMubGVuZ3RoLFxuXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeS5fX3ZlcnRleEFycmF5LFxuXHRcdGNvbG9yQXJyYXkgPSBnZW9tZXRyeS5fX2NvbG9yQXJyYXksXG5cdFx0bGluZURpc3RhbmNlQXJyYXkgPSBnZW9tZXRyeS5fX2xpbmVEaXN0YW5jZUFycmF5LFxuXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eUNvbG9ycyA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUsXG5cdFx0ZGlydHlMaW5lRGlzdGFuY2VzID0gZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUsXG5cblx0XHRjdXN0b21BdHRyaWJ1dGVzID0gZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LFxuXG5cdFx0aSwgaWwsXG5cdFx0YSwgY2EsIGNhbCwgdmFsdWUsXG5cdFx0Y3VzdG9tQXR0cmlidXRlO1xuXG5cdFx0aWYgKCBkaXJ0eVZlcnRpY2VzICkge1xuXG5cdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyB2IF07XG5cblx0XHRcdFx0b2Zmc2V0ID0gdiAqIDM7XG5cblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHZlcnRleC54O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdmVydGV4Lnk7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2ZXJ0ZXguejtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHZlcnRleEFycmF5LCBoaW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRpcnR5Q29sb3JzICkge1xuXG5cdFx0XHRmb3IgKCBjID0gMDsgYyA8IGNsOyBjICsrICkge1xuXG5cdFx0XHRcdGNvbG9yID0gY29sb3JzWyBjIF07XG5cblx0XHRcdFx0b2Zmc2V0ID0gYyAqIDM7XG5cblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3Iucjtcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZztcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYjtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY29sb3JBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eUxpbmVEaXN0YW5jZXMgKSB7XG5cblx0XHRcdGZvciAoIGQgPSAwOyBkIDwgZGw7IGQgKysgKSB7XG5cblx0XHRcdFx0bGluZURpc3RhbmNlQXJyYXlbIGQgXSA9IGxpbmVEaXN0YW5jZXNbIGQgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGxpbmVEaXN0YW5jZUFycmF5LCBoaW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLm5lZWRzVXBkYXRlICYmXG5cdFx0XHRcdFx0ICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdFx0IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSAndmVydGljZXMnICkgKSB7XG5cblx0XHRcdFx0XHRvZmZzZXQgPSAwO1xuXG5cdFx0XHRcdFx0Y2FsID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlLmxlbmd0aDtcblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICA9IHZhbHVlLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnR5cGUgPT09ICdjJyApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSAgID0gdmFsdWUucjtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS5iO1xuXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XG5cblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgPSB2YWx1ZS54O1xuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XG5cblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgID0gdmFsdWUueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxICBdID0gdmFsdWUueTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyICBdID0gdmFsdWUuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAzICBdID0gdmFsdWUudztcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5idWZmZXIgKTtcblx0XHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmFycmF5LCBoaW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QsIGhpbnQsIGRpc3Bvc2UsIG1hdGVyaWFsICkge1xuXG5cdFx0aWYgKCAhIGdlb21ldHJ5R3JvdXAuX19pbml0dGVkQXJyYXlzICkge1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgbmVlZHNTbW9vdGhOb3JtYWxzID0gbWF0ZXJpYWxOZWVkc1Ntb290aE5vcm1hbHMoIG1hdGVyaWFsICk7XG5cblx0XHR2YXIgZiwgZmwsIGZpLCBmYWNlLFxuXHRcdHZlcnRleE5vcm1hbHMsIGZhY2VOb3JtYWwsIG5vcm1hbCxcblx0XHR2ZXJ0ZXhDb2xvcnMsIGZhY2VDb2xvcixcblx0XHR2ZXJ0ZXhUYW5nZW50cyxcblx0XHR1diwgdXYyLCB2MSwgdjIsIHYzLCB2NCwgdDEsIHQyLCB0MywgdDQsIG4xLCBuMiwgbjMsIG40LFxuXHRcdGMxLCBjMiwgYzMsXG5cdFx0c3cxLCBzdzIsIHN3Mywgc3c0LFxuXHRcdHNpMSwgc2kyLCBzaTMsIHNpNCxcblx0XHRzYTEsIHNhMiwgc2EzLCBzYTQsXG5cdFx0c2IxLCBzYjIsIHNiMywgc2I0LFxuXHRcdG0sIG1sLCBpLCBpbCxcblx0XHR2biwgdXZpLCB1djJpLFxuXHRcdHZrLCB2a2wsIHZrYSxcblx0XHRua2EsIGNoZiwgZmFjZVZlcnRleE5vcm1hbHMsXG5cdFx0YSxcblxuXHRcdHZlcnRleEluZGV4ID0gMCxcblxuXHRcdG9mZnNldCA9IDAsXG5cdFx0b2Zmc2V0X3V2ID0gMCxcblx0XHRvZmZzZXRfdXYyID0gMCxcblx0XHRvZmZzZXRfZmFjZSA9IDAsXG5cdFx0b2Zmc2V0X25vcm1hbCA9IDAsXG5cdFx0b2Zmc2V0X3RhbmdlbnQgPSAwLFxuXHRcdG9mZnNldF9saW5lID0gMCxcblx0XHRvZmZzZXRfY29sb3IgPSAwLFxuXHRcdG9mZnNldF9za2luID0gMCxcblx0XHRvZmZzZXRfbW9ycGhUYXJnZXQgPSAwLFxuXHRcdG9mZnNldF9jdXN0b20gPSAwLFxuXHRcdG9mZnNldF9jdXN0b21TcmMgPSAwLFxuXG5cdFx0dmFsdWUsXG5cblx0XHR2ZXJ0ZXhBcnJheSA9IGdlb21ldHJ5R3JvdXAuX192ZXJ0ZXhBcnJheSxcblx0XHR1dkFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3V2QXJyYXksXG5cdFx0dXYyQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fdXYyQXJyYXksXG5cdFx0bm9ybWFsQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fbm9ybWFsQXJyYXksXG5cdFx0dGFuZ2VudEFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3RhbmdlbnRBcnJheSxcblx0XHRjb2xvckFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX2NvbG9yQXJyYXksXG5cblx0XHRza2luSW5kZXhBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19za2luSW5kZXhBcnJheSxcblx0XHRza2luV2VpZ2h0QXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fc2tpbldlaWdodEFycmF5LFxuXG5cdFx0bW9ycGhUYXJnZXRzQXJyYXlzID0gZ2VvbWV0cnlHcm91cC5fX21vcnBoVGFyZ2V0c0FycmF5cyxcblx0XHRtb3JwaE5vcm1hbHNBcnJheXMgPSBnZW9tZXRyeUdyb3VwLl9fbW9ycGhOb3JtYWxzQXJyYXlzLFxuXG5cdFx0Y3VzdG9tQXR0cmlidXRlcyA9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LFxuXHRcdGN1c3RvbUF0dHJpYnV0ZSxcblxuXHRcdGZhY2VBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19mYWNlQXJyYXksXG5cdFx0bGluZUFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX2xpbmVBcnJheSxcblxuXHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LCAvLyB0aGlzIGlzIHNoYXJlZCBmb3IgYWxsIGNodW5rc1xuXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eUVsZW1lbnRzID0gZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlLFxuXHRcdGRpcnR5VXZzID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eU5vcm1hbHMgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eVRhbmdlbnRzID0gZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlLFxuXHRcdGRpcnR5Q29sb3JzID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSxcblx0XHRkaXJ0eU1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c05lZWRVcGRhdGUsXG5cblx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLFxuXHRcdGNodW5rX2ZhY2VzMyA9IGdlb21ldHJ5R3JvdXAuZmFjZXMzLFxuXHRcdG9ial9mYWNlcyA9IGdlb21ldHJ5LmZhY2VzLFxuXG5cdFx0b2JqX3V2cyAgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0sXG5cdFx0b2JqX3V2czIgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAxIF0sXG5cblx0XHRvYmpfY29sb3JzID0gZ2VvbWV0cnkuY29sb3JzLFxuXG5cdFx0b2JqX3NraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXMsXG5cdFx0b2JqX3NraW5XZWlnaHRzID0gZ2VvbWV0cnkuc2tpbldlaWdodHMsXG5cblx0XHRtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMsXG5cdFx0bW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzO1xuXG5cdFx0aWYgKCBkaXJ0eVZlcnRpY2VzICkge1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHR2MSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcblx0XHRcdFx0djIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XG5cdFx0XHRcdHYzID0gdmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2MS54O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdjEueTtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDIgXSA9IHYxLno7XG5cblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDMgXSA9IHYyLng7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA0IF0gPSB2Mi55O1xuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNSBdID0gdjIuejtcblxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNiBdID0gdjMueDtcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDcgXSA9IHYzLnk7XG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA4IF0gPSB2My56O1xuXG5cdFx0XHRcdG9mZnNldCArPSA5O1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eU1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0Zm9yICggdmsgPSAwLCB2a2wgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyB2ayA8IHZrbDsgdmsgKysgKSB7XG5cblx0XHRcdFx0b2Zmc2V0X21vcnBoVGFyZ2V0ID0gMDtcblxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRjaGYgPSBjaHVua19mYWNlczNbIGYgXTtcblx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaGYgXTtcblxuXHRcdFx0XHRcdC8vIG1vcnBoIHBvc2l0aW9uc1xuXG5cdFx0XHRcdFx0djEgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHRcdHYyID0gbW9ycGhUYXJnZXRzWyB2ayBdLnZlcnRpY2VzWyBmYWNlLmIgXTtcblx0XHRcdFx0XHR2MyA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cblx0XHRcdFx0XHR2a2EgPSBtb3JwaFRhcmdldHNBcnJheXNbIHZrIF07XG5cblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCBdICAgICA9IHYxLng7XG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAxIF0gPSB2MS55O1xuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMiBdID0gdjEuejtcblxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMyBdID0gdjIueDtcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDQgXSA9IHYyLnk7XG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA1IF0gPSB2Mi56O1xuXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA2IF0gPSB2My54O1xuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNyBdID0gdjMueTtcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDggXSA9IHYzLno7XG5cblx0XHRcdFx0XHQvLyBtb3JwaCBub3JtYWxzXG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBuZWVkc1Ntb290aE5vcm1hbHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHNbIHZrIF0udmVydGV4Tm9ybWFsc1sgY2hmIF07XG5cblx0XHRcdFx0XHRcdFx0bjEgPSBmYWNlVmVydGV4Tm9ybWFscy5hO1xuXHRcdFx0XHRcdFx0XHRuMiA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmI7XG5cdFx0XHRcdFx0XHRcdG4zID0gZmFjZVZlcnRleE5vcm1hbHMuYztcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRuMSA9IG1vcnBoTm9ybWFsc1sgdmsgXS5mYWNlTm9ybWFsc1sgY2hmIF07XG5cdFx0XHRcdFx0XHRcdG4yID0gbjE7XG5cdFx0XHRcdFx0XHRcdG4zID0gbjE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bmthID0gbW9ycGhOb3JtYWxzQXJyYXlzWyB2ayBdO1xuXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCBdICAgICA9IG4xLng7XG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDEgXSA9IG4xLnk7XG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDIgXSA9IG4xLno7XG5cblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMyBdID0gbjIueDtcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNCBdID0gbjIueTtcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNSBdID0gbjIuejtcblxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA2IF0gPSBuMy54O1xuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA3IF0gPSBuMy55O1xuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA4IF0gPSBuMy56O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9cblxuXHRcdFx0XHRcdG9mZnNldF9tb3JwaFRhcmdldCArPSA5O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgdmsgXSApO1xuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgbW9ycGhUYXJnZXRzQXJyYXlzWyB2ayBdLCBoaW50ICk7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgdmsgXSApO1xuXHRcdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBtb3JwaE5vcm1hbHNBcnJheXNbIHZrIF0sIGhpbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggb2JqX3NraW5XZWlnaHRzLmxlbmd0aCApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0Ly8gd2VpZ2h0c1xuXG5cdFx0XHRcdHN3MSA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5hIF07XG5cdFx0XHRcdHN3MiA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5iIF07XG5cdFx0XHRcdHN3MyA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5jIF07XG5cblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHN3MS54O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMSBdID0gc3cxLnk7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAyIF0gPSBzdzEuejtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IHN3MS53O1xuXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA0IF0gPSBzdzIueDtcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDUgXSA9IHN3Mi55O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNiBdID0gc3cyLno7XG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA3IF0gPSBzdzIudztcblxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgOCBdICA9IHN3My54O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHN3My55O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTAgXSA9IHN3My56O1xuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTEgXSA9IHN3My53O1xuXG5cdFx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0XHRzaTEgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHRzaTIgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHRzaTMgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHNpMS54O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxIF0gPSBzaTEueTtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMiBdID0gc2kxLno7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IHNpMS53O1xuXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDQgXSA9IHNpMi54O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA1IF0gPSBzaTIueTtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNiBdID0gc2kyLno7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDcgXSA9IHNpMi53O1xuXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDggXSAgPSBzaTMueDtcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHNpMy55O1xuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxMCBdID0gc2kzLno7XG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDExIF0gPSBzaTMudztcblxuXHRcdFx0XHRvZmZzZXRfc2tpbiArPSAxMjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9mZnNldF9za2luID4gMCApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgKTtcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHNraW5JbmRleEFycmF5LCBoaW50ICk7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBza2luV2VpZ2h0QXJyYXksIGhpbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0dmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cdFx0XHRcdGZhY2VDb2xvciA9IGZhY2UuY29sb3I7XG5cblx0XHRcdFx0aWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICYmIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9PT0gVEhSRUUuVmVydGV4Q29sb3JzICkge1xuXG5cdFx0XHRcdFx0YzEgPSB2ZXJ0ZXhDb2xvcnNbIDAgXTtcblx0XHRcdFx0XHRjMiA9IHZlcnRleENvbG9yc1sgMSBdO1xuXHRcdFx0XHRcdGMzID0gdmVydGV4Q29sb3JzWyAyIF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGMxID0gZmFjZUNvbG9yO1xuXHRcdFx0XHRcdGMyID0gZmFjZUNvbG9yO1xuXHRcdFx0XHRcdGMzID0gZmFjZUNvbG9yO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgXSAgICAgPSBjMS5yO1xuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAxIF0gPSBjMS5nO1xuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAyIF0gPSBjMS5iO1xuXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDMgXSA9IGMyLnI7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDQgXSA9IGMyLmc7XG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDUgXSA9IGMyLmI7XG5cblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNiBdID0gYzMucjtcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNyBdID0gYzMuZztcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgOCBdID0gYzMuYjtcblxuXHRcdFx0XHRvZmZzZXRfY29sb3IgKz0gOTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9mZnNldF9jb2xvciA+IDAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbENvbG9yQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjb2xvckFycmF5LCBoaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlUYW5nZW50cyAmJiBnZW9tZXRyeS5oYXNUYW5nZW50cyApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0dmVydGV4VGFuZ2VudHMgPSBmYWNlLnZlcnRleFRhbmdlbnRzO1xuXG5cdFx0XHRcdHQxID0gdmVydGV4VGFuZ2VudHNbIDAgXTtcblx0XHRcdFx0dDIgPSB2ZXJ0ZXhUYW5nZW50c1sgMSBdO1xuXHRcdFx0XHR0MyA9IHZlcnRleFRhbmdlbnRzWyAyIF07XG5cblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCBdICAgICA9IHQxLng7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxIF0gPSB0MS55O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMiBdID0gdDEuejtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDMgXSA9IHQxLnc7XG5cblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDQgXSA9IHQyLng7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA1IF0gPSB0Mi55O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgNiBdID0gdDIuejtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDcgXSA9IHQyLnc7XG5cblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDggXSAgPSB0My54O1xuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgOSBdICA9IHQzLnk7XG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxMCBdID0gdDMuejtcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDExIF0gPSB0My53O1xuXG5cdFx0XHRcdG9mZnNldF90YW5nZW50ICs9IDEyO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xUYW5nZW50QnVmZmVyICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdGFuZ2VudEFycmF5LCBoaW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRpcnR5Tm9ybWFscyApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblx0XHRcdFx0ZmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsO1xuXG5cdFx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgJiYgbmVlZHNTbW9vdGhOb3JtYWxzICkge1xuXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2biA9IHZlcnRleE5vcm1hbHNbIGkgXTtcblxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgXSAgICAgPSB2bi54O1xuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAxIF0gPSB2bi55O1xuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAyIF0gPSB2bi56O1xuXG5cdFx0XHRcdFx0XHRvZmZzZXRfbm9ybWFsICs9IDM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgXSAgICAgPSBmYWNlTm9ybWFsLng7XG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCArIDEgXSA9IGZhY2VOb3JtYWwueTtcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMiBdID0gZmFjZU5vcm1hbC56O1xuXG5cdFx0XHRcdFx0XHRvZmZzZXRfbm9ybWFsICs9IDM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xOb3JtYWxCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBub3JtYWxBcnJheSwgaGludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eVV2cyAmJiBvYmpfdXZzICkge1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmkgPSBjaHVua19mYWNlczNbIGYgXTtcblxuXHRcdFx0XHR1diA9IG9ial91dnNbIGZpIF07XG5cblx0XHRcdFx0aWYgKCB1diA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dXZpID0gdXZbIGkgXTtcblxuXHRcdFx0XHRcdHV2QXJyYXlbIG9mZnNldF91diBdICAgICA9IHV2aS54O1xuXHRcdFx0XHRcdHV2QXJyYXlbIG9mZnNldF91diArIDEgXSA9IHV2aS55O1xuXG5cdFx0XHRcdFx0b2Zmc2V0X3V2ICs9IDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2Zmc2V0X3V2ID4gMCApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVVZCdWZmZXIgKTtcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHV2QXJyYXksIGhpbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXJ0eVV2cyAmJiBvYmpfdXZzMiApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZpID0gY2h1bmtfZmFjZXMzWyBmIF07XG5cblx0XHRcdFx0dXYyID0gb2JqX3V2czJbIGZpIF07XG5cblx0XHRcdFx0aWYgKCB1djIgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdHV2MmkgPSB1djJbIGkgXTtcblxuXHRcdFx0XHRcdHV2MkFycmF5WyBvZmZzZXRfdXYyIF0gICAgID0gdXYyaS54O1xuXHRcdFx0XHRcdHV2MkFycmF5WyBvZmZzZXRfdXYyICsgMSBdID0gdXYyaS55O1xuXG5cdFx0XHRcdFx0b2Zmc2V0X3V2MiArPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9mZnNldF91djIgPiAwICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVjJCdWZmZXIgKTtcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHV2MkFycmF5LCBoaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZGlydHlFbGVtZW50cyApIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgXSAgID0gdmVydGV4SW5kZXg7XG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyAxIF0gPSB2ZXJ0ZXhJbmRleCArIDE7XG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyAyIF0gPSB2ZXJ0ZXhJbmRleCArIDI7XG5cblx0XHRcdFx0b2Zmc2V0X2ZhY2UgKz0gMztcblxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lIF0gICAgID0gdmVydGV4SW5kZXg7XG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyAxIF0gPSB2ZXJ0ZXhJbmRleCArIDE7XG5cblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDIgXSA9IHZlcnRleEluZGV4O1xuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgMyBdID0gdmVydGV4SW5kZXggKyAyO1xuXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyA0IF0gPSB2ZXJ0ZXhJbmRleCArIDE7XG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyA1IF0gPSB2ZXJ0ZXhJbmRleCArIDI7XG5cblx0XHRcdFx0b2Zmc2V0X2xpbmUgKz0gNjtcblxuXHRcdFx0XHR2ZXJ0ZXhJbmRleCArPSAzO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VBcnJheSwgaGludCApO1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQnVmZmVyICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBsaW5lQXJyYXksIGhpbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY3VzdG9tQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUgPSBjdXN0b21BdHRyaWJ1dGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCAhIGN1c3RvbUF0dHJpYnV0ZS5fX29yaWdpbmFsLm5lZWRzVXBkYXRlICkgY29udGludWU7XG5cblx0XHRcdFx0b2Zmc2V0X2N1c3RvbSA9IDA7XG5cdFx0XHRcdG9mZnNldF9jdXN0b21TcmMgPSAwO1xuXG5cdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICd2ZXJ0aWNlcycgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdICAgICA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5jIF07XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAzO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gJ2ZhY2VzJyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdICAgICA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAzO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICd2ZXJ0aWNlcycgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdHYxID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmEgXTtcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xuXHRcdFx0XHRcdFx0XHR2MyA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5jIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gICAgID0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjEueTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2Mi54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2Mi55O1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYzLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYzLnk7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA2O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gJ2ZhY2VzJyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdHYxID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gICAgID0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjEueTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2Mi54O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2Mi55O1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYzLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYzLnk7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA2O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0XHR2YXIgcHA7XG5cblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSAnYycgKSB7XG5cblx0XHRcdFx0XHRcdHBwID0gWyAncicsICdnJywgJ2InIF07XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwcCA9IFsgJ3gnLCAneScsICd6JyBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSAndmVydGljZXMnICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XG5cdFx0XHRcdFx0XHRcdHYyID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmIgXTtcblx0XHRcdFx0XHRcdFx0djMgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdICAgICA9IHYxWyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHYxWyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYxWyBwcFsgMiBdIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gdjJbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjJbIHBwWyAxIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjJbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2IF0gPSB2M1sgcHBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3IF0gPSB2M1sgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4IF0gPSB2M1sgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gOTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICdmYWNlcycgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdICAgICA9IHYxWyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHYxWyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYxWyBwcFsgMiBdIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gdjJbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjJbIHBwWyAxIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjJbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2IF0gPSB2M1sgcHBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3IF0gPSB2M1sgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4IF0gPSB2M1sgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gOTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICdmYWNlVmVydGljZXMnICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZVsgMCBdO1xuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlWyAxIF07XG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWVbIDIgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSAgICAgPSB2MVsgcHBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MVsgcHBbIDEgXSBdO1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2MVsgcHBbIDIgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyWyBwcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYyWyBwcFsgMSBdIF07XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYyWyBwcFsgMiBdIF07XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiBdID0gdjNbIHBwWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyBdID0gdjNbIHBwWyAxIF0gXTtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCBdID0gdjNbIHBwWyAyIF0gXTtcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gJ3ZlcnRpY2VzJyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XG5cblx0XHRcdFx0XHRcdFx0djEgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xuXHRcdFx0XHRcdFx0XHR2MiA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gIF0gICA9IHYxLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MS55O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjEuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyAgXSA9IHYxLnc7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgIF0gPSB2Mi55O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjIuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyAgXSA9IHYyLnc7XG5cblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzLng7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDkgIF0gPSB2My55O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMCBdID0gdjMuejtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHYzLnc7XG5cblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAxMjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09ICdmYWNlcycgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSAgID0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2Mi56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjMueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjMudztcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gJ2ZhY2VWZXJ0aWNlcycgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcblxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlWyAwIF07XG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWVbIDEgXTtcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZVsgMiBdO1xuXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSAgID0gdjEueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2Mi56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcblxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjMueDtcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjMudztcblxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYnVmZmVyICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYXJyYXksIGhpbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBkaXNwb3NlICkge1xuXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX2luaXR0ZWRBcnJheXM7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX2NvbG9yQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX25vcm1hbEFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX190YW5nZW50QXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3V2QXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3V2MkFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19mYWNlQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3ZlcnRleEFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19saW5lQXJyYXk7XG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3NraW5JbmRleEFycmF5O1xuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19za2luV2VpZ2h0QXJyYXk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXREaXJlY3RCdWZmZXJzKCBnZW9tZXRyeSApIHtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHR2YXIgYXR0cmlidXRlc0tleXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzS2V5cztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZXNLZXlzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBrZXkgPSBhdHRyaWJ1dGVzS2V5c1sgaSBdO1xuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5idWZmZXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGUuYnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXR0cmlidXRlLm5lZWRzVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHZhciBidWZmZXJUeXBlID0gKCBrZXkgPT09ICdpbmRleCcgKSA/IF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiA6IF9nbC5BUlJBWV9CVUZGRVI7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZS5idWZmZXIgKTtcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZS5hcnJheSwgX2dsLlNUQVRJQ19EUkFXICk7XG5cblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xuXG5cdHRoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlID0gZnVuY3Rpb24gKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xuXG5cdFx0aW5pdEF0dHJpYnV0ZXMoKTtcblxuXHRcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyAmJiAhIG9iamVjdC5fX3dlYmdsVmVydGV4QnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyAmJiAhIG9iamVjdC5fX3dlYmdsTm9ybWFsQnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xOb3JtYWxCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgb2JqZWN0Ll9fd2ViZ2xVdkJ1ZmZlciApIG9iamVjdC5fX3dlYmdsVXZCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0aWYgKCBvYmplY3QuaGFzQ29sb3JzICYmICEgb2JqZWN0Ll9fd2ViZ2xDb2xvckJ1ZmZlciApIG9iamVjdC5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgKSB7XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5wb3NpdGlvbkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cdFx0XHRlbmFibGVBdHRyaWJ1dGUoIHByb2dyYW0uYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW0uYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuRmxhdFNoYWRpbmcgKSB7XG5cblx0XHRcdFx0dmFyIG54LCBueSwgbnosXG5cdFx0XHRcdFx0bmF4LCBuYngsIG5jeCwgbmF5LCBuYnksIG5jeSwgbmF6LCBuYnosIG5jeixcblx0XHRcdFx0XHRub3JtYWxBcnJheSxcblx0XHRcdFx0XHRpLCBpbCA9IG9iamVjdC5jb3VudCAqIDM7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArPSA5ICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXkgPSBvYmplY3Qubm9ybWFsQXJyYXk7XG5cblx0XHRcdFx0XHRuYXggID0gbm9ybWFsQXJyYXlbIGkgXTtcblx0XHRcdFx0XHRuYXkgID0gbm9ybWFsQXJyYXlbIGkgKyAxIF07XG5cdFx0XHRcdFx0bmF6ICA9IG5vcm1hbEFycmF5WyBpICsgMiBdO1xuXG5cdFx0XHRcdFx0bmJ4ICA9IG5vcm1hbEFycmF5WyBpICsgMyBdO1xuXHRcdFx0XHRcdG5ieSAgPSBub3JtYWxBcnJheVsgaSArIDQgXTtcblx0XHRcdFx0XHRuYnogID0gbm9ybWFsQXJyYXlbIGkgKyA1IF07XG5cblx0XHRcdFx0XHRuY3ggID0gbm9ybWFsQXJyYXlbIGkgKyA2IF07XG5cdFx0XHRcdFx0bmN5ICA9IG5vcm1hbEFycmF5WyBpICsgNyBdO1xuXHRcdFx0XHRcdG5jeiAgPSBub3JtYWxBcnJheVsgaSArIDggXTtcblxuXHRcdFx0XHRcdG54ID0gKCBuYXggKyBuYnggKyBuY3ggKSAvIDM7XG5cdFx0XHRcdFx0bnkgPSAoIG5heSArIG5ieSArIG5jeSApIC8gMztcblx0XHRcdFx0XHRueiA9ICggbmF6ICsgbmJ6ICsgbmN6ICkgLyAzO1xuXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgXSAgID0gbng7XG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyAxIF0gPSBueTtcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDIgXSA9IG56O1xuXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyAzIF0gPSBueDtcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDQgXSA9IG55O1xuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgNSBdID0gbno7XG5cblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDYgXSA9IG54O1xuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgNyBdID0gbnk7XG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyA4IF0gPSBuejtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5ub3JtYWxBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtLmF0dHJpYnV0ZXMubm9ybWFsICk7XG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbS5hdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5fX3dlYmdsVXZCdWZmZXIgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QudXZBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtLmF0dHJpYnV0ZXMudXYgKTtcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtLmF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkge1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cdFx0XHRlbmFibGVBdHRyaWJ1dGUoIHByb2dyYW0uYXR0cmlidXRlcy5jb2xvciApO1xuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW0uYXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcblxuXHRcdG9iamVjdC5jb3VudCA9IDA7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApIHtcblxuXHRcdHZhciBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVzO1xuXHRcdHZhciBwcm9ncmFtQXR0cmlidXRlc0tleXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXNLZXlzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcHJvZ3JhbUF0dHJpYnV0ZXNLZXlzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBrZXkgPSBwcm9ncmFtQXR0cmlidXRlc0tleXNbIGkgXTtcblx0XHRcdHZhciBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlBdHRyaWJ1dGUuYnVmZmVyICk7XG5cblx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogc2l6ZSAqIDQgKTsgLy8gNCBieXRlcyBwZXIgRmxvYXQzMlxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sga2V5IF0ubGVuZ3RoID09PSAyICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliMmZ2KCBwcm9ncmFtQXR0cmlidXRlLCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBrZXkgXSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sga2V5IF0ubGVuZ3RoID09PSAzICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBrZXkgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHR9XG5cblx0dGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiAoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBnZW9tZXRyeSwgb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0dmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZSxcblx0XHRcdHdpcmVmcmFtZUJpdCA9IG1hdGVyaWFsLndpcmVmcmFtZSA/IDEgOiAwLFxuXHRcdFx0Z2VvbWV0cnlIYXNoID0gKCBnZW9tZXRyeS5pZCAqIDB4ZmZmZmZmICkgKyAoIHByb2dyYW0uaWQgKiAyICkgKyB3aXJlZnJhbWVCaXQ7XG5cblx0XHRpZiAoIGdlb21ldHJ5SGFzaCAhPT0gX2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCApIHtcblxuXHRcdFx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IGdlb21ldHJ5SGFzaDtcblx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG5cdFx0XHRpbml0QXR0cmlidXRlcygpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmVuZGVyIG1lc2hcblxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0dmFyIG1vZGUgPSBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgPyBfZ2wuTElORVMgOiBfZ2wuVFJJQU5HTEVTO1xuXG5cdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmluZGV4O1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRcdC8vIGluZGV4ZWQgdHJpYW5nbGVzXG5cblx0XHRcdFx0dmFyIHR5cGUsIHNpemU7XG5cblx0XHRcdFx0aWYgKCBpbmRleC5hcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKSApIHtcblxuXHRcdFx0XHRcdHR5cGUgPSBfZ2wuVU5TSUdORURfSU5UO1xuXHRcdFx0XHRcdHNpemUgPSA0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xuXHRcdFx0XHRcdHNpemUgPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cblx0XHRcdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIDAgKTtcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4LmJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggbW9kZSwgaW5kZXguYXJyYXkubGVuZ3RoLCB0eXBlLCAwICk7XG5cblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBpbmRleC5hcnJheS5sZW5ndGg7IC8vIG5vdCByZWFsbHkgdHJ1ZSwgaGVyZSB2ZXJ0aWNlcyBjYW4gYmUgc2hhcmVkXG5cdFx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gaW5kZXguYXJyYXkubGVuZ3RoIC8gMztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIDEgY2h1bmtcblx0XHRcdFx0XHQvLyBtdXN0IHNldCBhdHRyaWJ1dGUgcG9pbnRlcnMgdG8gdXNlIG5ldyBvZmZzZXRzIGZvciBlYWNoIGNodW5rXG5cdFx0XHRcdFx0Ly8gZXZlbiBpZiBnZW9tZXRyeSBhbmQgbWF0ZXJpYWxzIGRpZG4ndCBjaGFuZ2VcblxuXHRcdFx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBzdGFydEluZGV4ID0gb2Zmc2V0c1sgaSBdLmluZGV4O1xuXG5cdFx0XHRcdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKTtcblx0XHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXguYnVmZmVyICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcmVuZGVyIGluZGV4ZWQgdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdF9nbC5kcmF3RWxlbWVudHMoIG1vZGUsIG9mZnNldHNbIGkgXS5jb3VudCwgdHlwZSwgb2Zmc2V0c1sgaSBdLnN0YXJ0ICogc2l6ZSApO1xuXG5cdFx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IG9mZnNldHNbIGkgXS5jb3VudDsgLy8gbm90IHJlYWxseSB0cnVlLCBoZXJlIHZlcnRpY2VzIGNhbiBiZSBzaGFyZWRcblx0XHRcdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICs9IG9mZnNldHNbIGkgXS5jb3VudCAvIDM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0XHRcdHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbICdwb3NpdGlvbicgXTtcblxuXHRcdFx0XHQvLyByZW5kZXIgbm9uLWluZGV4ZWQgdHJpYW5nbGVzXG5cblx0XHRcdFx0X2dsLmRyYXdBcnJheXMoIG1vZGUsIDAsIHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDMgKTtcblxuXHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gOTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCApIHtcblxuXHRcdFx0Ly8gcmVuZGVyIHBhcnRpY2xlc1xuXG5cdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHQvLyByZW5kZXIgcGFydGljbGVzXG5cblx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuUE9JTlRTLCAwLCBwb3NpdGlvbi5hcnJheS5sZW5ndGggLyAzICk7XG5cblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzICs9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDM7XG5cblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG5cdFx0XHR2YXIgbW9kZSA9ICggb2JqZWN0Lm1vZGUgPT09IFRIUkVFLkxpbmVTdHJpcCApID8gX2dsLkxJTkVfU1RSSVAgOiBfZ2wuTElORVM7XG5cblx0XHRcdHNldExpbmVXaWR0aCggbWF0ZXJpYWwubGluZXdpZHRoICk7XG5cblx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5kZXg7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdFx0Ly8gaW5kZXhlZCBsaW5lc1xuXG5cdFx0XHRcdHZhciB0eXBlLCBzaXplO1xuXG5cdFx0XHRcdGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSApIHtcblxuXHRcdFx0XHRcdHR5cGUgPSBfZ2wuVU5TSUdORURfSU5UO1xuXHRcdFx0XHRcdHNpemUgPSA0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xuXHRcdFx0XHRcdHNpemUgPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cblx0XHRcdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIDAgKTtcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4LmJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggbW9kZSwgaW5kZXguYXJyYXkubGVuZ3RoLCB0eXBlLCAwICk7IC8vIDIgYnl0ZXMgcGVyIFVpbnQxNkFycmF5XG5cblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBpbmRleC5hcnJheS5sZW5ndGg7IC8vIG5vdCByZWFsbHkgdHJ1ZSwgaGVyZSB2ZXJ0aWNlcyBjYW4gYmUgc2hhcmVkXG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiAxIGNodW5rXG5cdFx0XHRcdFx0Ly8gbXVzdCBzZXQgYXR0cmlidXRlIHBvaW50ZXJzIHRvIHVzZSBuZXcgb2Zmc2V0cyBmb3IgZWFjaCBjaHVua1xuXHRcdFx0XHRcdC8vIGV2ZW4gaWYgZ2VvbWV0cnkgYW5kIG1hdGVyaWFscyBkaWRuJ3QgY2hhbmdlXG5cblx0XHRcdFx0XHRpZiAoIG9mZnNldHMubGVuZ3RoID4gMSApIHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBzdGFydEluZGV4ID0gb2Zmc2V0c1sgaSBdLmluZGV4O1xuXG5cdFx0XHRcdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0XHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKTtcblx0XHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXguYnVmZmVyICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcmVuZGVyIGluZGV4ZWQgbGluZXNcblxuXHRcdFx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggbW9kZSwgb2Zmc2V0c1sgaSBdLmNvdW50LCB0eXBlLCBvZmZzZXRzWyBpIF0uc3RhcnQgKiBzaXplICk7IC8vIDIgYnl0ZXMgcGVyIFVpbnQxNkFycmF5XG5cblx0XHRcdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuXHRcdFx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gb2Zmc2V0c1sgaSBdLmNvdW50OyAvLyBub3QgcmVhbGx5IHRydWUsIGhlcmUgdmVydGljZXMgY2FuIGJlIHNoYXJlZFxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBsaW5lc1xuXG5cdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0XHRcdHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdFx0X2dsLmRyYXdBcnJheXMoIG1vZGUsIDAsIHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDMgKTtcblxuXHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzICs9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMucmVuZGVyQnVmZmVyID0gZnVuY3Rpb24gKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgZ2VvbWV0cnlHcm91cCwgb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXM7XG5cblx0XHR2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlLFxuXHRcdFx0d2lyZWZyYW1lQml0ID0gbWF0ZXJpYWwud2lyZWZyYW1lID8gMSA6IDAsXG5cdFx0XHRnZW9tZXRyeUdyb3VwSGFzaCA9ICggZ2VvbWV0cnlHcm91cC5pZCAqIDB4ZmZmZmZmICkgKyAoIHByb2dyYW0uaWQgKiAyICkgKyB3aXJlZnJhbWVCaXQ7XG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXBIYXNoICE9PSBfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoICkge1xuXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gZ2VvbWV0cnlHcm91cEhhc2g7XG5cdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0aW5pdEF0dHJpYnV0ZXMoKTtcblxuXHRcdH1cblxuXHRcdC8vIHZlcnRpY2VzXG5cblx0XHRpZiAoICEgbWF0ZXJpYWwubW9ycGhUYXJnZXRzICYmIGF0dHJpYnV0ZXMucG9zaXRpb24gPj0gMCApIHtcblxuXHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0QmFzZSApIHtcblxuXHRcdFx0XHRzZXR1cE1vcnBoVGFyZ2V0cyggbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblxuXHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuXHRcdFx0Ly8gY3VzdG9tIGF0dHJpYnV0ZXNcblxuXHRcdFx0Ly8gVXNlIHRoZSBwZXItZ2VvbWV0cnlHcm91cCBjdXN0b20gYXR0cmlidXRlIGFycmF5cyB3aGljaCBhcmUgc2V0dXAgaW4gaW5pdE1lc2hCdWZmZXJzXG5cblx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0WyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlIF0gPj0gMCApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZS5idWZmZXIgKTtcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgYXR0cmlidXRlLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGUgXSApO1xuXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlIF0sIGF0dHJpYnV0ZS5zaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gY29sb3JzXG5cblx0XHRcdGlmICggYXR0cmlidXRlcy5jb2xvciA+PSAwICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwIHx8IG9iamVjdC5nZW9tZXRyeS5mYWNlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbENvbG9yQnVmZmVyICk7XG5cdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmNvbG9yICk7XG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cblxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIGF0dHJpYnV0ZXMuY29sb3IsIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMuY29sb3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gbm9ybWFsc1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID49IDAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE5vcm1hbEJ1ZmZlciApO1xuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMubm9ybWFsICk7XG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHRhbmdlbnRzXG5cblx0XHRcdGlmICggYXR0cmlidXRlcy50YW5nZW50ID49IDAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFRhbmdlbnRCdWZmZXIgKTtcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnRhbmdlbnQgKTtcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudGFuZ2VudCwgNCwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHV2c1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgPj0gMCApIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0gKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVVZCdWZmZXIgKTtcblx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjJmdiggYXR0cmlidXRlcy51diwgbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcy51diApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYyID49IDAgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMSBdICkge1xuXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWMkJ1ZmZlciApO1xuXHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51djIgKTtcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51djIsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cblxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIGF0dHJpYnV0ZXMudXYyLCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzLnV2MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICYmXG5cdFx0XHRcdCBhdHRyaWJ1dGVzLnNraW5JbmRleCA+PSAwICYmIGF0dHJpYnV0ZXMuc2tpbldlaWdodCA+PSAwICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luSW5kaWNlc0J1ZmZlciApO1xuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuc2tpbkluZGV4ICk7XG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnNraW5JbmRleCwgNCwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciApO1xuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuc2tpbldlaWdodCApO1xuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5za2luV2VpZ2h0LCA0LCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gbGluZSBkaXN0YW5jZXNcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZSA+PSAwICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIgKTtcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZSApO1xuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5saW5lRGlzdGFuY2UsIDEsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHRcdC8vIHJlbmRlciBtZXNoXG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdHZhciB0eXBlID0gZ2VvbWV0cnlHcm91cC5fX3R5cGVBcnJheSA9PT0gVWludDMyQXJyYXkgPyBfZ2wuVU5TSUdORURfSU5UIDogX2dsLlVOU0lHTkVEX1NIT1JUO1xuXG5cdFx0XHQvLyB3aXJlZnJhbWVcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgKSB7XG5cblx0XHRcdFx0c2V0TGluZVdpZHRoKCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKTtcblx0XHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkgX2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZUJ1ZmZlciApO1xuXHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuTElORVMsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVDb3VudCwgdHlwZSwgMCApO1xuXG5cdFx0XHQvLyB0cmlhbmdsZXNcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSBfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQnVmZmVyICk7XG5cdFx0XHRcdF9nbC5kcmF3RWxlbWVudHMoIF9nbC5UUklBTkdMRVMsIGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VDb3VudCwgdHlwZSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50O1xuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50IC8gMztcblxuXHRcdC8vIHJlbmRlciBsaW5lc1xuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcblxuXHRcdFx0dmFyIG1vZGUgPSAoIG9iamVjdC5tb2RlID09PSBUSFJFRS5MaW5lU3RyaXAgKSA/IF9nbC5MSU5FX1NUUklQIDogX2dsLkxJTkVTO1xuXG5cdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLmxpbmV3aWR0aCApO1xuXG5cdFx0XHRfZ2wuZHJhd0FycmF5cyggbW9kZSwgMCwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZUNvdW50ICk7XG5cblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuXG5cdFx0Ly8gcmVuZGVyIHBhcnRpY2xlc1xuXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCApIHtcblxuXHRcdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5QT0lOVFMsIDAsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFBhcnRpY2xlQ291bnQgKTtcblxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XG5cdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5wb2ludHMgKz0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsUGFydGljbGVDb3VudDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGluaXRBdHRyaWJ1dGVzKCkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gX25ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X25ld0F0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG5cdFx0X25ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuXHRcdGlmICggX2VuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcblxuXHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcblx0XHRcdF9lbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBkaXNhYmxlVW51c2VkQXR0cmlidXRlcygpIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IF9lbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIF9lbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBfbmV3QXR0cmlidXRlc1sgaSBdICkge1xuXG5cdFx0XHRcdF9nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcblx0XHRcdFx0X2VuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldHVwTW9ycGhUYXJnZXRzICggbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApIHtcblxuXHRcdC8vIHNldCBiYXNlXG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IG1hdGVyaWFsLnByb2dyYW0uYXR0cmlidXRlcztcblxuXHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0QmFzZSAhPT0gLSAxICYmIGF0dHJpYnV0ZXMucG9zaXRpb24gPj0gMCApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbIG9iamVjdC5tb3JwaFRhcmdldEJhc2UgXSApO1xuXHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fSBlbHNlIGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiA+PSAwICkge1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyICk7XG5cdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdC5tb3JwaFRhcmdldEZvcmNlZE9yZGVyLmxlbmd0aCApIHtcblxuXHRcdFx0Ly8gc2V0IGZvcmNlZCBvcmRlclxuXG5cdFx0XHR2YXIgbSA9IDA7XG5cdFx0XHR2YXIgb3JkZXIgPSBvYmplY3QubW9ycGhUYXJnZXRGb3JjZWRPcmRlcjtcblx0XHRcdHZhciBpbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuXHRcdFx0d2hpbGUgKCBtIDwgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICYmIG0gPCBvcmRlci5sZW5ndGggKSB7XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgbSBdID49IDAgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgb3JkZXJbIG0gXSBdICk7XG5cdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgbSBdICk7XG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbICdtb3JwaFRhcmdldCcgKyBtIF0sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgbSBdID49IDAgJiYgbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xuXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnNbIG9yZGVyWyBtIF0gXSApO1xuXHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgJ21vcnBoTm9ybWFsJyArIG0gXSApO1xuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iamVjdC5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBtIF0gPSBpbmZsdWVuY2VzWyBvcmRlclsgbSBdIF07XG5cblx0XHRcdFx0bSArKztcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGZpbmQgdGhlIG1vc3QgaW5mbHVlbmNpbmdcblxuXHRcdFx0dmFyIGluZmx1ZW5jZSwgYWN0aXZlSW5mbHVlbmNlSW5kaWNlcyA9IFtdO1xuXHRcdFx0dmFyIGluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXHRcdFx0dmFyIGksIGlsID0gaW5mbHVlbmNlcy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0aW5mbHVlbmNlID0gaW5mbHVlbmNlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggaW5mbHVlbmNlID4gMCApIHtcblxuXHRcdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMucHVzaCggWyBpbmZsdWVuY2UsIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGFjdGl2ZUluZmx1ZW5jZUluZGljZXMubGVuZ3RoID4gbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMuc29ydCggbnVtZXJpY2FsU29ydCApO1xuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VJbmRpY2VzLmxlbmd0aCA9IG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cztcblxuXHRcdFx0fSBlbHNlIGlmICggYWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5sZW5ndGggPiBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgKSB7XG5cblx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5zb3J0KCBudW1lcmljYWxTb3J0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGFjdGl2ZUluZmx1ZW5jZUluZGljZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMucHVzaCggWyAwLCAwIF0gKTtcblxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGluZmx1ZW5jZUluZGV4LCBtID0gMDtcblxuXHRcdFx0d2hpbGUgKCBtIDwgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdGlmICggYWN0aXZlSW5mbHVlbmNlSW5kaWNlc1sgbSBdICkge1xuXG5cdFx0XHRcdFx0aW5mbHVlbmNlSW5kZXggPSBhY3RpdmVJbmZsdWVuY2VJbmRpY2VzWyBtIF1bIDEgXTtcblxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIG0gXSA+PSAwICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgaW5mbHVlbmNlSW5kZXggXSApO1xuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgbSBdICk7XG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgbSBdID49IDAgJiYgbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgaW5mbHVlbmNlSW5kZXggXSApO1xuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgbSBdICk7XG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgJ21vcnBoTm9ybWFsJyArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgbSBdID0gaW5mbHVlbmNlc1sgaW5mbHVlbmNlSW5kZXggXTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgXCJtb3JwaFRhcmdldFwiICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcblxuXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIFwibW9ycGhOb3JtYWxcIiArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCovXG5cblx0XHRcdFx0XHRvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgbSBdID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bSArKztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gbG9hZCB1cGRhdGVkIGluZmx1ZW5jZXMgdW5pZm9ybVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5wcm9ncmFtLnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gbnVsbCApIHtcblxuXHRcdFx0X2dsLnVuaWZvcm0xZnYoIG1hdGVyaWFsLnByb2dyYW0udW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLCBvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBTb3J0aW5nXG5cblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xuXG5cdFx0aWYgKCBhLm1hdGVyaWFsLmlkICE9PSBiLm1hdGVyaWFsLmlkICkge1xuXG5cdFx0XHRyZXR1cm4gYi5tYXRlcmlhbC5pZCAtIGEubWF0ZXJpYWwuaWQ7XG5cblx0XHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcblxuXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBhLmlkIC0gYi5pZDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcblxuXHRcdGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRcdHJldHVybiBhLnogLSBiLno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG51bWVyaWNhbFNvcnQgKCBhLCBiICkge1xuXG5cdFx0cmV0dXJuIGJbIDAgXSAtIGFbIDAgXTtcblxuXHR9XG5cblx0Ly8gUmVuZGVyaW5nXG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApIHtcblxuXHRcdGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgZm9nID0gc2NlbmUuZm9nO1xuXG5cdFx0Ly8gcmVzZXQgY2FjaGluZyBmb3IgdGhpcyBmcmFtZVxuXG5cdFx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IC0gMTtcblx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XG5cdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXHRcdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxuXG5cdFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuXHRcdGlmICggY2FtZXJhLnBhcmVudCA9PT0gdW5kZWZpbmVkICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHQvLyB1cGRhdGUgU2tlbGV0b24gb2JqZWN0c1xuXG5cdFx0c2NlbmUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdG9iamVjdC5za2VsZXRvbi51cGRhdGUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuXHRcdGxpZ2h0cy5sZW5ndGggPSAwO1xuXHRcdG9wYXF1ZU9iamVjdHMubGVuZ3RoID0gMDtcblx0XHR0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID0gMDtcblxuXHRcdHNwcml0ZXMubGVuZ3RoID0gMDtcblx0XHRsZW5zRmxhcmVzLmxlbmd0aCA9IDA7XG5cblx0XHRwcm9qZWN0T2JqZWN0KCBzY2VuZSwgc2NlbmUgKTtcblxuXHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cblx0XHRcdG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcblx0XHRcdHRyYW5zcGFyZW50T2JqZWN0cy5zb3J0KCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocHJlIHBhc3MpXG5cblx0XHRzaGFkb3dNYXBQbHVnaW4ucmVuZGVyKCBzY2VuZSwgY2FtZXJhICk7XG5cblx0XHQvL1xuXG5cdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgPSAwO1xuXHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzID0gMDtcblx0XHRfdGhpcy5pbmZvLnJlbmRlci5mYWNlcyA9IDA7XG5cdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzID0gMDtcblxuXHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcblxuXHRcdFx0dGhpcy5jbGVhciggdGhpcy5hdXRvQ2xlYXJDb2xvciwgdGhpcy5hdXRvQ2xlYXJEZXB0aCwgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsICk7XG5cblx0XHR9XG5cblx0XHQvLyBzZXQgbWF0cmljZXMgZm9yIGltbWVkaWF0ZSBvYmplY3RzXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHdlYmdsT2JqZWN0ID0gX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZVsgaSBdO1xuXHRcdFx0dmFyIG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcblxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcblxuXHRcdFx0XHRzZXR1cE1hdHJpY2VzKCBvYmplY3QsIGNhbWVyYSApO1xuXG5cdFx0XHRcdHVucm9sbEltbWVkaWF0ZUJ1ZmZlck1hdGVyaWFsKCB3ZWJnbE9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0XHRcdHRoaXMuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcblx0XHRcdHRoaXMuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcblx0XHRcdHRoaXMuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuXHRcdFx0c2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XG5cblx0XHRcdHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHRydWUsIG1hdGVyaWFsICk7XG5cdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHRydWUsIG1hdGVyaWFsICk7XG5cdFx0XHRyZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBfd2ViZ2xPYmplY3RzSW1tZWRpYXRlLCAnJywgY2FtZXJhLCBsaWdodHMsIGZvZywgZmFsc2UsIG1hdGVyaWFsICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBudWxsO1xuXG5cdFx0XHQvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcblxuXHRcdFx0dGhpcy5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xuXG5cdFx0XHRyZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBmYWxzZSwgbWF0ZXJpYWwgKTtcblx0XHRcdHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIF93ZWJnbE9iamVjdHNJbW1lZGlhdGUsICdvcGFxdWUnLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBmYWxzZSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0Ly8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcblxuXHRcdFx0cmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCB0cnVlLCBtYXRlcmlhbCApO1xuXHRcdFx0cmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSwgJ3RyYW5zcGFyZW50JywgY2FtZXJhLCBsaWdodHMsIGZvZywgdHJ1ZSwgbWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHRcdC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocG9zdCBwYXNzKVxuXG5cdFx0c3ByaXRlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuXHRcdGxlbnNGbGFyZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50V2lkdGgsIF9jdXJyZW50SGVpZ2h0ICk7XG5cblx0XHQvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHJlbmRlclRhcmdldC5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHtcblxuXHRcdFx0dXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXG5cblx0XHR0aGlzLnNldERlcHRoVGVzdCggdHJ1ZSApO1xuXHRcdHRoaXMuc2V0RGVwdGhXcml0ZSggdHJ1ZSApO1xuXG5cdFx0Ly8gX2dsLmZpbmlzaCgpO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gcHJvamVjdE9iamVjdCggc2NlbmUsIG9iamVjdCApIHtcblxuXHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TY2VuZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Hcm91cCApIHtcblxuXHRcdFx0Ly8gc2tpcFxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aW5pdE9iamVjdCggb2JqZWN0LCBzY2VuZSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0ICkge1xuXG5cdFx0XHRcdGxpZ2h0cy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xuXG5cdFx0XHRcdHNwcml0ZXMucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxlbnNGbGFyZSApIHtcblxuXHRcdFx0XHRsZW5zRmxhcmVzLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciB3ZWJnbE9iamVjdHMgPSBfd2ViZ2xPYmplY3RzWyBvYmplY3QuaWQgXTtcblxuXHRcdFx0XHRpZiAoIHdlYmdsT2JqZWN0cyAmJiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApICkge1xuXG5cdFx0XHRcdFx0dXBkYXRlT2JqZWN0KCBvYmplY3QsIHNjZW5lICk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB3ZWJnbE9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHdlYmdsT2JqZWN0ID0gd2ViZ2xPYmplY3RzW2ldO1xuXG5cdFx0XHRcdFx0XHR1bnJvbGxCdWZmZXJNYXRlcmlhbCggd2ViZ2xPYmplY3QgKTtcblxuXHRcdFx0XHRcdFx0d2ViZ2xPYmplY3QucmVuZGVyID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5yZW5kZXJEZXB0aCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHdlYmdsT2JqZWN0LnogPSBvYmplY3QucmVuZGVyRGVwdGg7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0d2ViZ2xPYmplY3QueiA9IF92ZWN0b3IzLno7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIG9iamVjdC5jaGlsZHJlblsgaSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHVzZUJsZW5kaW5nLCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG5cdFx0dmFyIG1hdGVyaWFsO1xuXG5cdFx0Zm9yICggdmFyIGkgPSByZW5kZXJMaXN0Lmxlbmd0aCAtIDE7IGkgIT09IC0gMTsgaSAtLSApIHtcblxuXHRcdFx0dmFyIHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xuXHRcdFx0dmFyIGJ1ZmZlciA9IHdlYmdsT2JqZWN0LmJ1ZmZlcjtcblxuXHRcdFx0c2V0dXBNYXRyaWNlcyggb2JqZWN0LCBjYW1lcmEgKTtcblxuXHRcdFx0aWYgKCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IHdlYmdsT2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdGlmICggISBtYXRlcmlhbCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmICggdXNlQmxlbmRpbmcgKSBfdGhpcy5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xuXG5cdFx0XHRcdF90aGlzLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0XHRcdF90aGlzLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblx0XHRcdFx0c2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X3RoaXMuc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcblxuXHRcdFx0aWYgKCBidWZmZXIgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBidWZmZXIsIG9iamVjdCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlciggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSAoIHJlbmRlckxpc3QsIG1hdGVyaWFsVHlwZSwgY2FtZXJhLCBsaWdodHMsIGZvZywgdXNlQmxlbmRpbmcsIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cblx0XHR2YXIgbWF0ZXJpYWw7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xuXHRcdFx0dmFyIG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcblxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcblxuXHRcdFx0XHRpZiAoIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gd2ViZ2xPYmplY3RbIG1hdGVyaWFsVHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCAhIG1hdGVyaWFsICkgY29udGludWU7XG5cblx0XHRcdFx0XHRpZiAoIHVzZUJsZW5kaW5nICkgX3RoaXMuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcblxuXHRcdFx0XHRcdF90aGlzLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0XHRcdFx0X3RoaXMuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuXHRcdFx0XHRcdHNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfdGhpcy5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLnJlbmRlckltbWVkaWF0ZU9iamVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcblxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IC0gMTtcblxuXHRcdF90aGlzLnNldE1hdGVyaWFsRmFjZXMoIG1hdGVyaWFsICk7XG5cblx0XHRpZiAoIG9iamVjdC5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjayApIHtcblxuXHRcdFx0b2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrKCBwcm9ncmFtLCBfZ2wsIF9mcnVzdHVtICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRvYmplY3QucmVuZGVyKCBmdW5jdGlvbiAoIG9iamVjdCApIHsgX3RoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICk7IH0gKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHVucm9sbEltbWVkaWF0ZUJ1ZmZlck1hdGVyaWFsICggZ2xvYmplY3QgKSB7XG5cblx0XHR2YXIgb2JqZWN0ID0gZ2xvYmplY3Qub2JqZWN0LFxuXHRcdFx0bWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xuXG5cdFx0XHRnbG9iamVjdC50cmFuc3BhcmVudCA9IG1hdGVyaWFsO1xuXHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbnVsbDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdsb2JqZWN0Lm9wYXF1ZSA9IG1hdGVyaWFsO1xuXHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB1bnJvbGxCdWZmZXJNYXRlcmlhbCAoIGdsb2JqZWN0ICkge1xuXG5cdFx0dmFyIG9iamVjdCA9IGdsb2JqZWN0Lm9iamVjdDtcblx0XHR2YXIgYnVmZmVyID0gZ2xvYmplY3QuYnVmZmVyO1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICkge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxJbmRleCA9IGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgPyAwIDogYnVmZmVyLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdG1hdGVyaWFsID0gbWF0ZXJpYWwubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRcdGdsb2JqZWN0Lm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XG5cblx0XHRcdFx0dHJhbnNwYXJlbnRPYmplY3RzLnB1c2goIGdsb2JqZWN0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0b3BhcXVlT2JqZWN0cy5wdXNoKCBnbG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0Z2xvYmplY3QubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuXHRcdFx0XHR0cmFuc3BhcmVudE9iamVjdHMucHVzaCggZ2xvYmplY3QgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvcGFxdWVPYmplY3RzLnB1c2goIGdsb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdE9iamVjdCggb2JqZWN0LCBzY2VuZSApIHtcblxuXHRcdGlmICggb2JqZWN0Ll9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG9iamVjdC5fX3dlYmdsSW5pdCA9IHRydWU7XG5cdFx0XHRvYmplY3QuX21vZGVsVmlld01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0XHRvYmplY3QuX25vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cblx0XHRcdG9iamVjdC5hZGRFdmVudExpc3RlbmVyKCAncmVtb3ZlZCcsIG9uT2JqZWN0UmVtb3ZlZCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0aWYgKCBnZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBJbW1lZGlhdGVSZW5kZXJPYmplY3RcblxuXHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGdlb21ldHJ5Ll9fd2ViZ2xJbml0ID0gdHJ1ZTtcblx0XHRcdGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdC8vXG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdFx0aW5pdEdlb21ldHJ5R3JvdXBzKCBzY2VuZSwgb2JqZWN0LCBnZW9tZXRyeSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y3JlYXRlTGluZUJ1ZmZlcnMoIGdlb21ldHJ5ICk7XG5cdFx0XHRcdFx0aW5pdExpbmVCdWZmZXJzKCBnZW9tZXRyeSwgb2JqZWN0ICk7XG5cblx0XHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50Q2xvdWQgKSB7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjcmVhdGVQYXJ0aWNsZUJ1ZmZlcnMoIGdlb21ldHJ5ICk7XG5cdFx0XHRcdFx0aW5pdFBhcnRpY2xlQnVmZmVycyggZ2VvbWV0cnksIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0Ll9fd2ViZ2xBY3RpdmUgPT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRvYmplY3QuX193ZWJnbEFjdGl2ZSA9IHRydWU7XG5cblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRhZGRCdWZmZXIoIF93ZWJnbE9iamVjdHMsIGdlb21ldHJ5LCBvYmplY3QgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5R3JvdXBzTGlzdCA9IGdlb21ldHJ5R3JvdXBzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLGwgPSBnZW9tZXRyeUdyb3Vwc0xpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0YWRkQnVmZmVyKCBfd2ViZ2xPYmplY3RzLCBnZW9tZXRyeUdyb3Vwc0xpc3RbIGkgXSwgb2JqZWN0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50Q2xvdWQgKSB7XG5cblx0XHRcdFx0YWRkQnVmZmVyKCBfd2ViZ2xPYmplY3RzLCBnZW9tZXRyeSwgb2JqZWN0ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCB8fCBvYmplY3QuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2sgKSB7XG5cblx0XHRcdFx0YWRkQnVmZmVySW1tZWRpYXRlKCBfd2ViZ2xPYmplY3RzSW1tZWRpYXRlLCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBHZW9tZXRyeSBzcGxpdHRpbmdcblxuXHR2YXIgZ2VvbWV0cnlHcm91cHMgPSB7fTtcblx0dmFyIGdlb21ldHJ5R3JvdXBDb3VudGVyID0gMDtcblxuXHRmdW5jdGlvbiBtYWtlR3JvdXBzKCBnZW9tZXRyeSwgdXNlc0ZhY2VNYXRlcmlhbCApIHtcblxuXHRcdHZhciBtYXhWZXJ0aWNlc0luR3JvdXAgPSBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgPyA0Mjk0OTY3Mjk2IDogNjU1MzU7XG5cblx0XHR2YXIgZ3JvdXBIYXNoLCBoYXNoX21hcCA9IHt9O1xuXG5cdFx0dmFyIG51bU1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XG5cdFx0dmFyIG51bU1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoTm9ybWFscy5sZW5ndGg7XG5cblx0XHR2YXIgZ3JvdXA7XG5cdFx0dmFyIGdyb3VwcyA9IHt9O1xuXHRcdHZhciBncm91cHNMaXN0ID0gW107XG5cblx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZ2VvbWV0cnkuZmFjZXNbIGYgXTtcblx0XHRcdHZhciBtYXRlcmlhbEluZGV4ID0gdXNlc0ZhY2VNYXRlcmlhbCA/IGZhY2UubWF0ZXJpYWxJbmRleCA6IDA7XG5cblx0XHRcdGlmICggISAoIG1hdGVyaWFsSW5kZXggaW4gaGFzaF9tYXAgKSApIHtcblxuXHRcdFx0XHRoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdID0geyBoYXNoOiBtYXRlcmlhbEluZGV4LCBjb3VudGVyOiAwIH07XG5cblx0XHRcdH1cblxuXHRcdFx0Z3JvdXBIYXNoID0gaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5oYXNoICsgJ18nICsgaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5jb3VudGVyO1xuXG5cdFx0XHRpZiAoICEgKCBncm91cEhhc2ggaW4gZ3JvdXBzICkgKSB7XG5cblx0XHRcdFx0Z3JvdXAgPSB7XG5cdFx0XHRcdFx0aWQ6IGdlb21ldHJ5R3JvdXBDb3VudGVyICsrLFxuXHRcdFx0XHRcdGZhY2VzMzogW10sXG5cdFx0XHRcdFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleCxcblx0XHRcdFx0XHR2ZXJ0aWNlczogMCxcblx0XHRcdFx0XHRudW1Nb3JwaFRhcmdldHM6IG51bU1vcnBoVGFyZ2V0cyxcblx0XHRcdFx0XHRudW1Nb3JwaE5vcm1hbHM6IG51bU1vcnBoTm9ybWFsc1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Z3JvdXBzWyBncm91cEhhc2ggXSA9IGdyb3VwO1xuXHRcdFx0XHRncm91cHNMaXN0LnB1c2goIGdyb3VwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBncm91cHNbIGdyb3VwSGFzaCBdLnZlcnRpY2VzICsgMyA+IG1heFZlcnRpY2VzSW5Hcm91cCApIHtcblxuXHRcdFx0XHRoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdLmNvdW50ZXIgKz0gMTtcblx0XHRcdFx0Z3JvdXBIYXNoID0gaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5oYXNoICsgJ18nICsgaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5jb3VudGVyO1xuXG5cdFx0XHRcdGlmICggISAoIGdyb3VwSGFzaCBpbiBncm91cHMgKSApIHtcblxuXHRcdFx0XHRcdGdyb3VwID0ge1xuXHRcdFx0XHRcdFx0aWQ6IGdlb21ldHJ5R3JvdXBDb3VudGVyICsrLFxuXHRcdFx0XHRcdFx0ZmFjZXMzOiBbXSxcblx0XHRcdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXgsXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlczogMCxcblx0XHRcdFx0XHRcdG51bU1vcnBoVGFyZ2V0czogbnVtTW9ycGhUYXJnZXRzLFxuXHRcdFx0XHRcdFx0bnVtTW9ycGhOb3JtYWxzOiBudW1Nb3JwaE5vcm1hbHNcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGdyb3Vwc1sgZ3JvdXBIYXNoIF0gPSBncm91cDtcblx0XHRcdFx0XHRncm91cHNMaXN0LnB1c2goIGdyb3VwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGdyb3Vwc1sgZ3JvdXBIYXNoIF0uZmFjZXMzLnB1c2goIGYgKTtcblx0XHRcdGdyb3Vwc1sgZ3JvdXBIYXNoIF0udmVydGljZXMgKz0gMztcblxuXHRcdH1cblxuXHRcdHJldHVybiBncm91cHNMaXN0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBpbml0R2VvbWV0cnlHcm91cHMoIHNjZW5lLCBvYmplY3QsIGdlb21ldHJ5ICkge1xuXG5cdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsLCBhZGRCdWZmZXJzID0gZmFsc2U7XG5cblx0XHRpZiAoIGdlb21ldHJ5R3JvdXBzWyBnZW9tZXRyeS5pZCBdID09PSB1bmRlZmluZWQgfHwgZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0ZGVsZXRlIF93ZWJnbE9iamVjdHNbIG9iamVjdC5pZCBdO1xuXG5cdFx0XHRnZW9tZXRyeUdyb3Vwc1sgZ2VvbWV0cnkuaWQgXSA9IG1ha2VHcm91cHMoIGdlb21ldHJ5LCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKTtcblxuXHRcdFx0Z2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGdlb21ldHJ5R3JvdXBzTGlzdCA9IGdlb21ldHJ5R3JvdXBzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0Ly8gY3JlYXRlIHNlcGFyYXRlIFZCT3MgcGVyIGdlb21ldHJ5IGNodW5rXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnlHcm91cHNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5R3JvdXBzTGlzdFsgaSBdO1xuXG5cdFx0XHQvLyBpbml0aWFsaXNlIFZCTyBvbiB0aGUgZmlyc3QgYWNjZXNzXG5cblx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y3JlYXRlTWVzaEJ1ZmZlcnMoIGdlb21ldHJ5R3JvdXAgKTtcblx0XHRcdFx0aW5pdE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKTtcblxuXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Z2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Z2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0YWRkQnVmZmVycyA9IHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YWRkQnVmZmVycyA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYWRkQnVmZmVycyB8fCBvYmplY3QuX193ZWJnbEFjdGl2ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGFkZEJ1ZmZlciggX3dlYmdsT2JqZWN0cywgZ2VvbWV0cnlHcm91cCwgb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdG9iamVjdC5fX3dlYmdsQWN0aXZlID0gdHJ1ZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQnVmZmVyKCBvYmpsaXN0LCBidWZmZXIsIG9iamVjdCApIHtcblxuXHRcdHZhciBpZCA9IG9iamVjdC5pZDtcblx0XHRvYmpsaXN0W2lkXSA9IG9iamxpc3RbaWRdIHx8IFtdO1xuXHRcdG9iamxpc3RbaWRdLnB1c2goXG5cdFx0XHR7XG5cdFx0XHRcdGlkOiBpZCxcblx0XHRcdFx0YnVmZmVyOiBidWZmZXIsXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0LFxuXHRcdFx0XHRtYXRlcmlhbDogbnVsbCxcblx0XHRcdFx0ejogMFxuXHRcdFx0fVxuXHRcdCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBhZGRCdWZmZXJJbW1lZGlhdGUoIG9iamxpc3QsIG9iamVjdCApIHtcblxuXHRcdG9iamxpc3QucHVzaChcblx0XHRcdHtcblx0XHRcdFx0aWQ6IG51bGwsXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0LFxuXHRcdFx0XHRvcGFxdWU6IG51bGwsXG5cdFx0XHRcdHRyYW5zcGFyZW50OiBudWxsLFxuXHRcdFx0XHR6OiAwXG5cdFx0XHR9XG5cdFx0KTtcblxuXHR9O1xuXG5cdC8vIE9iamVjdHMgdXBkYXRlc1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZU9iamVjdCggb2JqZWN0LCBzY2VuZSApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeSwgY3VzdG9tQXR0cmlidXRlc0RpcnR5LCBtYXRlcmlhbDtcblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0c2V0RGlyZWN0QnVmZmVycyggZ2VvbWV0cnkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdC8vIGNoZWNrIGFsbCBnZW9tZXRyeSBncm91cHNcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGluaXRHZW9tZXRyeUdyb3Vwcyggc2NlbmUsIG9iamVjdCwgZ2VvbWV0cnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZ2VvbWV0cnlHcm91cHNMaXN0ID0gZ2VvbWV0cnlHcm91cHNbIGdlb21ldHJ5LmlkIF07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeUdyb3Vwc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5R3JvdXAgPSBnZW9tZXRyeUdyb3Vwc0xpc3RbIGkgXTtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5R3JvdXAgKTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRpbml0TWVzaEJ1ZmZlcnMoIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGVzRGlydHkgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzICYmIGFyZUN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSB8fFxuXHRcdFx0XHRcdCBnZW9tZXRyeS51dnNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlIHx8XG5cdFx0XHRcdFx0IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlIHx8IGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSApIHtcblxuXHRcdFx0XHRcdHNldE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QsIF9nbC5EWU5BTUlDX0RSQVcsICEgZ2VvbWV0cnkuZHluYW1pYywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRnZW9tZXRyeS50YW5nZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0bWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBjbGVhckN1c3RvbUF0dHJpYnV0ZXMoIG1hdGVyaWFsICk7XG5cblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG5cdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5ICk7XG5cblx0XHRcdGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlIHx8IGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSApIHtcblxuXHRcdFx0XHRzZXRMaW5lQnVmZmVycyggZ2VvbWV0cnksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgY2xlYXJDdXN0b21BdHRyaWJ1dGVzKCBtYXRlcmlhbCApO1xuXG5cblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkICkge1xuXG5cdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5ICk7XG5cblx0XHRcdGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlIHx8IG9iamVjdC5zb3J0UGFydGljbGVzIHx8IGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSApIHtcblxuXHRcdFx0XHRzZXRQYXJ0aWNsZUJ1ZmZlcnMoIGdlb21ldHJ5LCBfZ2wuRFlOQU1JQ19EUkFXLCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0bWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBjbGVhckN1c3RvbUF0dHJpYnV0ZXMoIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIE9iamVjdHMgdXBkYXRlcyAtIGN1c3RvbSBhdHRyaWJ1dGVzIGNoZWNrXG5cblx0ZnVuY3Rpb24gYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApIHtcblxuXHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuYXR0cmlidXRlc1sgbmFtZSBdLm5lZWRzVXBkYXRlICkgcmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNsZWFyQ3VzdG9tQXR0cmlidXRlcyggbWF0ZXJpYWwgKSB7XG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRtYXRlcmlhbC5hdHRyaWJ1dGVzWyBuYW1lIF0ubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gT2JqZWN0cyByZW1vdmFsXG5cblx0ZnVuY3Rpb24gcmVtb3ZlT2JqZWN0KCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggIHx8XG5cdFx0XHQgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCB8fFxuXHRcdFx0IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cblx0XHRcdGRlbGV0ZSBfd2ViZ2xPYmplY3RzWyBvYmplY3QuaWQgXTtcblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCB8fCBvYmplY3QuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2sgKSB7XG5cblx0XHRcdHJlbW92ZUluc3RhbmNlcyggX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSwgb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRkZWxldGUgb2JqZWN0Ll9fd2ViZ2xJbml0O1xuXHRcdGRlbGV0ZSBvYmplY3QuX21vZGVsVmlld01hdHJpeDtcblx0XHRkZWxldGUgb2JqZWN0Ll9ub3JtYWxNYXRyaXg7XG5cblx0XHRkZWxldGUgb2JqZWN0Ll9fd2ViZ2xBY3RpdmU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZUluc3RhbmNlcyggb2JqbGlzdCwgb2JqZWN0ICkge1xuXG5cdFx0Zm9yICggdmFyIG8gPSBvYmpsaXN0Lmxlbmd0aCAtIDE7IG8gPj0gMDsgbyAtLSApIHtcblxuXHRcdFx0aWYgKCBvYmpsaXN0WyBvIF0ub2JqZWN0ID09PSBvYmplY3QgKSB7XG5cblx0XHRcdFx0b2JqbGlzdC5zcGxpY2UoIG8sIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBNYXRlcmlhbHNcblxuXHRmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xuXG5cdFx0bWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG5cdFx0dmFyIHNoYWRlcklEO1xuXG5cdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdkZXB0aCc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0c2hhZGVySUQgPSAnbm9ybWFsJztcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHNoYWRlcklEID0gJ2Jhc2ljJztcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuXHRcdFx0c2hhZGVySUQgPSAnbGFtYmVydCc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdwaG9uZyc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdiYXNpYyc7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCApIHtcblxuXHRcdFx0c2hhZGVySUQgPSAnZGFzaGVkJztcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsICkge1xuXG5cdFx0XHRzaGFkZXJJRCA9ICdwYXJ0aWNsZV9iYXNpYyc7XG5cblx0XHR9XG5cblx0XHRpZiAoIHNoYWRlcklEICkge1xuXG5cdFx0XHR2YXIgc2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBzaGFkZXJJRCBdO1xuXG5cdFx0XHRtYXRlcmlhbC5fX3dlYmdsU2hhZGVyID0ge1xuXHRcdFx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICksXG5cdFx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWF0ZXJpYWwuX193ZWJnbFNoYWRlciA9IHtcblx0XHRcdFx0dW5pZm9ybXM6IG1hdGVyaWFsLnVuaWZvcm1zLFxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IG1hdGVyaWFsLnZlcnRleFNoYWRlcixcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBoZXVyaXN0aWNzIHRvIGNyZWF0ZSBzaGFkZXIgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gbGlnaHRzIGluIHRoZSBzY2VuZVxuXHRcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXG5cblx0XHR2YXIgbWF4TGlnaHRDb3VudCA9IGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKTtcblx0XHR2YXIgbWF4U2hhZG93cyA9IGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICk7XG5cdFx0dmFyIG1heEJvbmVzID0gYWxsb2NhdGVCb25lcyggb2JqZWN0ICk7XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHtcblxuXHRcdFx0cHJlY2lzaW9uOiBfcHJlY2lzaW9uLFxuXHRcdFx0c3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogX3N1cHBvcnRzVmVydGV4VGV4dHVyZXMsXG5cblx0XHRcdG1hcDogISEgbWF0ZXJpYWwubWFwLFxuXHRcdFx0ZW52TWFwOiAhISBtYXRlcmlhbC5lbnZNYXAsXG5cdFx0XHRsaWdodE1hcDogISEgbWF0ZXJpYWwubGlnaHRNYXAsXG5cdFx0XHRidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxuXHRcdFx0bm9ybWFsTWFwOiAhISBtYXRlcmlhbC5ub3JtYWxNYXAsXG5cdFx0XHRzcGVjdWxhck1hcDogISEgbWF0ZXJpYWwuc3BlY3VsYXJNYXAsXG5cdFx0XHRhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXG5cblx0XHRcdHZlcnRleENvbG9yczogbWF0ZXJpYWwudmVydGV4Q29sb3JzLFxuXG5cdFx0XHRmb2c6IGZvZyxcblx0XHRcdHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxuXHRcdFx0Zm9nRXhwOiBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyLFxuXG5cdFx0XHRzaXplQXR0ZW51YXRpb246IG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbixcblx0XHRcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IF9sb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuXG5cdFx0XHRza2lubmluZzogbWF0ZXJpYWwuc2tpbm5pbmcsXG5cdFx0XHRtYXhCb25lczogbWF4Qm9uZXMsXG5cdFx0XHR1c2VWZXJ0ZXhUZXh0dXJlOiBfc3VwcG9ydHNCb25lVGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSxcblxuXHRcdFx0bW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXG5cdFx0XHRtb3JwaE5vcm1hbHM6IG1hdGVyaWFsLm1vcnBoTm9ybWFscyxcblx0XHRcdG1heE1vcnBoVGFyZ2V0czogX3RoaXMubWF4TW9ycGhUYXJnZXRzLFxuXHRcdFx0bWF4TW9ycGhOb3JtYWxzOiBfdGhpcy5tYXhNb3JwaE5vcm1hbHMsXG5cblx0XHRcdG1heERpckxpZ2h0czogbWF4TGlnaHRDb3VudC5kaXJlY3Rpb25hbCxcblx0XHRcdG1heFBvaW50TGlnaHRzOiBtYXhMaWdodENvdW50LnBvaW50LFxuXHRcdFx0bWF4U3BvdExpZ2h0czogbWF4TGlnaHRDb3VudC5zcG90LFxuXHRcdFx0bWF4SGVtaUxpZ2h0czogbWF4TGlnaHRDb3VudC5oZW1pLFxuXG5cdFx0XHRtYXhTaGFkb3dzOiBtYXhTaGFkb3dzLFxuXHRcdFx0c2hhZG93TWFwRW5hYmxlZDogX3RoaXMuc2hhZG93TWFwRW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBtYXhTaGFkb3dzID4gMCxcblx0XHRcdHNoYWRvd01hcFR5cGU6IF90aGlzLnNoYWRvd01hcFR5cGUsXG5cdFx0XHRzaGFkb3dNYXBEZWJ1ZzogX3RoaXMuc2hhZG93TWFwRGVidWcsXG5cdFx0XHRzaGFkb3dNYXBDYXNjYWRlOiBfdGhpcy5zaGFkb3dNYXBDYXNjYWRlLFxuXG5cdFx0XHRhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcblx0XHRcdG1ldGFsOiBtYXRlcmlhbC5tZXRhbCxcblx0XHRcdHdyYXBBcm91bmQ6IG1hdGVyaWFsLndyYXBBcm91bmQsXG5cdFx0XHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSxcblx0XHRcdGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGVcblxuXHRcdH07XG5cblx0XHQvLyBHZW5lcmF0ZSBjb2RlXG5cblx0XHR2YXIgY2h1bmtzID0gW107XG5cblx0XHRpZiAoIHNoYWRlcklEICkge1xuXG5cdFx0XHRjaHVua3MucHVzaCggc2hhZGVySUQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNodW5rcy5wdXNoKCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciApO1xuXHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XG5cblx0XHRcdFx0Y2h1bmtzLnB1c2goIG5hbWUgKTtcblx0XHRcdFx0Y2h1bmtzLnB1c2goIG1hdGVyaWFsLmRlZmluZXNbIG5hbWUgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRjaHVua3MucHVzaCggbmFtZSApO1xuXHRcdFx0Y2h1bmtzLnB1c2goIHBhcmFtZXRlcnNbIG5hbWUgXSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGNvZGUgPSBjaHVua3Muam9pbigpO1xuXG5cdFx0dmFyIHByb2dyYW07XG5cblx0XHQvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcblxuXHRcdGZvciAoIHZhciBwID0gMCwgcGwgPSBfcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cblx0XHRcdHZhciBwcm9ncmFtSW5mbyA9IF9wcm9ncmFtc1sgcCBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XG5cblx0XHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xuXHRcdFx0XHRwcm9ncmFtLnVzZWRUaW1lcyArKztcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHByb2dyYW0gPSBuZXcgVEhSRUUuV2ViR0xQcm9ncmFtKCBfdGhpcywgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcblx0XHRcdF9wcm9ncmFtcy5wdXNoKCBwcm9ncmFtICk7XG5cblx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnByb2dyYW1zID0gX3Byb2dyYW1zLmxlbmd0aDtcblxuXHRcdH1cblxuXHRcdG1hdGVyaWFsLnByb2dyYW0gPSBwcm9ncmFtO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXM7XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcblxuXHRcdFx0dmFyIGlkLCBiYXNlID0gJ21vcnBoVGFyZ2V0JztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG5cdFx0XHRcdGlkID0gYmFzZSArIGk7XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyBpZCBdID49IDAgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcblxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzID0gMDtcblxuXHRcdFx0dmFyIGlkLCBiYXNlID0gJ21vcnBoTm9ybWFsJztcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaE5vcm1hbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0aWQgPSBiYXNlICsgaTtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIGlkIF0gPj0gMCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdG1hdGVyaWFsLnVuaWZvcm1zTGlzdCA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIHUgaW4gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci51bmlmb3JtcyApIHtcblxuXHRcdFx0dmFyIGxvY2F0aW9uID0gbWF0ZXJpYWwucHJvZ3JhbS51bmlmb3Jtc1sgdSBdO1xuXG5cdFx0XHRpZiAoIGxvY2F0aW9uICkge1xuXHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc0xpc3QucHVzaCggWyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zWyB1IF0sIGxvY2F0aW9uIF0gKTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcblxuXHRcdF91c2VkVGV4dHVyZVVuaXRzID0gMDtcblxuXHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwucHJvZ3JhbSApIGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0aW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xuXHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRpZiAoICEgb2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdFx0b2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBfdGhpcy5tYXhNb3JwaFRhcmdldHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XG5cdFx0dmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xuXHRcdHZhciByZWZyZXNoTGlnaHRzID0gZmFsc2U7XG5cblx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsLnByb2dyYW0sXG5cdFx0XHRwX3VuaWZvcm1zID0gcHJvZ3JhbS51bmlmb3Jtcyxcblx0XHRcdG1fdW5pZm9ybXMgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xuXG5cdFx0aWYgKCBwcm9ncmFtLmlkICE9PSBfY3VycmVudFByb2dyYW0gKSB7XG5cblx0XHRcdF9nbC51c2VQcm9ncmFtKCBwcm9ncmFtLnByb2dyYW0gKTtcblx0XHRcdF9jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW0uaWQ7XG5cblx0XHRcdHJlZnJlc2hQcm9ncmFtID0gdHJ1ZTtcblx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcblxuXHRcdFx0aWYgKCBfY3VycmVudE1hdGVyaWFsSWQgPT09IC0xICkgcmVmcmVzaExpZ2h0cyA9IHRydWU7XG5cdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcblxuXHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggcmVmcmVzaFByb2dyYW0gfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcblxuXHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cblx0XHRcdGlmICggX2xvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggcF91bmlmb3Jtcy5sb2dEZXB0aEJ1ZkZDLCAyLjAgLyAoIE1hdGgubG9nKCBjYW1lcmEuZmFyICsgMS4wICkgLyBNYXRoLkxOMiApICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRpZiAoIGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSBfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcblxuXHRcdFx0Ly8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXHRcdFx0Ly8gKHNoYWRlciBtYXRlcmlhbCBhbHNvIGdldHMgdGhlbSBmb3IgdGhlIHNha2Ugb2YgZ2VuZXJpY2l0eSlcblxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbC5lbnZNYXAgKSB7XG5cblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbC5za2lubmluZyApIHtcblxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMudmlld01hdHJpeCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnZpZXdNYXRyaXgsIGZhbHNlLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBza2lubmluZyB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2Vcblx0XHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcblx0XHQvLyBub3Qgc3VyZSB3aHksIGJ1dCBvdGhlcndpc2Ugd2VpcmQgdGhpbmdzIGhhcHBlblxuXG5cdFx0aWYgKCBtYXRlcmlhbC5za2lubmluZyApIHtcblxuXHRcdFx0aWYgKCBvYmplY3QuYmluZE1hdHJpeCAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYmluZE1hdHJpeCwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4LmVsZW1lbnRzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvYmplY3QuYmluZE1hdHJpeEludmVyc2UgJiYgcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZS5lbGVtZW50cyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggX3N1cHBvcnRzQm9uZVRleHR1cmVzICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR2YXIgdGV4dHVyZVVuaXQgPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoLCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVXaWR0aCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0LCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVIZWlnaHQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICkge1xuXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMsIGZhbHNlLCBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcblxuXHRcdFx0Ly8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcblxuXHRcdFx0aWYgKCBmb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0ZvZyggbV91bmlmb3JtcywgZm9nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcblx0XHRcdFx0IG1hdGVyaWFsLmxpZ2h0cyApIHtcblxuXHRcdFx0XHRpZiAoIF9saWdodHNOZWVkVXBkYXRlICkge1xuXG5cdFx0XHRcdFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7XG5cdFx0XHRcdFx0c2V0dXBMaWdodHMoIGxpZ2h0cyApO1xuXHRcdFx0XHRcdF9saWdodHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHJlZnJlc2hMaWdodHMgKSB7XG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGlnaHRzKCBtX3VuaWZvcm1zLCBfbGlnaHRzICk7XG5cdFx0XHRcdFx0bWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHRydWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgZmFsc2UgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGFydGljbGUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdG1fdW5pZm9ybXMubU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcblx0XHRcdFx0bV91bmlmb3Jtcy5tRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcblx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmICEgbWF0ZXJpYWwuX3NoYWRvd1Bhc3MgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zU2hhZG93KCBtX3VuaWZvcm1zLCBsaWdodHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb2FkIGNvbW1vbiB1bmlmb3Jtc1xuXG5cdFx0XHRsb2FkVW5pZm9ybXNHZW5lcmljKCBtYXRlcmlhbC51bmlmb3Jtc0xpc3QgKTtcblxuXHRcdH1cblxuXHRcdGxvYWRVbmlmb3Jtc01hdHJpY2VzKCBwX3VuaWZvcm1zLCBvYmplY3QgKTtcblxuXHRcdGlmICggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCAhPT0gbnVsbCApIHtcblxuXHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXgsIGZhbHNlLCBvYmplY3QubWF0cml4V29ybGQuZWxlbWVudHMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdH1cblxuXHQvLyBVbmlmb3JtcyAocmVmcmVzaCB1bmlmb3JtcyBvYmplY3RzKVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG5cdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuXG5cdFx0fVxuXG5cdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXHRcdHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XG5cdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG5cdFx0Ly8gIDEuIGNvbG9yIG1hcFxuXHRcdC8vICAyLiBzcGVjdWxhciBtYXBcblx0XHQvLyAgMy4gbm9ybWFsIG1hcFxuXHRcdC8vICA0LiBidW1wIG1hcFxuXHRcdC8vICA1LiBhbHBoYSBtYXBcblxuXHRcdHZhciB1dlNjYWxlTWFwO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBvZmZzZXQgPSB1dlNjYWxlTWFwLm9mZnNldDtcblx0XHRcdHZhciByZXBlYXQgPSB1dlNjYWxlTWFwLnJlcGVhdDtcblxuXHRcdFx0dW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcblxuXHRcdH1cblxuXHRcdHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcblx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBtYXRlcmlhbC5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSA/IDEgOiAtIDE7XG5cblx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdC8vdW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5ICogbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuXHRcdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuXG5cdFx0fVxuXG5cdFx0dW5pZm9ybXMucmVmcmFjdGlvblJhdGlvLnZhbHVlID0gbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvO1xuXHRcdHVuaWZvcm1zLmNvbWJpbmUudmFsdWUgPSBtYXRlcmlhbC5jb21iaW5lO1xuXHRcdHVuaWZvcm1zLnVzZVJlZnJhY3QudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgaW5zdGFuY2VvZiBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2ggKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xuXHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLnBzQ29sb3IudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZTtcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuaGVpZ2h0IC8gMi4wOyAvLyBUT0RPOiBDYWNoZSB0aGlzLlxuXG5cdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNGb2cgKCB1bmlmb3JtcywgZm9nICkge1xuXG5cdFx0dW5pZm9ybXMuZm9nQ29sb3IudmFsdWUgPSBmb2cuY29sb3I7XG5cblx0XHRpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcblxuXHRcdFx0dW5pZm9ybXMuZm9nTmVhci52YWx1ZSA9IGZvZy5uZWFyO1xuXHRcdFx0dW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcblxuXHRcdH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBtYXRlcmlhbC5zaGluaW5lc3M7XG5cblx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFtYmllbnQudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLmFtYmllbnQgKTtcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5lbWlzc2l2ZSApO1xuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLnNwZWN1bGFyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50LnZhbHVlID0gbWF0ZXJpYWwuYW1iaWVudDtcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC53cmFwQXJvdW5kICkge1xuXG5cdFx0XHR1bmlmb3Jtcy53cmFwUkdCLnZhbHVlLmNvcHkoIG1hdGVyaWFsLndyYXBSR0IgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGFtYmVydCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcblxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudC52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuYW1iaWVudCApO1xuXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLmVtaXNzaXZlICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50LnZhbHVlID0gbWF0ZXJpYWwuYW1iaWVudDtcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLndyYXBBcm91bmQgKSB7XG5cblx0XHRcdHVuaWZvcm1zLndyYXBSR0IudmFsdWUuY29weSggbWF0ZXJpYWwud3JhcFJHQiApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaWdodHMgKCB1bmlmb3JtcywgbGlnaHRzICkge1xuXG5cdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuYW1iaWVudDtcblxuXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnM7XG5cdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5wb3NpdGlvbnM7XG5cblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMucG9pbnQuY29sb3JzO1xuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHRQb3NpdGlvbi52YWx1ZSA9IGxpZ2h0cy5wb2ludC5wb3NpdGlvbnM7XG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnBvaW50LmRpc3RhbmNlcztcblxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnNwb3QuY29sb3JzO1xuXHRcdHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnNwb3QucG9zaXRpb25zO1xuXHRcdHVuaWZvcm1zLnNwb3RMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnNwb3QuZGlzdGFuY2VzO1xuXHRcdHVuaWZvcm1zLnNwb3RMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5zcG90LmRpcmVjdGlvbnM7XG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0QW5nbGVDb3MudmFsdWUgPSBsaWdodHMuc3BvdC5hbmdsZXNDb3M7XG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RXhwb25lbnQudmFsdWUgPSBsaWdodHMuc3BvdC5leHBvbmVudHM7XG5cblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRTa3lDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLnNreUNvbG9ycztcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycztcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuaGVtaS5wb3NpdGlvbnM7XG5cblx0fVxuXG5cdC8vIElmIHVuaWZvcm1zIGFyZSBtYXJrZWQgYXMgY2xlYW4sIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBsb2FkZWQgdG8gdGhlIEdQVS5cblxuXHRmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSAoIHVuaWZvcm1zLCBib29sZWFuICkge1xuXG5cdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXG5cdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblxuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IGJvb2xlYW47XG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0RGlzdGFuY2UubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXHRcdHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHREaXN0YW5jZS5uZWVkc1VwZGF0ZSA9IGJvb2xlYW47XG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy5uZWVkc1VwZGF0ZSA9IGJvb2xlYW47XG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RXhwb25lbnQubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXG5cdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLm5lZWRzVXBkYXRlID0gYm9vbGVhbjtcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSBib29sZWFuO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTaGFkb3cgKCB1bmlmb3JtcywgbGlnaHRzICkge1xuXG5cdFx0aWYgKCB1bmlmb3Jtcy5zaGFkb3dNYXRyaXggKSB7XG5cblx0XHRcdHZhciBqID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbGlnaHQgPSBsaWdodHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgfHwgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgJiYgISBsaWdodC5zaGFkb3dDYXNjYWRlICkgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXAudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd01hcDtcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXBTaXplO1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWF0cml4LnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXRyaXg7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dEYXJrbmVzcy52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93RGFya25lc3M7XG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93Qmlhcy52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93QmlhcztcblxuXHRcdFx0XHRcdGogKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFVuaWZvcm1zIChsb2FkIHRvIEdQVSlcblxuXHRmdW5jdGlvbiBsb2FkVW5pZm9ybXNNYXRyaWNlcyAoIHVuaWZvcm1zLCBvYmplY3QgKSB7XG5cblx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgb2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdGlmICggdW5pZm9ybXMubm9ybWFsTWF0cml4ICkge1xuXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggdW5pZm9ybXMubm9ybWFsTWF0cml4LCBmYWxzZSwgb2JqZWN0Ll9ub3JtYWxNYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VGV4dHVyZVVuaXQoKSB7XG5cblx0XHR2YXIgdGV4dHVyZVVuaXQgPSBfdXNlZFRleHR1cmVVbml0cztcblxuXHRcdGlmICggdGV4dHVyZVVuaXQgPj0gX21heFRleHR1cmVzICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdXZWJHTFJlbmRlcmVyOiB0cnlpbmcgdG8gdXNlICcgKyB0ZXh0dXJlVW5pdCArICcgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5ICcgKyBfbWF4VGV4dHVyZXMgKTtcblxuXHRcdH1cblxuXHRcdF91c2VkVGV4dHVyZVVuaXRzICs9IDE7XG5cblx0XHRyZXR1cm4gdGV4dHVyZVVuaXQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWRVbmlmb3Jtc0dlbmVyaWMgKCB1bmlmb3JtcyApIHtcblxuXHRcdHZhciB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCwgb2Zmc2V0O1xuXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHVuaWZvcm1zLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHR2YXIgdW5pZm9ybSA9IHVuaWZvcm1zWyBqIF1bIDAgXTtcblxuXHRcdFx0Ly8gbmVlZHNVcGRhdGUgcHJvcGVydHkgaXMgbm90IGFkZGVkIHRvIGFsbCB1bmlmb3Jtcy5cblx0XHRcdGlmICggdW5pZm9ybS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIHR5cGUgPSB1bmlmb3JtLnR5cGU7XG5cdFx0XHR2YXIgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXHRcdFx0dmFyIGxvY2F0aW9uID0gdW5pZm9ybXNbIGogXVsgMSBdO1xuXG5cdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJzFpJzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICcxZic6XG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMmYnOlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnM2YnOlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdLCB2YWx1ZVsgMiBdICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnNGYnOlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdLCB2YWx1ZVsgMiBdLCB2YWx1ZVsgMyBdICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMWl2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnM2l2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMWZ2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMmZ2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnM2Z2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnNGZ2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTWF0cml4M2Z2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01hdHJpeDRmdic6XG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdGNhc2UgJ2knOlxuXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIGludGVnZXJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2YnOlxuXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIGZsb2F0XG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd2Mic6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yMlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd2Myc6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yM1xuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd2NCc6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVmVjdG9yNFxuXHRcdFx0XHRcdF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56LCB2YWx1ZS53ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdjJzpcblxuXHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5Db2xvclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZS5yLCB2YWx1ZS5nLCB2YWx1ZS5iICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpdjEnOlxuXG5cdFx0XHRcdFx0Ly8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyAoSlMgb3IgdHlwZWQgYXJyYXkpXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnaXYnOlxuXG5cdFx0XHRcdFx0Ly8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2Z2MSc6XG5cblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyAoSlMgb3IgdHlwZWQgYXJyYXkpXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZnYnOlxuXG5cdFx0XHRcdFx0Ly8gZmxhdCBhcnJheSBvZiBmbG9hdHMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd2MnYnOlxuXG5cdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yMlxuXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDIgKiB2YWx1ZS5sZW5ndGggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gaSAqIDI7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgXSAgID0gdmFsdWVbIGkgXS54O1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Yzdic6XG5cblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IzXG5cblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMyAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSBpICogMztcblxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCBdICAgPSB2YWx1ZVsgaSBdLng7XG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlWyBpIF0uejtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Y0dic6XG5cblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3I0XG5cblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggNCAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRvZmZzZXQgPSBpICogNDtcblxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCBdICAgPSB2YWx1ZVsgaSBdLng7XG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlWyBpIF0uejtcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAzIF0gPSB2YWx1ZVsgaSBdLnc7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtMyc6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuTWF0cml4M1xuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlLmVsZW1lbnRzICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtM3YnOlxuXG5cdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuTWF0cml4M1xuXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDkgKiB2YWx1ZS5sZW5ndGggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiA5ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbTQnOlxuXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLk1hdHJpeDRcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZS5lbGVtZW50cyApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbTR2JzpcblxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLk1hdHJpeDRcblxuXHRcdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDE2ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLl9hcnJheSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndCc6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuVGV4dHVyZSAoMmQgb3IgY3ViZSlcblxuXHRcdFx0XHRcdHRleHR1cmUgPSB2YWx1ZTtcblx0XHRcdFx0XHR0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHRcdGlmICggISB0ZXh0dXJlICkgY29udGludWU7XG5cblx0XHRcdFx0XHRpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5DdWJlVGV4dHVyZSB8fFxuXHRcdFx0XHRcdCAgICggdGV4dHVyZS5pbWFnZSBpbnN0YW5jZW9mIEFycmF5ICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkgKSB7IC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXG5cblx0XHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuXHRcdFx0XHRcdFx0c2V0Q3ViZVRleHR1cmVEeW5hbWljKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3R2JzpcblxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlRleHR1cmUgKDJkKVxuXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IFtdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpIF0gPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUgPSB1bmlmb3JtLnZhbHVlWyBpIF07XG5cdFx0XHRcdFx0XHR0ZXh0dXJlVW5pdCA9IHVuaWZvcm0uX2FycmF5WyBpIF07XG5cblx0XHRcdFx0XHRcdGlmICggISB0ZXh0dXJlICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5rbm93biB1bmlmb3JtIHR5cGU6ICcgKyB0eXBlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0dXBNYXRyaWNlcyAoIG9iamVjdCwgY2FtZXJhICkge1xuXG5cdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0b2JqZWN0Ll9ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QuX21vZGVsVmlld01hdHJpeCApO1xuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIHNldENvbG9yR2FtbWEoIGFycmF5LCBvZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHlTcSApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSAgICAgPSBjb2xvci5yICogY29sb3IuciAqIGludGVuc2l0eVNxO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nICogY29sb3IuZyAqIGludGVuc2l0eVNxO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iICogY29sb3IuYiAqIGludGVuc2l0eVNxO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRDb2xvckxpbmVhciggYXJyYXksIG9mZnNldCwgY29sb3IsIGludGVuc2l0eSApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSAgICAgPSBjb2xvci5yICogaW50ZW5zaXR5O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nICogaW50ZW5zaXR5O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iICogaW50ZW5zaXR5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXR1cExpZ2h0cyAoIGxpZ2h0cyApIHtcblxuXHRcdHZhciBsLCBsbCwgbGlnaHQsIG4sXG5cdFx0ciA9IDAsIGcgPSAwLCBiID0gMCxcblx0XHRjb2xvciwgc2t5Q29sb3IsIGdyb3VuZENvbG9yLFxuXHRcdGludGVuc2l0eSwgIGludGVuc2l0eVNxLFxuXHRcdHBvc2l0aW9uLFxuXHRcdGRpc3RhbmNlLFxuXG5cdFx0emxpZ2h0cyA9IF9saWdodHMsXG5cblx0XHRkaXJDb2xvcnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycyxcblx0XHRkaXJQb3NpdGlvbnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucyxcblxuXHRcdHBvaW50Q29sb3JzID0gemxpZ2h0cy5wb2ludC5jb2xvcnMsXG5cdFx0cG9pbnRQb3NpdGlvbnMgPSB6bGlnaHRzLnBvaW50LnBvc2l0aW9ucyxcblx0XHRwb2ludERpc3RhbmNlcyA9IHpsaWdodHMucG9pbnQuZGlzdGFuY2VzLFxuXG5cdFx0c3BvdENvbG9ycyA9IHpsaWdodHMuc3BvdC5jb2xvcnMsXG5cdFx0c3BvdFBvc2l0aW9ucyA9IHpsaWdodHMuc3BvdC5wb3NpdGlvbnMsXG5cdFx0c3BvdERpc3RhbmNlcyA9IHpsaWdodHMuc3BvdC5kaXN0YW5jZXMsXG5cdFx0c3BvdERpcmVjdGlvbnMgPSB6bGlnaHRzLnNwb3QuZGlyZWN0aW9ucyxcblx0XHRzcG90QW5nbGVzQ29zID0gemxpZ2h0cy5zcG90LmFuZ2xlc0Nvcyxcblx0XHRzcG90RXhwb25lbnRzID0gemxpZ2h0cy5zcG90LmV4cG9uZW50cyxcblxuXHRcdGhlbWlTa3lDb2xvcnMgPSB6bGlnaHRzLmhlbWkuc2t5Q29sb3JzLFxuXHRcdGhlbWlHcm91bmRDb2xvcnMgPSB6bGlnaHRzLmhlbWkuZ3JvdW5kQ29sb3JzLFxuXHRcdGhlbWlQb3NpdGlvbnMgPSB6bGlnaHRzLmhlbWkucG9zaXRpb25zLFxuXG5cdFx0ZGlyTGVuZ3RoID0gMCxcblx0XHRwb2ludExlbmd0aCA9IDAsXG5cdFx0c3BvdExlbmd0aCA9IDAsXG5cdFx0aGVtaUxlbmd0aCA9IDAsXG5cblx0XHRkaXJDb3VudCA9IDAsXG5cdFx0cG9pbnRDb3VudCA9IDAsXG5cdFx0c3BvdENvdW50ID0gMCxcblx0XHRoZW1pQ291bnQgPSAwLFxuXG5cdFx0ZGlyT2Zmc2V0ID0gMCxcblx0XHRwb2ludE9mZnNldCA9IDAsXG5cdFx0c3BvdE9mZnNldCA9IDAsXG5cdFx0aGVtaU9mZnNldCA9IDA7XG5cblx0XHRmb3IgKCBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XG5cblx0XHRcdGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cblx0XHRcdGlmICggbGlnaHQub25seVNoYWRvdyApIGNvbnRpbnVlO1xuXG5cdFx0XHRjb2xvciA9IGxpZ2h0LmNvbG9yO1xuXHRcdFx0aW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xuXHRcdFx0ZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkFtYmllbnRMaWdodCApIHtcblxuXHRcdFx0XHRpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcblxuXHRcdFx0XHRcdHIgKz0gY29sb3IuciAqIGNvbG9yLnI7XG5cdFx0XHRcdFx0ZyArPSBjb2xvci5nICogY29sb3IuZztcblx0XHRcdFx0XHRiICs9IGNvbG9yLmIgKiBjb2xvci5iO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyICs9IGNvbG9yLnI7XG5cdFx0XHRcdFx0ZyArPSBjb2xvci5nO1xuXHRcdFx0XHRcdGIgKz0gY29sb3IuYjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcblxuXHRcdFx0XHRkaXJDb3VudCArPSAxO1xuXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cblx0XHRcdFx0X2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xuXHRcdFx0XHRfZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGRpck9mZnNldCA9IGRpckxlbmd0aCAqIDM7XG5cblx0XHRcdFx0ZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgXSAgICAgPSBfZGlyZWN0aW9uLng7XG5cdFx0XHRcdGRpclBvc2l0aW9uc1sgZGlyT2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xuXHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcblxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdFx0XHRzZXRDb2xvckdhbW1hKCBkaXJDb2xvcnMsIGRpck9mZnNldCwgY29sb3IsIGludGVuc2l0eSAqIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggZGlyQ29sb3JzLCBkaXJPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlyTGVuZ3RoICs9IDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHRwb2ludENvdW50ICs9IDE7XG5cblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuXHRcdFx0XHRwb2ludE9mZnNldCA9IHBvaW50TGVuZ3RoICogMztcblxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdFx0XHRzZXRDb2xvckdhbW1hKCBwb2ludENvbG9ycywgcG9pbnRPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKiBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIHBvaW50Q29sb3JzLCBwb2ludE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0IF0gICAgID0gX3ZlY3RvcjMueDtcblx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMSBdID0gX3ZlY3RvcjMueTtcblx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMiBdID0gX3ZlY3RvcjMuejtcblxuXHRcdFx0XHRwb2ludERpc3RhbmNlc1sgcG9pbnRMZW5ndGggXSA9IGRpc3RhbmNlO1xuXG5cdFx0XHRcdHBvaW50TGVuZ3RoICs9IDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkge1xuXG5cdFx0XHRcdHNwb3RDb3VudCArPSAxO1xuXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cblx0XHRcdFx0c3BvdE9mZnNldCA9IHNwb3RMZW5ndGggKiAzO1xuXG5cdFx0XHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcblxuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIHNwb3RDb2xvcnMsIHNwb3RPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKiBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIHNwb3RDb2xvcnMsIHNwb3RPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCBdICAgICA9IF9kaXJlY3Rpb24ueDtcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcblxuXHRcdFx0XHRzcG90RGlzdGFuY2VzWyBzcG90TGVuZ3RoIF0gPSBkaXN0YW5jZTtcblxuXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcblx0XHRcdFx0X2RpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCBdICAgICA9IF9kaXJlY3Rpb24ueDtcblx0XHRcdFx0c3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG5cdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xuXG5cdFx0XHRcdHNwb3RBbmdsZXNDb3NbIHNwb3RMZW5ndGggXSA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xuXHRcdFx0XHRzcG90RXhwb25lbnRzWyBzcG90TGVuZ3RoIF0gPSBsaWdodC5leHBvbmVudDtcblxuXHRcdFx0XHRzcG90TGVuZ3RoICs9IDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkge1xuXG5cdFx0XHRcdGhlbWlDb3VudCArPSAxO1xuXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cblx0XHRcdFx0X2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdF9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0aGVtaU9mZnNldCA9IGhlbWlMZW5ndGggKiAzO1xuXG5cdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgXSAgICAgPSBfZGlyZWN0aW9uLng7XG5cdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG5cdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cblx0XHRcdFx0c2t5Q29sb3IgPSBsaWdodC5jb2xvcjtcblx0XHRcdFx0Z3JvdW5kQ29sb3IgPSBsaWdodC5ncm91bmRDb2xvcjtcblxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XG5cblx0XHRcdFx0XHRpbnRlbnNpdHlTcSA9IGludGVuc2l0eSAqIGludGVuc2l0eTtcblxuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIGhlbWlTa3lDb2xvcnMsIGhlbWlPZmZzZXQsIHNreUNvbG9yLCBpbnRlbnNpdHlTcSApO1xuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIGhlbWlHcm91bmRDb2xvcnMsIGhlbWlPZmZzZXQsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHlTcSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggaGVtaVNreUNvbG9ycywgaGVtaU9mZnNldCwgc2t5Q29sb3IsIGludGVuc2l0eSApO1xuXHRcdFx0XHRcdHNldENvbG9yTGluZWFyKCBoZW1pR3JvdW5kQ29sb3JzLCBoZW1pT2Zmc2V0LCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGhlbWlMZW5ndGggKz0gMTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gbnVsbCBldmVudHVhbCByZW1haW5zIGZyb20gcmVtb3ZlZCBsaWdodHNcblx0XHQvLyAodGhpcyBpcyB0byBhdm9pZCBpZiBpbiBzaGFkZXIpXG5cblx0XHRmb3IgKCBsID0gZGlyTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggZGlyQ29sb3JzLmxlbmd0aCwgZGlyQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGRpckNvbG9yc1sgbCBdID0gMC4wO1xuXHRcdGZvciAoIGwgPSBwb2ludExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHBvaW50Q29sb3JzLmxlbmd0aCwgcG9pbnRDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgcG9pbnRDb2xvcnNbIGwgXSA9IDAuMDtcblx0XHRmb3IgKCBsID0gc3BvdExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHNwb3RDb2xvcnMubGVuZ3RoLCBzcG90Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHNwb3RDb2xvcnNbIGwgXSA9IDAuMDtcblx0XHRmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlTa3lDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlTa3lDb2xvcnNbIGwgXSA9IDAuMDtcblx0XHRmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlHcm91bmRDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlHcm91bmRDb2xvcnNbIGwgXSA9IDAuMDtcblxuXHRcdHpsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyTGVuZ3RoO1xuXHRcdHpsaWdodHMucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XG5cdFx0emxpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XG5cdFx0emxpZ2h0cy5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XG5cblx0XHR6bGlnaHRzLmFtYmllbnRbIDAgXSA9IHI7XG5cdFx0emxpZ2h0cy5hbWJpZW50WyAxIF0gPSBnO1xuXHRcdHpsaWdodHMuYW1iaWVudFsgMiBdID0gYjtcblxuXHR9XG5cblx0Ly8gR0wgc3RhdGUgc2V0dGluZ1xuXG5cdHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XG5cblx0XHRpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZU5vbmUgKSB7XG5cblx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKSB7XG5cblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNXICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlQmFjayApIHtcblxuXHRcdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnNldE1hdGVyaWFsRmFjZXMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG5cdFx0dmFyIGRvdWJsZVNpZGVkID0gbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZTtcblx0XHR2YXIgZmxpcFNpZGVkID0gbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGU7XG5cblx0XHRpZiAoIF9vbGREb3VibGVTaWRlZCAhPT0gZG91YmxlU2lkZWQgKSB7XG5cblx0XHRcdGlmICggZG91YmxlU2lkZWQgKSB7XG5cblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X29sZERvdWJsZVNpZGVkID0gZG91YmxlU2lkZWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIF9vbGRGbGlwU2lkZWQgIT09IGZsaXBTaWRlZCApIHtcblxuXHRcdFx0aWYgKCBmbGlwU2lkZWQgKSB7XG5cblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNXICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9vbGRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnNldERlcHRoVGVzdCA9IGZ1bmN0aW9uICggZGVwdGhUZXN0ICkge1xuXG5cdFx0aWYgKCBfb2xkRGVwdGhUZXN0ICE9PSBkZXB0aFRlc3QgKSB7XG5cblx0XHRcdGlmICggZGVwdGhUZXN0ICkge1xuXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5ERVBUSF9URVNUICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5ERVBUSF9URVNUICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X29sZERlcHRoVGVzdCA9IGRlcHRoVGVzdDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuc2V0RGVwdGhXcml0ZSA9IGZ1bmN0aW9uICggZGVwdGhXcml0ZSApIHtcblxuXHRcdGlmICggX29sZERlcHRoV3JpdGUgIT09IGRlcHRoV3JpdGUgKSB7XG5cblx0XHRcdF9nbC5kZXB0aE1hc2soIGRlcHRoV3JpdGUgKTtcblx0XHRcdF9vbGREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNldExpbmVXaWR0aCAoIHdpZHRoICkge1xuXG5cdFx0aWYgKCB3aWR0aCAhPT0gX29sZExpbmVXaWR0aCApIHtcblxuXHRcdFx0X2dsLmxpbmVXaWR0aCggd2lkdGggKTtcblxuXHRcdFx0X29sZExpbmVXaWR0aCA9IHdpZHRoO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRQb2x5Z29uT2Zmc2V0ICggcG9seWdvbm9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcblxuXHRcdGlmICggX29sZFBvbHlnb25PZmZzZXQgIT09IHBvbHlnb25vZmZzZXQgKSB7XG5cblx0XHRcdGlmICggcG9seWdvbm9mZnNldCApIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9vbGRQb2x5Z29uT2Zmc2V0ID0gcG9seWdvbm9mZnNldDtcblxuXHRcdH1cblxuXHRcdGlmICggcG9seWdvbm9mZnNldCAmJiAoIF9vbGRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgX29sZFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMgKSApIHtcblxuXHRcdFx0X2dsLnBvbHlnb25PZmZzZXQoIGZhY3RvciwgdW5pdHMgKTtcblxuXHRcdFx0X29sZFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XG5cdFx0XHRfb2xkUG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuc2V0QmxlbmRpbmcgPSBmdW5jdGlvbiAoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QgKSB7XG5cblx0XHRpZiAoIGJsZW5kaW5nICE9PSBfb2xkQmxlbmRpbmcgKSB7XG5cblx0XHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk5vQmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5CTEVORCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZyApIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb24oIF9nbC5GVU5DX0FERCApO1xuXHRcdFx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nICkge1xuXG5cdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb24oIF9nbC5GVU5DX0FERCApO1xuXHRcdFx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuWkVSTywgX2dsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0Ly8gVE9ETzogRmluZCBibGVuZEZ1bmNTZXBhcmF0ZSgpIGNvbWJpbmF0aW9uXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xuXHRcdFx0XHRfZ2wuYmxlbmRFcXVhdGlvbiggX2dsLkZVTkNfQUREICk7XG5cdFx0XHRcdF9nbC5ibGVuZEZ1bmMoIF9nbC5aRVJPLCBfZ2wuU1JDX0NPTE9SICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5DdXN0b21CbGVuZGluZyApIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggX2dsLkZVTkNfQURELCBfZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0X2dsLmJsZW5kRnVuY1NlcGFyYXRlKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgX2dsLk9ORSwgX2dsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfb2xkQmxlbmRpbmcgPSBibGVuZGluZztcblxuXHRcdH1cblxuXHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xuXG5cdFx0XHRpZiAoIGJsZW5kRXF1YXRpb24gIT09IF9vbGRCbGVuZEVxdWF0aW9uICkge1xuXG5cdFx0XHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbiApICk7XG5cblx0XHRcdFx0X29sZEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYmxlbmRTcmMgIT09IF9vbGRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gX29sZEJsZW5kRHN0ICkge1xuXG5cdFx0XHRcdF9nbC5ibGVuZEZ1bmMoIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyYyApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3QgKSApO1xuXG5cdFx0XHRcdF9vbGRCbGVuZFNyYyA9IGJsZW5kU3JjO1xuXHRcdFx0XHRfb2xkQmxlbmREc3QgPSBibGVuZERzdDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X29sZEJsZW5kRXF1YXRpb24gPSBudWxsO1xuXHRcdFx0X29sZEJsZW5kU3JjID0gbnVsbDtcblx0XHRcdF9vbGRCbGVuZERzdCA9IG51bGw7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBUZXh0dXJlc1xuXG5cdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzICggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG5cdFx0dmFyIGV4dGVuc2lvbjtcblxuXHRcdGlmICggaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwUyApICk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFQgKSApO1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cblx0XHR9XG5cblx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9uICYmIHRleHR1cmUudHlwZSAhPT0gVEhSRUUuRmxvYXRUeXBlICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmUuYW5pc290cm9weSA+IDEgfHwgdGV4dHVyZS5fX29sZEFuaXNvdHJvcHkgKSB7XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIF90aGlzLmdldE1heEFuaXNvdHJvcHkoKSApICk7XG5cdFx0XHRcdHRleHR1cmUuX19vbGRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMudXBsb2FkVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuXHRcdGlmICggdGV4dHVyZS5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcblxuXHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuXHRcdFx0dGV4dHVyZS5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xuXG5cdFx0fVxuXG5cdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xuXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XG5cdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcblxuXHRcdHRleHR1cmUuaW1hZ2UgPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZSwgX21heFRleHR1cmVTaXplICk7XG5cblx0XHR2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlLFxuXHRcdGlzSW1hZ2VQb3dlck9mVHdvID0gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApLFxuXHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXG5cdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xuXG5cdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xuXG5cdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcblxuXHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlICkge1xuXG5cdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG5cdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuXHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdF9nbC5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRcIiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfZ2wudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgeyAvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxuXG5cdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG5cdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuXHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5pbWFnZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXG5cdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSgpO1xuXG5cdH07XG5cblx0dGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblxuXHRcdGlmICggdGV4dHVyZS5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0X3RoaXMudXBsb2FkVGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gY2xhbXBUb01heFNpemUgKCBpbWFnZSwgbWF4U2l6ZSApIHtcblxuXHRcdGlmICggaW1hZ2Uud2lkdGggPiBtYXhTaXplIHx8IGltYWdlLmhlaWdodCA+IG1heFNpemUgKSB7XG5cblx0XHRcdC8vIFdhcm5pbmc6IFNjYWxpbmcgdGhyb3VnaCB0aGUgY2FudmFzIHdpbGwgb25seSB3b3JrIHdpdGggaW1hZ2VzIHRoYXQgdXNlXG5cdFx0XHQvLyBwcmVtdWx0aXBsaWVkIGFscGhhLlxuXG5cdFx0XHR2YXIgc2NhbGUgPSBtYXhTaXplIC8gTWF0aC5tYXgoIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG5cdFx0XHRjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKCBpbWFnZS53aWR0aCAqIHNjYWxlICk7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vciggaW1hZ2UuaGVpZ2h0ICogc2NhbGUgKTtcblxuXHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcblxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOicsIGltYWdlLCAnaXMgdG9vIGJpZyAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuIFJlc2l6ZWQgdG8gJyArIGNhbnZhcy53aWR0aCArICd4JyArIGNhbnZhcy5oZWlnaHQgKyAnLicgKTtcblxuXHRcdFx0cmV0dXJuIGNhbnZhcztcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmUgKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApIHtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdGlmICggISB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuXHRcdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG5cblx0XHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9IHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZTtcblx0XHRcdFx0dmFyIGlzRGF0YVRleHR1cmUgPSB0ZXh0dXJlLmltYWdlWyAwIF0gaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZTtcblxuXHRcdFx0XHR2YXIgY3ViZUltYWdlID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggX3RoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgJiYgISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlWyBpIF0sIF9tYXhDdWJlbWFwU2l6ZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcblx0XHRcdFx0aXNJbWFnZVBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICksXG5cdFx0XHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXG5cdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggaXNEYXRhVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdFx0XHRfZ2wudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGogXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JGb3JtYXQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdFwiICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuXHRcdFx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlRHluYW1pYyAoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcblxuXHR9XG5cblx0Ly8gUmVuZGVyIHRhcmdldHNcblxuXHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyICggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZVRhcmdldCApIHtcblxuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCB0ZXh0dXJlVGFyZ2V0LCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUsIDAgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXIgKCByZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCAgKSB7XG5cblx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cblx0XHQvKiBGb3Igc29tZSByZWFzb24gdGhpcyBpcyBub3Qgd29ya2luZy4gRGVmYXVsdGluZyB0byBSR0JBNC5cblx0XHR9IGVsc2UgaWYgKCAhIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5TVEVOQ0lMX0lOREVYOCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLlNURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cdFx0Ki9cblx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cblx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID0gdHJ1ZTtcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID0gdHJ1ZTtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cblx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xuXG5cdFx0XHQvLyBTZXR1cCB0ZXh0dXJlLCBjcmVhdGUgcmVuZGVyIGFuZCBmcmFtZSBidWZmZXJzXG5cblx0XHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC5oZWlnaHQgKSxcblx0XHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LmZvcm1hdCApLFxuXHRcdFx0XHRnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LnR5cGUgKTtcblxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuXHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IFtdO1xuXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldCwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cblx0XHRcdFx0XHRfZ2wudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcblxuXHRcdFx0XHRcdHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xuXHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgPSByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20uX193ZWJnbFJlbmRlcmJ1ZmZlcjtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldCwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cblx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV8yRCApO1xuXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xuXG5cdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVsZWFzZSBldmVyeXRoaW5nXG5cblx0XHRcdGlmICggaXNDdWJlICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGZyYW1lYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCB2eCwgdnk7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdFx0ZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0d2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG5cdFx0XHRoZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuXG5cdFx0XHR2eCA9IDA7XG5cdFx0XHR2eSA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmcmFtZWJ1ZmZlciA9IG51bGw7XG5cblx0XHRcdHdpZHRoID0gX3ZpZXdwb3J0V2lkdGg7XG5cdFx0XHRoZWlnaHQgPSBfdmlld3BvcnRIZWlnaHQ7XG5cblx0XHRcdHZ4ID0gX3ZpZXdwb3J0WDtcblx0XHRcdHZ5ID0gX3ZpZXdwb3J0WTtcblxuXHRcdH1cblxuXHRcdGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblx0XHRcdF9nbC52aWV3cG9ydCggdngsIHZ5LCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHRcdF9jdXJyZW50RnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdF9jdXJyZW50V2lkdGggPSB3aWR0aDtcblx0XHRfY3VycmVudEhlaWdodCA9IGhlaWdodDtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcblx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xuXG5cdGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrICggZiApIHtcblxuXHRcdGlmICggZiA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkge1xuXG5cdFx0XHRyZXR1cm4gX2dsLk5FQVJFU1Q7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gX2dsLkxJTkVBUjtcblxuXHR9XG5cblx0Ly8gTWFwIHRocmVlLmpzIGNvbnN0YW50cyB0byBXZWJHTCBjb25zdGFudHNcblxuXHRmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCAoIHAgKSB7XG5cblx0XHR2YXIgZXh0ZW5zaW9uO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuUkVQRUFUO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiBfZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHRpZiAoIHAgPT09IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLk1JUlJPUkVEX1JFUEVBVDtcblxuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUjtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XG5cblx0XHRpZiAoIHAgPT09IFRIUkVFLkJ5dGVUeXBlICkgcmV0dXJuIF9nbC5CWVRFO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5TSE9SVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkludFR5cGUgKSByZXR1cm4gX2dsLklOVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkSW50VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfSU5UO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuRmxvYXRUeXBlICkgcmV0dXJuIF9nbC5GTE9BVDtcblxuXHRcdGlmICggcCA9PT0gVEhSRUUuQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkFMUEhBO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuUkdCRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0I7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0JBO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0U7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFX0FMUEhBO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5BZGRFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19BREQ7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5TdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1NVQlRSQUNUO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVDtcblxuXHRcdGlmICggcCA9PT0gVEhSRUUuWmVyb0ZhY3RvciApIHJldHVybiBfZ2wuWkVSTztcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZUZhY3RvciApIHJldHVybiBfZ2wuT05FO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19DT0xPUjtcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQ09MT1I7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkRzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQUxQSEE7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0FMUEhBO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5Ec3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuRFNUX0NPTE9SO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQV9TQVRVUkFURTtcblxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cblx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcblxuXHRcdH1cblxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xuXG5cdFx0fVxuXG5cdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdGlmICggcCA9PT0gVEhSRUUuTWluRXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1JTl9FWFQ7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLk1heEVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NQVhfRVhUO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cblx0fVxuXG5cdC8vIEFsbG9jYXRpb25zXG5cblx0ZnVuY3Rpb24gYWxsb2NhdGVCb25lcyAoIG9iamVjdCApIHtcblxuXHRcdGlmICggX3N1cHBvcnRzQm9uZVRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cblx0XHRcdHJldHVybiAxMDI0O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxuXHRcdFx0Ly8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlclxuXHRcdFx0Ly8gICB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGUgb2JqZWN0cyApXG5cdFx0XHQvL1xuXHRcdFx0Ly8gIC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcblx0XHRcdC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xuXHRcdFx0Ly8gICAgKHVwIHRvIDU0IHNob3VsZCBiZSBzYWZlKVxuXG5cdFx0XHR2YXIgblZlcnRleFVuaWZvcm1zID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICk7XG5cdFx0XHR2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xuXG5cdFx0XHR2YXIgbWF4Qm9uZXMgPSBuVmVydGV4TWF0cmljZXM7XG5cblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cblx0XHRcdFx0bWF4Qm9uZXMgPSBNYXRoLm1pbiggb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgbWF4Qm9uZXMgKTtcblxuXHRcdFx0XHRpZiAoIG1heEJvbmVzIDwgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRvbyBtYW55IGJvbmVzIC0gJyArIG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKyAnLCB0aGlzIEdQVSBzdXBwb3J0cyBqdXN0ICcgKyBtYXhCb25lcyArICcgKHRyeSBPcGVuR0wgaW5zdGVhZCBvZiBBTkdMRSknICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXhCb25lcztcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gYWxsb2NhdGVMaWdodHMoIGxpZ2h0cyApIHtcblxuXHRcdHZhciBkaXJMaWdodHMgPSAwO1xuXHRcdHZhciBwb2ludExpZ2h0cyA9IDA7XG5cdFx0dmFyIHNwb3RMaWdodHMgPSAwO1xuXHRcdHZhciBoZW1pTGlnaHRzID0gMDtcblxuXHRcdGZvciAoIHZhciBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XG5cblx0XHRcdHZhciBsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG5cdFx0XHRpZiAoIGxpZ2h0Lm9ubHlTaGFkb3cgfHwgbGlnaHQudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSBkaXJMaWdodHMgKys7XG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHBvaW50TGlnaHRzICsrO1xuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHNwb3RMaWdodHMgKys7XG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkgaGVtaUxpZ2h0cyArKztcblxuXHRcdH1cblxuXHRcdHJldHVybiB7ICdkaXJlY3Rpb25hbCc6IGRpckxpZ2h0cywgJ3BvaW50JzogcG9pbnRMaWdodHMsICdzcG90Jzogc3BvdExpZ2h0cywgJ2hlbWknOiBoZW1pTGlnaHRzIH07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICkge1xuXG5cdFx0dmFyIG1heFNoYWRvd3MgPSAwO1xuXG5cdFx0Zm9yICggdmFyIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcblxuXHRcdFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XG5cblx0XHRcdGlmICggISBsaWdodC5jYXN0U2hhZG93ICkgY29udGludWU7XG5cblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBtYXhTaGFkb3dzICsrO1xuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgJiYgISBsaWdodC5zaGFkb3dDYXNjYWRlICkgbWF4U2hhZG93cyArKztcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXhTaGFkb3dzO1xuXG5cdH1cblxuXHQvLyBERVBSRUNBVEVEXG5cdFxuXHR0aGlzLmluaXRNYXRlcmlhbCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5pbml0TWF0ZXJpYWwoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9O1xuXG5cdHRoaXMuYWRkUHJlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFByZVBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdH07XG5cblx0dGhpcy5hZGRQb3N0UGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFBvc3RQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHR9O1xuXG5cdHRoaXMudXBkYXRlU2hhZG93TWFwID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnVwZGF0ZVNoYWRvd01hcCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdH07XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldC5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XG5cblx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHR0aGlzLndyYXBTID0gb3B0aW9ucy53cmFwUyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdHRoaXMud3JhcFQgPSBvcHRpb25zLndyYXBUICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHR0aGlzLm1hZ0ZpbHRlciA9IG9wdGlvbnMubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcblx0dGhpcy5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cblx0dGhpcy5hbmlzb3Ryb3B5ID0gb3B0aW9ucy5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaXNvdHJvcHkgOiAxO1xuXG5cdHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcblx0dGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG5cdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcblx0dGhpcy50eXBlID0gb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG5cdHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcblx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xuXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblxuXHR0aGlzLnNoYXJlRGVwdGhGcm9tID0gbnVsbDtcblxufTtcblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCxcblxuXHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRtcCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQgKTtcblxuXHRcdHRtcC53cmFwUyA9IHRoaXMud3JhcFM7XG5cdFx0dG1wLndyYXBUID0gdGhpcy53cmFwVDtcblxuXHRcdHRtcC5tYWdGaWx0ZXIgPSB0aGlzLm1hZ0ZpbHRlcjtcblx0XHR0bXAubWluRmlsdGVyID0gdGhpcy5taW5GaWx0ZXI7XG5cblx0XHR0bXAuYW5pc290cm9weSA9IHRoaXMuYW5pc290cm9weTtcblxuXHRcdHRtcC5vZmZzZXQuY29weSggdGhpcy5vZmZzZXQgKTtcblx0XHR0bXAucmVwZWF0LmNvcHkoIHRoaXMucmVwZWF0ICk7XG5cblx0XHR0bXAuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG5cdFx0dG1wLnR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHR0bXAuZGVwdGhCdWZmZXIgPSB0aGlzLmRlcHRoQnVmZmVyO1xuXHRcdHRtcC5zdGVuY2lsQnVmZmVyID0gdGhpcy5zdGVuY2lsQnVmZmVyO1xuXG5cdFx0dG1wLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0dG1wLnNoYXJlRGVwdGhGcm9tID0gdGhpcy5zaGFyZURlcHRoRnJvbTtcblxuXHRcdHJldHVybiB0bXA7XG5cblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXRDdWJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbVxuICovXG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcblxuXHRUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5jYWxsKCB0aGlzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XG5cblx0dGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7IC8vIFBYIDAsIE5YIDEsIFBZIDIsIE5ZIDMsIFBaIDQsIE5aIDVcblxufTtcblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xFeHRlbnNpb25zLmpzXG5cblRIUkVFLldlYkdMRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uICggZ2wgKSB7XG5cblx0dmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuXHR0aGlzLmdldCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBleHRlbnNpb25zWyBuYW1lIF07XG5cblx0XHR9XG5cblx0XHR2YXIgZXh0ZW5zaW9uO1xuXG5cdFx0c3dpdGNoICggbmFtZSApIHtcblx0XHRcblx0XHRcdGNhc2UgJ09FU190ZXh0dXJlX2Zsb2F0Jzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdPRVNfZWxlbWVudF9pbmRleF91aW50Jzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0VYVF9ibGVuZF9taW5tYXgnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnRVhUX2ZyYWdfZGVwdGgnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfZnJhZ19kZXB0aCcgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgbmFtZSArICcgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0ZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbjtcblxuXHR9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtLmpzXG5cblRIUkVFLldlYkdMUHJvZ3JhbSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBwcm9ncmFtSWRDb3VudCA9IDA7XG5cblx0dmFyIGdlbmVyYXRlRGVmaW5lcyA9IGZ1bmN0aW9uICggZGVmaW5lcyApIHtcblxuXHRcdHZhciB2YWx1ZSwgY2h1bmssIGNodW5rcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGQgaW4gZGVmaW5lcyApIHtcblxuXHRcdFx0dmFsdWUgPSBkZWZpbmVzWyBkIF07XG5cdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRjaHVuayA9IFwiI2RlZmluZSBcIiArIGQgKyBcIiBcIiArIHZhbHVlO1xuXHRcdFx0Y2h1bmtzLnB1c2goIGNodW5rICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2h1bmtzLmpvaW4oIFwiXFxuXCIgKTtcblxuXHR9O1xuXG5cdHZhciBjYWNoZVVuaWZvcm1Mb2NhdGlvbnMgPSBmdW5jdGlvbiAoIGdsLCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcblxuXHRcdHZhciB1bmlmb3JtcyA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaWRlbnRpZmllcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGlkID0gaWRlbnRpZmllcnNbIGkgXTtcblx0XHRcdHVuaWZvcm1zWyBpZCBdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBpZCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVuaWZvcm1zO1xuXG5cdH07XG5cblx0dmFyIGNhY2hlQXR0cmlidXRlTG9jYXRpb25zID0gZnVuY3Rpb24gKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaWRlbnRpZmllcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGlkID0gaWRlbnRpZmllcnNbIGkgXTtcblx0XHRcdGF0dHJpYnV0ZXNbIGlkIF0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgaWQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGVzO1xuXG5cdH07XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0dmFyIF90aGlzID0gcmVuZGVyZXI7XG5cdFx0dmFyIF9nbCA9IF90aGlzLmNvbnRleHQ7XG5cblx0XHR2YXIgZGVmaW5lcyA9IG1hdGVyaWFsLmRlZmluZXM7XG5cdFx0dmFyIHVuaWZvcm1zID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci51bmlmb3Jtcztcblx0XHR2YXIgYXR0cmlidXRlcyA9IG1hdGVyaWFsLmF0dHJpYnV0ZXM7XG5cblx0XHR2YXIgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci52ZXJ0ZXhTaGFkZXI7XG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5mcmFnbWVudFNoYWRlcjtcblxuXHRcdHZhciBpbmRleDBBdHRyaWJ1dGVOYW1lID0gbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZTtcblxuXHRcdGlmICggaW5kZXgwQXR0cmlidXRlTmFtZSA9PT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG5cdFx0XHQvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcblxuXHRcdFx0aW5kZXgwQXR0cmlidXRlTmFtZSA9ICdwb3NpdGlvbic7XG5cblx0XHR9XG5cblx0XHR2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9IFwiU0hBRE9XTUFQX1RZUEVfQkFTSUNcIjtcblxuXHRcdGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTaGFkb3dNYXAgKSB7XG5cblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSBcIlNIQURPV01BUF9UWVBFX1BDRlwiO1xuXG5cdFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwICkge1xuXG5cdFx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gXCJTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVFwiO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29uc29sZS5sb2coIFwiYnVpbGRpbmcgbmV3IHByb2dyYW0gXCIgKTtcblxuXHRcdC8vXG5cblx0XHR2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBwcm9ncmFtID0gX2dsLmNyZWF0ZVByb2dyYW0oKTtcblxuXHRcdHZhciBwcmVmaXhfdmVydGV4LCBwcmVmaXhfZnJhZ21lbnQ7XG5cblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHByZWZpeF92ZXJ0ZXggPSAnJztcblx0XHRcdHByZWZpeF9mcmFnbWVudCA9ICcnO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cHJlZml4X3ZlcnRleCA9IFtcblxuXHRcdFx0XHRcInByZWNpc2lvbiBcIiArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgXCIgZmxvYXQ7XCIsXG5cdFx0XHRcdFwicHJlY2lzaW9uIFwiICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyBcIiBpbnQ7XCIsXG5cblx0XHRcdFx0Y3VzdG9tRGVmaW5lcyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyBcIiNkZWZpbmUgVkVSVEVYX1RFWFRVUkVTXCIgOiBcIlwiLFxuXG5cdFx0XHRcdF90aGlzLmdhbW1hSW5wdXQgPyBcIiNkZWZpbmUgR0FNTUFfSU5QVVRcIiA6IFwiXCIsXG5cdFx0XHRcdF90aGlzLmdhbW1hT3V0cHV0ID8gXCIjZGVmaW5lIEdBTU1BX09VVFBVVFwiIDogXCJcIixcblxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcblx0XHRcdFx0XCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX1NQT1RfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX0hFTUlfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxuXG5cdFx0XHRcdFwiI2RlZmluZSBNQVhfU0hBRE9XUyBcIiArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcblxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX0JPTkVTIFwiICsgcGFyYW1ldGVycy5tYXhCb25lcyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/IFwiI2RlZmluZSBVU0VfTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/IFwiI2RlZmluZSBVU0VfRU5WTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gXCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gXCIjZGVmaW5lIFVTRV9CVU1QTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfTk9STUFMTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/IFwiI2RlZmluZSBVU0VfQUxQSEFNQVBcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gXCIjZGVmaW5lIFVTRV9DT0xPUlwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNraW5uaW5nID8gXCIjZGVmaW5lIFVTRV9TS0lOTklOR1wiIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy51c2VWZXJ0ZXhUZXh0dXJlID8gXCIjZGVmaW5lIEJPTkVfVEVYVFVSRVwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/IFwiI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyA/IFwiI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLndyYXBBcm91bmQgPyBcIiNkZWZpbmUgV1JBUF9BUk9VTkRcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyBcIiNkZWZpbmUgRE9VQkxFX1NJREVEXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/IFwiI2RlZmluZSBGTElQX1NJREVEXCIgOiBcIlwiLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBVU0VfU0hBRE9XTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyBcIiNkZWZpbmUgXCIgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/IFwiI2RlZmluZSBTSEFET1dNQVBfREVCVUdcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwQ2FzY2FkZSA/IFwiI2RlZmluZSBTSEFET1dNQVBfQ0FTQ0FERVwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/IFwiI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OXCIgOiBcIlwiLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/IFwiI2RlZmluZSBVU0VfTE9HREVQVEhCVUZcIiA6IFwiXCIsXG5cdFx0XHRcdC8vX3RoaXMuX2dsRXh0ZW5zaW9uRnJhZ0RlcHRoID8gXCIjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFRcIiA6IFwiXCIsXG5cblxuXHRcdFx0XHRcInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcIixcblx0XHRcdFx0XCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiLFxuXHRcdFx0XHRcInVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbm9ybWFsO1wiLFxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2MjtcIixcblxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfQ09MT1JcIixcblxuXHRcdFx0XHRcIlx0YXR0cmlidXRlIHZlYzMgY29sb3I7XCIsXG5cblx0XHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXCIsXG5cblx0XHRcdFx0XCJcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDtcIixcblx0XHRcdFx0XCJcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTtcIixcblx0XHRcdFx0XCJcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjtcIixcblx0XHRcdFx0XCJcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MztcIixcblxuXHRcdFx0XHRcIlx0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcIixcblxuXHRcdFx0XHRcIlx0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7XCIsXG5cdFx0XHRcdFwiXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTtcIixcblx0XHRcdFx0XCJcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyO1wiLFxuXHRcdFx0XHRcIlx0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7XCIsXG5cblx0XHRcdFx0XCJcdCNlbHNlXCIsXG5cblx0XHRcdFx0XCJcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0O1wiLFxuXHRcdFx0XHRcIlx0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDU7XCIsXG5cdFx0XHRcdFwiXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjtcIixcblx0XHRcdFx0XCJcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3O1wiLFxuXG5cdFx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxuXG5cdFx0XHRcdFwiXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7XCIsXG5cdFx0XHRcdFwiXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0O1wiLFxuXG5cdFx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFx0XCJcIlxuXG5cdFx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHRcdHByZWZpeF9mcmFnbWVudCA9IFtcblxuXHRcdFx0XHRcInByZWNpc2lvbiBcIiArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgXCIgZmxvYXQ7XCIsXG5cdFx0XHRcdFwicHJlY2lzaW9uIFwiICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyBcIiBpbnQ7XCIsXG5cblx0XHRcdFx0KCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgKSA/IFwiI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcIiA6IFwiXCIsXG5cblx0XHRcdFx0Y3VzdG9tRGVmaW5lcyxcblxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcblx0XHRcdFx0XCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX1NQT1RfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxuXHRcdFx0XHRcIiNkZWZpbmUgTUFYX0hFTUlfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxuXG5cdFx0XHRcdFwiI2RlZmluZSBNQVhfU0hBRE9XUyBcIiArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFscGhhVGVzdCA/IFwiI2RlZmluZSBBTFBIQVRFU1QgXCIgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdDogXCJcIixcblxuXHRcdFx0XHRfdGhpcy5nYW1tYUlucHV0ID8gXCIjZGVmaW5lIEdBTU1BX0lOUFVUXCIgOiBcIlwiLFxuXHRcdFx0XHRfdGhpcy5nYW1tYU91dHB1dCA/IFwiI2RlZmluZSBHQU1NQV9PVVRQVVRcIiA6IFwiXCIsXG5cblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gXCIjZGVmaW5lIFVTRV9GT0dcIiA6IFwiXCIsXG5cdFx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAgKSA/IFwiI2RlZmluZSBGT0dfRVhQMlwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/IFwiI2RlZmluZSBVU0VfTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/IFwiI2RlZmluZSBVU0VfRU5WTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gXCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gXCIjZGVmaW5lIFVTRV9CVU1QTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfTk9STUFMTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/IFwiI2RlZmluZSBVU0VfQUxQSEFNQVBcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gXCIjZGVmaW5lIFVTRV9DT0xPUlwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1ldGFsID8gXCIjZGVmaW5lIE1FVEFMXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLndyYXBBcm91bmQgPyBcIiNkZWZpbmUgV1JBUF9BUk9VTkRcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyBcIiNkZWZpbmUgRE9VQkxFX1NJREVEXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/IFwiI2RlZmluZSBGTElQX1NJREVEXCIgOiBcIlwiLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBVU0VfU0hBRE9XTUFQXCIgOiBcIlwiLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyBcIiNkZWZpbmUgXCIgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogXCJcIixcblx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/IFwiI2RlZmluZSBTSEFET1dNQVBfREVCVUdcIiA6IFwiXCIsXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwQ2FzY2FkZSA/IFwiI2RlZmluZSBTSEFET1dNQVBfQ0FTQ0FERVwiIDogXCJcIixcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyBcIiNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGXCIgOiBcIlwiLFxuXHRcdFx0XHQvL190aGlzLl9nbEV4dGVuc2lvbkZyYWdEZXB0aCA/IFwiI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUXCIgOiBcIlwiLFxuXG5cdFx0XHRcdFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcIlwiXG5cblx0XHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdH1cblxuXHRcdHZhciBnbFZlcnRleFNoYWRlciA9IG5ldyBUSFJFRS5XZWJHTFNoYWRlciggX2dsLCBfZ2wuVkVSVEVYX1NIQURFUiwgcHJlZml4X3ZlcnRleCArIHZlcnRleFNoYWRlciApO1xuXHRcdHZhciBnbEZyYWdtZW50U2hhZGVyID0gbmV3IFRIUkVFLldlYkdMU2hhZGVyKCBfZ2wsIF9nbC5GUkFHTUVOVF9TSEFERVIsIHByZWZpeF9mcmFnbWVudCArIGZyYWdtZW50U2hhZGVyICk7XG5cblx0XHRfZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xuXHRcdF9nbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdGlmICggaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXG5cdFx0XHQvLyBiZWNhdXNlIHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBlbXVsYXRpb24gaXMgZG9uZSBieSBicm93c2VyIGlmIGF0dHJpYnV0ZSAwIGlzIGRpc2FibGVkLlxuXHRcdFx0Ly8gQW5kLCBjb2xvciwgZm9yIGV4YW1wbGUgaXMgb2Z0ZW4gYXV0b21hdGljYWxseSBib3VuZCB0byBpbmRleCAwIHNvIGRpc2FibGluZyBpdFxuXG5cdFx0XHRfZ2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBpbmRleDBBdHRyaWJ1dGVOYW1lICk7XG5cblx0XHR9XG5cblx0XHRfZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdGlmICggX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIF9nbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUHJvZ3JhbTogQ291bGQgbm90IGluaXRpYWxpc2Ugc2hhZGVyLicgKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdnbC5WQUxJREFURV9TVEFUVVMnLCBfZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgX2dsLlZBTElEQVRFX1NUQVRVUyApICk7XG5cdFx0XHRjb25zb2xlLmVycm9yKCAnZ2wuZ2V0RXJyb3IoKScsIF9nbC5nZXRFcnJvcigpICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIF9nbC5nZXRQcm9ncmFtSW5mb0xvZyggcHJvZ3JhbSApICE9PSAnJyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgX2dsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNsZWFuIHVwXG5cblx0XHRfZ2wuZGVsZXRlU2hhZGVyKCBnbFZlcnRleFNoYWRlciApO1xuXHRcdF9nbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdC8vIGNhY2hlIHVuaWZvcm0gbG9jYXRpb25zXG5cblx0XHR2YXIgaWRlbnRpZmllcnMgPSBbXG5cblx0XHRcdCd2aWV3TWF0cml4JywgJ21vZGVsVmlld01hdHJpeCcsICdwcm9qZWN0aW9uTWF0cml4JywgJ25vcm1hbE1hdHJpeCcsICdtb2RlbE1hdHJpeCcsICdjYW1lcmFQb3NpdGlvbicsICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnLCAnYmluZE1hdHJpeCcsICdiaW5kTWF0cml4SW52ZXJzZSdcblxuXHRcdF07XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggJ2JvbmVUZXh0dXJlJyApO1xuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggJ2JvbmVUZXh0dXJlV2lkdGgnICk7XG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCAnYm9uZVRleHR1cmVIZWlnaHQnICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCAnYm9uZUdsb2JhbE1hdHJpY2VzJyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cblx0XHRcdGlkZW50aWZpZXJzLnB1c2goJ2xvZ0RlcHRoQnVmRkMnKTtcblxuXHRcdH1cblxuXG5cdFx0Zm9yICggdmFyIHUgaW4gdW5pZm9ybXMgKSB7XG5cblx0XHRcdGlkZW50aWZpZXJzLnB1c2goIHUgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMudW5pZm9ybXMgPSBjYWNoZVVuaWZvcm1Mb2NhdGlvbnMoIF9nbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKTtcblxuXHRcdC8vIGNhY2hlIGF0dHJpYnV0ZXMgbG9jYXRpb25zXG5cblx0XHRpZGVudGlmaWVycyA9IFtcblxuXHRcdFx0XCJwb3NpdGlvblwiLCBcIm5vcm1hbFwiLCBcInV2XCIsIFwidXYyXCIsIFwidGFuZ2VudFwiLCBcImNvbG9yXCIsXG5cdFx0XHRcInNraW5JbmRleFwiLCBcInNraW5XZWlnaHRcIiwgXCJsaW5lRGlzdGFuY2VcIlxuXG5cdFx0XTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHBhcmFtZXRlcnMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCBcIm1vcnBoVGFyZ2V0XCIgKyBpICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcblxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggXCJtb3JwaE5vcm1hbFwiICsgaSApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGEgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggYSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0gY2FjaGVBdHRyaWJ1dGVMb2NhdGlvbnMoIF9nbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKTtcblx0XHR0aGlzLmF0dHJpYnV0ZXNLZXlzID0gT2JqZWN0LmtleXMoIHRoaXMuYXR0cmlidXRlcyApO1xuXG5cdFx0Ly9cblxuXHRcdHRoaXMuaWQgPSBwcm9ncmFtSWRDb3VudCArKztcblx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHRcdHRoaXMudXNlZFRpbWVzID0gMTtcblx0XHR0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuXHRcdHRoaXMudmVydGV4U2hhZGVyID0gZ2xWZXJ0ZXhTaGFkZXI7XG5cdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGdsRnJhZ21lbnRTaGFkZXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZGVyLmpzXG5cblRIUkVFLldlYkdMU2hhZGVyID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGFkZExpbmVOdW1iZXJzID0gZnVuY3Rpb24gKCBzdHJpbmcgKSB7XG5cblx0XHR2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBsaW5lcy5qb2luKCAnXFxuJyApO1xuXG5cdH07XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggZ2wsIHR5cGUsIHN0cmluZyApIHtcblxuXHRcdHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIHR5cGUgKTsgXG5cblx0XHRnbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XG5cdFx0Z2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XG5cblx0XHRpZiAoIGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgIT09ICcnICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgKTtcblx0XHRcdGNvbnNvbGUud2FybiggYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XG5cblx0XHR9XG5cblx0XHQvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxuXHRcdC8vIGNvbnNvbGUubG9nKCB0eXBlLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XG5cblx0XHRyZXR1cm4gc2hhZGVyO1xuXG5cdH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9MZW5zRmxhcmVQbHVnaW4uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5MZW5zRmxhcmVQbHVnaW4gPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBmbGFyZXMgKSB7XG5cblx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblxuXHR2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xuXHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG5cdHZhciBoYXNWZXJ0ZXhUZXh0dXJlO1xuXG5cdHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcblxuXHR2YXIgaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblx0XHRcdC0xLCAtMSwgIDAsIDAsXG5cdFx0XHQgMSwgLTEsICAxLCAwLFxuXHRcdFx0IDEsICAxLCAgMSwgMSxcblx0XHRcdC0xLCAgMSwgIDAsIDFcblx0XHRdICk7XG5cblx0XHR2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcblx0XHRcdDAsIDEsIDIsXG5cdFx0XHQwLCAyLCAzXG5cdFx0XSApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0dmVydGV4QnVmZmVyICAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGVsZW1lbnRCdWZmZXIgICAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG5cdFx0Ly8gdGV4dHVyZXNcblxuXHRcdHRlbXBUZXh0dXJlICAgICAgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0b2NjbHVzaW9uVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuXHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMTYsIDE2LCAwLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xuXHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDE2LCAxNiwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuXHRcdGhhc1ZlcnRleFRleHR1cmUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApID4gMDtcblxuXHRcdHZhciBzaGFkZXI7XG5cblx0XHRpZiAoIGhhc1ZlcnRleFRleHR1cmUgKSB7XG5cblx0XHRcdHNoYWRlciA9IHtcblxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXG5cblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXG5cblx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cdFx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG5cdFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XHRcdFwidlVWID0gdXY7XCIsXG5cblx0XHRcdFx0XHRcdFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcblxuXHRcdFx0XHRcdFx0XCJpZiggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwidmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICk7XCIsXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjEgKSApO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICk7XCIsXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICk7XCIsXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjUgKSApO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuZyAvIDkuMDtcIixcblx0XHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7XCIsXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wO1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblx0XHRcdFx0XHRcdFx0XCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuXG5cdFx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcblxuXHRcdFx0XHRcdFwifVwiXG5cblx0XHRcdFx0XS5qb2luKCBcIlxcblwiICksXG5cblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXG5cblx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cdFx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG5cdFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XHRcdC8vIHBpbmsgc3F1YXJlXG5cblx0XHRcdFx0XHRcdFwiaWYoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApO1wiLFxuXG5cdFx0XHRcdFx0XHQvLyByZXN0b3JlXG5cblx0XHRcdFx0XHRcdFwifSBlbHNlIGlmKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG5cblx0XHRcdFx0XHRcdC8vIGZsYXJlXG5cblx0XHRcdFx0XHRcdFwifSBlbHNlIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5O1wiLFxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcblxuXHRcdFx0XHRcdFx0XCJ9XCIsXG5cblx0XHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRcdF0uam9pbiggXCJcXG5cIiApXG5cblx0XHRcdH07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzaGFkZXIgPSB7XG5cblx0XHRcdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcblxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblxuXHRcdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XHRcInZVViA9IHV2O1wiLFxuXG5cdFx0XHRcdFx0XHRcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXG5cblx0XHRcdFx0XHRcdFwiaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cdFx0XHRcdFx0XHRcdFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblxuXHRcdFx0XHRcdFx0XCJ9XCIsXG5cblx0XHRcdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cblx0XHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFx0XHRcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLFxuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cblx0XHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcblxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblxuXHRcdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XHQvLyBwaW5rIHNxdWFyZVxuXG5cdFx0XHRcdFx0XHRcImlmKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQoIG1hcCwgdlVWICkucmdiLCAwLjAgKTtcIixcblxuXHRcdFx0XHRcdFx0Ly8gcmVzdG9yZVxuXG5cdFx0XHRcdFx0XHRcIn0gZWxzZSBpZiggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG5cdFx0XHRcdFx0XHQvLyBmbGFyZVxuXG5cdFx0XHRcdFx0XHRcIn0gZWxzZSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJmbG9hdCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKS5hO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKS5hO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKS5hO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKS5hO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgPSAoIDEuMCAtIHZpc2liaWxpdHkgLyA0LjAgKTtcIixcblxuXHRcdFx0XHRcdFx0XHRcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZpc2liaWxpdHk7XCIsXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxuXG5cdFx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFwifVwiXG5cblx0XHRcdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKTtcblxuXHRcdGF0dHJpYnV0ZXMgPSB7XG5cdFx0XHR2ZXJ0ZXg6IGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHR1djogICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJ1dlwiIClcblx0XHR9XG5cblx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdHJlbmRlclR5cGU6ICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwicmVuZGVyVHlwZVwiICksXG5cdFx0XHRtYXA6ICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm1hcFwiICksXG5cdFx0XHRvY2NsdXNpb25NYXA6ICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9jY2x1c2lvbk1hcFwiICksXG5cdFx0XHRvcGFjaXR5OiAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9wYWNpdHlcIiApLFxuXHRcdFx0Y29sb3I6ICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJjb2xvclwiICksXG5cdFx0XHRzY2FsZTogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjYWxlXCIgKSxcblx0XHRcdHJvdGF0aW9uOiAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwicm90YXRpb25cIiApLFxuXHRcdFx0c2NyZWVuUG9zaXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJzY3JlZW5Qb3NpdGlvblwiIClcblx0XHR9O1xuXG5cdH07XG5cblx0Lypcblx0ICogUmVuZGVyIGxlbnMgZmxhcmVzXG5cdCAqIE1ldGhvZDogcmVuZGVycyAxNngxNiAweGZmMDBmZi1jb2xvcmVkIHBvaW50cyBzY2F0dGVyZWQgb3ZlciB0aGUgbGlnaHQgc291cmNlIGFyZWEsXG5cdCAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXG5cdCAqL1xuXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCApIHtcblxuXHRcdGlmICggZmxhcmVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdHZhciB0ZW1wUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0dmFyIGludkFzcGVjdCA9IHZpZXdwb3J0SGVpZ2h0IC8gdmlld3BvcnRXaWR0aCxcblx0XHRcdGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aCAqIDAuNSxcblx0XHRcdGhhbGZWaWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0SGVpZ2h0ICogMC41O1xuXG5cdFx0dmFyIHNpemUgPSAxNiAvIHZpZXdwb3J0SGVpZ2h0LFxuXHRcdFx0c2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG5cdFx0dmFyIHNjcmVlblBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDAgKSxcblx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpbml0KCk7XG5cblx0XHR9XG5cblx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy52ZXJ0ZXggKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy51diApO1xuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIGFsbCBsZW5zIGZsYXJlcyB0byB1cGRhdGUgdGhlaXIgb2NjbHVzaW9uIGFuZCBwb3NpdGlvbnNcblx0XHQvLyBzZXR1cCBnbCBhbmQgY29tbW9uIHVzZWQgYXR0cmlicy91bmZvcm1zXG5cblx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xuXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAxICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudmVydGV4LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblxuXHRcdGdsLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xuXHRcdGdsLmRlcHRoTWFzayggZmFsc2UgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodDtcblx0XHRcdHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xuXG5cdFx0XHQvLyBjYWxjIG9iamVjdCBzY3JlZW4gcG9zaXRpb25cblxuXHRcdFx0dmFyIGZsYXJlID0gZmxhcmVzWyBpIF07XG5cdFx0XHRcblx0XHRcdHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEyXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbMTNdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxNF0gKTtcblxuXHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5UHJvamVjdGlvbiggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0Ly8gc2V0dXAgYXJyYXlzIGZvciBnbCBwcm9ncmFtc1xuXG5cdFx0XHRzY3JlZW5Qb3NpdGlvbi5jb3B5KCB0ZW1wUG9zaXRpb24gKVxuXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICsgaGFsZlZpZXdwb3J0V2lkdGg7XG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCArIGhhbGZWaWV3cG9ydEhlaWdodDtcblxuXHRcdFx0Ly8gc2NyZWVuIGN1bGxcblxuXHRcdFx0aWYgKCBoYXNWZXJ0ZXhUZXh0dXJlIHx8IChcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA+IDAgJiZcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA8IHZpZXdwb3J0V2lkdGggJiZcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA+IDAgJiZcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA8IHZpZXdwb3J0SGVpZ2h0ICkgKSB7XG5cblx0XHRcdFx0Ly8gc2F2ZSBjdXJyZW50IFJHQiB0byB0ZW1wIHRleHR1cmVcblxuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xuXHRcdFx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcblx0XHRcdFx0Z2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcblxuXG5cdFx0XHRcdC8vIHJlbmRlciBwaW5rIHF1YWRcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDAgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuXHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XG5cblx0XHRcdFx0Z2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcblx0XHRcdFx0Z2wuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cblx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblxuXHRcdFx0XHQvLyBjb3B5IHJlc3VsdCB0byBvY2NsdXNpb25NYXBcblxuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuXHRcdFx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xuXHRcdFx0XHRnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcblxuXG5cdFx0XHRcdC8vIHJlc3RvcmUgZ3JhcGhpY3NcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDEgKTtcblx0XHRcdFx0Z2wuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG5cdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG5cdFx0XHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuXHRcdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXG5cdFx0XHRcdC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXG5cblx0XHRcdFx0ZmxhcmUucG9zaXRpb25TY3JlZW4uY29weSggc2NyZWVuUG9zaXRpb24gKVxuXG5cdFx0XHRcdGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XG5cblx0XHRcdFx0XHRmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayggZmxhcmUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZW5kZXIgZmxhcmVzXG5cblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XG5cdFx0XHRcdGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoIHNwcml0ZS5vcGFjaXR5ID4gMC4wMDEgJiYgc3ByaXRlLnNjYWxlID4gMC4wMDEgKSB7XG5cblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnkgPSBzcHJpdGUueTtcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnogPSBzcHJpdGUuejtcblxuXHRcdFx0XHRcdFx0c2l6ZSA9IHNwcml0ZS5zaXplICogc3ByaXRlLnNjYWxlIC8gdmlld3BvcnRIZWlnaHQ7XG5cblx0XHRcdFx0XHRcdHNjYWxlLnggPSBzaXplICogaW52QXNwZWN0O1xuXHRcdFx0XHRcdFx0c2NhbGUueSA9IHNpemU7XG5cblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xuXG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIHNwcml0ZS5vcGFjaXR5ICk7XG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XG5cblx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldEJsZW5kaW5nKCBzcHJpdGUuYmxlbmRpbmcsIHNwcml0ZS5ibGVuZEVxdWF0aW9uLCBzcHJpdGUuYmxlbmRTcmMsIHNwcml0ZS5ibGVuZERzdCApO1xuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggc3ByaXRlLnRleHR1cmUsIDEgKTtcblxuXHRcdFx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyByZXN0b3JlIGdsXG5cblx0XHRnbC5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXHRcdGdsLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXHRcdGdsLmRlcHRoTWFzayggdHJ1ZSApO1xuXG5cdFx0cmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICggc2hhZGVyICkge1xuXG5cdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cblx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xuXHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcblxuXHRcdHZhciBwcmVmaXggPSBcInByZWNpc2lvbiBcIiArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgXCIgZmxvYXQ7XFxuXCI7XG5cblx0XHRnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgKTtcblx0XHRnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLnZlcnRleFNoYWRlciApO1xuXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcblx0XHRnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcblxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xuXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvU2hhZG93TWFwUGx1Z2luLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TaGFkb3dNYXBQbHVnaW4gPSBmdW5jdGlvbiAoIF9yZW5kZXJlciwgX2xpZ2h0cywgX3dlYmdsT2JqZWN0cywgX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSApIHtcblxuXHR2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQ7XG5cblx0dmFyIF9kZXB0aE1hdGVyaWFsLCBfZGVwdGhNYXRlcmlhbE1vcnBoLCBfZGVwdGhNYXRlcmlhbFNraW4sIF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luLFxuXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcblx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG5cdF9taW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRfbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuXHRfbWF0cml4UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcblx0X3JlbmRlckxpc3QgPSBbXTtcblxuXHQvLyBpbml0XG5cblx0dmFyIGRlcHRoU2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcImRlcHRoUkdCQVwiIF07XG5cdHZhciBkZXB0aFVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggZGVwdGhTaGFkZXIudW5pZm9ybXMgKTtcblxuXHRfZGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuXHRcdHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLFxuXHRcdHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuXHRcdGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlclxuXHQgfSApO1xuXG5cdF9kZXB0aE1hdGVyaWFsTW9ycGggPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHR1bmlmb3JtczogZGVwdGhVbmlmb3Jtcyxcblx0XHR2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0bW9ycGhUYXJnZXRzOiB0cnVlXG5cdH0gKTtcblxuXHRfZGVwdGhNYXRlcmlhbFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHR1bmlmb3JtczogZGVwdGhVbmlmb3Jtcyxcblx0XHR2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0c2tpbm5pbmc6IHRydWVcblx0fSApO1xuXG5cdF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG5cdFx0dW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsXG5cdFx0dmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuXHRcdG1vcnBoVGFyZ2V0czogdHJ1ZSxcblx0XHRza2lubmluZzogdHJ1ZVxuXHR9ICk7XG5cblx0X2RlcHRoTWF0ZXJpYWwuX3NoYWRvd1Bhc3MgPSB0cnVlO1xuXHRfZGVwdGhNYXRlcmlhbE1vcnBoLl9zaGFkb3dQYXNzID0gdHJ1ZTtcblx0X2RlcHRoTWF0ZXJpYWxTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcblx0X2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4uX3NoYWRvd1Bhc3MgPSB0cnVlO1xuXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0aWYgKCBfcmVuZGVyZXIuc2hhZG93TWFwRW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR2YXIgaSwgaWwsIGosIGpsLCBuLFxuXG5cdFx0c2hhZG93TWFwLCBzaGFkb3dNYXRyaXgsIHNoYWRvd0NhbWVyYSxcblx0XHRwcm9ncmFtLCBidWZmZXIsIG1hdGVyaWFsLFxuXHRcdHdlYmdsT2JqZWN0LCBvYmplY3QsIGxpZ2h0LFxuXG5cdFx0bGlnaHRzID0gW10sXG5cdFx0ayA9IDAsXG5cblx0XHRmb2cgPSBudWxsO1xuXG5cdFx0Ly8gc2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXBcblxuXHRcdF9nbC5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XG5cdFx0X2dsLmRpc2FibGUoIF9nbC5CTEVORCApO1xuXG5cdFx0X2dsLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcblxuXHRcdGlmICggX3JlbmRlcmVyLnNoYWRvd01hcEN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG5cdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG5cdFx0fVxuXG5cdFx0X3JlbmRlcmVyLnNldERlcHRoVGVzdCggdHJ1ZSApO1xuXG5cdFx0Ly8gcHJlcHJvY2VzcyBsaWdodHNcblx0XHQvLyBcdC0gc2tpcCBsaWdodHMgdGhhdCBhcmUgbm90IGNhc3Rpbmcgc2hhZG93c1xuXHRcdC8vXHQtIGNyZWF0ZSB2aXJ0dWFsIGxpZ2h0cyBmb3IgY2FzY2FkZWQgc2hhZG93IG1hcHNcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IF9saWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGxpZ2h0ID0gX2xpZ2h0c1sgaSBdO1xuXG5cdFx0XHRpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xuXG5cdFx0XHRpZiAoICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgJiYgbGlnaHQuc2hhZG93Q2FzY2FkZSApIHtcblxuXHRcdFx0XHRmb3IgKCBuID0gMDsgbiA8IGxpZ2h0LnNoYWRvd0Nhc2NhZGVDb3VudDsgbiArKyApIHtcblxuXHRcdFx0XHRcdHZhciB2aXJ0dWFsTGlnaHQ7XG5cblx0XHRcdFx0XHRpZiAoICEgbGlnaHQuc2hhZG93Q2FzY2FkZUFycmF5WyBuIF0gKSB7XG5cblx0XHRcdFx0XHRcdHZpcnR1YWxMaWdodCA9IGNyZWF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIG4gKTtcblx0XHRcdFx0XHRcdHZpcnR1YWxMaWdodC5vcmlnaW5hbENhbWVyYSA9IGNhbWVyYTtcblxuXHRcdFx0XHRcdFx0dmFyIGd5cm8gPSBuZXcgVEhSRUUuR3lyb3Njb3BlKCk7XG5cdFx0XHRcdFx0XHRneXJvLnBvc2l0aW9uLmNvcHkoIGxpZ2h0LnNoYWRvd0Nhc2NhZGVPZmZzZXQgKTtcblxuXHRcdFx0XHRcdFx0Z3lyby5hZGQoIHZpcnR1YWxMaWdodCApO1xuXHRcdFx0XHRcdFx0Z3lyby5hZGQoIHZpcnR1YWxMaWdodC50YXJnZXQgKTtcblxuXHRcdFx0XHRcdFx0Y2FtZXJhLmFkZCggZ3lybyApO1xuXG5cdFx0XHRcdFx0XHRsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIG4gXSA9IHZpcnR1YWxMaWdodDtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coIFwiQ3JlYXRlZCB2aXJ0dWFsTGlnaHRcIiwgdmlydHVhbExpZ2h0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2aXJ0dWFsTGlnaHQgPSBsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIG4gXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHVwZGF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIG4gKTtcblxuXHRcdFx0XHRcdGxpZ2h0c1sgayBdID0gdmlydHVhbExpZ2h0O1xuXHRcdFx0XHRcdGsgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGxpZ2h0c1sgayBdID0gbGlnaHQ7XG5cdFx0XHRcdGsgKys7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHJlbmRlciBkZXB0aCBtYXBcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0bGlnaHQgPSBsaWdodHNbIGkgXTtcblxuXHRcdFx0aWYgKCAhIGxpZ2h0LnNoYWRvd01hcCApIHtcblxuXHRcdFx0XHR2YXIgc2hhZG93RmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG5cdFx0XHRcdGlmICggX3JlbmRlcmVyLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cblx0XHRcdFx0XHRzaGFkb3dGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcGFycyA9IHsgbWluRmlsdGVyOiBzaGFkb3dGaWx0ZXIsIG1hZ0ZpbHRlcjogc2hhZG93RmlsdGVyLCBmb3JtYXQ6IFRIUkVFLlJHQkFGb3JtYXQgfTtcblxuXHRcdFx0XHRsaWdodC5zaGFkb3dNYXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIGxpZ2h0LnNoYWRvd01hcFdpZHRoLCBsaWdodC5zaGFkb3dNYXBIZWlnaHQsIHBhcnMgKTtcblx0XHRcdFx0bGlnaHQuc2hhZG93TWFwU2l6ZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBsaWdodC5zaGFkb3dNYXBXaWR0aCwgbGlnaHQuc2hhZG93TWFwSGVpZ2h0ICk7XG5cblx0XHRcdFx0bGlnaHQuc2hhZG93TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgbGlnaHQuc2hhZG93Q2FtZXJhICkge1xuXG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XG5cblx0XHRcdFx0XHRsaWdodC5zaGFkb3dDYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGxpZ2h0LnNoYWRvd0NhbWVyYUZvdiwgbGlnaHQuc2hhZG93TWFwV2lkdGggLyBsaWdodC5zaGFkb3dNYXBIZWlnaHQsIGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIGxpZ2h0LnNoYWRvd0NhbWVyYUZhciApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcblxuXHRcdFx0XHRcdGxpZ2h0LnNoYWRvd0NhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGxpZ2h0LnNoYWRvd0NhbWVyYUxlZnQsIGxpZ2h0LnNoYWRvd0NhbWVyYVJpZ2h0LCBsaWdodC5zaGFkb3dDYW1lcmFUb3AsIGxpZ2h0LnNoYWRvd0NhbWVyYUJvdHRvbSwgbGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgbGlnaHQuc2hhZG93Q2FtZXJhRmFyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVW5zdXBwb3J0ZWQgbGlnaHQgdHlwZSBmb3Igc2hhZG93XCIgKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NlbmUuYWRkKCBsaWdodC5zaGFkb3dDYW1lcmEgKTtcblxuXHRcdFx0XHRpZiAoIHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSAmJiAhIGxpZ2h0LmNhbWVyYUhlbHBlciApIHtcblxuXHRcdFx0XHRsaWdodC5jYW1lcmFIZWxwZXIgPSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3dDYW1lcmEgKTtcblx0XHRcdFx0c2NlbmUuYWRkKCBsaWdodC5jYW1lcmFIZWxwZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGxpZ2h0LmlzVmlydHVhbCAmJiB2aXJ0dWFsTGlnaHQub3JpZ2luYWxDYW1lcmEgPT0gY2FtZXJhICkge1xuXG5cdFx0XHRcdHVwZGF0ZVNoYWRvd0NhbWVyYSggY2FtZXJhLCBsaWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNoYWRvd01hcCA9IGxpZ2h0LnNoYWRvd01hcDtcblx0XHRcdHNoYWRvd01hdHJpeCA9IGxpZ2h0LnNoYWRvd01hdHJpeDtcblx0XHRcdHNoYWRvd0NhbWVyYSA9IGxpZ2h0LnNoYWRvd0NhbWVyYTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdF9tYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0c2hhZG93Q2FtZXJhLmxvb2tBdCggX21hdHJpeFBvc2l0aW9uICk7XG5cdFx0XHRzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0c2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0aWYgKCBsaWdodC5jYW1lcmFIZWxwZXIgKSBsaWdodC5jYW1lcmFIZWxwZXIudmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XG5cdFx0XHRpZiAoIGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgKSBsaWdodC5jYW1lcmFIZWxwZXIudXBkYXRlKCk7XG5cblx0XHRcdC8vIGNvbXB1dGUgc2hhZG93IG1hdHJpeFxuXG5cdFx0XHRzaGFkb3dNYXRyaXguc2V0KFxuXHRcdFx0XHQwLjUsIDAuMCwgMC4wLCAwLjUsXG5cdFx0XHRcdDAuMCwgMC41LCAwLjAsIDAuNSxcblx0XHRcdFx0MC4wLCAwLjAsIDAuNSwgMC41LFxuXHRcdFx0XHQwLjAsIDAuMCwgMC4wLCAxLjBcblx0XHRcdCk7XG5cblx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXG5cdFx0XHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHQvLyByZW5kZXIgc2hhZG93IG1hcFxuXG5cdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcblx0XHRcdF9yZW5kZXJlci5jbGVhcigpO1xuXG5cdFx0XHQvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXG5cblx0XHRcdF9yZW5kZXJMaXN0Lmxlbmd0aCA9IDA7XG5cblx0XHRcdHByb2plY3RPYmplY3QoIHNjZW5lLCBzY2VuZSwgc2hhZG93Q2FtZXJhICk7XG5cblxuXHRcdFx0Ly8gcmVuZGVyIHJlZ3VsYXIgb2JqZWN0c1xuXG5cdFx0XHR2YXIgb2JqZWN0TWF0ZXJpYWwsIHVzZU1vcnBoaW5nLCB1c2VTa2lubmluZztcblxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gX3JlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0d2ViZ2xPYmplY3QgPSBfcmVuZGVyTGlzdFsgaiBdO1xuXG5cdFx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcblx0XHRcdFx0YnVmZmVyID0gd2ViZ2xPYmplY3QuYnVmZmVyO1xuXG5cdFx0XHRcdC8vIGN1bGxpbmcgaXMgb3ZlcnJpZGVuIGdsb2JhbGx5IGZvciBhbGwgb2JqZWN0c1xuXHRcdFx0XHQvLyB3aGlsZSByZW5kZXJpbmcgZGVwdGggbWFwXG5cblx0XHRcdFx0Ly8gbmVlZCB0byBkZWFsIHdpdGggTWVzaEZhY2VNYXRlcmlhbCBzb21laG93XG5cdFx0XHRcdC8vIGluIHRoYXQgY2FzZSBqdXN0IHVzZSB0aGUgZmlyc3Qgb2YgbWF0ZXJpYWwubWF0ZXJpYWxzIGZvciBub3dcblx0XHRcdFx0Ly8gKHByb3BlciBzb2x1dGlvbiB3b3VsZCByZXF1aXJlIHRvIGJyZWFrIG9iamVjdHMgYnkgbWF0ZXJpYWxzXG5cdFx0XHRcdC8vICBzaW1pbGFybHkgdG8gcmVndWxhciByZW5kZXJpbmcgYW5kIHRoZW4gc2V0IGNvcnJlc3BvbmRpbmdcblx0XHRcdFx0Ly8gIGRlcHRoIG1hdGVyaWFscyBwZXIgZWFjaCBjaHVuayBpbnN0ZWFkIG9mIGp1c3Qgb25jZSBwZXIgb2JqZWN0KVxuXG5cdFx0XHRcdG9iamVjdE1hdGVyaWFsID0gZ2V0T2JqZWN0TWF0ZXJpYWwoIG9iamVjdCApO1xuXG5cdFx0XHRcdHVzZU1vcnBoaW5nID0gb2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCAmJiBvYmplY3RNYXRlcmlhbC5tb3JwaFRhcmdldHM7XG5cdFx0XHRcdHVzZVNraW5uaW5nID0gb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggJiYgb2JqZWN0TWF0ZXJpYWwuc2tpbm5pbmc7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWw7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdXNlU2tpbm5pbmcgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbCA9IHVzZU1vcnBoaW5nID8gX2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4gOiBfZGVwdGhNYXRlcmlhbFNraW47XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdXNlTW9ycGhpbmcgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbCA9IF9kZXB0aE1hdGVyaWFsTW9ycGg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9yZW5kZXJlci5zZXRNYXRlcmlhbEZhY2VzKCBvYmplY3RNYXRlcmlhbCApO1xuXG5cdFx0XHRcdGlmICggYnVmZmVyIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIF9saWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXIoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgZm9nLCBtYXRlcmlhbCwgYnVmZmVyLCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0IG1hdHJpY2VzIGFuZCByZW5kZXIgaW1tZWRpYXRlIG9iamVjdHNcblxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZS5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR3ZWJnbE9iamVjdCA9IF93ZWJnbE9iamVjdHNJbW1lZGlhdGVbIGogXTtcblx0XHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgJiYgb2JqZWN0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgZm9nLCBfZGVwdGhNYXRlcmlhbCwgb2JqZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyByZXN0b3JlIEdMIHN0YXRlXG5cblx0XHR2YXIgY2xlYXJDb2xvciA9IF9yZW5kZXJlci5nZXRDbGVhckNvbG9yKCksXG5cdFx0Y2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cblx0XHRfZ2wuY2xlYXJDb2xvciggY2xlYXJDb2xvci5yLCBjbGVhckNvbG9yLmcsIGNsZWFyQ29sb3IuYiwgY2xlYXJBbHBoYSApO1xuXHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xuXG5cdFx0aWYgKCBfcmVuZGVyZXIuc2hhZG93TWFwQ3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XG5cblx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcblxuXHRcdH1cblxuXHRcdF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIHNjZW5lLCBvYmplY3QsIHNoYWRvd0NhbWVyYSApe1xuXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcblxuXHRcdFx0dmFyIHdlYmdsT2JqZWN0cyA9IF93ZWJnbE9iamVjdHNbIG9iamVjdC5pZCBdO1xuXG5cdFx0XHRpZiAoIHdlYmdsT2JqZWN0cyAmJiBvYmplY3QuY2FzdFNoYWRvdyAmJiAob2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlKSApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB3ZWJnbE9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciB3ZWJnbE9iamVjdCA9IHdlYmdsT2JqZWN0c1sgaSBdO1xuXG5cdFx0XHRcdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0X3JlbmRlckxpc3QucHVzaCggd2ViZ2xPYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIG9iamVjdC5jaGlsZHJlblsgaSBdLCBzaGFkb3dDYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsTGlnaHQoIGxpZ2h0LCBjYXNjYWRlICkge1xuXG5cdFx0dmFyIHZpcnR1YWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCk7XG5cblx0XHR2aXJ0dWFsTGlnaHQuaXNWaXJ0dWFsID0gdHJ1ZTtcblxuXHRcdHZpcnR1YWxMaWdodC5vbmx5U2hhZG93ID0gdHJ1ZTtcblx0XHR2aXJ0dWFsTGlnaHQuY2FzdFNoYWRvdyA9IHRydWU7XG5cblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhTmVhciA9IGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXI7XG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYUZhciA9IGxpZ2h0LnNoYWRvd0NhbWVyYUZhcjtcblxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFMZWZ0ID0gbGlnaHQuc2hhZG93Q2FtZXJhTGVmdDtcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhUmlnaHQgPSBsaWdodC5zaGFkb3dDYW1lcmFSaWdodDtcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tID0gbGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tO1xuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFUb3AgPSBsaWdodC5zaGFkb3dDYW1lcmFUb3A7XG5cblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XG5cblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93RGFya25lc3MgPSBsaWdodC5zaGFkb3dEYXJrbmVzcztcblxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dCaWFzID0gbGlnaHQuc2hhZG93Q2FzY2FkZUJpYXNbIGNhc2NhZGUgXTtcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93TWFwV2lkdGggPSBsaWdodC5zaGFkb3dDYXNjYWRlV2lkdGhbIGNhc2NhZGUgXTtcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93TWFwSGVpZ2h0ID0gbGlnaHQuc2hhZG93Q2FzY2FkZUhlaWdodFsgY2FzY2FkZSBdO1xuXG5cdFx0dmlydHVhbExpZ2h0LnBvaW50c1dvcmxkID0gW107XG5cdFx0dmlydHVhbExpZ2h0LnBvaW50c0ZydXN0dW0gPSBbXTtcblxuXHRcdHZhciBwb2ludHNXb3JsZCA9IHZpcnR1YWxMaWdodC5wb2ludHNXb3JsZCxcblx0XHRcdHBvaW50c0ZydXN0dW0gPSB2aXJ0dWFsTGlnaHQucG9pbnRzRnJ1c3R1bTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDg7IGkgKysgKSB7XG5cblx0XHRcdHBvaW50c1dvcmxkWyBpIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0cG9pbnRzRnJ1c3R1bVsgaSBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdH1cblxuXHRcdHZhciBuZWFyWiA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVOZWFyWlsgY2FzY2FkZSBdO1xuXHRcdHZhciBmYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZUZhclpbIGNhc2NhZGUgXTtcblxuXHRcdHBvaW50c0ZydXN0dW1bIDAgXS5zZXQoIC0gMSwgLSAxLCBuZWFyWiApO1xuXHRcdHBvaW50c0ZydXN0dW1bIDEgXS5zZXQoICAxLCAtIDEsIG5lYXJaICk7XG5cdFx0cG9pbnRzRnJ1c3R1bVsgMiBdLnNldCggLSAxLCAgMSwgbmVhclogKTtcblx0XHRwb2ludHNGcnVzdHVtWyAzIF0uc2V0KCAgMSwgIDEsIG5lYXJaICk7XG5cblx0XHRwb2ludHNGcnVzdHVtWyA0IF0uc2V0KCAtIDEsIC0gMSwgZmFyWiApO1xuXHRcdHBvaW50c0ZydXN0dW1bIDUgXS5zZXQoICAxLCAtIDEsIGZhclogKTtcblx0XHRwb2ludHNGcnVzdHVtWyA2IF0uc2V0KCAtIDEsICAxLCBmYXJaICk7XG5cdFx0cG9pbnRzRnJ1c3R1bVsgNyBdLnNldCggIDEsICAxLCBmYXJaICk7XG5cblx0XHRyZXR1cm4gdmlydHVhbExpZ2h0O1xuXG5cdH1cblxuXHQvLyBTeW5jaHJvbml6ZSB2aXJ0dWFsIGxpZ2h0IHdpdGggdGhlIG9yaWdpbmFsIGxpZ2h0XG5cblx0ZnVuY3Rpb24gdXBkYXRlVmlydHVhbExpZ2h0KCBsaWdodCwgY2FzY2FkZSApIHtcblxuXHRcdHZhciB2aXJ0dWFsTGlnaHQgPSBsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIGNhc2NhZGUgXTtcblxuXHRcdHZpcnR1YWxMaWdodC5wb3NpdGlvbi5jb3B5KCBsaWdodC5wb3NpdGlvbiApO1xuXHRcdHZpcnR1YWxMaWdodC50YXJnZXQucG9zaXRpb24uY29weSggbGlnaHQudGFyZ2V0LnBvc2l0aW9uICk7XG5cdFx0dmlydHVhbExpZ2h0Lmxvb2tBdCggdmlydHVhbExpZ2h0LnRhcmdldCApO1xuXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgPSBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dEYXJrbmVzcyA9IGxpZ2h0LnNoYWRvd0RhcmtuZXNzO1xuXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3dDYXNjYWRlQmlhc1sgY2FzY2FkZSBdO1xuXG5cdFx0dmFyIG5lYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZU5lYXJaWyBjYXNjYWRlIF07XG5cdFx0dmFyIGZhclogPSBsaWdodC5zaGFkb3dDYXNjYWRlRmFyWlsgY2FzY2FkZSBdO1xuXG5cdFx0dmFyIHBvaW50c0ZydXN0dW0gPSB2aXJ0dWFsTGlnaHQucG9pbnRzRnJ1c3R1bTtcblxuXHRcdHBvaW50c0ZydXN0dW1bIDAgXS56ID0gbmVhclo7XG5cdFx0cG9pbnRzRnJ1c3R1bVsgMSBdLnogPSBuZWFyWjtcblx0XHRwb2ludHNGcnVzdHVtWyAyIF0ueiA9IG5lYXJaO1xuXHRcdHBvaW50c0ZydXN0dW1bIDMgXS56ID0gbmVhclo7XG5cblx0XHRwb2ludHNGcnVzdHVtWyA0IF0ueiA9IGZhclo7XG5cdFx0cG9pbnRzRnJ1c3R1bVsgNSBdLnogPSBmYXJaO1xuXHRcdHBvaW50c0ZydXN0dW1bIDYgXS56ID0gZmFyWjtcblx0XHRwb2ludHNGcnVzdHVtWyA3IF0ueiA9IGZhclo7XG5cblx0fVxuXG5cdC8vIEZpdCBzaGFkb3cgY2FtZXJhJ3Mgb3J0aG8gZnJ1c3R1bSB0byBjYW1lcmEgZnJ1c3R1bVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZVNoYWRvd0NhbWVyYSggY2FtZXJhLCBsaWdodCApIHtcblxuXHRcdHZhciBzaGFkb3dDYW1lcmEgPSBsaWdodC5zaGFkb3dDYW1lcmEsXG5cdFx0XHRwb2ludHNGcnVzdHVtID0gbGlnaHQucG9pbnRzRnJ1c3R1bSxcblx0XHRcdHBvaW50c1dvcmxkID0gbGlnaHQucG9pbnRzV29ybGQ7XG5cblx0XHRfbWluLnNldCggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xuXHRcdF9tYXguc2V0KCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA4OyBpICsrICkge1xuXG5cdFx0XHR2YXIgcCA9IHBvaW50c1dvcmxkWyBpIF07XG5cblx0XHRcdHAuY29weSggcG9pbnRzRnJ1c3R1bVsgaSBdICk7XG5cdFx0XHRwLnVucHJvamVjdCggY2FtZXJhICk7XG5cblx0XHRcdHAuYXBwbHlNYXRyaXg0KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRcdGlmICggcC54IDwgX21pbi54ICkgX21pbi54ID0gcC54O1xuXHRcdFx0aWYgKCBwLnggPiBfbWF4LnggKSBfbWF4LnggPSBwLng7XG5cblx0XHRcdGlmICggcC55IDwgX21pbi55ICkgX21pbi55ID0gcC55O1xuXHRcdFx0aWYgKCBwLnkgPiBfbWF4LnkgKSBfbWF4LnkgPSBwLnk7XG5cblx0XHRcdGlmICggcC56IDwgX21pbi56ICkgX21pbi56ID0gcC56O1xuXHRcdFx0aWYgKCBwLnogPiBfbWF4LnogKSBfbWF4LnogPSBwLno7XG5cblx0XHR9XG5cblx0XHRzaGFkb3dDYW1lcmEubGVmdCA9IF9taW4ueDtcblx0XHRzaGFkb3dDYW1lcmEucmlnaHQgPSBfbWF4Lng7XG5cdFx0c2hhZG93Q2FtZXJhLnRvcCA9IF9tYXgueTtcblx0XHRzaGFkb3dDYW1lcmEuYm90dG9tID0gX21pbi55O1xuXG5cdFx0Ly8gY2FuJ3QgcmVhbGx5IGZpdCBuZWFyL2ZhclxuXHRcdC8vc2hhZG93Q2FtZXJhLm5lYXIgPSBfbWluLno7XG5cdFx0Ly9zaGFkb3dDYW1lcmEuZmFyID0gX21heC56O1xuXG5cdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHR9XG5cblx0Ly8gRm9yIHRoZSBtb21lbnQganVzdCBpZ25vcmUgb2JqZWN0cyB0aGF0IGhhdmUgbXVsdGlwbGUgbWF0ZXJpYWxzIHdpdGggZGlmZmVyZW50IGFuaW1hdGlvbiBtZXRob2RzXG5cdC8vIE9ubHkgdGhlIGZpcnN0IG1hdGVyaWFsIHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50IGZvciBkZWNpZGluZyB3aGljaCBkZXB0aCBtYXRlcmlhbCB0byB1c2UgZm9yIHNoYWRvdyBtYXBzXG5cblx0ZnVuY3Rpb24gZ2V0T2JqZWN0TWF0ZXJpYWwoIG9iamVjdCApIHtcblxuXHRcdHJldHVybiBvYmplY3QubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsXG5cdFx0XHQ/IG9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHNbIDAgXVxuXHRcdFx0OiBvYmplY3QubWF0ZXJpYWw7XG5cblx0fTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvU3ByaXRlUGx1Z2luLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3ByaXRlUGx1Z2luID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc3ByaXRlcyApIHtcblxuXHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuXG5cdHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XG5cdHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcblxuXHR2YXIgdGV4dHVyZTtcblx0XG5cdHZhciBpbml0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXHRcdFx0LSAwLjUsIC0gMC41LCAgMCwgMCxcblx0XHRcdCAgMC41LCAtIDAuNSwgIDEsIDAsXG5cdFx0XHQgIDAuNSwgICAwLjUsICAxLCAxLFxuXHRcdFx0LSAwLjUsICAgMC41LCAgMCwgMVxuXHRcdF0gKTtcblxuXHRcdHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xuXHRcdFx0MCwgMSwgMixcblx0XHRcdDAsIDIsIDNcblx0XHRdICk7XG5cblx0XHR2ZXJ0ZXhCdWZmZXIgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0ZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblx0XHRnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cblx0XHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0YXR0cmlidXRlcyA9IHtcblx0XHRcdHBvc2l0aW9uOlx0XHRcdGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgJ3Bvc2l0aW9uJyApLFxuXHRcdFx0dXY6XHRcdFx0XHRcdGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgJ3V2JyApXG5cdFx0fTtcblxuXHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0dXZPZmZzZXQ6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZPZmZzZXQnICksXG5cdFx0XHR1dlNjYWxlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXG5cblx0XHRcdHJvdGF0aW9uOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3JvdGF0aW9uJyApLFxuXHRcdFx0c2NhbGU6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcblxuXHRcdFx0Y29sb3I6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjb2xvcicgKSxcblx0XHRcdG1hcDpcdFx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcblx0XHRcdG9wYWNpdHk6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb3BhY2l0eScgKSxcblxuXHRcdFx0bW9kZWxWaWV3TWF0cml4OiBcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcblx0XHRcdHByb2plY3Rpb25NYXRyaXg6XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdwcm9qZWN0aW9uTWF0cml4JyApLFxuXG5cdFx0XHRmb2dUeXBlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXG5cdFx0XHRmb2dEZW5zaXR5Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlbnNpdHknICksXG5cdFx0XHRmb2dOZWFyOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ05lYXInICksXG5cdFx0XHRmb2dGYXI6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dGYXInICksXG5cdFx0XHRmb2dDb2xvcjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dDb2xvcicgKSxcblxuXHRcdFx0YWxwaGFUZXN0Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2FscGhhVGVzdCcgKVxuXHRcdH07XG5cblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcblx0XHRjYW52YXMud2lkdGggPSA4O1xuXHRcdGNhbnZhcy5oZWlnaHQgPSA4O1xuXG5cdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcblx0XHRjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XG5cblx0XHR0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGNhbnZhcyApO1xuXHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH07XG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRpZiAoIHNwcml0ZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG5cdFx0Ly8gc2V0dXAgZ2xcblxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpbml0KCk7XG5cblx0XHR9XG5cblx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGVzLnV2ICk7XG5cblx0XHRnbC5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblx0XHRnbC5lbmFibGUoIGdsLkJMRU5EICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cblx0XHRnbC5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAwICk7XG5cblx0XHR2YXIgb2xkRm9nVHlwZSA9IDA7XG5cdFx0dmFyIHNjZW5lRm9nVHlwZSA9IDA7XG5cdFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcblxuXHRcdGlmICggZm9nICkge1xuXG5cdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XG5cblx0XHRcdGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nICkge1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcblx0XHRcdFx0b2xkRm9nVHlwZSA9IDE7XG5cdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cblx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xuXHRcdFx0XHRvbGRGb2dUeXBlID0gMjtcblx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMjtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAwICk7XG5cdFx0XHRvbGRGb2dUeXBlID0gMDtcblx0XHRcdHNjZW5lRm9nVHlwZSA9IDA7XG5cblx0XHR9XG5cblxuXHRcdC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblxuXHRcdFx0c3ByaXRlLl9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgc3ByaXRlLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdGlmICggc3ByaXRlLnJlbmRlckRlcHRoID09PSBudWxsICkge1xuXG5cdFx0XHRcdHNwcml0ZS56ID0gLSBzcHJpdGUuX21vZGVsVmlld01hdHJpeC5lbGVtZW50c1sgMTQgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzcHJpdGUueiA9IHNwcml0ZS5yZW5kZXJEZXB0aDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xuXG5cdFx0Ly8gcmVuZGVyIGFsbCBzcHJpdGVzXG5cblx0XHR2YXIgc2NhbGUgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblx0XHRcdHZhciBtYXRlcmlhbCA9IHNwcml0ZS5tYXRlcmlhbDtcblxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgc3ByaXRlLl9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdFx0c2NhbGVbIDAgXSA9IHNwcml0ZS5zY2FsZS54O1xuXHRcdFx0c2NhbGVbIDEgXSA9IHNwcml0ZS5zY2FsZS55O1xuXG5cdFx0XHR2YXIgZm9nVHlwZSA9IDA7XG5cblx0XHRcdGlmICggc2NlbmUuZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcblxuXHRcdFx0XHRmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2xkRm9nVHlwZSAhPT0gZm9nVHlwZSApIHtcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcblx0XHRcdFx0b2xkRm9nVHlwZSA9IGZvZ1R5cGU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnkgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIDAsIDAgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCAxLCAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBtYXRlcmlhbC5vcGFjaXR5ICk7XG5cdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XG5cblx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XG5cdFx0XHRnbC51bmlmb3JtMmZ2KCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUgKTtcblxuXHRcdFx0cmVuZGVyZXIuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcblx0XHRcdHJlbmRlcmVyLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0XHRyZW5kZXJlci5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICYmIG1hdGVyaWFsLm1hcC5pbWFnZSAmJiBtYXRlcmlhbC5tYXAuaW1hZ2Uud2lkdGggKSB7XG5cblx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggbWF0ZXJpYWwubWFwLCAwICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggdGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmVzdG9yZSBnbFxuXG5cdFx0Z2wuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblx0XHRcblx0XHRyZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0gKCkge1xuXG5cdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cblx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcblxuXHRcdGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBbXG5cblx0XHRcdCdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxuXG5cdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG5cdFx0XHQndW5pZm9ybSBmbG9hdCByb3RhdGlvbjsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMiB1dlNjYWxlOycsXG5cblx0XHRcdCdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxuXHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cblx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cblx0XHRcdCd2b2lkIG1haW4oKSB7JyxcblxuXHRcdFx0XHQndlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7JyxcblxuXHRcdFx0XHQndmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiAqIHNjYWxlOycsXG5cblx0XHRcdFx0J3ZlYzIgcm90YXRlZFBvc2l0aW9uOycsXG5cdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7Jyxcblx0XHRcdFx0J3JvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxuXG5cdFx0XHRcdCd2ZWM0IGZpbmFsUG9zaXRpb247JyxcblxuXHRcdFx0XHQnZmluYWxQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApOycsXG5cdFx0XHRcdCdmaW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxuXHRcdFx0XHQnZmluYWxQb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBmaW5hbFBvc2l0aW9uOycsXG5cblx0XHRcdFx0J2dsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjsnLFxuXG5cdFx0XHQnfSdcblxuXHRcdF0uam9pbiggJ1xcbicgKSApO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xuXG5cdFx0XHQncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcblxuXHRcdFx0J3VuaWZvcm0gdmVjMyBjb2xvcjsnLFxuXHRcdFx0J3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxuXG5cdFx0XHQndW5pZm9ybSBpbnQgZm9nVHlwZTsnLFxuXHRcdFx0J3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nTmVhcjsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXG5cdFx0XHQndW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7JyxcblxuXHRcdFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcblxuXHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxuXG5cdFx0XHRcdCd2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcblxuXHRcdFx0XHQnaWYgKCB0ZXh0dXJlLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkOycsXG5cblx0XHRcdFx0J2dsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTsnLFxuXG5cdFx0XHRcdCdpZiAoIGZvZ1R5cGUgPiAwICkgeycsXG5cblx0XHRcdFx0XHQnZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53OycsXG5cdFx0XHRcdFx0J2Zsb2F0IGZvZ0ZhY3RvciA9IDAuMDsnLFxuXG5cdFx0XHRcdFx0J2lmICggZm9nVHlwZSA9PSAxICkgeycsXG5cblx0XHRcdFx0XHRcdCdmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7JyxcblxuXHRcdFx0XHRcdCd9IGVsc2UgeycsXG5cblx0XHRcdFx0XHRcdCdjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7Jyxcblx0XHRcdFx0XHRcdCdmbG9hdCBmb2dGYWN0b3IgPSBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZGVwdGggKiBkZXB0aCAqIExPRzIgKTsnLFxuXHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcblxuXHRcdFx0XHRcdCd9JyxcblxuXHRcdFx0XHRcdCdnbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApOycsXG5cblx0XHRcdFx0J30nLFxuXG5cdFx0XHQnfSdcblxuXHRcdF0uam9pbiggJ1xcbicgKSApO1xuXG5cdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG5cdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xuXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xuXG5cdFx0aWYgKCBhLnogIT09IGIueiApIHtcblxuXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBiLmlkIC0gYS5pZDtcblxuXHRcdH1cblxuXHR9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvR2VvbWV0cnlVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuR2VvbWV0cnlVdGlscyA9IHtcblxuXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeTEsIGdlb21ldHJ5MiwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5tZXJnZSgpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkgaW5zdGVhZC4nICk7XG5cblx0XHR2YXIgbWF0cml4O1xuXG5cdFx0aWYgKCBnZW9tZXRyeTIgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG5cdFx0XHRnZW9tZXRyeTIubWF0cml4QXV0b1VwZGF0ZSAmJiBnZW9tZXRyeTIudXBkYXRlTWF0cml4KCk7XG5cblx0XHRcdG1hdHJpeCA9IGdlb21ldHJ5Mi5tYXRyaXg7XG5cdFx0XHRnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeTEubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICk7XG5cblx0fSxcblxuXHRjZW50ZXI6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAuY2VudGVyKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5jZW50ZXIoKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gZ2VvbWV0cnkuY2VudGVyKCk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvSW1hZ2VVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBEYW9zaGVuZyBNdSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9EYW9zaGVuZ011L1xuICovXG5cblRIUkVFLkltYWdlVXRpbHMgPSB7XG5cblx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcblxuXHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcblx0XHRsb2FkZXIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggdW5kZWZpbmVkLCBtYXBwaW5nICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRleHR1cmUuc291cmNlRmlsZSA9IHVybDtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH0sXG5cblx0bG9hZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoIGFycmF5LCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgaW1hZ2VzID0gW107XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG5cdFx0bG9hZGVyLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkN1YmVUZXh0dXJlKCBpbWFnZXMsIG1hcHBpbmcgKTtcblxuXHRcdC8vIG5vIGZsaXBwaW5nIG5lZWRlZCBmb3IgY3ViZSB0ZXh0dXJlc1xuXG5cdFx0dGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuXG5cdFx0dmFyIGxvYWRlZCA9IDA7XG5cblx0XHR2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIGkgKSB7XG5cblx0XHRcdGxvYWRlci5sb2FkKCBhcnJheVsgaSBdLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcblxuXHRcdFx0XHRsb2FkZWQgKz0gMTtcblxuXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuXHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH0sXG5cblx0bG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKVxuXG5cdH0sXG5cblx0bG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApXG5cblx0fSxcblxuXHRnZXROb3JtYWxNYXA6IGZ1bmN0aW9uICggaW1hZ2UsIGRlcHRoICkge1xuXG5cdFx0Ly8gQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL2xhYi9oZWlnaHRub3JtYWwvXG5cblx0XHR2YXIgY3Jvc3MgPSBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHJldHVybiBbIGFbIDEgXSAqIGJbIDIgXSAtIGFbIDIgXSAqIGJbIDEgXSwgYVsgMiBdICogYlsgMCBdIC0gYVsgMCBdICogYlsgMiBdLCBhWyAwIF0gKiBiWyAxIF0gLSBhWyAxIF0gKiBiWyAwIF0gXTtcblxuXHRcdH1cblxuXHRcdHZhciBzdWJ0cmFjdCA9IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdFx0cmV0dXJuIFsgYVsgMCBdIC0gYlsgMCBdLCBhWyAxIF0gLSBiWyAxIF0sIGFbIDIgXSAtIGJbIDIgXSBdO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdFx0dmFyIGwgPSBNYXRoLnNxcnQoIGFbIDAgXSAqIGFbIDAgXSArIGFbIDEgXSAqIGFbIDEgXSArIGFbIDIgXSAqIGFbIDIgXSApO1xuXHRcdFx0cmV0dXJuIFsgYVsgMCBdIC8gbCwgYVsgMSBdIC8gbCwgYVsgMiBdIC8gbCBdO1xuXG5cdFx0fVxuXG5cdFx0ZGVwdGggPSBkZXB0aCB8IDE7XG5cblx0XHR2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG5cdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG5cdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XG5cdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAgKTtcblxuXHRcdHZhciBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKS5kYXRhO1xuXHRcdHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSggd2lkdGgsIGhlaWdodCApO1xuXHRcdHZhciBvdXRwdXQgPSBpbWFnZURhdGEuZGF0YTtcblxuXHRcdGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4ICsrICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGx5ID0geSAtIDEgPCAwID8gMCA6IHkgLSAxO1xuXHRcdFx0XHR2YXIgdXkgPSB5ICsgMSA+IGhlaWdodCAtIDEgPyBoZWlnaHQgLSAxIDogeSArIDE7XG5cdFx0XHRcdHZhciBseCA9IHggLSAxIDwgMCA/IDAgOiB4IC0gMTtcblx0XHRcdFx0dmFyIHV4ID0geCArIDEgPiB3aWR0aCAtIDEgPyB3aWR0aCAtIDEgOiB4ICsgMTtcblxuXHRcdFx0XHR2YXIgcG9pbnRzID0gW107XG5cdFx0XHRcdHZhciBvcmlnaW4gPSBbIDAsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXTtcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgLSAxLCAwLCBkYXRhWyAoIHkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIC0gMSwgLSAxLCBkYXRhWyAoIGx5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXHRcdFx0XHRwb2ludHMucHVzaCggWyAwLCAtIDEsIGRhdGFbICggbHkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgIDEsIC0gMSwgZGF0YVsgKCBseSAqIHdpZHRoICsgdXggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgMSwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXHRcdFx0XHRwb2ludHMucHVzaCggWyAxLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXHRcdFx0XHRwb2ludHMucHVzaCggWyAwLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyB4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIC0gMSwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcblxuXHRcdFx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdFx0XHR2YXIgbnVtX3BvaW50cyA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbnVtX3BvaW50czsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciB2MSA9IHBvaW50c1sgaSBdO1xuXHRcdFx0XHRcdHZhciB2MiA9IHBvaW50c1sgKCBpICsgMSApICUgbnVtX3BvaW50cyBdO1xuXHRcdFx0XHRcdHYxID0gc3VidHJhY3QoIHYxLCBvcmlnaW4gKTtcblx0XHRcdFx0XHR2MiA9IHN1YnRyYWN0KCB2Miwgb3JpZ2luICk7XG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWxpemUoIGNyb3NzKCB2MSwgdjIgKSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBub3JtYWwgPSBbIDAsIDAsIDAgXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBub3JtYWxzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG5vcm1hbFsgMCBdICs9IG5vcm1hbHNbIGkgXVsgMCBdO1xuXHRcdFx0XHRcdG5vcm1hbFsgMSBdICs9IG5vcm1hbHNbIGkgXVsgMSBdO1xuXHRcdFx0XHRcdG5vcm1hbFsgMiBdICs9IG5vcm1hbHNbIGkgXVsgMiBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRub3JtYWxbIDAgXSAvPSBub3JtYWxzLmxlbmd0aDtcblx0XHRcdFx0bm9ybWFsWyAxIF0gLz0gbm9ybWFscy5sZW5ndGg7XG5cdFx0XHRcdG5vcm1hbFsgMiBdIC89IG5vcm1hbHMubGVuZ3RoO1xuXG5cdFx0XHRcdHZhciBpZHggPSAoIHkgKiB3aWR0aCArIHggKSAqIDQ7XG5cblx0XHRcdFx0b3V0cHV0WyBpZHggXSA9ICggKCBub3JtYWxbIDAgXSArIDEuMCApIC8gMi4wICogMjU1ICkgfCAwO1xuXHRcdFx0XHRvdXRwdXRbIGlkeCArIDEgXSA9ICggKCBub3JtYWxbIDEgXSArIDEuMCApIC8gMi4wICogMjU1ICkgfCAwO1xuXHRcdFx0XHRvdXRwdXRbIGlkeCArIDIgXSA9ICggbm9ybWFsWyAyIF0gKiAyNTUgKSB8IDA7XG5cdFx0XHRcdG91dHB1dFsgaWR4ICsgMyBdID0gMjU1O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2VEYXRhLCAwLCAwICk7XG5cblx0XHRyZXR1cm4gY2FudmFzO1xuXG5cdH0sXG5cblx0Z2VuZXJhdGVEYXRhVGV4dHVyZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBjb2xvciApIHtcblxuXHRcdHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQ7XG5cdFx0dmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSggMyAqIHNpemUgKTtcblxuXHRcdHZhciByID0gTWF0aC5mbG9vciggY29sb3IuciAqIDI1NSApO1xuXHRcdHZhciBnID0gTWF0aC5mbG9vciggY29sb3IuZyAqIDI1NSApO1xuXHRcdHZhciBiID0gTWF0aC5mbG9vciggY29sb3IuYiAqIDI1NSApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArKyApIHtcblxuXHRcdFx0ZGF0YVsgaSAqIDMgXSBcdCAgID0gcjtcblx0XHRcdGRhdGFbIGkgKiAzICsgMSBdID0gZztcblx0XHRcdGRhdGFbIGkgKiAzICsgMiBdID0gYjtcblxuXHRcdH1cblxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBUSFJFRS5SR0JGb3JtYXQgKTtcblx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL1NjZW5lVXRpbHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNjZW5lVXRpbHMgPSB7XG5cblx0Y3JlYXRlTXVsdGlNYXRlcmlhbE9iamVjdDogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWxzICkge1xuXG5cdFx0dmFyIGdyb3VwID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Z3JvdXAuYWRkKCBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsc1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBncm91cDtcblxuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgcGFyZW50LCBzY2VuZSApIHtcblxuXHRcdGNoaWxkLmFwcGx5TWF0cml4KCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRwYXJlbnQucmVtb3ZlKCBjaGlsZCApO1xuXHRcdHNjZW5lLmFkZCggY2hpbGQgKTtcblxuXHR9LFxuXG5cdGF0dGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgc2NlbmUsIHBhcmVudCApIHtcblxuXHRcdHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdG1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRjaGlsZC5hcHBseU1hdHJpeCggbWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRzY2VuZS5yZW1vdmUoIGNoaWxkICk7XG5cdFx0cGFyZW50LmFkZCggY2hpbGQgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9Gb250VXRpbHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEZvciBUZXh0IG9wZXJhdGlvbnMgaW4gdGhyZWUuanMgKFNlZSBUZXh0R2VvbWV0cnkpXG4gKlxuICogSXQgdXNlcyB0ZWNobmlxdWVzIHVzZWQgaW46XG4gKlxuICogXHR0eXBlZmFjZS5qcyBhbmQgY2FudmFzdGV4dFxuICogXHRcdEZvciBjb252ZXJ0aW5nIGZvbnRzIGFuZCByZW5kZXJpbmcgd2l0aCBqYXZhc2NyaXB0XG4gKlx0XHRodHRwOi8vdHlwZWZhY2UubmVvY3JhY3kub3JnXG4gKlxuICpcdFRyaWFuZ3VsYXRpb24gcG9ydGVkIGZyb20gQVMzXG4gKlx0XHRTaW1wbGUgUG9seWdvbiBUcmlhbmd1bGF0aW9uXG4gKlx0XHRodHRwOi8vYWN0aW9uc25pcHBldC5jb20vP3A9MTQ2MlxuICpcbiAqIFx0QSBNZXRob2QgdG8gdHJpYW5ndWxhdGUgc2hhcGVzIHdpdGggaG9sZXNcbiAqXHRcdGh0dHA6Ly93d3cuc2FrcmkubmV0L2Jsb2cvMjAwOS8wNi8xMi9hbi1hcHByb2FjaC10by10cmlhbmd1bGF0aW5nLXBvbHlnb25zLXdpdGgtaG9sZXMvXG4gKlxuICovXG5cblRIUkVFLkZvbnRVdGlscyA9IHtcblxuXHRmYWNlczoge30sXG5cblx0Ly8gSnVzdCBmb3Igbm93LiBmYWNlW3dlaWdodF1bc3R5bGVdXG5cblx0ZmFjZTogJ2hlbHZldGlrZXInLFxuXHR3ZWlnaHQ6ICdub3JtYWwnLFxuXHRzdHlsZTogJ25vcm1hbCcsXG5cdHNpemU6IDE1MCxcblx0ZGl2aXNpb25zOiAxMCxcblxuXHRnZXRGYWNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5mYWNlc1sgdGhpcy5mYWNlIF1bIHRoaXMud2VpZ2h0IF1bIHRoaXMuc3R5bGUgXTtcblxuXHRcdH0gY2F0Y2ggKGUpIHtcblxuXHRcdFx0dGhyb3cgXCJUaGUgZm9udCBcIiArIHRoaXMuZmFjZSArIFwiIHdpdGggXCIgKyB0aGlzLndlaWdodCArIFwiIHdlaWdodCBhbmQgXCIgKyB0aGlzLnN0eWxlICsgXCIgc3R5bGUgaXMgbWlzc2luZy5cIlxuXG5cdFx0fTtcblxuXHR9LFxuXG5cdGxvYWRGYWNlOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHR2YXIgZmFtaWx5ID0gZGF0YS5mYW1pbHlOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHR2YXIgVGhyZWVGb250ID0gdGhpcztcblxuXHRcdFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdIHx8IHt9O1xuXG5cdFx0VGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSB8fCB7fTtcblx0XHRUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXVsgZGF0YS5jc3NGb250U3R5bGUgXSA9IGRhdGE7XG5cblx0XHR2YXIgZmFjZSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH0sXG5cblx0ZHJhd1RleHQ6IGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdHZhciBjaGFyYWN0ZXJQdHMgPSBbXSwgYWxsUHRzID0gW107XG5cblx0XHQvLyBSZW5kZXJUZXh0XG5cblx0XHR2YXIgaSwgcCxcblx0XHRcdGZhY2UgPSB0aGlzLmdldEZhY2UoKSxcblx0XHRcdHNjYWxlID0gdGhpcy5zaXplIC8gZmFjZS5yZXNvbHV0aW9uLFxuXHRcdFx0b2Zmc2V0ID0gMCxcblx0XHRcdGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICksXG5cdFx0XHRsZW5ndGggPSBjaGFycy5sZW5ndGg7XG5cblx0XHR2YXIgZm9udFBhdGhzID0gW107XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG5cdFx0XHR2YXIgcmV0ID0gdGhpcy5leHRyYWN0R2x5cGhQb2ludHMoIGNoYXJzWyBpIF0sIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKTtcblx0XHRcdG9mZnNldCArPSByZXQub2Zmc2V0O1xuXG5cdFx0XHRmb250UGF0aHMucHVzaCggcmV0LnBhdGggKTtcblxuXHRcdH1cblxuXHRcdC8vIGdldCB0aGUgd2lkdGhcblxuXHRcdHZhciB3aWR0aCA9IG9mZnNldCAvIDI7XG5cdFx0Ly9cblx0XHQvLyBmb3IgKCBwID0gMDsgcCA8IGFsbFB0cy5sZW5ndGg7IHArKyApIHtcblx0XHQvL1xuXHRcdC8vIFx0YWxsUHRzWyBwIF0ueCAtPSB3aWR0aDtcblx0XHQvL1xuXHRcdC8vIH1cblxuXHRcdC8vdmFyIGV4dHJhY3QgPSB0aGlzLmV4dHJhY3RQb2ludHMoIGFsbFB0cywgY2hhcmFjdGVyUHRzICk7XG5cdFx0Ly9leHRyYWN0LmNvbnRvdXIgPSBhbGxQdHM7XG5cblx0XHQvL2V4dHJhY3QucGF0aHMgPSBmb250UGF0aHM7XG5cdFx0Ly9leHRyYWN0Lm9mZnNldCA9IHdpZHRoO1xuXG5cdFx0cmV0dXJuIHsgcGF0aHM6IGZvbnRQYXRocywgb2Zmc2V0OiB3aWR0aCB9O1xuXG5cdH0sXG5cblxuXG5cblx0ZXh0cmFjdEdseXBoUG9pbnRzOiBmdW5jdGlvbiAoIGMsIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKSB7XG5cblx0XHR2YXIgcHRzID0gW107XG5cblx0XHR2YXIgaSwgaTIsIGRpdmlzaW9ucyxcblx0XHRcdG91dGxpbmUsIGFjdGlvbiwgbGVuZ3RoLFxuXHRcdFx0c2NhbGVYLCBzY2FsZVksXG5cdFx0XHR4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5Mixcblx0XHRcdGxhc3RlLFxuXHRcdFx0Z2x5cGggPSBmYWNlLmdseXBoc1sgYyBdIHx8IGZhY2UuZ2x5cGhzWyAnPycgXTtcblxuXHRcdGlmICggISBnbHlwaCApIHJldHVybjtcblxuXHRcdGlmICggZ2x5cGgubyApIHtcblxuXHRcdFx0b3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8ICggZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCAnICcgKSApO1xuXHRcdFx0bGVuZ3RoID0gb3V0bGluZS5sZW5ndGg7XG5cblx0XHRcdHNjYWxlWCA9IHNjYWxlO1xuXHRcdFx0c2NhbGVZID0gc2NhbGU7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyApIHtcblxuXHRcdFx0XHRhY3Rpb24gPSBvdXRsaW5lWyBpICsrIF07XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZyggYWN0aW9uICk7XG5cblx0XHRcdFx0c3dpdGNoICggYWN0aW9uICkge1xuXG5cdFx0XHRcdGNhc2UgJ20nOlxuXG5cdFx0XHRcdFx0Ly8gTW92ZSBUb1xuXG5cdFx0XHRcdFx0eCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcblx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xuXG5cdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHgsIHkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdsJzpcblxuXHRcdFx0XHRcdC8vIExpbmUgVG9cblxuXHRcdFx0XHRcdHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XG5cdFx0XHRcdFx0eSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWTtcblx0XHRcdFx0XHRwYXRoLmxpbmVUbyggeCx5ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncSc6XG5cblx0XHRcdFx0XHQvLyBRdWFkcmF0aWNDdXJ2ZVRvXG5cblx0XHRcdFx0XHRjcHggID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdGNweSAgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVk7XG5cdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcblx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xuXG5cdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgsIGNweSApO1xuXG5cdFx0XHRcdFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0XHRpZiAoIGxhc3RlICkge1xuXG5cdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcblx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG5cdFx0XHRcdFx0XHRcdHZhciB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcblx0XHRcdFx0XHRcdFx0dmFyIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXHRcdFx0XHRcdCAgfVxuXG5cdFx0XHRcdCAgfVxuXG5cdFx0XHRcdCAgYnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYic6XG5cblx0XHRcdFx0XHQvLyBDdWJpYyBCZXppZXIgQ3VydmVcblxuXHRcdFx0XHRcdGNweCAgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdGNweSAgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuXHRcdFx0XHRcdGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuXHRcdFx0XHRcdGNweDIgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuXHRcdFx0XHRcdGNweTIgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuXG5cdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xuXG5cdFx0XHRcdFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0XHRpZiAoIGxhc3RlICkge1xuXG5cdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcblx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG5cdFx0XHRcdFx0XHRcdHZhciB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcblx0XHRcdFx0XHRcdFx0dmFyIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cblxuXG5cdFx0cmV0dXJuIHsgb2Zmc2V0OiBnbHlwaC5oYSAqIHNjYWxlLCBwYXRoOnBhdGggfTtcblx0fVxuXG59O1xuXG5cblRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyA9IGZ1bmN0aW9uICggdGV4dCwgcGFyYW1ldGVycyApIHtcblxuXHQvLyBQYXJhbWV0ZXJzIFxuXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdHZhciBzaXplID0gcGFyYW1ldGVycy5zaXplICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnNpemUgOiAxMDA7XG5cdHZhciBjdXJ2ZVNlZ21lbnRzID0gcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgOiA0O1xuXG5cdHZhciBmb250ID0gcGFyYW1ldGVycy5mb250ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZvbnQgOiAnaGVsdmV0aWtlcic7XG5cdHZhciB3ZWlnaHQgPSBwYXJhbWV0ZXJzLndlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy53ZWlnaHQgOiAnbm9ybWFsJztcblx0dmFyIHN0eWxlID0gcGFyYW1ldGVycy5zdHlsZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdHlsZSA6ICdub3JtYWwnO1xuXG5cdFRIUkVFLkZvbnRVdGlscy5zaXplID0gc2l6ZTtcblx0VEhSRUUuRm9udFV0aWxzLmRpdmlzaW9ucyA9IGN1cnZlU2VnbWVudHM7XG5cblx0VEhSRUUuRm9udFV0aWxzLmZhY2UgPSBmb250O1xuXHRUSFJFRS5Gb250VXRpbHMud2VpZ2h0ID0gd2VpZ2h0O1xuXHRUSFJFRS5Gb250VXRpbHMuc3R5bGUgPSBzdHlsZTtcblxuXHQvLyBHZXQgYSBGb250IGRhdGEganNvbiBvYmplY3RcblxuXHR2YXIgZGF0YSA9IFRIUkVFLkZvbnRVdGlscy5kcmF3VGV4dCggdGV4dCApO1xuXG5cdHZhciBwYXRocyA9IGRhdGEucGF0aHM7XG5cdHZhciBzaGFwZXMgPSBbXTtcblxuXHRmb3IgKCB2YXIgcCA9IDAsIHBsID0gcGF0aHMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cblx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggc2hhcGVzLCBwYXRoc1sgcCBdLnRvU2hhcGVzKCkgKTtcblxuXHR9XG5cblx0cmV0dXJuIHNoYXBlcztcblxufTtcblxuXG4vKipcbiAqIFRoaXMgY29kZSBpcyBhIHF1aWNrIHBvcnQgb2YgY29kZSB3cml0dGVuIGluIEMrKyB3aGljaCB3YXMgc3VibWl0dGVkIHRvXG4gKiBmbGlwY29kZS5jb20gYnkgSm9obiBXLiBSYXRjbGlmZiAgLy8gSnVseSAyMiwgMjAwMFxuICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcbiAqIGh0dHA6Ly93d3cuZmxpcGNvZGUuY29tL2FyY2hpdmVzL0VmZmljaWVudF9Qb2x5Z29uX1RyaWFuZ3VsYXRpb24uc2h0bWxcbiAqXG4gKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxuICogd3d3LmFjdGlvbnNuaXBwZXQuY29tXG4gKlxuICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xuICogaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqL1xuXG5cbiggZnVuY3Rpb24gKCBuYW1lc3BhY2UgKSB7XG5cblx0dmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cblx0Ly8gdGFrZXMgaW4gYW4gY29udG91ciBhcnJheSBhbmQgcmV0dXJuc1xuXG5cdHZhciBwcm9jZXNzID0gZnVuY3Rpb24gKCBjb250b3VyLCBpbmRpY2VzICkge1xuXG5cdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdGlmICggbiA8IDMgKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHRcdHZlcnRzID0gW10sXG5cdFx0XHR2ZXJ0SW5kaWNlcyA9IFtdO1xuXG5cdFx0Lyogd2Ugd2FudCBhIGNvdW50ZXItY2xvY2t3aXNlIHBvbHlnb24gaW4gdmVydHMgKi9cblxuXHRcdHZhciB1LCB2LCB3O1xuXG5cdFx0aWYgKCBhcmVhKCBjb250b3VyICkgPiAwLjAgKSB7XG5cblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgbjsgdiArKyApIHZlcnRzWyB2IF0gPSB2O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggdiA9IDA7IHYgPCBuOyB2ICsrICkgdmVydHNbIHYgXSA9ICggbiAtIDEgKSAtIHY7XG5cblx0XHR9XG5cblx0XHR2YXIgbnYgPSBuO1xuXG5cdFx0LyogIHJlbW92ZSBudiAtIDIgdmVydGljZXMsIGNyZWF0aW5nIDEgdHJpYW5nbGUgZXZlcnkgdGltZSAqL1xuXG5cdFx0dmFyIGNvdW50ID0gMiAqIG52OyAgIC8qIGVycm9yIGRldGVjdGlvbiAqL1xuXG5cdFx0Zm9yICggdiA9IG52IC0gMTsgbnYgPiAyOyApIHtcblxuXHRcdFx0LyogaWYgd2UgbG9vcCwgaXQgaXMgcHJvYmFibHkgYSBub24tc2ltcGxlIHBvbHlnb24gKi9cblxuXHRcdFx0aWYgKCAoIGNvdW50IC0tICkgPD0gMCApIHtcblxuXHRcdFx0XHQvLyoqIFRyaWFuZ3VsYXRlOiBFUlJPUiAtIHByb2JhYmxlIGJhZCBwb2x5Z29uIVxuXG5cdFx0XHRcdC8vdGhyb3cgKCBcIldhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uIVwiICk7XG5cdFx0XHRcdC8vcmV0dXJuIG51bGw7XG5cdFx0XHRcdC8vIFNvbWV0aW1lcyB3YXJuaW5nIGlzIGZpbmUsIGVzcGVjaWFsbHkgcG9seWdvbnMgYXJlIHRyaWFuZ3VsYXRlZCBpbiByZXZlcnNlLlxuXHRcdFx0XHRjb25zb2xlLmxvZyggJ1dhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uIScgKTtcblxuXHRcdFx0XHRpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHRcdH1cblxuXHRcdFx0LyogdGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+ICovXG5cblx0XHRcdHUgPSB2OyBcdCBcdGlmICggbnYgPD0gdSApIHUgPSAwOyAgICAgLyogcHJldmlvdXMgKi9cblx0XHRcdHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cblx0XHRcdHcgPSB2ICsgMTsgIGlmICggbnYgPD0gdyApIHcgPSAwOyAgICAgLyogbmV4dCAgICAgKi9cblxuXHRcdFx0aWYgKCBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBudiwgdmVydHMgKSApIHtcblxuXHRcdFx0XHR2YXIgYSwgYiwgYywgcywgdDtcblxuXHRcdFx0XHQvKiB0cnVlIG5hbWVzIG9mIHRoZSB2ZXJ0aWNlcyAqL1xuXG5cdFx0XHRcdGEgPSB2ZXJ0c1sgdSBdO1xuXHRcdFx0XHRiID0gdmVydHNbIHYgXTtcblx0XHRcdFx0YyA9IHZlcnRzWyB3IF07XG5cblx0XHRcdFx0Lyogb3V0cHV0IFRyaWFuZ2xlICovXG5cblx0XHRcdFx0cmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxuXHRcdFx0XHRcdGNvbnRvdXJbIGIgXSxcblx0XHRcdFx0XHRjb250b3VyWyBjIF0gXSApO1xuXG5cblx0XHRcdFx0dmVydEluZGljZXMucHVzaCggWyB2ZXJ0c1sgdSBdLCB2ZXJ0c1sgdiBdLCB2ZXJ0c1sgdyBdIF0gKTtcblxuXHRcdFx0XHQvKiByZW1vdmUgdiBmcm9tIHRoZSByZW1haW5pbmcgcG9seWdvbiAqL1xuXG5cdFx0XHRcdGZvciAoIHMgPSB2LCB0ID0gdiArIDE7IHQgPCBudjsgcysrLCB0KysgKSB7XG5cblx0XHRcdFx0XHR2ZXJ0c1sgcyBdID0gdmVydHNbIHQgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bnYgLS07XG5cblx0XHRcdFx0LyogcmVzZXQgZXJyb3IgZGV0ZWN0aW9uIGNvdW50ZXIgKi9cblxuXHRcdFx0XHRjb3VudCA9IDIgKiBudjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fTtcblxuXHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG5cblx0dmFyIGFyZWEgPSBmdW5jdGlvbiAoIGNvbnRvdXIgKSB7XG5cblx0XHR2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xuXHRcdHZhciBhID0gMC4wO1xuXG5cdFx0Zm9yICggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSArKyApIHtcblxuXHRcdFx0YSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhICogMC41O1xuXG5cdH07XG5cblx0dmFyIHNuaXAgPSBmdW5jdGlvbiAoIGNvbnRvdXIsIHUsIHYsIHcsIG4sIHZlcnRzICkge1xuXG5cdFx0dmFyIHA7XG5cdFx0dmFyIGF4LCBheSwgYngsIGJ5O1xuXHRcdHZhciBjeCwgY3ksIHB4LCBweTtcblxuXHRcdGF4ID0gY29udG91clsgdmVydHNbIHUgXSBdLng7XG5cdFx0YXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcblxuXHRcdGJ4ID0gY29udG91clsgdmVydHNbIHYgXSBdLng7XG5cdFx0YnkgPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueTtcblxuXHRcdGN4ID0gY29udG91clsgdmVydHNbIHcgXSBdLng7XG5cdFx0Y3kgPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueTtcblxuXHRcdGlmICggRVBTSUxPTiA+ICggKCAoIGJ4IC0gYXggKSAqICggY3kgLSBheSApICkgLSAoICggYnkgLSBheSApICogKCBjeCAtIGF4ICkgKSApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dmFyIGFYLCBhWSwgYlgsIGJZLCBjWCwgY1k7XG5cdFx0dmFyIGFweCwgYXB5LCBicHgsIGJweSwgY3B4LCBjcHk7XG5cdFx0dmFyIGNDUk9TU2FwLCBiQ1JPU1NjcCwgYUNST1NTYnA7XG5cblx0XHRhWCA9IGN4IC0gYng7ICBhWSA9IGN5IC0gYnk7XG5cdFx0YlggPSBheCAtIGN4OyAgYlkgPSBheSAtIGN5O1xuXHRcdGNYID0gYnggLSBheDsgIGNZID0gYnkgLSBheTtcblxuXHRcdGZvciAoIHAgPSAwOyBwIDwgbjsgcCArKyApIHtcblxuXHRcdFx0cHggPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueFxuXHRcdFx0cHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueVxuXG5cdFx0XHRpZiAoICggKCBweCA9PT0gYXggKSAmJiAoIHB5ID09PSBheSApICkgfHxcblx0XHRcdFx0ICggKCBweCA9PT0gYnggKSAmJiAoIHB5ID09PSBieSApICkgfHxcblx0XHRcdFx0ICggKCBweCA9PT0gY3ggKSAmJiAoIHB5ID09PSBjeSApICkgKVx0Y29udGludWU7XG5cblx0XHRcdGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xuXHRcdFx0YnB4ID0gcHggLSBieDsgIGJweSA9IHB5IC0gYnk7XG5cdFx0XHRjcHggPSBweCAtIGN4OyAgY3B5ID0gcHkgLSBjeTtcblxuXHRcdFx0Ly8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xuXG5cdFx0XHRhQ1JPU1NicCA9IGFYICogYnB5IC0gYVkgKiBicHg7XG5cdFx0XHRjQ1JPU1NhcCA9IGNYICogYXB5IC0gY1kgKiBhcHg7XG5cdFx0XHRiQ1JPU1NjcCA9IGJYICogY3B5IC0gYlkgKiBjcHg7XG5cblx0XHRcdGlmICggKCBhQ1JPU1NicCA+PSAtIEVQU0lMT04gKSAmJiAoIGJDUk9TU2NwID49IC0gRVBTSUxPTiApICYmICggY0NST1NTYXAgPj0gLSBFUFNJTE9OICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9O1xuXG5cblx0bmFtZXNwYWNlLlRyaWFuZ3VsYXRlID0gcHJvY2Vzcztcblx0bmFtZXNwYWNlLlRyaWFuZ3VsYXRlLmFyZWEgPSBhcmVhO1xuXG5cdHJldHVybiBuYW1lc3BhY2U7XG5cbn0gKSggVEhSRUUuRm9udFV0aWxzICk7XG5cbi8vIFRvIHVzZSB0aGUgdHlwZWZhY2UuanMgZmFjZSBmaWxlcywgaG9vayB1cCB0aGUgQVBJXG5zZWxmLl90eXBlZmFjZV9qcyA9IHsgZmFjZXM6IFRIUkVFLkZvbnRVdGlscy5mYWNlcywgbG9hZEZhY2U6IFRIUkVFLkZvbnRVdGlscy5sb2FkRmFjZSB9O1xuVEhSRUUudHlwZWZhY2VfanMgPSBzZWxmLl90eXBlZmFjZV9qcztcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2F1ZGlvL0F1ZGlvLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5BdWRpbyA9IGZ1bmN0aW9uICggbGlzdGVuZXIgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdBdWRpbyc7XG5cblx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcblx0dGhpcy5zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cblx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdHRoaXMucGFubmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuXHR0aGlzLnBhbm5lci5jb25uZWN0KCB0aGlzLmdhaW4gKTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCBmaWxlICkge1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0cmVxdWVzdC5vcGVuKCAnR0VUJywgZmlsZSwgdHJ1ZSApO1xuXHRyZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCBlICkge1xuXG5cdFx0c2NvcGUuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIHRoaXMucmVzcG9uc2UsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRzY29wZS5zb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xuXHRcdFx0c2NvcGUuc291cmNlLmNvbm5lY3QoIHNjb3BlLnBhbm5lciApO1xuXHRcdFx0c2NvcGUuc291cmNlLnN0YXJ0KCAwICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblx0cmVxdWVzdC5zZW5kKCk7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHR0aGlzLnNvdXJjZS5sb29wID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0dGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBmb3JjZSApIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG5cdFx0cG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHR0aGlzLnBhbm5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuXG5cdH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYXVkaW8vQXVkaW9MaXN0ZW5lci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXVkaW9MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xuXG5cdHRoaXMuY29udGV4dCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XG5cbn07XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXHR2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHZhciBvcmllbnRhdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2ZWxvY2l0eSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dmFyIHBvc2l0aW9uUHJldiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuXHRcdHZhciBsaXN0ZW5lciA9IHRoaXMuY29udGV4dC5saXN0ZW5lcjtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcblxuXHRcdG9yaWVudGF0aW9uLnNldCggMCwgMCwgLTEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblx0XHR2ZWxvY2l0eS5zdWJWZWN0b3JzKCBwb3NpdGlvbiwgcG9zaXRpb25QcmV2ICk7XG5cblx0XHRsaXN0ZW5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuXHRcdGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKCBvcmllbnRhdGlvbi54LCBvcmllbnRhdGlvbi55LCBvcmllbnRhdGlvbi56LCB0aGlzLnVwLngsIHRoaXMudXAueSwgdGhpcy51cC56ICk7XG5cdFx0bGlzdGVuZXIuc2V0VmVsb2NpdHkoIHZlbG9jaXR5LngsIHZlbG9jaXR5LnksIHZlbG9jaXR5LnogKTtcblxuXHRcdHBvc2l0aW9uUHJldi5jb3B5KCBwb3NpdGlvbiApO1xuXG5cdH07XG5cbn0gKSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9DdXJ2ZS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0XG4gKlxuICogU29tZSBjb21tb24gb2YgQ3VydmUgbWV0aG9kc1xuICogLmdldFBvaW50KHQpLCBnZXRUYW5nZW50KHQpXG4gKiAuZ2V0UG9pbnRBdCh1KSwgZ2V0VGFnZW50QXQodSlcbiAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXG4gKiAuZ2V0TGVuZ3RoKClcbiAqIC51cGRhdGVBcmNMZW5ndGhzKClcbiAqXG4gKiBUaGlzIGZvbGxvd2luZyBjbGFzc2VzIHN1YmNsYXNzZXMgVEhSRUUuQ3VydmU6XG4gKlxuICogLS0gMmQgY2xhc3NlcyAtLVxuICogVEhSRUUuTGluZUN1cnZlXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZVxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxuICogVEhSRUUuU3BsaW5lQ3VydmVcbiAqIFRIUkVFLkFyY0N1cnZlXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcbiAqXG4gKiAtLSAzZCBjbGFzc2VzIC0tXG4gKiBUSFJFRS5MaW5lQ3VydmUzXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZTNcbiAqIFRIUkVFLkNsb3NlZFNwbGluZUN1cnZlM1xuICpcbiAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGhcbiAqXG4gKiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3NcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3VydmUgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuLy9cdC0gdCBbMCAuLiAxXVxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0Y29uc29sZS5sb2coIFwiV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcblx0cmV0dXJuIG51bGw7XG5cbn07XG5cbi8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuLy8gLSB1IFswIC4uIDFdXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1ICkge1xuXG5cdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xuXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCApO1xuXG59O1xuXG4vLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xuXG5cdHZhciBkLCBwdHMgPSBbXTtcblxuXHRmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cblx0XHRwdHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0fVxuXG5cdHJldHVybiBwdHM7XG5cbn07XG5cbi8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcblxuXHR2YXIgZCwgcHRzID0gW107XG5cblx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG5cdFx0cHRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0fVxuXG5cdHJldHVybiBwdHM7XG5cbn07XG5cbi8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblx0cmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xuXG59O1xuXG4vLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3RocyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSAodGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucykgPyAodGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyk6IDIwMDtcblxuXHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzXG5cdFx0JiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT0gZGl2aXNpb25zICsgMSApXG5cdFx0JiYgISB0aGlzLm5lZWRzVXBkYXRlKSB7XG5cblx0XHQvL2NvbnNvbGUubG9nKCBcImNhY2hlZFwiLCB0aGlzLmNhY2hlQXJjTGVuZ3RocyApO1xuXHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcblxuXHR9XG5cblx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHZhciBjYWNoZSA9IFtdO1xuXHR2YXIgY3VycmVudCwgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoIDAgKTtcblx0dmFyIHAsIHN1bSA9IDA7XG5cblx0Y2FjaGUucHVzaCggMCApO1xuXG5cdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcblxuXHRcdGN1cnJlbnQgPSB0aGlzLmdldFBvaW50ICggcCAvIGRpdmlzaW9ucyApO1xuXHRcdHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcblx0XHRjYWNoZS5wdXNoKCBzdW0gKTtcblx0XHRsYXN0ID0gY3VycmVudDtcblxuXHR9XG5cblx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcblxuXHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTpzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXG5cbn07XG5cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLnVwZGF0ZUFyY0xlbmd0aHMgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdHRoaXMuZ2V0TGVuZ3RocygpO1xufTtcblxuLy8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpIGRpc3RhbmNlXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRVdG9UbWFwcGluZyA9IGZ1bmN0aW9uICggdSwgZGlzdGFuY2UgKSB7XG5cblx0dmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblxuXHR2YXIgaSA9IDAsIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XG5cblx0dmFyIHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XG5cblx0aWYgKCBkaXN0YW5jZSApIHtcblxuXHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xuXG5cdH0gZWxzZSB7XG5cblx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XG5cblx0fVxuXG5cdC8vdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXG5cdC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXG5cblx0dmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XG5cblx0d2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcblxuXHRcdGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xuXG5cdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuXHRcdGlmICggY29tcGFyaXNvbiA8IDAgKSB7XG5cblx0XHRcdGxvdyA9IGkgKyAxO1xuXHRcdFx0Y29udGludWU7XG5cblx0XHR9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcblxuXHRcdFx0aGlnaCA9IGkgLSAxO1xuXHRcdFx0Y29udGludWU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRoaWdoID0gaTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBET05FXG5cblx0XHR9XG5cblx0fVxuXG5cdGkgPSBoaWdoO1xuXG5cdC8vY29uc29sZS5sb2coJ2InICwgaSwgbG93LCBoaWdoLCBEYXRlLm5vdygpLSB0aW1lKTtcblxuXHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PSB0YXJnZXRBcmNMZW5ndGggKSB7XG5cblx0XHR2YXIgdCA9IGkgLyAoIGlsIC0gMSApO1xuXHRcdHJldHVybiB0O1xuXG5cdH1cblxuXHQvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0YXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXG5cblx0dmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcbiAgICB2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xuXG4gICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTtcblxuICAgIC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXG5cbiAgICB2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XG5cbiAgICB2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtMSApO1xuXG5cdHJldHVybiB0O1xuXG59O1xuXG4vLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XG4vLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXG4vLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuLy8gd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvblxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG5cdHZhciBkZWx0YSA9IDAuMDAwMTtcblx0dmFyIHQxID0gdCAtIGRlbHRhO1xuXHR2YXIgdDIgPSB0ICsgZGVsdGE7XG5cblx0Ly8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxuXG5cdGlmICggdDEgPCAwICkgdDEgPSAwO1xuXHRpZiAoIHQyID4gMSApIHQyID0gMTtcblxuXHR2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcblx0dmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cblx0dmFyIHZlYyA9IHB0Mi5jbG9uZSgpLnN1YihwdDEpO1xuXHRyZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xuXG59O1xuXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XG5cblx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG5cdHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcblxufTtcblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRVdGlsc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdXJ2ZS5VdGlscyA9IHtcblxuXHR0YW5nZW50UXVhZHJhdGljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XG5cblx0XHRyZXR1cm4gMiAqICggMSAtIHQgKSAqICggcDEgLSBwMCApICsgMiAqIHQgKiAoIHAyIC0gcDEgKTtcblxuXHR9LFxuXG5cdC8vIFB1YXkgQmluZywgdGhhbmtzIGZvciBoZWxwaW5nIHdpdGggdGhpcyBkZXJpdmF0aXZlIVxuXG5cdHRhbmdlbnRDdWJpY0JlemllcjogZnVuY3Rpb24gKHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG5cdFx0cmV0dXJuIC0gMyAqIHAwICogKDEgLSB0KSAqICgxIC0gdCkgICtcblx0XHRcdDMgKiBwMSAqICgxIC0gdCkgKiAoMS10KSAtIDYgKnQgKnAxICogKDEtdCkgK1xuXHRcdFx0NiAqIHQgKiAgcDIgKiAoMS10KSAtIDMgKiB0ICogdCAqIHAyICtcblx0XHRcdDMgKiB0ICogdCAqIHAzO1xuXG5cdH0sXG5cblx0dGFuZ2VudFNwbGluZTogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRcdC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XG5cblx0XHR2YXIgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7IFx0Ly8gZGVyaXZlZCBmcm9tIDJ0XjMg4oiSIDN0XjIgKyAxXG5cdFx0dmFyIGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTsgLy8gdF4zIOKIkiAydF4yICsgdFxuXHRcdHZhciBoMDEgPSAtIDYgKiB0ICogdCArIDYgKiB0OyBcdC8vIOKIkiAydDMgKyAzdDJcblx0XHR2YXIgaDExID0gMyAqIHQgKiB0IC0gMiAqIHQ7XHQvLyB0MyDiiJIgdDJcblxuXHRcdHJldHVybiBoMDAgKyBoMTAgKyBoMDEgKyBoMTE7XG5cblx0fSxcblxuXHQvLyBDYXRtdWxsLVJvbVxuXG5cdGludGVycG9sYXRlOiBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHQgKSB7XG5cblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcblx0XHR2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblx0XHR2YXIgdDIgPSB0ICogdDtcblx0XHR2YXIgdDMgPSB0ICogdDI7XG5cdFx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cblx0fVxuXG59O1xuXG5cbi8vIFRPRE86IFRyYW5zZm9ybWF0aW9uIGZvciBDdXJ2ZXM/XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdDNEIEN1cnZlc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBBIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBuZXcgY3VydmUgc3ViY2xhc3Nlc1xuXG5USFJFRS5DdXJ2ZS5jcmVhdGUgPSBmdW5jdGlvbiAoIGNvbnN0cnVjdG9yLCBnZXRQb2ludEZ1bmMgKSB7XG5cblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50RnVuYztcblxuXHRyZXR1cm4gY29uc3RydWN0b3I7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL0N1cnZlUGF0aC5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxuICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1cnZlUGF0aCA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLmN1cnZlcyA9IFtdO1xuXHR0aGlzLmJlbmRzID0gW107XG5cdFxuXHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggY3VydmUgKSB7XG5cblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0Ly8gVE9ET1xuXHQvLyBJZiB0aGUgZW5kaW5nIG9mIGN1cnZlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nXG5cdC8vIG9yIHRoZSBuZXh0IGN1cnZlLCB0aGVuLCB0aGlzIGlzIG5vdCBhIHJlYWwgcGF0aFxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcblx0Ly8gVE9ETyBUZXN0XG5cdC8vIGFuZCB2ZXJpZnkgZm9yIHZlY3RvcjMgKG5lZWRzIHRvIGltcGxlbWVudCBlcXVhbHMpXG5cdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxuXHR2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWzBdLmdldFBvaW50KDApO1xuXHR2YXIgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1t0aGlzLmN1cnZlcy5sZW5ndGgtMV0uZ2V0UG9pbnQoMSk7XG5cdFxuXHRpZiAoISBzdGFydFBvaW50LmVxdWFscyhlbmRQb2ludCkpIHtcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgVEhSRUUuTGluZUN1cnZlKGVuZFBvaW50LCBzdGFydFBvaW50KSApO1xuXHR9XG5cdFxufTtcblxuLy8gVG8gZ2V0IGFjY3VyYXRlIHBvaW50IHdpdGggcmVmZXJlbmNlIHRvXG4vLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXG4vLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XG5cbi8vIDEuIExlbmd0aCBvZiBlYWNoIHN1YiBwYXRoIGhhdmUgdG8gYmUga25vd25cbi8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxuLy8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxuLy8gNC4gUmV0dXJuIGN1cnZlLmdldFBvaW50QXQodCcpXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcblxuXHR2YXIgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xuXHR2YXIgY3VydmVMZW5ndGhzID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcblx0dmFyIGkgPSAwLCBkaWZmLCBjdXJ2ZTtcblxuXHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cblxuXHR3aGlsZSAoIGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoICkge1xuXG5cdFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xuXG5cdFx0XHRkaWZmID0gY3VydmVMZW5ndGhzWyBpIF0gLSBkO1xuXHRcdFx0Y3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xuXG5cdFx0XHR2YXIgdSA9IDEgLSBkaWZmIC8gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cblx0XHRcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XG5cblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGkgKys7XG5cblx0fVxuXG5cdHJldHVybiBudWxsO1xuXG5cdC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxuXG59O1xuXG4vKlxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG59OyovXG5cblxuLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuLy8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXG4vLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cblx0dmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRyZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuLy8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRDdXJ2ZUxlbmd0aHMgPSBmdW5jdGlvbigpIHtcblxuXHQvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXG5cblx0aWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT0gdGhpcy5jdXJ2ZXMubGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzO1xuXG5cdH07XG5cblx0Ly8gR2V0IGxlbmd0aCBvZiBzdWJzdXJ2ZVxuXHQvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcblxuXHR2YXIgbGVuZ3RocyA9IFtdLCBzdW1zID0gMDtcblx0dmFyIGksIGlsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoO1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRzdW1zICs9IHRoaXMuY3VydmVzWyBpIF0uZ2V0TGVuZ3RoKCk7XG5cdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XG5cblx0fVxuXG5cdHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcblxuXHRyZXR1cm4gbGVuZ3RocztcblxufTtcblxuXG5cbi8vIFJldHVybnMgbWluIGFuZCBtYXggY29vcmRpbmF0ZXNcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcblxuXHR2YXIgbWF4WCwgbWF4WSwgbWF4Wjtcblx0dmFyIG1pblgsIG1pblksIG1pblo7XG5cblx0bWF4WCA9IG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cdG1pblggPSBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG5cdHZhciBwLCBpLCBpbCwgc3VtO1xuXG5cdHZhciB2MyA9IHBvaW50c1swXSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjM7XG5cblx0c3VtID0gdjMgPyBuZXcgVEhSRUUuVmVjdG9yMygpIDogbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRmb3IgKCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRwID0gcG9pbnRzWyBpIF07XG5cblx0XHRpZiAoIHAueCA+IG1heFggKSBtYXhYID0gcC54O1xuXHRcdGVsc2UgaWYgKCBwLnggPCBtaW5YICkgbWluWCA9IHAueDtcblxuXHRcdGlmICggcC55ID4gbWF4WSApIG1heFkgPSBwLnk7XG5cdFx0ZWxzZSBpZiAoIHAueSA8IG1pblkgKSBtaW5ZID0gcC55O1xuXG5cdFx0aWYgKCB2MyApIHtcblxuXHRcdFx0aWYgKCBwLnogPiBtYXhaICkgbWF4WiA9IHAuejtcblx0XHRcdGVsc2UgaWYgKCBwLnogPCBtaW5aICkgbWluWiA9IHAuejtcblxuXHRcdH1cblxuXHRcdHN1bS5hZGQoIHAgKTtcblxuXHR9XG5cblx0dmFyIHJldCA9IHtcblxuXHRcdG1pblg6IG1pblgsXG5cdFx0bWluWTogbWluWSxcblx0XHRtYXhYOiBtYXhYLFxuXHRcdG1heFk6IG1heFlcblxuXHR9O1xuXG5cdGlmICggdjMgKSB7XG5cblx0XHRyZXQubWF4WiA9IG1heFo7XG5cdFx0cmV0Lm1pblogPSBtaW5aO1xuXG5cdH1cblxuXHRyZXR1cm4gcmV0O1xuXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDcmVhdGUgR2VvbWV0cmllcyBIZWxwZXJzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIHBhdGggcG9pbnRzIChmb3IgTGluZSBvciBQb2ludHMgb2JqZWN0cylcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cblx0dmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMsIHRydWUgKTtcblx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG59O1xuXG4vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIGVxdWlkaXN0YW5jZSBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuXHR2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xuXHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiggcG9pbnRzICkge1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSwgcG9pbnRzWyBpIF0ueiB8fCAwKSApO1xuXG5cdH1cblxuXHRyZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0QmVuZCAvIFdyYXAgSGVscGVyIE1ldGhvZHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gV3JhcCBwYXRoIC8gQmVuZCBtb2RpZmllcnM/XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkV3JhcFBhdGggPSBmdW5jdGlvbiAoIGJlbmRwYXRoICkge1xuXG5cdHRoaXMuYmVuZHMucHVzaCggYmVuZHBhdGggKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XG5cblx0dmFyIG9sZFB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBzZWdtZW50cyApOyAvLyBnZXRQb2ludHMgZ2V0U3BhY2VkUG9pbnRzXG5cdHZhciBpLCBpbDtcblxuXHRpZiAoICEgYmVuZHMgKSB7XG5cblx0XHRiZW5kcyA9IHRoaXMuYmVuZHM7XG5cblx0fVxuXG5cdGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0b2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuXHR9XG5cblx0cmV0dXJuIG9sZFB0cztcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XG5cblx0dmFyIG9sZFB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBzZWdtZW50cyApO1xuXG5cdHZhciBpLCBpbDtcblxuXHRpZiAoICEgYmVuZHMgKSB7XG5cblx0XHRiZW5kcyA9IHRoaXMuYmVuZHM7XG5cblx0fVxuXG5cdGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0b2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuXHR9XG5cblx0cmV0dXJuIG9sZFB0cztcblxufTtcblxuLy8gVGhpcyByZXR1cm5zIGdldFBvaW50cygpIGJlbmQvd3JhcHBlZCBhcm91bmQgdGhlIGNvbnRvdXIgb2YgYSBwYXRoLlxuLy8gUmVhZCBodHRwOi8vd3d3LnBsYW5ldGNsZWdnLmNvbS9wcm9qZWN0cy9XYXJwaW5nVGV4dFRvU3BsaW5lcy5odG1sXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0V3JhcFBvaW50cyA9IGZ1bmN0aW9uICggb2xkUHRzLCBwYXRoICkge1xuXG5cdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG5cblx0dmFyIGksIGlsLCBwLCBvbGRYLCBvbGRZLCB4Tm9ybTtcblxuXHRmb3IgKCBpID0gMCwgaWwgPSBvbGRQdHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRwID0gb2xkUHRzWyBpIF07XG5cblx0XHRvbGRYID0gcC54O1xuXHRcdG9sZFkgPSBwLnk7XG5cblx0XHR4Tm9ybSA9IG9sZFggLyBib3VuZHMubWF4WDtcblxuXHRcdC8vIElmIHVzaW5nIGFjdHVhbCBkaXN0YW5jZSwgZm9yIGxlbmd0aCA+IHBhdGgsIHJlcXVpcmVzIGxpbmUgZXh0cnVzaW9uc1xuXHRcdC8veE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKHhOb3JtLCBvbGRYKTsgLy8gMyBzdHlsZXMuIDEpIHdyYXAgc3RyZXRjaGVkLiAyKSB3cmFwIHN0cmV0Y2ggYnkgYXJjIGxlbmd0aCAzKSB3YXJwIGJ5IGFjdHVhbCBkaXN0YW5jZVxuXG5cdFx0eE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKCB4Tm9ybSwgb2xkWCApO1xuXG5cdFx0Ly8gY2hlY2sgZm9yIG91dCBvZiBib3VuZHM/XG5cblx0XHR2YXIgcGF0aFB0ID0gcGF0aC5nZXRQb2ludCggeE5vcm0gKTtcblx0XHR2YXIgbm9ybWFsID0gcGF0aC5nZXRUYW5nZW50KCB4Tm9ybSApO1xuXHRcdG5vcm1hbC5zZXQoIC0gbm9ybWFsLnksIG5vcm1hbC54ICkubXVsdGlwbHlTY2FsYXIoIG9sZFkgKTtcblxuXHRcdHAueCA9IHBhdGhQdC54ICsgbm9ybWFsLng7XG5cdFx0cC55ID0gcGF0aFB0LnkgKyBub3JtYWwueTtcblxuXHR9XG5cblx0cmV0dXJuIG9sZFB0cztcblxufTtcblxuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9HeXJvc2NvcGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkd5cm9zY29wZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbn07XG5cblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciB0cmFuc2xhdGlvbk9iamVjdCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBxdWF0ZXJuaW9uT2JqZWN0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblx0dmFyIHNjYWxlT2JqZWN0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR2YXIgdHJhbnNsYXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBxdWF0ZXJuaW9uV29ybGQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXHR2YXIgc2NhbGVXb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgJiYgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdC8vIHVwZGF0ZSBtYXRyaXhXb3JsZFxuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XG5cblx0XHRcdGlmICggdGhpcy5wYXJlbnQgKSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggdHJhbnNsYXRpb25Xb3JsZCwgcXVhdGVybmlvbldvcmxkLCBzY2FsZVdvcmxkICk7XG5cdFx0XHRcdHRoaXMubWF0cml4LmRlY29tcG9zZSggdHJhbnNsYXRpb25PYmplY3QsIHF1YXRlcm5pb25PYmplY3QsIHNjYWxlT2JqZWN0ICk7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb21wb3NlKCB0cmFuc2xhdGlvbldvcmxkLCBxdWF0ZXJuaW9uT2JqZWN0LCBzY2FsZVdvcmxkICk7XG5cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGNoaWxkcmVuXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdH1cblxuXHR9O1xuXHRcbn0oKSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9QYXRoLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQ3JlYXRlcyBmcmVlIGZvcm0gMmQgcGF0aCB1c2luZyBzZXJpZXMgb2YgcG9pbnRzLCBsaW5lcyBvciBjdXJ2ZXMuXG4gKlxuICoqL1xuXG5USFJFRS5QYXRoID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cblx0VEhSRUUuQ3VydmVQYXRoLmNhbGwodGhpcyk7XG5cblx0dGhpcy5hY3Rpb25zID0gW107XG5cblx0aWYgKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLmZyb21Qb2ludHMoIHBvaW50cyApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlICk7XG5cblRIUkVFLlBhdGhBY3Rpb25zID0ge1xuXG5cdE1PVkVfVE86ICdtb3ZlVG8nLFxuXHRMSU5FX1RPOiAnbGluZVRvJyxcblx0UVVBRFJBVElDX0NVUlZFX1RPOiAncXVhZHJhdGljQ3VydmVUbycsIC8vIEJlemllciBxdWFkcmF0aWMgY3VydmVcblx0QkVaSUVSX0NVUlZFX1RPOiAnYmV6aWVyQ3VydmVUbycsIFx0XHQvLyBCZXppZXIgY3ViaWMgY3VydmVcblx0Q1NQTElORV9USFJVOiAnc3BsaW5lVGhydScsXHRcdFx0XHQvLyBDYXRtdWxsLXJvbSBzcGxpbmVcblx0QVJDOiAnYXJjJyxcdFx0XHRcdFx0XHRcdFx0Ly8gQ2lyY2xlXG5cdEVMTElQU0U6ICdlbGxpcHNlJ1xufTtcblxuLy8gVE9ETyBDbGVhbiB1cCBQQVRIIEFQSVxuXG4vLyBDcmVhdGUgcGF0aCB1c2luZyBzdHJhaWdodCBsaW5lcyB0byBjb25uZWN0IGFsbCBwb2ludHNcbi8vIC0gdmVjdG9yczogYXJyYXkgb2YgVmVjdG9yMlxuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5mcm9tUG9pbnRzID0gZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG5cdHRoaXMubW92ZVRvKCB2ZWN0b3JzWyAwIF0ueCwgdmVjdG9yc1sgMCBdLnkgKTtcblxuXHRmb3IgKCB2YXIgdiA9IDEsIHZsZW4gPSB2ZWN0b3JzLmxlbmd0aDsgdiA8IHZsZW47IHYgKysgKSB7XG5cblx0XHR0aGlzLmxpbmVUbyggdmVjdG9yc1sgdiBdLngsIHZlY3RvcnNbIHYgXS55ICk7XG5cblx0fTtcblxufTtcblxuLy8gc3RhcnRQYXRoKCkgZW5kUGF0aCgpP1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5MaW5lQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSwgbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKSApO1xuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTElORV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApICk7XG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5RVUFEUkFUSUNfQ1VSVkVfVE8sIGFyZ3M6IGFyZ3MgfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUDF4LCBhQ1AxeSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgICBhQ1AyeCwgYUNQMnksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgYVgsIGFZICkge1xuXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLkN1YmljQmV6aWVyQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKSApO1xuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydSA9IGZ1bmN0aW9uKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcbi8vLS0tXG5cdHZhciBucHRzID0gWyBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICkgXTtcblx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIG5wdHMsIHB0cyApO1xuXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggbnB0cyApO1xuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQ1NQTElORV9USFJVLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuLy8gRlVUVVJFOiBDaGFuZ2UgdGhlIEFQSSBvciBmb2xsb3cgY2FudmFzIEFQST9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMV0uYXJncztcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuXHR0aGlzLmFic2FyYyhhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxuXHRcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuIH07XG5cbiBUSFJFRS5QYXRoLnByb3RvdHlwZS5hYnNhcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRcdCAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblx0dGhpcy5hYnNlbGxpcHNlKGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSk7XG4gfTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0ICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDFdLmFyZ3M7XG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0dGhpcy5hYnNlbGxpcHNlKGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsXG5cdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG4gfTtcblxuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hYnNlbGxpcHNlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHR2YXIgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoMSk7XG5cdGFyZ3MucHVzaChsYXN0UG9pbnQueCk7XG5cdGFyZ3MucHVzaChsYXN0UG9pbnQueSk7XG5cblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFLCBhcmdzOiBhcmdzIH0gKTtcblxuIH07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xuXG5cdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA0MDtcblxuXHR2YXIgcG9pbnRzID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGl2aXNpb25zOyBpICsrICkge1xuXG5cdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0Ly9pZiggIXRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApIHRocm93IFwiRElFXCI7XG5cblx0fVxuXG5cdC8vIGlmICggY2xvc2VkUGF0aCApIHtcblx0Ly9cblx0Ly8gXHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblx0Ly9cblx0Ly8gfVxuXG5cdHJldHVybiBwb2ludHM7XG5cbn07XG5cbi8qIFJldHVybiBhbiBhcnJheSBvZiB2ZWN0b3JzIGJhc2VkIG9uIGNvbnRvdXIgb2YgdGhlIHBhdGggKi9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcblxuXHRpZiAodGhpcy51c2VTcGFjZWRQb2ludHMpIHtcblx0XHRjb25zb2xlLmxvZygndGF0YScpO1xuXHRcdHJldHVybiB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCBjbG9zZWRQYXRoICk7XG5cdH1cblxuXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XG5cblx0dmFyIHBvaW50cyA9IFtdO1xuXG5cdHZhciBpLCBpbCwgaXRlbSwgYWN0aW9uLCBhcmdzO1xuXHR2YXIgY3B4LCBjcHksIGNweDIsIGNweTIsIGNweDEsIGNweTEsIGNweDAsIGNweTAsXG5cdFx0bGFzdGUsIGosXG5cdFx0dCwgdHgsIHR5O1xuXG5cdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGl0ZW0gPSB0aGlzLmFjdGlvbnNbIGkgXTtcblxuXHRcdGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXHRcdGFyZ3MgPSBpdGVtLmFyZ3M7XG5cblx0XHRzd2l0Y2goIGFjdGlvbiApIHtcblxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTzpcblxuXHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPOlxuXG5cdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcblxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTzpcblxuXHRcdFx0Y3B4ICA9IGFyZ3NbIDIgXTtcblx0XHRcdGNweSAgPSBhcmdzWyAzIF07XG5cblx0XHRcdGNweDEgPSBhcmdzWyAwIF07XG5cdFx0XHRjcHkxID0gYXJnc1sgMSBdO1xuXG5cdFx0XHRpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xuXHRcdFx0XHRjcHkwID0gbGFzdGUueTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG5cdFx0XHRcdGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xuXHRcdFx0XHRjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdFx0dCA9IGogLyBkaXZpc2lvbnM7XG5cblx0XHRcdFx0dHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XG5cdFx0XHRcdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPOlxuXG5cdFx0XHRjcHggID0gYXJnc1sgNCBdO1xuXHRcdFx0Y3B5ICA9IGFyZ3NbIDUgXTtcblxuXHRcdFx0Y3B4MSA9IGFyZ3NbIDAgXTtcblx0XHRcdGNweTEgPSBhcmdzWyAxIF07XG5cblx0XHRcdGNweDIgPSBhcmdzWyAyIF07XG5cdFx0XHRjcHkyID0gYXJnc1sgMyBdO1xuXG5cdFx0XHRpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xuXHRcdFx0XHRjcHkwID0gbGFzdGUueTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG5cdFx0XHRcdGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xuXHRcdFx0XHRjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGZvciAoIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcblxuXHRcdFx0XHR0ID0gaiAvIGRpdmlzaW9ucztcblxuXHRcdFx0XHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcblx0XHRcdFx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B5MCwgY3B5MSwgY3B5MiwgY3B5ICk7XG5cblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5DU1BMSU5FX1RIUlU6XG5cblx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cblx0XHRcdHZhciBsYXN0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF0sIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF0gKTtcblx0XHRcdHZhciBzcHRzID0gWyBsYXN0IF07XG5cblx0XHRcdHZhciBuID0gZGl2aXNpb25zICogYXJnc1sgMCBdLmxlbmd0aDtcblxuXHRcdFx0c3B0cyA9IHNwdHMuY29uY2F0KCBhcmdzWyAwIF0gKTtcblxuXHRcdFx0dmFyIHNwbGluZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggc3B0cyApO1xuXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSBuOyBqICsrICkge1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBzcGxpbmUuZ2V0UG9pbnRBdCggaiAvIG4gKSApIDtcblxuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQVJDOlxuXG5cdFx0XHR2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxuXHRcdFx0XHRhUmFkaXVzID0gYXJnc1sgMiBdLFxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDMgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNCBdLFxuXHRcdFx0XHRhQ2xvY2t3aXNlID0gISEgYXJnc1sgNSBdO1xuXG5cdFx0XHR2YXIgZGVsdGFBbmdsZSA9IGFFbmRBbmdsZSAtIGFTdGFydEFuZ2xlO1xuXHRcdFx0dmFyIGFuZ2xlO1xuXHRcdFx0dmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xuXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xuXG5cdFx0XHRcdHQgPSBqIC8gdGRpdmlzaW9ucztcblxuXHRcdFx0XHRpZiAoICEgYUNsb2Nrd2lzZSApIHtcblxuXHRcdFx0XHRcdHQgPSAxIC0gdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG5cdFx0XHRcdHR4ID0gYVggKyBhUmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0XHRcdHR5ID0gYVkgKyBhUmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL2NvbnNvbGUubG9nKHBvaW50cyk7XG5cblx0XHQgIGJyZWFrO1xuXHRcdCAgXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFOlxuXG5cdFx0XHR2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxuXHRcdFx0XHR4UmFkaXVzID0gYXJnc1sgMiBdLFxuXHRcdFx0XHR5UmFkaXVzID0gYXJnc1sgMyBdLFxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDQgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNSBdLFxuXHRcdFx0XHRhQ2xvY2t3aXNlID0gISEgYXJnc1sgNiBdO1xuXG5cblx0XHRcdHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XG5cdFx0XHR2YXIgYW5nbGU7XG5cdFx0XHR2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XG5cblx0XHRcdGZvciAoIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdFx0dCA9IGogLyB0ZGl2aXNpb25zO1xuXG5cdFx0XHRcdGlmICggISBhQ2xvY2t3aXNlICkge1xuXG5cdFx0XHRcdFx0dCA9IDEgLSB0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cblx0XHRcdFx0dHggPSBhWCArIHhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHRcdFx0dHkgPSBhWSArIHlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XG5cblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vY29uc29sZS5sb2cocG9pbnRzKTtcblxuXHRcdCAgYnJlYWs7XG5cblx0XHR9IC8vIGVuZCBzd2l0Y2hcblxuXHR9XG5cblxuXG5cdC8vIE5vcm1hbGl6ZSB0byByZW1vdmUgdGhlIGNsb3NpbmcgcG9pbnQgYnkgZGVmYXVsdC5cblx0dmFyIGxhc3RQb2ludCA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDFdO1xuXHR2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblx0aWYgKCBNYXRoLmFicyhsYXN0UG9pbnQueCAtIHBvaW50c1sgMCBdLngpIDwgRVBTSUxPTiAmJlxuXHRcdFx0IE1hdGguYWJzKGxhc3RQb2ludC55IC0gcG9pbnRzWyAwIF0ueSkgPCBFUFNJTE9OKVxuXHRcdHBvaW50cy5zcGxpY2UoIHBvaW50cy5sZW5ndGggLSAxLCAxKTtcblx0aWYgKCBjbG9zZWRQYXRoICkge1xuXG5cdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cblx0fVxuXG5cdHJldHVybiBwb2ludHM7XG5cbn07XG5cbi8vXG4vLyBCcmVha3MgcGF0aCBpbnRvIHNoYXBlc1xuLy9cbi8vXHRBc3N1bXB0aW9ucyAoaWYgcGFyYW1ldGVyIGlzQ0NXPT10cnVlIHRoZSBvcHBvc2l0ZSBob2xkcyk6XG4vL1x0LSBzb2xpZCBzaGFwZXMgYXJlIGRlZmluZWQgY2xvY2t3aXNlIChDVylcbi8vXHQtIGhvbGVzIGFyZSBkZWZpbmVkIGNvdW50ZXJjbG9ja3dpc2UgKENDVylcbi8vXG4vL1x0SWYgcGFyYW1ldGVyIG5vSG9sZXM9PXRydWU6XG4vLyAgLSBhbGwgc3ViUGF0aHMgYXJlIHJlZ2FyZGVkIGFzIHNvbGlkIHNoYXBlc1xuLy8gIC0gZGVmaW5pdGlvbiBvcmRlciBDVy9DQ1cgaGFzIG5vIHJlbGV2YW5jZVxuLy9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUudG9TaGFwZXMgPSBmdW5jdGlvbiggaXNDQ1csIG5vSG9sZXMgKSB7XG5cblx0ZnVuY3Rpb24gZXh0cmFjdFN1YnBhdGhzKCBpbkFjdGlvbnMgKSB7XG5cblx0XHR2YXIgaSwgaWwsIGl0ZW0sIGFjdGlvbiwgYXJncztcblxuXHRcdHZhciBzdWJQYXRocyA9IFtdLCBsYXN0UGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBpbkFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGl0ZW0gPSBpbkFjdGlvbnNbIGkgXTtcblxuXHRcdFx0YXJncyA9IGl0ZW0uYXJncztcblx0XHRcdGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXG5cdFx0XHRpZiAoIGFjdGlvbiA9PSBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPICkge1xuXG5cdFx0XHRcdGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT0gMCApIHtcblxuXHRcdFx0XHRcdHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XG5cdFx0XHRcdFx0bGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsYXN0UGF0aFsgYWN0aW9uIF0uYXBwbHkoIGxhc3RQYXRoLCBhcmdzICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9IDAgKSB7XG5cblx0XHRcdHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XG5cblx0XHR9XG5cblx0XHQvLyBjb25zb2xlLmxvZyhzdWJQYXRocyk7XG5cblx0XHRyZXR1cm5cdHN1YlBhdGhzO1xuXHR9XG5cblx0ZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xuXG5cdFx0dmFyIHNoYXBlcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xuXG5cdFx0XHR2YXIgdG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcblx0XHRcdHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG5cdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuXHRcdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG5cdFx0fVxuXG5cdFx0Ly9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cblx0XHRyZXR1cm4gc2hhcGVzO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XG5cdFx0dmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cblx0XHR2YXIgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7XG5cblx0XHQvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxuXHRcdC8vIHRvZ2dsaW5nIG9mIGluc2lkZS9vdXRzaWRlIGF0IGV2ZXJ5IHNpbmdsZSEgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGFuIGVkZ2Vcblx0XHQvLyAgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XG5cdFx0Ly8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcblx0XHR2YXIgaW5zaWRlID0gZmFsc2U7XG5cdFx0Zm9yKCB2YXIgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxICsrICkge1xuXHRcdFx0dmFyIGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHAgXTtcblx0XHRcdHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XG5cblx0XHRcdHZhciBlZGdlRHggPSBlZGdlSGlnaFB0LnggLSBlZGdlTG93UHQueDtcblx0XHRcdHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyhlZGdlRHkpID4gRVBTSUxPTiApIHtcdFx0XHQvLyBub3QgcGFyYWxsZWxcblx0XHRcdFx0aWYgKCBlZGdlRHkgPCAwICkge1xuXHRcdFx0XHRcdGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHEgXTsgZWRnZUR4ID0gLSBlZGdlRHg7XG5cdFx0XHRcdFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgXHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmICggaW5QdC55ID09IGVkZ2VMb3dQdC55ICkge1xuXHRcdFx0XHRcdGlmICggaW5QdC54ID09IGVkZ2VMb3dQdC54IClcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXHRcdFx0XHRcdC8vIGNvbnRpbnVlO1x0XHRcdFx0Ly8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBwZXJwRWRnZSA9IGVkZ2VEeSAqIChpblB0LnggLSBlZGdlTG93UHQueCkgLSBlZGdlRHggKiAoaW5QdC55IC0gZWRnZUxvd1B0LnkpO1xuXHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPT0gMCApXHRcdFx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XG5cdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA8IDAgKSBcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1x0XHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcdFx0Ly8gcGFyYWxsZWwgb3IgY29saW5lYXJcblx0XHRcdFx0aWYgKCBpblB0LnkgIT0gZWRnZUxvd1B0LnkgKSBcdFx0Y29udGludWU7XHRcdFx0Ly8gcGFyYWxsZWxcblx0XHRcdFx0Ly8gZWdkZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XG5cdFx0XHRcdGlmICggKCAoIGVkZ2VIaWdoUHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlTG93UHQueCApICkgfHxcblx0XHRcdFx0XHQgKCAoIGVkZ2VMb3dQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VIaWdoUHQueCApICkgKVx0XHRyZXR1cm5cdHRydWU7XHQvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcblx0XHRcdFx0Ly8gY29udGludWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuXHRpbnNpZGU7XG5cdH1cblxuXG5cdHZhciBzdWJQYXRocyA9IGV4dHJhY3RTdWJwYXRocyggdGhpcy5hY3Rpb25zICk7XG5cdGlmICggc3ViUGF0aHMubGVuZ3RoID09IDAgKSByZXR1cm4gW107XG5cblx0aWYgKCBub0hvbGVzID09PSB0cnVlIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cblx0dmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XG5cblx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT0gMSkge1xuXG5cdFx0dG1wUGF0aCA9IHN1YlBhdGhzWzBdO1xuXHRcdHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XG5cdFx0dG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcblx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdH1cblxuXHR2YXIgaG9sZXNGaXJzdCA9ICEgVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcblx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcblxuXHQvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xuXHRcblx0dmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcblx0dmFyIG5ld1NoYXBlcyA9IFtdO1xuXHR2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xuXHR2YXIgbWFpbklkeCA9IDA7XG5cdHZhciB0bXBQb2ludHM7XG5cblx0bmV3U2hhcGVzW21haW5JZHhdID0gdW5kZWZpbmVkO1xuXHRuZXdTaGFwZUhvbGVzW21haW5JZHhdID0gW107XG5cblx0dmFyIGksIGlsO1xuXG5cdGZvciAoIGkgPSAwLCBpbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XG5cdFx0dG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcblx0XHRzb2xpZCA9IFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB0bXBQb2ludHMgKTtcblx0XHRzb2xpZCA9IGlzQ0NXID8gISBzb2xpZCA6IHNvbGlkO1xuXG5cdFx0aWYgKCBzb2xpZCApIHtcblxuXHRcdFx0aWYgKCAoISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbbWFpbklkeF0gKSApXHRtYWluSWR4ICsrO1xuXG5cdFx0XHRuZXdTaGFwZXNbbWFpbklkeF0gPSB7IHM6IG5ldyBUSFJFRS5TaGFwZSgpLCBwOiB0bXBQb2ludHMgfTtcblx0XHRcdG5ld1NoYXBlc1ttYWluSWR4XS5zLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG5cdFx0XHRuZXdTaGFwZXNbbWFpbklkeF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblx0XHRcdFxuXHRcdFx0aWYgKCBob2xlc0ZpcnN0IClcdG1haW5JZHggKys7XG5cdFx0XHRuZXdTaGFwZUhvbGVzW21haW5JZHhdID0gW107XG5cblx0XHRcdC8vY29uc29sZS5sb2coJ2N3JywgaSk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRuZXdTaGFwZUhvbGVzW21haW5JZHhdLnB1c2goIHsgaDogdG1wUGF0aCwgcDogdG1wUG9pbnRzWzBdIH0gKTtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZygnY2N3JywgaSk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxuXHRpZiAoICEgbmV3U2hhcGVzWzBdIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cblx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcblx0XHR2YXIgYW1iaWdpb3VzID0gZmFsc2U7XG5cdFx0dmFyIHRvQ2hhbmdlID0gW107XG5cblx0XHRmb3IgKHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXHRcdFx0YmV0dGVyU2hhcGVIb2xlc1tzSWR4XSA9IFtdO1xuXHRcdH1cblx0XHRmb3IgKHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXHRcdFx0dmFyIHNoID0gbmV3U2hhcGVzW3NJZHhdO1xuXHRcdFx0dmFyIHNobyA9IG5ld1NoYXBlSG9sZXNbc0lkeF07XG5cdFx0XHRmb3IgKHZhciBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHggKysgKSB7XG5cdFx0XHRcdHZhciBobyA9IHNob1toSWR4XTtcblx0XHRcdFx0dmFyIGhvbGVfdW5hc3NpZ25lZCA9IHRydWU7XG5cdFx0XHRcdGZvciAodmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcblx0XHRcdFx0XHRpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbczJJZHhdLnAgKSApIHtcblx0XHRcdFx0XHRcdGlmICggc0lkeCAhPSBzMklkeCApXHRcdHRvQ2hhbmdlLnB1c2goIHsgZnJvbXM6IHNJZHgsIHRvczogczJJZHgsIGhvbGU6IGhJZHggfSApO1xuXHRcdFx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzW3MySWR4XS5wdXNoKCBobyApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YW1iaWdpb3VzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7IGJldHRlclNoYXBlSG9sZXNbc0lkeF0ucHVzaCggaG8gKTsgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBjb25zb2xlLmxvZyhcImFtYmlnaW91czogXCIsIGFtYmlnaW91cyk7XG5cdFx0aWYgKCB0b0NoYW5nZS5sZW5ndGggPiAwICkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJ0byBjaGFuZ2U6IFwiLCB0b0NoYW5nZSk7XG5cdFx0XHRpZiAoISBhbWJpZ2lvdXMpXHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcblx0XHR9XG5cdH1cblxuXHR2YXIgdG1wSG9sZXMsIGosIGpsO1xuXHRmb3IgKCBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cdFx0dG1wU2hhcGUgPSBuZXdTaGFwZXNbaV0ucztcblx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblx0XHR0bXBIb2xlcyA9IG5ld1NoYXBlSG9sZXNbaV07XG5cdFx0Zm9yICggaiA9IDAsIGpsID0gdG1wSG9sZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cdFx0XHR0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1tqXS5oICk7XG5cdFx0fVxuXHR9XG5cblx0Ly9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cblx0cmV0dXJuIHNoYXBlcztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvU2hhcGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXG4gKiovXG5cbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxuLy8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxuLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcbi8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXG5cblRIUkVFLlNoYXBlID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLlBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR0aGlzLmhvbGVzID0gW107XG5cbn07XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gRXh0cnVkZUdlb21ldHJ5XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXG5cdHZhciBleHRydWRlZCA9IG5ldyBUSFJFRS5FeHRydWRlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcblx0cmV0dXJuIGV4dHJ1ZGVkO1xuXG59O1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmV0dXJuIFNoYXBlR2VvbWV0cnlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuXHRyZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cbi8vIEdldCBwb2ludHMgb2YgaG9sZXNcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFBvaW50c0hvbGVzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0dmFyIGksIGlsID0gdGhpcy5ob2xlcy5sZW5ndGgsIGhvbGVzUHRzID0gW107XG5cblx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0VHJhbnNmb3JtZWRQb2ludHMoIGRpdmlzaW9ucywgdGhpcy5iZW5kcyApO1xuXG5cdH1cblxuXHRyZXR1cm4gaG9sZXNQdHM7XG5cbn07XG5cbi8vIEdldCBwb2ludHMgb2YgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzSG9sZXMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHR2YXIgaSwgaWwgPSB0aGlzLmhvbGVzLmxlbmd0aCwgaG9sZXNQdHMgPSBbXTtcblxuXHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0aG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCB0aGlzLmJlbmRzICk7XG5cblx0fVxuXG5cdHJldHVybiBob2xlc1B0cztcblxufTtcblxuXG4vLyBHZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRyZXR1cm4ge1xuXG5cdFx0c2hhcGU6IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoIGRpdmlzaW9ucyApLFxuXHRcdGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxuXG5cdH07XG5cbn07XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0UG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0aWYgKHRoaXMudXNlU3BhY2VkUG9pbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyhkaXZpc2lvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuZXh0cmFjdEFsbFBvaW50cyhkaXZpc2lvbnMpO1xuXG59O1xuXG4vL1xuLy8gVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHNXaXRoQmVuZCA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBiZW5kICkge1xuLy9cbi8vIFx0cmV0dXJuIHtcbi8vXG4vLyBcdFx0c2hhcGU6IHRoaXMudHJhbnNmb3JtKCBiZW5kLCBkaXZpc2lvbnMgKSxcbi8vIFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zLCBiZW5kIClcbi8vXG4vLyBcdH07XG4vL1xuLy8gfTtcblxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdHJldHVybiB7XG5cblx0XHRzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyggZGl2aXNpb25zICksXG5cdFx0aG9sZXM6IHRoaXMuZ2V0U3BhY2VkUG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cblx0fTtcblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0VXRpbHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuU2hhcGUuVXRpbHMgPSB7XG5cblx0dHJpYW5ndWxhdGVTaGFwZTogZnVuY3Rpb24gKCBjb250b3VyLCBob2xlcyApIHtcblxuXHRcdGZ1bmN0aW9uIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnUHQxLCBpblNlZ1B0MiwgaW5PdGhlclB0ICkge1xuXHRcdFx0Ly8gaW5PdGhlclB0IG5lZWRzIHRvIGJlIGNvbGluZWFyIHRvIHRoZSBpblNlZ21lbnRcblx0XHRcdGlmICggaW5TZWdQdDEueCAhPSBpblNlZ1B0Mi54ICkge1xuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnggPCBpblNlZ1B0Mi54ICkge1xuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQxLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQyLnggKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQxLnggKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnkgPCBpblNlZ1B0Mi55ICkge1xuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQxLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQyLnkgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQxLnkgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxLCBpblNlZzJQdDIsIGluRXhjbHVkZUFkamFjZW50U2VncyApIHtcblx0XHRcdHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG5cdFx0XHR2YXIgc2VnMWR4ID0gaW5TZWcxUHQyLnggLSBpblNlZzFQdDEueCwgICBzZWcxZHkgPSBpblNlZzFQdDIueSAtIGluU2VnMVB0MS55O1xuXHRcdFx0dmFyIHNlZzJkeCA9IGluU2VnMlB0Mi54IC0gaW5TZWcyUHQxLngsICAgc2VnMmR5ID0gaW5TZWcyUHQyLnkgLSBpblNlZzJQdDEueTtcblxuXHRcdFx0dmFyIHNlZzFzZWcyZHggPSBpblNlZzFQdDEueCAtIGluU2VnMlB0MS54O1xuXHRcdFx0dmFyIHNlZzFzZWcyZHkgPSBpblNlZzFQdDEueSAtIGluU2VnMlB0MS55O1xuXG5cdFx0XHR2YXIgbGltaXRcdFx0PSBzZWcxZHkgKiBzZWcyZHggLSBzZWcxZHggKiBzZWcyZHk7XG5cdFx0XHR2YXIgcGVycFNlZzFcdD0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMobGltaXQpID4gRVBTSUxPTiApIHtcdFx0XHQvLyBub3QgcGFyYWxsZWxcblxuXHRcdFx0XHR2YXIgcGVycFNlZzI7XG5cdFx0XHRcdGlmICggbGltaXQgPiAwICkge1xuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMSA8IDAgKSB8fCAoIHBlcnBTZWcxID4gbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0cGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPCAwICkgfHwgKCBwZXJwU2VnMiA+IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMSA+IDAgKSB8fCAoIHBlcnBTZWcxIDwgbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0cGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPiAwICkgfHwgKCBwZXJwU2VnMiA8IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaS5lLiB0byByZWR1Y2Ugcm91bmRpbmcgZXJyb3JzXG5cdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzE/XG5cdFx0XHRcdGlmICggcGVycFNlZzIgPT0gMCApIHtcblx0XHRcdFx0XHRpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcblx0XHRcdFx0XHRcdCAoICggcGVycFNlZzEgPT0gMCApIHx8ICggcGVycFNlZzEgPT0gbGltaXQgKSApIClcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdHJldHVybiAgWyBpblNlZzFQdDEgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHBlcnBTZWcyID09IGxpbWl0ICkge1xuXHRcdFx0XHRcdGlmICggKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAmJlxuXHRcdFx0XHRcdFx0ICggKCBwZXJwU2VnMSA9PSAwICkgfHwgKCBwZXJwU2VnMSA9PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0cmV0dXJuICBbIGluU2VnMVB0MiBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzI/XG5cdFx0XHRcdGlmICggcGVycFNlZzEgPT0gMCApXHRcdHJldHVybiAgWyBpblNlZzJQdDEgXTtcblx0XHRcdFx0aWYgKCBwZXJwU2VnMSA9PSBsaW1pdCApXHRyZXR1cm4gIFsgaW5TZWcyUHQyIF07XG5cblx0XHRcdFx0Ly8gcmV0dXJuIHJlYWwgaW50ZXJzZWN0aW9uIHBvaW50XG5cdFx0XHRcdHZhciBmYWN0b3JTZWcxID0gcGVycFNlZzIgLyBsaW1pdDtcblx0XHRcdFx0cmV0dXJuXHRbIHsgeDogaW5TZWcxUHQxLnggKyBmYWN0b3JTZWcxICogc2VnMWR4LFxuXHRcdFx0XHRcdFx0XHR5OiBpblNlZzFQdDEueSArIGZhY3RvclNlZzEgKiBzZWcxZHkgfSBdO1xuXG5cdFx0XHR9IGVsc2Uge1x0XHQvLyBwYXJhbGxlbCBvciBjb2xpbmVhclxuXHRcdFx0XHRpZiAoICggcGVycFNlZzEgIT0gMCApIHx8XG5cdFx0XHRcdFx0ICggc2VnMmR5ICogc2VnMXNlZzJkeCAhPSBzZWcyZHggKiBzZWcxc2VnMmR5ICkgKSBcdFx0XHRyZXR1cm4gW107XG5cblx0XHRcdFx0Ly8gdGhleSBhcmUgY29sbGluZWFyIG9yIGRlZ2VuZXJhdGVcblx0XHRcdFx0dmFyIHNlZzFQdCA9ICggKHNlZzFkeCA9PSAwKSAmJiAoc2VnMWR5ID09IDApICk7XHQvLyBzZWdtZW50MSBpc3QganVzdCBhIHBvaW50P1xuXHRcdFx0XHR2YXIgc2VnMlB0ID0gKCAoc2VnMmR4ID09IDApICYmIChzZWcyZHkgPT0gMCkgKTtcdC8vIHNlZ21lbnQyIGlzdCBqdXN0IGEgcG9pbnQ/XG5cdFx0XHRcdC8vIGJvdGggc2VnbWVudHMgYXJlIHBvaW50c1xuXHRcdFx0XHRpZiAoIHNlZzFQdCAmJiBzZWcyUHQgKSB7XG5cdFx0XHRcdFx0aWYgKCAoaW5TZWcxUHQxLnggIT0gaW5TZWcyUHQxLngpIHx8XG5cdFx0XHRcdFx0XHQgKGluU2VnMVB0MS55ICE9IGluU2VnMlB0MS55KSApXHRcdHJldHVybiBbXTsgICBcdC8vIHRoZXkgYXJlIGRpc3RpbmN0ICBwb2ludHNcblx0XHRcdFx0XHRyZXR1cm4gIFsgaW5TZWcxUHQxIF07ICAgICAgICAgICAgICAgICBcdFx0XHRcdFx0Ly8gdGhleSBhcmUgdGhlIHNhbWUgcG9pbnRcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzZWdtZW50IzEgIGlzIGEgc2luZ2xlIHBvaW50XG5cdFx0XHRcdGlmICggc2VnMVB0ICkge1xuXHRcdFx0XHRcdGlmICghIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpblNlZzFQdDEgKSApXHRcdHJldHVybiBbXTtcdFx0Ly8gYnV0IG5vdCBpbiBzZWdtZW50IzJcblx0XHRcdFx0XHRyZXR1cm4gIFsgaW5TZWcxUHQxIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc2VnbWVudCMyICBpcyBhIHNpbmdsZSBwb2ludFxuXHRcdFx0XHRpZiAoIHNlZzJQdCApIHtcblx0XHRcdFx0XHRpZiAoISBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxICkgKVx0XHRyZXR1cm4gW107XHRcdC8vIGJ1dCBub3QgaW4gc2VnbWVudCMxXG5cdFx0XHRcdFx0cmV0dXJuICBbIGluU2VnMlB0MSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdGhleSBhcmUgY29sbGluZWFyIHNlZ21lbnRzLCB3aGljaCBtaWdodCBvdmVybGFwXG5cdFx0XHRcdHZhciBzZWcxbWluLCBzZWcxbWF4LCBzZWcxbWluVmFsLCBzZWcxbWF4VmFsO1xuXHRcdFx0XHR2YXIgc2VnMm1pbiwgc2VnMm1heCwgc2VnMm1pblZhbCwgc2VnMm1heFZhbDtcblx0XHRcdFx0aWYgKHNlZzFkeCAhPSAwKSB7XHRcdC8vIHRoZSBzZWdtZW50cyBhcmUgTk9UIG9uIGEgdmVydGljYWwgbGluZVxuXHRcdFx0XHRcdGlmICggaW5TZWcxUHQxLnggPCBpblNlZzFQdDIueCApIHtcblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueDtcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi54O1xuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS54O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGluU2VnMlB0MS54IDwgaW5TZWcyUHQyLnggKSB7XG5cdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLng7XG5cdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLng7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueDtcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHQvLyB0aGUgc2VnbWVudHMgYXJlIG9uIGEgdmVydGljYWwgbGluZVxuXHRcdFx0XHRcdGlmICggaW5TZWcxUHQxLnkgPCBpblNlZzFQdDIueSApIHtcblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueTtcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi55O1xuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS55O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGluU2VnMlB0MS55IDwgaW5TZWcyUHQyLnkgKSB7XG5cdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLnk7XG5cdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLnk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzZWcxbWluVmFsIDw9IHNlZzJtaW5WYWwgKSB7XG5cdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDwgIHNlZzJtaW5WYWwgKVx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA9PSBzZWcybWluVmFsIClcdHtcblx0XHRcdFx0XHRcdGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzIClcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgc2VnMm1pbiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNlZzFtYXhWYWwgPD0gc2VnMm1heFZhbCApXHRyZXR1cm4gWyBzZWcybWluLCBzZWcxbWF4IF07XG5cdFx0XHRcdFx0cmV0dXJuXHRbIHNlZzJtaW4sIHNlZzJtYXggXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIHNlZzFtaW5WYWwgPiAgc2VnMm1heFZhbCApXHRyZXR1cm4gW107XG5cdFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsID09IHNlZzJtYXhWYWwgKVx0e1xuXHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBzZWcxbWluIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzFtaW4sIHNlZzFtYXggXTtcblx0XHRcdFx0XHRyZXR1cm5cdFsgc2VnMW1pbiwgc2VnMm1heCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNQb2ludEluc2lkZUFuZ2xlKCBpblZlcnRleCwgaW5MZWdGcm9tUHQsIGluTGVnVG9QdCwgaW5PdGhlclB0ICkge1xuXHRcdFx0Ly8gVGhlIG9yZGVyIG9mIGxlZ3MgaXMgaW1wb3J0YW50XG5cblx0XHRcdHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG5cdFx0XHQvLyB0cmFuc2xhdGlvbiBvZiBhbGwgcG9pbnRzLCBzbyB0aGF0IFZlcnRleCBpcyBhdCAoMCwwKVxuXHRcdFx0dmFyIGxlZ0Zyb21QdFhcdD0gaW5MZWdGcm9tUHQueCAtIGluVmVydGV4LngsICBsZWdGcm9tUHRZXHQ9IGluTGVnRnJvbVB0LnkgLSBpblZlcnRleC55O1xuXHRcdFx0dmFyIGxlZ1RvUHRYXHQ9IGluTGVnVG9QdC54XHQtIGluVmVydGV4LngsICBsZWdUb1B0WVx0XHQ9IGluTGVnVG9QdC55XHQtIGluVmVydGV4Lnk7XG5cdFx0XHR2YXIgb3RoZXJQdFhcdD0gaW5PdGhlclB0LnhcdC0gaW5WZXJ0ZXgueCwgIG90aGVyUHRZXHRcdD0gaW5PdGhlclB0LnlcdC0gaW5WZXJ0ZXgueTtcblxuXHRcdFx0Ly8gbWFpbiBhbmdsZSA+MDogPCAxODAgZGVnLjsgMDogMTgwIGRlZy47IDwwOiA+IDE4MCBkZWcuXG5cdFx0XHR2YXIgZnJvbTJ0b0FuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBsZWdUb1B0WSAtIGxlZ0Zyb21QdFkgKiBsZWdUb1B0WDtcblx0XHRcdHZhciBmcm9tMm90aGVyQW5nbGVcdD0gbGVnRnJvbVB0WCAqIG90aGVyUHRZIC0gbGVnRnJvbVB0WSAqIG90aGVyUHRYO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKGZyb20ydG9BbmdsZSkgPiBFUFNJTE9OICkge1x0XHRcdC8vIGFuZ2xlICE9IDE4MCBkZWcuXG5cblx0XHRcdFx0dmFyIG90aGVyMnRvQW5nbGVcdFx0PSBvdGhlclB0WCAqIGxlZ1RvUHRZIC0gb3RoZXJQdFkgKiBsZWdUb1B0WDtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogXCIgKyBmcm9tMnRvQW5nbGUgKyBcIiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgKyBcIiwgb3RoZXIydG86IFwiICsgb3RoZXIydG9BbmdsZSApO1xuXG5cdFx0XHRcdGlmICggZnJvbTJ0b0FuZ2xlID4gMCApIHtcdFx0XHRcdC8vIG1haW4gYW5nbGUgPCAxODAgZGVnLlxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgJiYgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1x0XHRcdFx0XHRcdFx0XHQvLyBtYWluIGFuZ2xlID4gMTgwIGRlZy5cblx0XHRcdFx0XHRyZXR1cm5cdCggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApIHx8ICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZ2xlID09IDE4MCBkZWcuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IDE4MCBkZWcuLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSAgKTtcblx0XHRcdFx0cmV0dXJuXHQoIGZyb20yb3RoZXJBbmdsZSA+IDAgKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApIHtcblxuXHRcdFx0dmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXG5cdFx0XHR2YXIgaG9sZTtcblxuXHRcdFx0ZnVuY3Rpb24gaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBpblNoYXBlSWR4LCBpbkhvbGVJZHggKSB7XG5cdFx0XHRcdC8vIENoZWNrIGlmIGhvbGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIHNoYXBlIHBvaW50XG5cdFx0XHRcdHZhciBsYXN0U2hhcGVJZHggPSBzaGFwZS5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdHZhciBwcmV2U2hhcGVJZHggPSBpblNoYXBlSWR4IC0gMTtcblx0XHRcdFx0aWYgKCBwcmV2U2hhcGVJZHggPCAwIClcdFx0XHRwcmV2U2hhcGVJZHggPSBsYXN0U2hhcGVJZHg7XG5cblx0XHRcdFx0dmFyIG5leHRTaGFwZUlkeCA9IGluU2hhcGVJZHggKyAxO1xuXHRcdFx0XHRpZiAoIG5leHRTaGFwZUlkeCA+IGxhc3RTaGFwZUlkeCApXHRuZXh0U2hhcGVJZHggPSAwO1xuXG5cdFx0XHRcdHZhciBpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggc2hhcGVbaW5TaGFwZUlkeF0sIHNoYXBlWyBwcmV2U2hhcGVJZHggXSwgc2hhcGVbIG5leHRTaGFwZUlkeCBdLCBob2xlW2luSG9sZUlkeF0gKTtcblx0XHRcdFx0aWYgKCEgaW5zaWRlQW5nbGUgKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChTaGFwZSk6IFwiICsgaW5TaGFwZUlkeCArIFwiLCBQb2ludDogXCIgKyBob2xlW2luSG9sZUlkeF0ueCArIFwiL1wiICsgaG9sZVtpbkhvbGVJZHhdLnkgKTtcblx0XHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgc2hhcGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIGhvbGUgcG9pbnRcblx0XHRcdFx0dmFyIGxhc3RIb2xlSWR4ID0gaG9sZS5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdHZhciBwcmV2SG9sZUlkeCA9IGluSG9sZUlkeCAtIDE7XG5cdFx0XHRcdGlmICggcHJldkhvbGVJZHggPCAwIClcdFx0XHRwcmV2SG9sZUlkeCA9IGxhc3RIb2xlSWR4O1xuXG5cdFx0XHRcdHZhciBuZXh0SG9sZUlkeCA9IGluSG9sZUlkeCArIDE7XG5cdFx0XHRcdGlmICggbmV4dEhvbGVJZHggPiBsYXN0SG9sZUlkeCApXHRuZXh0SG9sZUlkeCA9IDA7XG5cblx0XHRcdFx0aW5zaWRlQW5nbGUgPSBpc1BvaW50SW5zaWRlQW5nbGUoIGhvbGVbaW5Ib2xlSWR4XSwgaG9sZVsgcHJldkhvbGVJZHggXSwgaG9sZVsgbmV4dEhvbGVJZHggXSwgc2hhcGVbaW5TaGFwZUlkeF0gKTtcblx0XHRcdFx0aWYgKCEgaW5zaWRlQW5nbGUgKSB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChIb2xlKTogXCIgKyBpbkhvbGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgc2hhcGVbaW5TaGFwZUlkeF0ueCArIFwiL1wiICsgc2hhcGVbaW5TaGFwZUlkeF0ueSApO1xuXHRcdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm5cdHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGludGVyc2VjdHNTaGFwZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XG5cdFx0XHRcdC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHNoYXBlIGVkZ2VzXG5cdFx0XHRcdHZhciBzSWR4LCBuZXh0SWR4LCBpbnRlcnNlY3Rpb247XG5cdFx0XHRcdGZvciAoIHNJZHggPSAwOyBzSWR4IDwgc2hhcGUubGVuZ3RoOyBzSWR4ICsrICkge1xuXHRcdFx0XHRcdG5leHRJZHggPSBzSWR4KzE7IG5leHRJZHggJT0gc2hhcGUubGVuZ3RoO1xuXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgc2hhcGVbc0lkeF0sIHNoYXBlW25leHRJZHhdLCB0cnVlICk7XG5cdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApXHRcdHJldHVyblx0dHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbmRlcEhvbGVzID0gW107XG5cblx0XHRcdGZ1bmN0aW9uIGludGVyc2VjdHNIb2xlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcblx0XHRcdFx0Ly8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggaG9sZSBlZGdlc1xuXHRcdFx0XHR2YXIgaWhJZHgsIGNoa0hvbGUsXG5cdFx0XHRcdFx0aElkeCwgbmV4dElkeCwgaW50ZXJzZWN0aW9uO1xuXHRcdFx0XHRmb3IgKCBpaElkeCA9IDA7IGloSWR4IDwgaW5kZXBIb2xlcy5sZW5ndGg7IGloSWR4ICsrICkge1xuXHRcdFx0XHRcdGNoa0hvbGUgPSBob2xlc1tpbmRlcEhvbGVzW2loSWR4XV07XG5cdFx0XHRcdFx0Zm9yICggaElkeCA9IDA7IGhJZHggPCBjaGtIb2xlLmxlbmd0aDsgaElkeCArKyApIHtcblx0XHRcdFx0XHRcdG5leHRJZHggPSBoSWR4KzE7IG5leHRJZHggJT0gY2hrSG9sZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIGNoa0hvbGVbaElkeF0sIGNoa0hvbGVbbmV4dElkeF0sIHRydWUgKTtcblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKVx0XHRyZXR1cm5cdHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBob2xlSW5kZXgsIHNoYXBlSW5kZXgsXG5cdFx0XHRcdHNoYXBlUHQsIGhvbGVQdCxcblx0XHRcdFx0aG9sZUlkeCwgY3V0S2V5LCBmYWlsZWRDdXRzID0gW10sXG5cdFx0XHRcdHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxuXHRcdFx0XHR0bXBIb2xlMSwgdG1wSG9sZTI7XG5cblx0XHRcdGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRpbmRlcEhvbGVzLnB1c2goIGggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWluU2hhcGVJbmRleCA9IDA7XG5cdFx0XHR2YXIgY291bnRlciA9IGluZGVwSG9sZXMubGVuZ3RoICogMjtcblx0XHRcdHdoaWxlICggaW5kZXBIb2xlcy5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRjb3VudGVyIC0tO1xuXHRcdFx0XHRpZiAoIGNvdW50ZXIgPCAwICkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcIkluZmluaXRlIExvb3AhIEhvbGVzIGxlZnQ6XCIgKyBpbmRlcEhvbGVzLmxlbmd0aCArIFwiLCBQcm9iYWJseSBIb2xlIG91dHNpZGUgU2hhcGUhXCIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNlYXJjaCBmb3Igc2hhcGUtdmVydGV4IGFuZCBob2xlLXZlcnRleCxcblx0XHRcdFx0Ly8gd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcblx0XHRcdFx0Zm9yICggc2hhcGVJbmRleCA9IG1pblNoYXBlSW5kZXg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGg7IHNoYXBlSW5kZXggKysgKSB7XG5cblx0XHRcdFx0XHRzaGFwZVB0ID0gc2hhcGVbIHNoYXBlSW5kZXggXTtcblx0XHRcdFx0XHRob2xlSW5kZXhcdD0gLSAxO1xuXG5cdFx0XHRcdFx0Ly8gc2VhcmNoIGZvciBob2xlIHdoaWNoIGNhbiBiZSByZWFjaGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuXHRcdFx0XHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGluZGVwSG9sZXMubGVuZ3RoOyBoICsrICkge1xuXHRcdFx0XHRcdFx0aG9sZUlkeCA9IGluZGVwSG9sZXNbaF07XG5cblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgbXVsdGlwbGUgY2hlY2tzXG5cdFx0XHRcdFx0XHRjdXRLZXkgPSBzaGFwZVB0LnggKyBcIjpcIiArIHNoYXBlUHQueSArIFwiOlwiICsgaG9sZUlkeDtcblx0XHRcdFx0XHRcdGlmICggZmFpbGVkQ3V0c1tjdXRLZXldICE9PSB1bmRlZmluZWQgKVx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRob2xlID0gaG9sZXNbaG9sZUlkeF07XG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaDIgPSAwOyBoMiA8IGhvbGUubGVuZ3RoOyBoMiArKyApIHtcblx0XHRcdFx0XHRcdFx0aG9sZVB0ID0gaG9sZVsgaDIgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCEgaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBzaGFwZUluZGV4LCBoMiApIClcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0c1NoYXBlRWRnZSggc2hhcGVQdCwgaG9sZVB0ICkgKVx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzSG9sZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRcdFx0aG9sZUluZGV4ID0gaDI7XG5cdFx0XHRcdFx0XHRcdGluZGVwSG9sZXMuc3BsaWNlKGgsMSk7XG5cblx0XHRcdFx0XHRcdFx0dG1wU2hhcGUxID0gc2hhcGUuc2xpY2UoIDAsIHNoYXBlSW5kZXgrMSApO1xuXHRcdFx0XHRcdFx0XHR0bXBTaGFwZTIgPSBzaGFwZS5zbGljZSggc2hhcGVJbmRleCApO1xuXHRcdFx0XHRcdFx0XHR0bXBIb2xlMSA9IGhvbGUuc2xpY2UoIGhvbGVJbmRleCApO1xuXHRcdFx0XHRcdFx0XHR0bXBIb2xlMiA9IGhvbGUuc2xpY2UoIDAsIGhvbGVJbmRleCsxICk7XG5cblx0XHRcdFx0XHRcdFx0c2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xuXG5cdFx0XHRcdFx0XHRcdG1pblNoYXBlSW5kZXggPSBzaGFwZUluZGV4O1xuXG5cdFx0XHRcdFx0XHRcdC8vIERlYnVnIG9ubHksIHRvIHNob3cgdGhlIHNlbGVjdGVkIGN1dHNcblx0XHRcdFx0XHRcdFx0Ly8gZ2xvYl9DdXRMaW5lcy5wdXNoKCBbIHNoYXBlUHQsIGhvbGVQdCBdICk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGhvbGVJbmRleCA+PSAwIClcdGJyZWFrO1x0XHQvLyBob2xlLXZlcnRleCBmb3VuZFxuXG5cdFx0XHRcdFx0XHRmYWlsZWRDdXRzW2N1dEtleV0gPSB0cnVlO1x0XHRcdC8vIHJlbWVtYmVyIGZhaWx1cmVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2hhcGU7IFx0XHRcdC8qIHNoYXBlIHdpdGggbm8gaG9sZXMgKi9cblx0XHR9XG5cblxuXHRcdHZhciBpLCBpbCwgZiwgZmFjZSxcblx0XHRcdGtleSwgaW5kZXgsXG5cdFx0XHRhbGxQb2ludHNNYXAgPSB7fTtcblxuXHRcdC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cblxuXHRcdHZhciBhbGxwb2ludHMgPSBjb250b3VyLmNvbmNhdCgpO1xuXG5cdFx0Zm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYWxscG9pbnRzLCBob2xlc1toXSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9jb25zb2xlLmxvZyggXCJhbGxwb2ludHNcIixhbGxwb2ludHMsIGFsbHBvaW50cy5sZW5ndGggKTtcblxuXHRcdC8vIHByZXBhcmUgYWxsIHBvaW50cyBtYXBcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFsbHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0a2V5ID0gYWxscG9pbnRzWyBpIF0ueCArIFwiOlwiICsgYWxscG9pbnRzWyBpIF0ueTtcblxuXHRcdFx0aWYgKCBhbGxQb2ludHNNYXBbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5sb2coIFwiRHVwbGljYXRlIHBvaW50XCIsIGtleSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFsbFBvaW50c01hcFsga2V5IF0gPSBpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmVtb3ZlIGhvbGVzIGJ5IGN1dHRpbmcgcGF0aHMgdG8gaG9sZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBzaGFwZVxuXHRcdHZhciBzaGFwZVdpdGhvdXRIb2xlcyA9IHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApO1xuXG5cdFx0dmFyIHRyaWFuZ2xlcyA9IFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZSggc2hhcGVXaXRob3V0SG9sZXMsIGZhbHNlICk7IC8vIFRydWUgcmV0dXJucyBpbmRpY2VzIGZvciBwb2ludHMgb2Ygc3Bvb2xlZCBzaGFwZVxuXHRcdC8vY29uc29sZS5sb2coIFwidHJpYW5nbGVzXCIsdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoICk7XG5cblx0XHQvLyBjaGVjayBhbGwgZmFjZSB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0cmlhbmdsZXNbIGkgXTtcblxuXHRcdFx0Zm9yICggZiA9IDA7IGYgPCAzOyBmICsrICkge1xuXG5cdFx0XHRcdGtleSA9IGZhY2VbIGYgXS54ICsgXCI6XCIgKyBmYWNlWyBmIF0ueTtcblxuXHRcdFx0XHRpbmRleCA9IGFsbFBvaW50c01hcFsga2V5IF07XG5cblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0ZmFjZVsgZiBdID0gaW5kZXg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJpYW5nbGVzLmNvbmNhdCgpO1xuXG5cdH0sXG5cblx0aXNDbG9ja1dpc2U6IGZ1bmN0aW9uICggcHRzICkge1xuXG5cdFx0cmV0dXJuIFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKCBwdHMgKSA8IDA7XG5cblx0fSxcblxuXHQvLyBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cblx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuXG5cdC8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xuXG5cdGIycDA6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuXHRcdHZhciBrID0gMSAtIHQ7XG5cdFx0cmV0dXJuIGsgKiBrICogcDtcblxuXHR9LFxuXG5cdGIycDE6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuXHRcdHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XG5cblx0fSxcblxuXHRiMnAyOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cblx0XHRyZXR1cm4gdCAqIHQgKiBwO1xuXG5cdH0sXG5cblx0YjI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcblxuXHRcdHJldHVybiB0aGlzLmIycDAoIHQsIHAwICkgKyB0aGlzLmIycDEoIHQsIHAxICkgKyB0aGlzLmIycDIoIHQsIHAyICk7XG5cblx0fSxcblxuXHQvLyBDdWJpYyBCZXppZXIgRnVuY3Rpb25zXG5cblx0YjNwMDogZnVuY3Rpb24gKCB0LCBwICkge1xuXG5cdFx0dmFyIGsgPSAxIC0gdDtcblx0XHRyZXR1cm4gayAqIGsgKiBrICogcDtcblxuXHR9LFxuXG5cdGIzcDE6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuXHRcdHZhciBrID0gMSAtIHQ7XG5cdFx0cmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xuXG5cdH0sXG5cblx0YjNwMjogZnVuY3Rpb24gKCB0LCBwICkge1xuXG5cdFx0dmFyIGsgPSAxIC0gdDtcblx0XHRyZXR1cm4gMyAqIGsgKiB0ICogdCAqIHA7XG5cblx0fSxcblxuXHRiM3AzOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcblxuXHR9LFxuXG5cdGIzOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYjNwMCggdCwgcDAgKSArIHRoaXMuYjNwMSggdCwgcDEgKSArIHRoaXMuYjNwMiggdCwgcDIgKSArICB0aGlzLmIzcDMoIHQsIHAzICk7XG5cblx0fVxuXG59O1xuXG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdExpbmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuTGluZUN1cnZlID0gZnVuY3Rpb24gKCB2MSwgdjIgKSB7XG5cblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cbn07XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHR2YXIgcG9pbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKHRoaXMudjEpO1xuXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xuXG5cdHJldHVybiBwb2ludDtcblxufTtcblxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcblxuXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdSApO1xuXG59O1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuXHR2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIodGhpcy52MSk7XG5cblx0cmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0UXVhZHJhdGljIEJlemllciBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xuXG5cdHRoaXMudjAgPSB2MDtcblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cbn07XG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHR2ZWN0b3IueCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG5cdHZlY3Rvci55ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcblxuXHRyZXR1cm4gdmVjdG9yO1xuXG59O1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cblx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0dmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XG5cdHZlY3Rvci55ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xuXG5cdC8vIHJldHVybnMgdW5pdCB2ZWN0b3JcblxuXHRyZXR1cm4gdmVjdG9yLm5vcm1hbGl6ZSgpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q3ViaWMgQmV6aWVyIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xuXG5cdHRoaXMudjAgPSB2MDtcblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cdHRoaXMudjMgPSB2MztcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIHR4LCB0eTtcblxuXHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcblx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG5cdHZhciB0eCwgdHk7XG5cblx0dHggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xuXHR0eSA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cblx0dmFyIHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XG5cdHRhbmdlbnQubm9ybWFsaXplKCk7XG5cblx0cmV0dXJuIHRhbmdlbnQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvU3BsaW5lQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0U3BsaW5lIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlNwbGluZUN1cnZlID0gZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcblxuXHR0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cbn07XG5cblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHR2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cdHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG5cdHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdXG5cdHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF1cblx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLTEgOiBpbnRQb2ludCArIDEgXVxuXHR2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtMSA6IGludFBvaW50ICsgMiBdXG5cblx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0dmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApO1xuXHR2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG5cblx0cmV0dXJuIHZlY3RvcjtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9FbGxpcHNlQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0RWxsaXBzZSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5FbGxpcHNlQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuXHR0aGlzLmFYID0gYVg7XG5cdHRoaXMuYVkgPSBhWTtcblxuXHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xuXHR0aGlzLnlSYWRpdXMgPSB5UmFkaXVzO1xuXG5cdHRoaXMuYVN0YXJ0QW5nbGUgPSBhU3RhcnRBbmdsZTtcblx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XG5cblx0dGhpcy5hQ2xvY2t3aXNlID0gYUNsb2Nrd2lzZTtcblxufTtcblxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG5cdHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xuXG5cdGlmICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IE1hdGguUEkgKiAyO1xuXHRpZiAoIGRlbHRhQW5nbGUgPiBNYXRoLlBJICogMiApIGRlbHRhQW5nbGUgLT0gTWF0aC5QSSAqIDI7XG5cblx0dmFyIGFuZ2xlO1xuXG5cdGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICkge1xuXG5cdFx0YW5nbGUgPSB0aGlzLmFFbmRBbmdsZSArICggMSAtIHQgKSAqICggTWF0aC5QSSAqIDIgLSBkZWx0YUFuZ2xlICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG5cdH1cblx0XG5cdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHZlY3Rvci54ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuXHR2ZWN0b3IueSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRyZXR1cm4gdmVjdG9yO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0FyY0N1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEFyYyBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5BcmNDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFRIUkVFLkVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcbn07XG5cblRIUkVFLkFyY0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdExpbmUzRFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5MaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG5cdGZ1bmN0aW9uICggdjEsIHYyICkge1xuXG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0dmVjdG9yLnN1YlZlY3RvcnMoIHRoaXMudjIsIHRoaXMudjEgKTsgLy8gZGlmZlxuXHRcdHZlY3Rvci5tdWx0aXBseVNjYWxhciggdCApO1xuXHRcdHZlY3Rvci5hZGQoIHRoaXMudjEgKTtcblxuXHRcdHJldHVybiB2ZWN0b3I7XG5cblx0fVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuXHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XG5cblx0XHR0aGlzLnYwID0gdjA7XG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0dmVjdG9yLnggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xuXHRcdHZlY3Rvci55ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcblx0XHR2ZWN0b3IueiA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56ICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yO1xuXG5cdH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRDdWJpYyBCZXppZXIgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXHRcdHRoaXMudjMgPSB2MztcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0dmVjdG9yLnggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICk7XG5cdFx0dmVjdG9yLnkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG5cdFx0dmVjdG9yLnogPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiwgdGhpcy52My56ICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yO1xuXG5cdH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0U3BsaW5lIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuVEhSRUUuU3BsaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG5cdGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8pIHtcblxuXHRcdHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxuXHR9LFxuXG5cdGZ1bmN0aW9uICggdCApIHtcblxuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHR2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdFx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0XHR2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuXHRcdHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xuXHRcdHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XG5cdFx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG5cdFx0dmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKTtcblx0XHR2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG5cdFx0dmVjdG9yLnogPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApO1xuXG5cdFx0cmV0dXJuIHZlY3RvcjtcblxuXHR9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2xvc2VkU3BsaW5lQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdENsb3NlZCBTcGxpbmUgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5USFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0ZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLykge1xuXG5cdFx0dGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xuXG5cdH0sXG5cblx0ZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdHZhciBwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDAgKSAqIHQ7IC8vIFRoaXMgbmVlZHMgdG8gYmUgZnJvbSAwLWxlbmd0aCArMVxuXG5cdFx0dmFyIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0XHR2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuXHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gcG9pbnRzLmxlbmd0aCApICsgMSApICogcG9pbnRzLmxlbmd0aDtcblxuXHRcdHZhciBwb2ludDAgPSBwb2ludHNbICggaW50UG9pbnQgLSAxICkgJSBwb2ludHMubGVuZ3RoIF07XG5cdFx0dmFyIHBvaW50MSA9IHBvaW50c1sgKCBpbnRQb2ludCAgICAgKSAlIHBvaW50cy5sZW5ndGggXTtcblx0XHR2YXIgcG9pbnQyID0gcG9pbnRzWyAoIGludFBvaW50ICsgMSApICUgcG9pbnRzLmxlbmd0aCBdO1xuXHRcdHZhciBwb2ludDMgPSBwb2ludHNbICggaW50UG9pbnQgKyAyICkgJSBwb2ludHMubGVuZ3RoIF07XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHZlY3Rvci54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKTtcblx0XHR2ZWN0b3IueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICk7XG5cdFx0dmVjdG9yLnogPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnosIHBvaW50MS56LCBwb2ludDIueiwgcG9pbnQzLnosIHdlaWdodCApO1xuXG5cdFx0cmV0dXJuIHZlY3RvcjtcblxuXHR9XG5cbik7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vQW5pbWF0aW9uSGFuZGxlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKi9cblxuVEhSRUUuQW5pbWF0aW9uSGFuZGxlciA9IHtcblxuXHRMSU5FQVI6IDAsXG5cdENBVE1VTExST006IDEsXG5cdENBVE1VTExST01fRk9SV0FSRDogMixcblxuXHQvL1xuXG5cdGFkZDogZnVuY3Rpb24gKCkgeyBjb25zb2xlLndhcm4oICdUSFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuJyApOyB9LFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgY29uc29sZS53YXJuKCAnVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLicgKTsgfSxcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7IGNvbnNvbGUud2FybiggJ1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIucmVtb3ZlKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4nICk7IH0sXG5cblx0Ly9cblxuXHRhbmltYXRpb25zOiBbXSxcblxuXHRpbml0OiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHRpZiAoIGRhdGEuaW5pdGlhbGl6ZWQgPT09IHRydWUgKSByZXR1cm47XG5cblx0XHQvLyBsb29wIHRocm91Z2ggYWxsIGtleXNcblxuXHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCArKyApIHtcblxuXHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHQvLyByZW1vdmUgbWludXMgdGltZXNcblxuXHRcdFx0XHRpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPCAwICkge1xuXG5cdFx0XHRcdFx0IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgcXVhdGVybmlvbnNcblxuXHRcdFx0XHRpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdCAgISAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCBpbnN0YW5jZW9mIFRIUkVFLlF1YXRlcm5pb24gKSApIHtcblxuXHRcdFx0XHRcdHZhciBxdWF0ID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90O1xuXHRcdFx0XHRcdGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuZnJvbUFycmF5KCBxdWF0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHByZXBhcmUgbW9ycGggdGFyZ2V0IGtleXNcblxuXHRcdFx0aWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoICYmIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIGdldCBhbGwgdXNlZFxuXG5cdFx0XHRcdHZhciB1c2VkTW9ycGhUYXJnZXRzID0ge307XG5cblx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBtb3JwaFRhcmdldE5hbWUgPSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNbIG0gXTtcblx0XHRcdFx0XHRcdHVzZWRNb3JwaFRhcmdldHNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gLSAxO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLnVzZWRNb3JwaFRhcmdldHMgPSB1c2VkTW9ycGhUYXJnZXRzO1xuXG5cblx0XHRcdFx0Ly8gc2V0IGFsbCB1c2VkIG9uIGFsbCBmcmFtZXNcblxuXHRcdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZmx1ZW5jZXMgPSB7fTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gdXNlZE1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwOyBtIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdID09PSBtb3JwaFRhcmdldE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbmZsdWVuY2VzWyBtb3JwaFRhcmdldE5hbWUgXSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXNbIG0gXTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBtID09PSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0XHRcdGluZmx1ZW5jZXNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gMDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzSW5mbHVlbmNlcyA9IGluZmx1ZW5jZXM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gcmVtb3ZlIGFsbCBrZXlzIHRoYXQgYXJlIG9uIHRoZSBzYW1lIHRpbWVcblxuXHRcdFx0Zm9yICggdmFyIGsgPSAxOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHRpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPT09IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayAtIDEgXS50aW1lICkge1xuXG5cdFx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLnNwbGljZSggaywgMSApO1xuXHRcdFx0XHRcdGsgLS07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gc2V0IGluZGV4XG5cblx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0uaW5kZXggPSBrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRkYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICggcm9vdCApIHtcblxuXHRcdHZhciBwYXJzZVJlY3Vyc2VIaWVyYXJjaHkgPSBmdW5jdGlvbiAoIHJvb3QsIGhpZXJhcmNoeSApIHtcblxuXHRcdFx0aGllcmFyY2h5LnB1c2goIHJvb3QgKTtcblxuXHRcdFx0Zm9yICggdmFyIGMgPSAwOyBjIDwgcm9vdC5jaGlsZHJlbi5sZW5ndGg7IGMgKysgKVxuXHRcdFx0XHRwYXJzZVJlY3Vyc2VIaWVyYXJjaHkoIHJvb3QuY2hpbGRyZW5bIGMgXSwgaGllcmFyY2h5ICk7XG5cblx0XHR9O1xuXG5cdFx0Ly8gc2V0dXAgaGllcmFyY2h5XG5cblx0XHR2YXIgaGllcmFyY2h5ID0gW107XG5cblx0XHRpZiAoIHJvb3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCApIHtcblxuXHRcdFx0Zm9yICggdmFyIGIgPSAwOyBiIDwgcm9vdC5za2VsZXRvbi5ib25lcy5sZW5ndGg7IGIgKysgKSB7XG5cblx0XHRcdFx0aGllcmFyY2h5LnB1c2goIHJvb3Quc2tlbGV0b24uYm9uZXNbIGIgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRwYXJzZVJlY3Vyc2VIaWVyYXJjaHkoIHJvb3QsIGhpZXJhcmNoeSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhpZXJhcmNoeTtcblxuXHR9LFxuXG5cdHBsYXk6IGZ1bmN0aW9uICggYW5pbWF0aW9uICkge1xuXG5cdFx0aWYgKCB0aGlzLmFuaW1hdGlvbnMuaW5kZXhPZiggYW5pbWF0aW9uICkgPT09IC0gMSApIHtcblxuXHRcdFx0dGhpcy5hbmltYXRpb25zLnB1c2goIGFuaW1hdGlvbiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24gKCBhbmltYXRpb24gKSB7XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLmFuaW1hdGlvbnMuaW5kZXhPZiggYW5pbWF0aW9uICk7XG5cblx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uICggZGVsdGFUaW1lTVMgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmFuaW1hdGlvbnNbIGkgXS5yZXNldEJsZW5kV2VpZ2h0cyggKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuYW5pbWF0aW9uc1sgaSBdLnVwZGF0ZSggZGVsdGFUaW1lTVMgKTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkFuaW1hdGlvbiA9IGZ1bmN0aW9uICggcm9vdCwgZGF0YSApIHtcblxuXHR0aGlzLnJvb3QgPSByb290O1xuXHR0aGlzLmRhdGEgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLmluaXQoIGRhdGEgKTtcblx0dGhpcy5oaWVyYXJjaHkgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKCByb290ICk7XG5cblx0dGhpcy5jdXJyZW50VGltZSA9IDA7XG5cdHRoaXMudGltZVNjYWxlID0gMTtcblxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXHR0aGlzLmxvb3AgPSB0cnVlO1xuXHR0aGlzLndlaWdodCA9IDA7XG5cblx0dGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuTElORUFSO1xuXG59O1xuXG5cblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUua2V5VHlwZXMgPSBbIFwicG9zXCIsIFwicm90XCIsIFwic2NsXCIgXTtcblxuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoIHN0YXJ0VGltZSwgd2VpZ2h0ICkge1xuXG5cdHRoaXMuY3VycmVudFRpbWUgPSBzdGFydFRpbWUgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZSA6IDA7XG5cdHRoaXMud2VpZ2h0ID0gd2VpZ2h0ICE9PSB1bmRlZmluZWQgPyB3ZWlnaHQ6IDE7XG5cblx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG5cdHRoaXMucmVzZXQoKTtcblxuXHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBsYXkoIHRoaXMgKTtcblxufTtcblxuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcblxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG5cdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuc3RvcCggdGhpcyApO1xuXG59O1xuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG5cdGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuXG5cdFx0b2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdFx0aWYgKCBvYmplY3QuYW5pbWF0aW9uQ2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlID0ge1xuXHRcdFx0XHRhbmltYXRpb25zOiB7fSxcblx0XHRcdFx0YmxlbmRpbmc6IHtcblx0XHRcdFx0XHRwb3NpdGlvbldlaWdodDogMC4wLFxuXHRcdFx0XHRcdHF1YXRlcm5pb25XZWlnaHQ6IDAuMCxcblx0XHRcdFx0XHRzY2FsZVdlaWdodDogMC4wXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYW5pbWF0aW9uc1t0aGlzLmRhdGEubmFtZV0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnNbdGhpcy5kYXRhLm5hbWVdID0ge307XG5cdFx0XHRvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYW5pbWF0aW9uc1t0aGlzLmRhdGEubmFtZV0ucHJldktleSA9IHsgcG9zOiAwLCByb3Q6IDAsIHNjbDogMCB9O1xuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnNbdGhpcy5kYXRhLm5hbWVdLm5leHRLZXkgPSB7IHBvczogMCwgcm90OiAwLCBzY2w6IDAgfTtcblx0XHRcdG9iamVjdC5hbmltYXRpb25DYWNoZS5hbmltYXRpb25zW3RoaXMuZGF0YS5uYW1lXS5vcmlnaW5hbE1hdHJpeCA9IG9iamVjdC5tYXRyaXg7XG5cblx0XHR9XG5cblx0XHR2YXIgYW5pbWF0aW9uQ2FjaGUgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYW5pbWF0aW9uc1t0aGlzLmRhdGEubmFtZV07XG5cblx0XHQvLyBHZXQga2V5cyB0byBtYXRjaCBvdXIgY3VycmVudCB0aW1lXG5cblx0XHRmb3IgKCB2YXIgdCA9IDA7IHQgPCAzOyB0ICsrICkge1xuXG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMua2V5VHlwZXNbIHQgXTtcblxuXHRcdFx0dmFyIHByZXZLZXkgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuXHRcdFx0dmFyIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCAxICk7XG5cblx0XHRcdHdoaWxlICggbmV4dEtleS50aW1lIDwgdGhpcy5jdXJyZW50VGltZSAmJiBuZXh0S2V5LmluZGV4ID4gcHJldktleS5pbmRleCApIHtcblxuXHRcdFx0XHRwcmV2S2V5ID0gbmV4dEtleTtcblx0XHRcdFx0bmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIG5leHRLZXkuaW5kZXggKyAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdID0gcHJldktleTtcblx0XHRcdGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXSA9IG5leHRLZXk7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnJlc2V0QmxlbmRXZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuXG5cdGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuXG5cdFx0aWYgKCBvYmplY3QuYW5pbWF0aW9uQ2FjaGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLmJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ID0gMC4wO1xuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLmJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgPSAwLjA7XG5cdFx0XHRvYmplY3QuYW5pbWF0aW9uQ2FjaGUuYmxlbmRpbmcuc2NhbGVXZWlnaHQgPSAwLjA7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IChmdW5jdGlvbigpe1xuXG5cdHZhciBwb2ludHMgPSBbXTtcblx0dmFyIHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBuZXdWZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgbmV3UXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0Ly8gQ2F0bXVsbC1Sb20gc3BsaW5lXG5cblx0dmFyIGludGVycG9sYXRlQ2F0bXVsbFJvbSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzY2FsZSApIHtcblxuXHRcdHZhciBjID0gW10sIHYzID0gW10sXG5cdFx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3Myxcblx0XHRwYSwgcGIsIHBjLCBwZDtcblxuXHRcdHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogc2NhbGU7XG5cdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuXHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cblx0XHRjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xuXHRcdGNbIDEgXSA9IGludFBvaW50O1xuXHRcdGNbIDIgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMTtcblx0XHRjWyAzIF0gPSBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gaW50UG9pbnQgOiBpbnRQb2ludCArIDI7XG5cblx0XHRwYSA9IHBvaW50c1sgY1sgMCBdIF07XG5cdFx0cGIgPSBwb2ludHNbIGNbIDEgXSBdO1xuXHRcdHBjID0gcG9pbnRzWyBjWyAyIF0gXTtcblx0XHRwZCA9IHBvaW50c1sgY1sgMyBdIF07XG5cblx0XHR3MiA9IHdlaWdodCAqIHdlaWdodDtcblx0XHR3MyA9IHdlaWdodCAqIHcyO1xuXG5cdFx0djNbIDAgXSA9IGludGVycG9sYXRlKCBwYVsgMCBdLCBwYlsgMCBdLCBwY1sgMCBdLCBwZFsgMCBdLCB3ZWlnaHQsIHcyLCB3MyApO1xuXHRcdHYzWyAxIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDEgXSwgcGJbIDEgXSwgcGNbIDEgXSwgcGRbIDEgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcblx0XHR2M1sgMiBdID0gaW50ZXJwb2xhdGUoIHBhWyAyIF0sIHBiWyAyIF0sIHBjWyAyIF0sIHBkWyAyIF0sIHdlaWdodCwgdzIsIHczICk7XG5cblx0XHRyZXR1cm4gdjM7XG5cblx0fTtcblxuXHR2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XG5cblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcblx0XHRcdHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cblx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuXHR9O1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHR0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhICogdGhpcy50aW1lU2NhbGU7XG5cblx0XHRpZiAoIHRoaXMud2VpZ2h0ID09PSAwIClcblx0XHRcdHJldHVybjtcblxuXHRcdC8vXG5cblx0XHR2YXIgZHVyYXRpb24gPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRUaW1lID4gZHVyYXRpb24gfHwgdGhpcy5jdXJyZW50VGltZSA8IDAgKSB7XG5cblx0XHRcdGlmICggdGhpcy5sb29wICkge1xuXG5cdFx0XHRcdHRoaXMuY3VycmVudFRpbWUgJT0gZHVyYXRpb247XG5cblx0XHRcdFx0aWYgKCB0aGlzLmN1cnJlbnRUaW1lIDwgMCApXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50VGltZSArPSBkdXJhdGlvbjtcblxuXHRcdFx0XHR0aGlzLnJlc2V0KCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5zdG9wKCk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcblx0XHRcdHZhciBhbmltYXRpb25DYWNoZSA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5hbmltYXRpb25zW3RoaXMuZGF0YS5uYW1lXTtcblx0XHRcdHZhciBibGVuZGluZyA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5ibGVuZGluZztcblxuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIHBvcy9yb3Qvc2NsXG5cblx0XHRcdGZvciAoIHZhciB0ID0gMDsgdCA8IDM7IHQgKysgKSB7XG5cblx0XHRcdFx0Ly8gZ2V0IGtleXNcblxuXHRcdFx0XHR2YXIgdHlwZSAgICA9IHRoaXMua2V5VHlwZXNbIHQgXTtcblx0XHRcdFx0dmFyIHByZXZLZXkgPSBhbmltYXRpb25DYWNoZS5wcmV2S2V5WyB0eXBlIF07XG5cdFx0XHRcdHZhciBuZXh0S2V5ID0gYW5pbWF0aW9uQ2FjaGUubmV4dEtleVsgdHlwZSBdO1xuXG5cdFx0XHRcdGlmICggKCB0aGlzLnRpbWVTY2FsZSA+IDAgJiYgbmV4dEtleS50aW1lIDw9IHRoaXMuY3VycmVudFRpbWUgKSB8fFxuXHRcdFx0XHRcdCggdGhpcy50aW1lU2NhbGUgPCAwICYmIHByZXZLZXkudGltZSA+PSB0aGlzLmN1cnJlbnRUaW1lICkgKSB7XG5cblx0XHRcdFx0XHRwcmV2S2V5ID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcblx0XHRcdFx0XHRuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgMSApO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRwcmV2S2V5ID0gbmV4dEtleTtcblx0XHRcdFx0XHRcdG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdID0gcHJldktleTtcblx0XHRcdFx0XHRhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF0gPSBuZXh0S2V5O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR2YXIgc2NhbGUgPSAoIHRoaXMuY3VycmVudFRpbWUgLSBwcmV2S2V5LnRpbWUgKSAvICggbmV4dEtleS50aW1lIC0gcHJldktleS50aW1lICk7XG5cblx0XHRcdFx0dmFyIHByZXZYWVogPSBwcmV2S2V5WyB0eXBlIF07XG5cdFx0XHRcdHZhciBuZXh0WFlaID0gbmV4dEtleVsgdHlwZSBdO1xuXG5cdFx0XHRcdGlmICggc2NhbGUgPCAwICkgc2NhbGUgPSAwO1xuXHRcdFx0XHRpZiAoIHNjYWxlID4gMSApIHNjYWxlID0gMTtcblxuXHRcdFx0XHQvLyBpbnRlcnBvbGF0ZVxuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJwb3NcIiApIHtcblxuXHRcdFx0XHRcdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5MSU5FQVIgKSB7XG5cblx0XHRcdFx0XHRcdG5ld1ZlY3Rvci54ID0gcHJldlhZWlsgMCBdICsgKCBuZXh0WFlaWyAwIF0gLSBwcmV2WFlaWyAwIF0gKSAqIHNjYWxlO1xuXHRcdFx0XHRcdFx0bmV3VmVjdG9yLnkgPSBwcmV2WFlaWyAxIF0gKyAoIG5leHRYWVpbIDEgXSAtIHByZXZYWVpbIDEgXSApICogc2NhbGU7XG5cdFx0XHRcdFx0XHRuZXdWZWN0b3IueiA9IHByZXZYWVpbIDIgXSArICggbmV4dFhZWlsgMiBdIC0gcHJldlhZWlsgMiBdICkgKiBzY2FsZTtcblxuXHRcdFx0XHRcdFx0Ly8gYmxlbmRcblx0XHRcdFx0XHRcdHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5wb3NpdGlvbldlaWdodCApO1xuXHRcdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLmxlcnAoIG5ld1ZlY3RvciwgcHJvcG9ydGlvbmFsV2VpZ2h0ICk7XG5cdFx0XHRcdFx0XHRibGVuZGluZy5wb3NpdGlvbldlaWdodCArPSB0aGlzLndlaWdodDtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG5cdFx0XHRcdFx0XHRwb2ludHNbIDAgXSA9IHRoaXMuZ2V0UHJldktleVdpdGgoIFwicG9zXCIsIGgsIHByZXZLZXkuaW5kZXggLSAxIClbIFwicG9zXCIgXTtcblx0XHRcdFx0XHRcdHBvaW50c1sgMSBdID0gcHJldlhZWjtcblx0XHRcdFx0XHRcdHBvaW50c1sgMiBdID0gbmV4dFhZWjtcblx0XHRcdFx0XHRcdHBvaW50c1sgMyBdID0gdGhpcy5nZXROZXh0S2V5V2l0aCggXCJwb3NcIiwgaCwgbmV4dEtleS5pbmRleCArIDEgKVsgXCJwb3NcIiBdO1xuXG5cdFx0XHRcdFx0XHRzY2FsZSA9IHNjYWxlICogMC4zMyArIDAuMzM7XG5cblx0XHRcdFx0XHRcdHZhciBjdXJyZW50UG9pbnQgPSBpbnRlcnBvbGF0ZUNhdG11bGxSb20oIHBvaW50cywgc2NhbGUgKTtcblx0XHRcdFx0XHRcdHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5wb3NpdGlvbldlaWdodCApO1xuXHRcdFx0XHRcdFx0YmxlbmRpbmcucG9zaXRpb25XZWlnaHQgKz0gdGhpcy53ZWlnaHQ7XG5cblx0XHRcdFx0XHRcdC8vIGJsZW5kXG5cblx0XHRcdFx0XHRcdHZhciB2ZWN0b3IgPSBvYmplY3QucG9zaXRpb247XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHZlY3Rvci54ID0gdmVjdG9yLnggKyAoIGN1cnJlbnRQb2ludFsgMCBdIC0gdmVjdG9yLnggKSAqIHByb3BvcnRpb25hbFdlaWdodDtcblx0XHRcdFx0XHRcdHZlY3Rvci55ID0gdmVjdG9yLnkgKyAoIGN1cnJlbnRQb2ludFsgMSBdIC0gdmVjdG9yLnkgKSAqIHByb3BvcnRpb25hbFdlaWdodDtcblx0XHRcdFx0XHRcdHZlY3Rvci56ID0gdmVjdG9yLnogKyAoIGN1cnJlbnRQb2ludFsgMiBdIC0gdmVjdG9yLnogKSAqIHByb3BvcnRpb25hbFdlaWdodDtcblxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZm9yd2FyZFBvaW50ID0gaW50ZXJwb2xhdGVDYXRtdWxsUm9tKCBwb2ludHMsIHNjYWxlICogMS4wMSApO1xuXG5cdFx0XHRcdFx0XHRcdHRhcmdldC5zZXQoIGZvcndhcmRQb2ludFsgMCBdLCBmb3J3YXJkUG9pbnRbIDEgXSwgZm9yd2FyZFBvaW50WyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0LnN1YiggdmVjdG9yICk7XG5cdFx0XHRcdFx0XHRcdHRhcmdldC55ID0gMDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Lm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoIHRhcmdldC54LCB0YXJnZXQueiApO1xuXHRcdFx0XHRcdFx0XHRvYmplY3Qucm90YXRpb24uc2V0KCAwLCBhbmdsZSwgMCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJyb3RcIiApIHtcblxuXHRcdFx0XHRcdFRIUkVFLlF1YXRlcm5pb24uc2xlcnAoIHByZXZYWVosIG5leHRYWVosIG5ld1F1YXQsIHNjYWxlICk7XG5cblx0XHRcdFx0XHQvLyBBdm9pZCBwYXlpbmcgdGhlIGNvc3Qgb2YgYW4gYWRkaXRpb25hbCBzbGVycCBpZiB3ZSBkb24ndCBoYXZlIHRvXG5cdFx0XHRcdFx0aWYgKCBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5jb3B5KG5ld1F1YXQpO1xuXHRcdFx0XHRcdFx0YmxlbmRpbmcucXVhdGVybmlvbldlaWdodCA9IHRoaXMud2VpZ2h0O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dmFyIHByb3BvcnRpb25hbFdlaWdodCA9IHRoaXMud2VpZ2h0IC8gKCB0aGlzLndlaWdodCArIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgKTtcblx0XHRcdFx0XHRcdFRIUkVFLlF1YXRlcm5pb24uc2xlcnAoIG9iamVjdC5xdWF0ZXJuaW9uLCBuZXdRdWF0LCBvYmplY3QucXVhdGVybmlvbiwgcHJvcG9ydGlvbmFsV2VpZ2h0ICk7XG5cdFx0XHRcdFx0XHRibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwic2NsXCIgKSB7XG5cblx0XHRcdFx0XHRuZXdWZWN0b3IueCA9IHByZXZYWVpbIDAgXSArICggbmV4dFhZWlsgMCBdIC0gcHJldlhZWlsgMCBdICkgKiBzY2FsZTtcblx0XHRcdFx0XHRuZXdWZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcblx0XHRcdFx0XHRuZXdWZWN0b3IueiA9IHByZXZYWVpbIDIgXSArICggbmV4dFhZWlsgMiBdIC0gcHJldlhZWlsgMiBdICkgKiBzY2FsZTtcblxuXHRcdFx0XHRcdHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5zY2FsZVdlaWdodCApO1xuXHRcdFx0XHRcdG9iamVjdC5zY2FsZS5sZXJwKCBuZXdWZWN0b3IsIHByb3BvcnRpb25hbFdlaWdodCApO1xuXHRcdFx0XHRcdGJsZW5kaW5nLnNjYWxlV2VpZ2h0ICs9IHRoaXMud2VpZ2h0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fTtcblxufSkoKTtcblxuXG5cblxuXG4vLyBHZXQgbmV4dCBrZXkgd2l0aFxuXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLmdldE5leHRLZXlXaXRoID0gZnVuY3Rpb24gKCB0eXBlLCBoLCBrZXkgKSB7XG5cblx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcblxuXHRpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxuXHRcdCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuXHRcdGtleSA9IGtleSA8IGtleXMubGVuZ3RoIC0gMSA/IGtleSA6IGtleXMubGVuZ3RoIC0gMTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0a2V5ID0ga2V5ICUga2V5cy5sZW5ndGg7XG5cblx0fVxuXG5cdGZvciAoIDsga2V5IDwga2V5cy5sZW5ndGg7IGtleSArKyApIHtcblxuXHRcdGlmICgga2V5c1sga2V5IF1bIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4ga2V5c1sga2V5IF07XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuXG59O1xuXG4vLyBHZXQgcHJldmlvdXMga2V5IHdpdGhcblxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5nZXRQcmV2S2V5V2l0aCA9IGZ1bmN0aW9uICggdHlwZSwgaCwga2V5ICkge1xuXG5cdHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XG5cblx0aWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcblx0XHR0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuXHRcdGtleSA9IGtleSA+IDAgPyBrZXkgOiAwO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRrZXkgPSBrZXkgPj0gMCA/IGtleSA6IGtleSArIGtleXMubGVuZ3RoO1xuXG5cdH1cblxuXG5cdGZvciAoIDsga2V5ID49IDA7IGtleSAtLSApIHtcblxuXHRcdGlmICgga2V5c1sga2V5IF1bIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4ga2V5c1sga2V5IF07XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sga2V5cy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vS2V5RnJhbWVBbmltYXRpb24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGtoYW5nIGR1b25nXG4gKiBAYXV0aG9yIGVyaWsga2l0c29uXG4gKi9cblxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24gPSBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0dGhpcy5yb290ID0gZGF0YS5ub2RlO1xuXHR0aGlzLmRhdGEgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLmluaXQoIGRhdGEgKTtcblx0dGhpcy5oaWVyYXJjaHkgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKCB0aGlzLnJvb3QgKTtcblx0dGhpcy5jdXJyZW50VGltZSA9IDA7XG5cdHRoaXMudGltZVNjYWxlID0gMC4wMDE7XG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cdHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXHR0aGlzLmxvb3AgPSB0cnVlO1xuXG5cdC8vIGluaXRpYWxpemUgdG8gZmlyc3Qga2V5ZnJhbWVzXG5cblx0Zm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLmtleXMsXG5cdFx0XHRzaWRzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVtoXS5zaWRzLFxuXHRcdFx0b2JqID0gdGhpcy5oaWVyYXJjaHlbaF07XG5cblx0XHRpZiAoIGtleXMubGVuZ3RoICYmIHNpZHMgKSB7XG5cblx0XHRcdGZvciAoIHZhciBzID0gMDsgcyA8IHNpZHMubGVuZ3RoOyBzICsrICkge1xuXG5cdFx0XHRcdHZhciBzaWQgPSBzaWRzWyBzIF0sXG5cdFx0XHRcdFx0bmV4dCA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHNpZCwgaCwgMCApO1xuXG5cdFx0XHRcdGlmICggbmV4dCApIHtcblxuXHRcdFx0XHRcdG5leHQuYXBwbHkoIHNpZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRvYmoubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5kYXRhLmhpZXJhcmNoeVtoXS5ub2RlLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0b2JqLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICggc3RhcnRUaW1lICkge1xuXG5cdHRoaXMuY3VycmVudFRpbWUgPSBzdGFydFRpbWUgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZSA6IDA7XG5cblx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSB7XG5cblx0XHR0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cblx0XHQvLyByZXNldCBrZXkgY2FjaGVcblxuXHRcdHZhciBoLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aCxcblx0XHRcdG9iamVjdCxcblx0XHRcdG5vZGU7XG5cblx0XHRmb3IgKCBoID0gMDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuXHRcdFx0bm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcblxuXHRcdFx0aWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bm9kZS5hbmltYXRpb25DYWNoZSA9IHt9O1xuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBudWxsO1xuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBudWxsO1xuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLm9yaWdpbmFsTWF0cml4ID0gb2JqZWN0Lm1hdHJpeDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0ua2V5cztcblxuXHRcdFx0aWYgKGtleXMubGVuZ3RoKSB7XG5cblx0XHRcdFx0bm9kZS5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0ga2V5c1sgMCBdO1xuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBrZXlzWyAxIF07XG5cblx0XHRcdFx0dGhpcy5zdGFydFRpbWUgPSBNYXRoLm1pbigga2V5c1swXS50aW1lLCB0aGlzLnN0YXJ0VGltZSApO1xuXHRcdFx0XHR0aGlzLmVuZFRpbWUgPSBNYXRoLm1heCgga2V5c1trZXlzLmxlbmd0aCAtIDFdLnRpbWUsIHRoaXMuZW5kVGltZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZSggMCApO1xuXG5cdH1cblxuXHR0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cblx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wbGF5KCB0aGlzICk7XG5cbn07XG5cblxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcblxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXHR0aGlzLmlzUGF1c2VkICA9IGZhbHNlO1xuXG5cdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuc3RvcCggdGhpcyApO1xuXG5cdC8vIHJlc2V0IEpJVCBtYXRyaXggYW5kIHJlbW92ZSBjYWNoZVxuXG5cdGZvciAoIHZhciBoID0gMDsgaCA8IHRoaXMuZGF0YS5oaWVyYXJjaHkubGVuZ3RoOyBoICsrICkge1xuXHRcdFxuXHRcdHZhciBvYmogPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuXHRcdHZhciBub2RlID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdO1xuXG5cdFx0aWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBvcmlnaW5hbCA9IG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg7XG5cblx0XHRcdG9yaWdpbmFsLmNvcHkoIG9iai5tYXRyaXggKTtcblx0XHRcdG9iai5tYXRyaXggPSBvcmlnaW5hbDtcblxuXHRcdFx0ZGVsZXRlIG5vZGUuYW5pbWF0aW9uQ2FjaGU7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5cbi8vIFVwZGF0ZVxuXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBkZWx0YSApIHtcblxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcblxuXHR0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhICogdGhpcy50aW1lU2NhbGU7XG5cblx0Ly9cblxuXHR2YXIgZHVyYXRpb24gPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG5cdGlmICggdGhpcy5sb29wID09PSB0cnVlICYmIHRoaXMuY3VycmVudFRpbWUgPiBkdXJhdGlvbiApIHtcblxuXHRcdHRoaXMuY3VycmVudFRpbWUgJT0gZHVyYXRpb247XG5cblx0fVxuXG5cdHRoaXMuY3VycmVudFRpbWUgPSBNYXRoLm1pbiggdGhpcy5jdXJyZW50VGltZSwgZHVyYXRpb24gKTtcblxuXHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHR2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcblx0XHR2YXIgbm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcblxuXHRcdHZhciBrZXlzID0gbm9kZS5rZXlzLFxuXHRcdFx0YW5pbWF0aW9uQ2FjaGUgPSBub2RlLmFuaW1hdGlvbkNhY2hlO1xuXG5cblx0XHRpZiAoIGtleXMubGVuZ3RoICkge1xuXG5cdFx0XHR2YXIgcHJldktleSA9IGFuaW1hdGlvbkNhY2hlLnByZXZLZXk7XG5cdFx0XHR2YXIgbmV4dEtleSA9IGFuaW1hdGlvbkNhY2hlLm5leHRLZXk7XG5cblx0XHRcdGlmICggbmV4dEtleS50aW1lIDw9IHRoaXMuY3VycmVudFRpbWUgKSB7XG5cblx0XHRcdFx0d2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG5cdFx0XHRcdFx0cHJldktleSA9IG5leHRLZXk7XG5cdFx0XHRcdFx0bmV4dEtleSA9IGtleXNbIHByZXZLZXkuaW5kZXggKyAxIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBwcmV2S2V5O1xuXHRcdFx0XHRhbmltYXRpb25DYWNoZS5uZXh0S2V5ID0gbmV4dEtleTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5leHRLZXkudGltZSA+PSB0aGlzLmN1cnJlbnRUaW1lICkge1xuXG5cdFx0XHRcdHByZXZLZXkuaW50ZXJwb2xhdGUoIG5leHRLZXksIHRoaXMuY3VycmVudFRpbWUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRwcmV2S2V5LmludGVycG9sYXRlKCBuZXh0S2V5LCBuZXh0S2V5LnRpbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ubm9kZS51cGRhdGVNYXRyaXgoKTtcblx0XHRcdG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cbi8vIEdldCBuZXh0IGtleSB3aXRoXG5cblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5nZXROZXh0S2V5V2l0aCA9IGZ1bmN0aW9uKCBzaWQsIGgsIGtleSApIHtcblxuXHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXHRrZXkgPSBrZXkgJSBrZXlzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGtleSA8IGtleXMubGVuZ3RoOyBrZXkgKysgKSB7XG5cblx0XHRpZiAoIGtleXNbIGtleSBdLmhhc1RhcmdldCggc2lkICkgKSB7XG5cblx0XHRcdHJldHVybiBrZXlzWyBrZXkgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGtleXNbIDAgXTtcblxufTtcblxuLy8gR2V0IHByZXZpb3VzIGtleSB3aXRoXG5cblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5nZXRQcmV2S2V5V2l0aCA9IGZ1bmN0aW9uKCBzaWQsIGgsIGtleSApIHtcblxuXHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXHRrZXkgPSBrZXkgPj0gMCA/IGtleSA6IGtleSArIGtleXMubGVuZ3RoO1xuXG5cdGZvciAoIDsga2V5ID49IDA7IGtleSAtLSApIHtcblxuXHRcdGlmICgga2V5c1sga2V5IF0uaGFzVGFyZ2V0KCBzaWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIGtleXNbIGtleSBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4ga2V5c1sga2V5cy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9hbmltYXRpb24vTW9ycGhBbmltYXRpb24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXG4gKi9cblxuVEhSRUUuTW9ycGhBbmltYXRpb24gPSBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cblx0dGhpcy5tZXNoID0gbWVzaDtcblx0dGhpcy5mcmFtZXMgPSBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7XG5cdHRoaXMuY3VycmVudFRpbWUgPSAwO1xuXHR0aGlzLmR1cmF0aW9uID0gMTAwMDtcblx0dGhpcy5sb29wID0gdHJ1ZTtcblxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG5cblx0cGxheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG5cdH0sXG5cblx0cGF1c2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0fSxcblxuXHR1cGRhdGU6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxhc3RGcmFtZSA9IDA7XG5cdFx0dmFyIGN1cnJlbnRGcmFtZSA9IDA7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkZWx0YSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGE7XG5cblx0XHRcdGlmICggdGhpcy5sb29wID09PSB0cnVlICYmIHRoaXMuY3VycmVudFRpbWUgPiB0aGlzLmR1cmF0aW9uICkge1xuXG5cdFx0XHRcdHRoaXMuY3VycmVudFRpbWUgJT0gdGhpcy5kdXJhdGlvbjtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmN1cnJlbnRUaW1lID0gTWF0aC5taW4oIHRoaXMuY3VycmVudFRpbWUsIHRoaXMuZHVyYXRpb24gKTtcblxuXHRcdFx0dmFyIGludGVycG9sYXRpb24gPSB0aGlzLmR1cmF0aW9uIC8gdGhpcy5mcmFtZXM7XG5cdFx0XHR2YXIgZnJhbWUgPSBNYXRoLmZsb29yKCB0aGlzLmN1cnJlbnRUaW1lIC8gaW50ZXJwb2xhdGlvbiApO1xuXG5cdFx0XHRpZiAoIGZyYW1lICE9IGN1cnJlbnRGcmFtZSApIHtcblxuXHRcdFx0XHR0aGlzLm1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBsYXN0RnJhbWUgXSA9IDA7XG5cdFx0XHRcdHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGN1cnJlbnRGcmFtZSBdID0gMTtcblx0XHRcdFx0dGhpcy5tZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgZnJhbWUgXSA9IDA7XG5cblx0XHRcdFx0bGFzdEZyYW1lID0gY3VycmVudEZyYW1lO1xuXHRcdFx0XHRjdXJyZW50RnJhbWUgPSBmcmFtZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBmcmFtZSBdID0gKCB0aGlzLmN1cnJlbnRUaW1lICUgaW50ZXJwb2xhdGlvbiApIC8gaW50ZXJwb2xhdGlvbjtcblx0XHRcdHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGxhc3RGcmFtZSBdID0gMSAtIHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGZyYW1lIF07XG5cblx0XHR9XG5cblx0fSApKClcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL0N1YmUuYXNcbiAqL1xuXG5USFJFRS5Cb3hHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQm94R2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHR3aWR0aDogd2lkdGgsXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0ZGVwdGg6IGRlcHRoLFxuXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdGRlcHRoU2VnbWVudHM6IGRlcHRoU2VnbWVudHNcblx0fTtcblxuXHR0aGlzLndpZHRoU2VnbWVudHMgPSB3aWR0aFNlZ21lbnRzIHx8IDE7XG5cdHRoaXMuaGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xuXHR0aGlzLmRlcHRoU2VnbWVudHMgPSBkZXB0aFNlZ21lbnRzIHx8IDE7XG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHR2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcblx0dmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblx0dmFyIGRlcHRoX2hhbGYgPSBkZXB0aCAvIDI7XG5cblx0YnVpbGRQbGFuZSggJ3onLCAneScsIC0gMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aF9oYWxmLCAwICk7IC8vIHB4XG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAgIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aF9oYWxmLCAxICk7IC8vIG54XG5cdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAgIDEsICAgMSwgd2lkdGgsIGRlcHRoLCBoZWlnaHRfaGFsZiwgMiApOyAvLyBweVxuXHRidWlsZFBsYW5lKCAneCcsICd6JywgICAxLCAtIDEsIHdpZHRoLCBkZXB0aCwgLSBoZWlnaHRfaGFsZiwgMyApOyAvLyBueVxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgICAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoX2hhbGYsIDQgKTsgLy8gcHpcblx0YnVpbGRQbGFuZSggJ3gnLCAneScsIC0gMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCAtIGRlcHRoX2hhbGYsIDUgKTsgLy8gbnpcblxuXHRmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdHZhciB3LCBpeCwgaXksXG5cdFx0Z3JpZFggPSBzY29wZS53aWR0aFNlZ21lbnRzLFxuXHRcdGdyaWRZID0gc2NvcGUuaGVpZ2h0U2VnbWVudHMsXG5cdFx0d2lkdGhfaGFsZiA9IHdpZHRoIC8gMixcblx0XHRoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXG5cdFx0b2Zmc2V0ID0gc2NvcGUudmVydGljZXMubGVuZ3RoO1xuXG5cdFx0aWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneCcgKSApIHtcblxuXHRcdFx0dyA9ICd6JztcblxuXHRcdH0gZWxzZSBpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd6JyApIHx8ICggdSA9PT0gJ3onICYmIHYgPT09ICd4JyApICkge1xuXG5cdFx0XHR3ID0gJ3knO1xuXHRcdFx0Z3JpZFkgPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xuXG5cdFx0fSBlbHNlIGlmICggKCB1ID09PSAneicgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3onICkgKSB7XG5cblx0XHRcdHcgPSAneCc7XG5cdFx0XHRncmlkWCA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XG5cblx0XHR9XG5cblx0XHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxLFxuXHRcdGdyaWRZMSA9IGdyaWRZICsgMSxcblx0XHRzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWCxcblx0XHRzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZLFxuXHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRub3JtYWxbIHcgXSA9IGRlcHRoID4gMCA/IDEgOiAtIDE7XG5cblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcblxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cblx0XHRcdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdHZlY3RvclsgdSBdID0gKCBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmICkgKiB1ZGlyO1xuXHRcdFx0XHR2ZWN0b3JbIHYgXSA9ICggaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmICkgKiB2ZGlyO1xuXHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoO1xuXG5cdFx0XHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIHZlY3RvciApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG5cdFx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG5cdFx0XHRcdHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcblx0XHRcdFx0dmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG5cdFx0XHRcdHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcblx0XHRcdFx0dmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gKCBpeSArIDEgKSAvIGdyaWRZICk7XG5cdFx0XHRcdHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gKCBpeSArIDEgKSAvIGdyaWRZICk7XG5cdFx0XHRcdHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xuXG5cdFx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhICsgb2Zmc2V0LCBiICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XG5cdFx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xuXHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcblx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cblx0XHRcdFx0ZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYiArIG9mZnNldCwgYyArIG9mZnNldCwgZCArIG9mZnNldCApO1xuXHRcdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcblx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxufTtcblxuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBodWdoZXNcbiAqL1xuXG5USFJFRS5DaXJjbGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcblx0c2VnbWVudHMgPSBzZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHNlZ21lbnRzICkgOiA4O1xuXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcblx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuXHR2YXIgaSwgdXZzID0gW10sXG5cdGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGNlbnRlclVWID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAuNSwgMC41ICk7XG5cblx0dGhpcy52ZXJ0aWNlcy5wdXNoKGNlbnRlcik7XG5cdHV2cy5wdXNoKCBjZW50ZXJVViApO1xuXG5cdGZvciAoIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgaSAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cblx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblx0XHR1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyByYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gcmFkaXVzICsgMSApIC8gMiApICk7XG5cblx0fVxuXG5cdHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuXHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBpLCBpICsgMSwgMCwgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuXHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBpIF0uY2xvbmUoKSwgdXZzWyBpICsgMSBdLmNsb25lKCksIGNlbnRlclVWLmNsb25lKCkgXSApO1xuXG5cdH1cblxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0N1YmVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuXG5USFJFRS5DdWJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5DdWJlR2VvbWV0cnkgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Cb3hHZW9tZXRyeS4nICk7XG5cdHJldHVybiBuZXcgVEhSRUUuQm94R2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApO1xuXG4gfTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQ3lsaW5kZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdDeWxpbmRlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZFxuXHR9O1xuXG5cdHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMjA7XG5cdHJhZGl1c0JvdHRvbSA9IHJhZGl1c0JvdHRvbSAhPT0gdW5kZWZpbmVkID8gcmFkaXVzQm90dG9tIDogMjA7XG5cdGhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogMTAwO1xuXG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0aGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xuXG5cdG9wZW5FbmRlZCA9IG9wZW5FbmRlZCAhPT0gdW5kZWZpbmVkID8gb3BlbkVuZGVkIDogZmFsc2U7XG5cblx0dmFyIGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xuXG5cdHZhciB4LCB5LCB2ZXJ0aWNlcyA9IFtdLCB1dnMgPSBbXTtcblxuXHRmb3IgKCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuXHRcdHZhciB1dnNSb3cgPSBbXTtcblxuXHRcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuXHRcdHZhciByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcblxuXHRcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHR2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICogTWF0aC5QSSAqIDIgKTtcblx0XHRcdHZlcnRleC55ID0gLSB2ICogaGVpZ2h0ICsgaGVpZ2h0SGFsZjtcblx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKiBNYXRoLlBJICogMiApO1xuXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG5cdFx0XHR2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcblx0XHRcdHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xuXG5cdFx0fVxuXG5cdFx0dmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcblx0XHR1dnMucHVzaCggdXZzUm93ICk7XG5cblx0fVxuXG5cdHZhciB0YW5UaGV0YSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG5cdHZhciBuYSwgbmI7XG5cblx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdGlmICggcmFkaXVzVG9wICE9PSAwICkge1xuXG5cdFx0XHRuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggXSBdLmNsb25lKCk7XG5cdFx0XHRuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4IF0gXS5jbG9uZSgpO1xuXHRcdFx0bmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdG5hLnNldFkoIE1hdGguc3FydCggbmEueCAqIG5hLnggKyBuYS56ICogbmEueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcblx0XHRuYi5zZXRZKCBNYXRoLnNxcnQoIG5iLnggKiBuYi54ICsgbmIueiAqIG5iLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XG5cblx0XHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0XHR2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xuXHRcdFx0dmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG5cdFx0XHR2YXIgdjQgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xuXG5cdFx0XHR2YXIgbjEgPSBuYS5jbG9uZSgpO1xuXHRcdFx0dmFyIG4yID0gbmEuY2xvbmUoKTtcblx0XHRcdHZhciBuMyA9IG5iLmNsb25lKCk7XG5cdFx0XHR2YXIgbjQgPSBuYi5jbG9uZSgpO1xuXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2MiA9IHV2c1sgeSArIDEgXVsgeCBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXYzID0gdXZzWyB5ICsgMSBdWyB4ICsgMSBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjQsIFsgbjEsIG4yLCBuNCBdICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2NCBdICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MiwgdjMsIHY0LCBbIG4yLmNsb25lKCksIG4zLCBuNC5jbG9uZSgpIF0gKSApO1xuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIHRvcCBjYXBcblxuXHRpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgJiYgcmFkaXVzVG9wID4gMCApIHtcblxuXHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIGhlaWdodEhhbGYsIDAgKSApO1xuXG5cdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIDAgXVsgeCBdO1xuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIDAgXVsgeCArIDEgXTtcblx0XHRcdHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcblxuXHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblx0XHRcdHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cdFx0XHR2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXG5cdFx0XHR2YXIgdXYxID0gdXZzWyAwIF1bIHggXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2MiA9IHV2c1sgMCBdWyB4ICsgMSBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAwICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBib3R0b20gY2FwXG5cblx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c0JvdHRvbSA+IDAgKSB7XG5cblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIGhlaWdodEhhbGYsIDAgKSApO1xuXG5cdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcblx0XHRcdHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcblxuXHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuXHRcdFx0dmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuXHRcdFx0dmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xuXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djIgPSB1dnNbIHkgXVsgeCBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAxICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG59XG5cblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0V4dHJ1ZGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnZW1lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xuICogIGFtb3VudDogPGludD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXG4gKlxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGlzIGJldmVsXG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcbiAqXG4gKiAgZXh0cnVkZVBhdGg6IDxUSFJFRS5DdXJ2ZVBhdGg+IC8vIDNkIHNwbGluZSBwYXRoIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmcuIChjcmVhdGVzIEZyYW1lcyBpZiAuZnJhbWVzIGFyZW4ndCBkZWZpbmVkKVxuICogIGZyYW1lczogPFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXM+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcbiAqXG4gKiAgbWF0ZXJpYWw6IDxpbnQ+IC8vIG1hdGVyaWFsIGluZGV4IGZvciBmcm9udCBhbmQgYmFjayBmYWNlc1xuICogIGV4dHJ1ZGVNYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGV4dHJ1c2lvbiBhbmQgYmV2ZWxlZCBmYWNlc1xuICogIHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG4gKlxuICogfVxuICoqL1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuXHRpZiAoIHR5cGVvZiggc2hhcGVzICkgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0c2hhcGVzID0gW107XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdFeHRydWRlR2VvbWV0cnknO1xuXG5cdHNoYXBlcyA9IHNoYXBlcyBpbnN0YW5jZW9mIEFycmF5ID8gc2hhcGVzIDogWyBzaGFwZXMgXTtcblxuXHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHQvLyBjYW4ndCByZWFsbHkgdXNlIGF1dG9tYXRpYyB2ZXJ0ZXggbm9ybWFsc1xuXHQvLyBhcyB0aGVuIGZyb250IGFuZCBiYWNrIHNpZGVzIGdldCBzbW9vdGhlZCB0b29cblx0Ly8gc2hvdWxkIGRvIHNlcGFyYXRlIHNtb290aGluZyBqdXN0IGZvciBzaWRlc1xuXG5cdC8vdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdC8vY29uc29sZS5sb2coIFwidG9va1wiLCAoIERhdGUubm93KCkgLSBzdGFydFRpbWUgKSApO1xuXG59O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cdHZhciBzbCA9IHNoYXBlcy5sZW5ndGg7XG5cblx0Zm9yICggdmFyIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG5cdFx0dmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcblx0fVxufTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XG5cblx0dmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcblxuXHR2YXIgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogNjsgLy8gMTBcblx0dmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjsgLy8gOFxuXHR2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcblxuXHR2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcblxuXHR2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cblx0dmFyIHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XG5cblx0dmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcblx0dmFyIGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcblxuXHR2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xuXHR2YXIgZXh0cnVkZU1hdGVyaWFsID0gb3B0aW9ucy5leHRydWRlTWF0ZXJpYWw7XG5cblx0Ly8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXG5cdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcjtcblxuXHR2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xuXHRpZiAoIGV4dHJ1ZGVQYXRoICkge1xuXG5cdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcblxuXHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuXHRcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cblxuXHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcblxuXHRcdC8vIFJldXNlIFROQiBmcm9tIFR1YmVHZW9tdHJ5IGZvciBub3cuXG5cdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cblxuXHRcdHNwbGluZVR1YmUgPSBvcHRpb25zLmZyYW1lcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mcmFtZXMgOiBuZXcgVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyhleHRydWRlUGF0aCwgc3RlcHMsIGZhbHNlKTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xuXG5cdFx0Ymlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cG9zaXRpb24yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR9XG5cblx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cblx0aWYgKCAhIGJldmVsRW5hYmxlZCApIHtcblxuXHRcdGJldmVsU2VnbWVudHMgPSAwO1xuXHRcdGJldmVsVGhpY2tuZXNzID0gMDtcblx0XHRiZXZlbFNpemUgPSAwO1xuXG5cdH1cblxuXHQvLyBWYXJpYWJsZXMgaW5pdGFsaXphdGlvblxuXG5cdHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcblx0dmFyIHNjb3BlID0gdGhpcztcblx0dmFyIGJldmVsUG9pbnRzID0gW107XG5cblx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG5cdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcblx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cblx0dmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApIDtcblxuXHRpZiAoIHJldmVyc2UgKSB7XG5cblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcblxuXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXG5cblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xuXG5cdFx0XHRcdGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldmVyc2UgPSBmYWxzZTsgLy8gSWYgdmVydGljZXMgYXJlIGluIG9yZGVyIG5vdywgd2Ugc2hvdWxkbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlbSBhZ2FpbiAoaG9wZWZ1bGx5KSFcblxuXHR9XG5cblxuXHR2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZS5VdGlscy50cmlhbmd1bGF0ZVNoYXBlICggdmVydGljZXMsIGhvbGVzICk7XG5cblx0LyogVmVydGljZXMgKi9cblxuXHR2YXIgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxuXG5cdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgIGggPCBobDsgaCArKyApIHtcblxuXHRcdGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xuXG5cdH1cblxuXG5cdGZ1bmN0aW9uIHNjYWxlUHQyICggcHQsIHZlYywgc2l6ZSApIHtcblxuXHRcdGlmICggISB2ZWMgKSBjb25zb2xlLmxvZyggXCJkaWVcIiApO1xuXG5cdFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xuXG5cdH1cblxuXHR2YXIgYiwgYnMsIHQsIHosXG5cdFx0dmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCxcblx0XHRmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoLFxuXHRcdGNvbnQsIGNsZW4gPSBjb250b3VyLmxlbmd0aDtcblxuXG5cdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXHR2YXIgUkFEX1RPX0RFR1JFRVMgPSAxODAgLyBNYXRoLlBJO1xuXG5cblx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xuXG5cdFx0dmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cdFx0XG5cdFx0Ly8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxuXHRcdC8vICAgc2hpZnRldCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcblx0XHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcblx0XHQvL1xuXHRcdC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXG5cdFx0Ly8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cblx0XHRcblx0XHR2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieSA9IDE7XHRcdC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcblxuXHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcblx0XHQvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxuXG5cdFx0dmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsIHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG5cdFx0dmFyIHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsIHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XG5cdFx0XG5cdFx0dmFyIHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcblx0XHRcblx0XHQvLyBjaGVjayBmb3IgY29saW5lYXIgZWRnZXNcblx0XHR2YXIgY29saW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXHRcdFxuXHRcdGlmICggTWF0aC5hYnMoIGNvbGluZWFyMCApID4gRVBTSUxPTiApIHtcdFx0Ly8gbm90IGNvbGluZWFyXG5cdFx0XHRcblx0XHRcdC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xuXHRcblx0XHRcdHZhciB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblx0XHRcdHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xuXHRcdFx0XG5cdFx0XHQvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XG5cdFxuXHRcdFx0dmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XG5cdFx0XHR2YXIgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcblx0XHRcdFxuXHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XG5cdFx0XHR2YXIgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcblx0XG5cdFx0XHQvLyBzY2FsaW5nIGZhY3RvciBmb3Igdl9wcmV2IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXHRcblx0XHRcdHZhciBzZiA9ICggICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cblx0XHRcdFx0XHRcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICAgICkgL1xuXHRcdFx0XHRcdCAgKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXHRcblx0XHRcdC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cdFxuXHRcdFx0dl90cmFuc194ID0gKCBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueCApO1xuXHRcdFx0dl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xuXHRcblx0XHRcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XG5cdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG5cdFx0XHR2YXIgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195IClcblx0XHRcdGlmICggdl90cmFuc19sZW5zcSA8PSAyICkge1xuXHRcdFx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3RyYW5zX2xlbnNxIC8gMiApO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSBlbHNlIHtcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xpbmVhciBlZGdlc1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uX2VxID0gZmFsc2U7XHRcdC8vIGFzc3VtZXM6IG9wcG9zaXRlXG5cdFx0XHRpZiAoIHZfcHJldl94ID4gRVBTSUxPTiApIHtcblx0XHRcdFx0aWYgKCB2X25leHRfeCA+IEVQU0lMT04gKSB7IGRpcmVjdGlvbl9lcSA9IHRydWU7IH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggdl9wcmV2X3ggPCAtIEVQU0lMT04gKSB7XG5cdFx0XHRcdFx0aWYgKCB2X25leHRfeCA8IC0gRVBTSUxPTiApIHsgZGlyZWN0aW9uX2VxID0gdHJ1ZTsgfVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggTWF0aC5zaWduKHZfcHJldl95KSA9PSBNYXRoLnNpZ24odl9uZXh0X3kpICkgeyBkaXJlY3Rpb25fZXEgPSB0cnVlOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkaXJlY3Rpb25fZXEgKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XG5cdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XG5cdFx0XHRcdHZfdHJhbnNfeSA9ICB2X3ByZXZfeDtcblx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XG5cdFx0XHRcdHZfdHJhbnNfeCA9IHZfcHJldl94O1xuXHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeTtcblx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xuXG5cdH1cblxuXG5cdHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuXHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcblx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXG5cblx0XHR2YXIgcHRfaSA9IGNvbnRvdXJbIGkgXTtcblx0XHR2YXIgcHRfaiA9IGNvbnRvdXJbIGogXTtcblx0XHR2YXIgcHRfayA9IGNvbnRvdXJbIGsgXTtcblxuXHRcdGNvbnRvdXJNb3ZlbWVudHNbIGkgXT0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcblxuXHR9XG5cblx0dmFyIGhvbGVzTW92ZW1lbnRzID0gW10sIG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcblxuXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XG5cblx0XHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcblx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuXHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxuXHRcdFx0b25lSG9sZU1vdmVtZW50c1sgaSBdPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG5cdFx0fVxuXG5cdFx0aG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xuXHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cblx0fVxuXG5cblx0Ly8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXG5cblx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXHQvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcblxuXHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcblx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XG5cblx0XHQvL3ogPSBiZXZlbFRoaWNrbmVzcyAqIHQ7XG5cdFx0YnMgPSBiZXZlbFNpemUgKiAoIE1hdGguc2luICggdCAqIE1hdGguUEkvMiApICkgOyAvLyBjdXJ2ZWRcblx0XHQvL2JzID0gYmV2ZWxTaXplICogdCA7IC8vIGxpbmVhclxuXG5cdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgLSB6ICk7XG5cblx0XHR9XG5cblx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRicyA9IGJldmVsU2l6ZTtcblxuXHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cblx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XG5cblx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbMF0gKS5tdWx0aXBseVNjYWxhcih2ZXJ0LngpO1xuXHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbMF0gKS5tdWx0aXBseVNjYWxhcih2ZXJ0LnkpO1xuXG5cdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1swXSApLmFkZChub3JtYWwpLmFkZChiaW5vcm1hbCk7XG5cblx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cblx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xuXG5cdHZhciBzO1xuXG5cdGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG5cdFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50IC8gc3RlcHMgKiBzICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xuXG5cdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbc10gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG5cdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzW3NdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG5cdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzW3NdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cblx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cblx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXG5cdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcblx0Zm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XG5cblx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0eiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xuXHRcdC8vYnMgPSBiZXZlbFNpemUgKiAoIDEtTWF0aC5zaW4gKCAoIDEgLSB0ICkgKiBNYXRoLlBJLzIgKSApO1xuXHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4gKCB0ICogTWF0aC5QSS8yICkgO1xuXG5cdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcblxuXHRcdH1cblxuXHRcdC8vIGV4cGFuZCBob2xlc1xuXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qIEZhY2VzICovXG5cblx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcblxuXHRidWlsZExpZEZhY2VzKCk7XG5cblx0Ly8gU2lkZXMgZmFjZXNcblxuXHRidWlsZFNpZGVGYWNlcygpO1xuXG5cblx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xuXG5cdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cblx0XHRpZiAoIGJldmVsRW5hYmxlZCApIHtcblxuXHRcdFx0dmFyIGxheWVyID0gMCA7IC8vIHN0ZXBzICsgMVxuXHRcdFx0dmFyIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuXHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0ZjMoIGZhY2VbIDIgXSsgb2Zmc2V0LCBmYWNlWyAxIF0rIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xuXHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG5cdFx0XHQvLyBUb3AgZmFjZXNcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBCb3R0b20gZmFjZXNcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXHRcdFx0XHRmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFRvcCBmYWNlc1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XG5cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cblx0ZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XG5cblx0XHR2YXIgbGF5ZXJvZmZzZXQgPSAwO1xuXHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcblx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgIGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcblxuXHRcdFx0Ly8sIHRydWVcblx0XHRcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcblxuXHRcdHZhciBqLCBrO1xuXHRcdGkgPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdHdoaWxlICggLS1pID49IDAgKSB7XG5cblx0XHRcdGogPSBpO1xuXHRcdFx0ayA9IGkgLSAxO1xuXHRcdFx0aWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cblx0XHRcdC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xuXG5cdFx0XHR2YXIgcyA9IDAsIHNsID0gc3RlcHMgICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cblx0XHRcdGZvciAoIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG5cblx0XHRcdFx0dmFyIHNsZW4xID0gdmxlbiAqIHM7XG5cdFx0XHRcdHZhciBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XG5cblx0XHRcdFx0dmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcblx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG5cdFx0XHRcdFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxuXHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblxuXHRcdFx0XHRmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcblxuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblxuXHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG5cdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcblxuXHRcdGEgKz0gc2hhcGVzT2Zmc2V0O1xuXHRcdGIgKz0gc2hhcGVzT2Zmc2V0O1xuXHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xuXG5cdFx0Ly8gbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxcblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcblxuXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgYSwgYiwgYyApO1xuXG4gXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dnMgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQsIHdhbGxDb250b3VyLCBzdGVwSW5kZXgsIHN0ZXBzTGVuZ3RoLCBjb250b3VySW5kZXgxLCBjb250b3VySW5kZXgyICkge1xuXG5cdFx0YSArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0YiArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0YyArPSBzaGFwZXNPZmZzZXQ7XG5cdFx0ZCArPSBzaGFwZXNPZmZzZXQ7XG5cbiBcdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkLCBudWxsLCBudWxsLCBleHRydWRlTWF0ZXJpYWwgKSApO1xuIFx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQsIG51bGwsIG51bGwsIGV4dHJ1ZGVNYXRlcmlhbCApICk7XG5cbiBcdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIGEsIGIsIGMsIGQgKTtcblxuIFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDAgXSwgdXZzWyAxIF0sIHV2c1sgMyBdIF0gKTtcbiBcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAxIF0sIHV2c1sgMiBdLCB1dnNbIDMgXSBdICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA9IHtcblxuXHRnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHR2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcblx0XHR2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcblx0XHR2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcblxuXHRcdHJldHVybiBbXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYS54LCBhLnkgKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIGIueSApLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgYy55IClcblx0XHRdO1xuXG5cdH0sXG5cblx0Z2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XG5cblx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xuXHRcdHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xuXHRcdHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xuXHRcdHZhciBkID0gdmVydGljZXNbIGluZGV4RCBdO1xuXG5cdFx0aWYgKCBNYXRoLmFicyggYS55IC0gYi55ICkgPCAwLjAxICkge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYi54LCAxIC0gYi56ICksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBjLngsIDEgLSBjLnogKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGQueCwgMSAtIGQueiApXG5cdFx0XHRdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYS55LCAxIC0gYS56ICksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBiLnksIDEgLSBiLnogKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGMueSwgMSAtIGMueiApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggZC55LCAxIC0gZC56IClcblx0XHRcdF07XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TaGFwZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXG4gKlxuICogQ3JlYXRlcyBhIG9uZS1zaWRlZCBwb2x5Z29uYWwgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuIFNpbWlsYXIgdG9cbiAqIEV4dHJ1ZGVHZW9tZXRyeS5cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICpcbiAqXHRjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzLiBOT1QgVVNFRCBBVCBUSEUgTU9NRU5ULlxuICpcbiAqXHRtYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGZyb250IGFuZCBiYWNrIGZhY2VzXG4gKlx0dXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAqXG4gKiB9XG4gKiovXG5cblRIUkVFLlNoYXBlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXG5cdGlmICggc2hhcGVzIGluc3RhbmNlb2YgQXJyYXkgPT09IGZhbHNlICkgc2hhcGVzID0gWyBzaGFwZXMgXTtcblxuXHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLyoqXG4gKiBBZGQgYW4gYXJyYXkgb2Ygc2hhcGVzIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnkuXG4gKi9cblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGVzWyBpIF0sIG9wdGlvbnMgKTtcblxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8qKlxuICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cbiAqL1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xuXG5cdGlmICggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucyA9IHt9O1xuXHR2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cblx0dmFyIG1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcblx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciA9PT0gdW5kZWZpbmVkID8gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgOiBvcHRpb25zLlVWR2VuZXJhdG9yO1xuXG5cdC8vXG5cblx0dmFyIGksIGwsIGhvbGUsIHM7XG5cblx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXHR2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cblx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG5cdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG5cdHZhciByZXZlcnNlID0gISBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcblxuXHRpZiAoIHJldmVyc2UgKSB7XG5cblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcblxuXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUuLi5cblxuXHRcdGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aG9sZSA9IGhvbGVzWyBpIF07XG5cblx0XHRcdGlmICggVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIGhvbGUgKSApIHtcblxuXHRcdFx0XHRob2xlc1sgaSBdID0gaG9sZS5yZXZlcnNlKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldmVyc2UgPSBmYWxzZTtcblxuXHR9XG5cblx0dmFyIGZhY2VzID0gVEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XG5cblx0Ly8gVmVydGljZXNcblxuXHR2YXIgY29udG91ciA9IHZlcnRpY2VzO1xuXG5cdGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGhvbGUgPSBob2xlc1sgaSBdO1xuXHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBob2xlICk7XG5cblx0fVxuXG5cdC8vXG5cblx0dmFyIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cdHZhciBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xuXHR2YXIgY29udCwgY2xlbiA9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdHZlcnQgPSB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydC54LCB2ZXJ0LnksIDAgKSApO1xuXG5cdH1cblxuXHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdHZhciBhID0gZmFjZVsgMCBdICsgc2hhcGVzT2Zmc2V0O1xuXHRcdHZhciBiID0gZmFjZVsgMSBdICsgc2hhcGVzT2Zmc2V0O1xuXHRcdHZhciBjID0gZmFjZVsgMiBdICsgc2hhcGVzT2Zmc2V0O1xuXG5cdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcblx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dmdlbi5nZW5lcmF0ZVRvcFVWKCB0aGlzLCBhLCBiLCBjICkgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0xhdGhlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cbi8vIHBvaW50cyAtIHRvIGNyZWF0ZSBhIGNsb3NlZCB0b3J1cywgb25lIG11c3QgdXNlIGEgc2V0IG9mIHBvaW50cyBcbi8vICAgIGxpa2Ugc286IFsgYSwgYiwgYywgZCwgYSBdLCBzZWUgZmlyc3QgaXMgdGhlIHNhbWUgYXMgbGFzdC5cbi8vIHNlZ21lbnRzIC0gdGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGNyZWF0ZVxuLy8gcGhpU3RhcnQgLSB0aGUgc3RhcnRpbmcgcmFkaWFuXG4vLyBwaGlMZW5ndGggLSB0aGUgcmFkaWFuICgwIHRvIDIqUEkpIHJhbmdlIG9mIHRoZSBsYXRoZWQgc2VjdGlvblxuLy8gICAgMipwaSBpcyBhIGNsb3NlZCBsYXRoZSwgbGVzcyB0aGFuIDJQSSBpcyBhIHBvcnRpb24uXG5cblRIUkVFLkxhdGhlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMYXRoZUdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cG9pbnRzOiBwb2ludHMsXG5cdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcblx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aFxuXHR9O1xuXG5cdHNlZ21lbnRzID0gc2VnbWVudHMgfHwgMTI7XG5cdHBoaVN0YXJ0ID0gcGhpU3RhcnQgfHwgMDtcblx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoIHx8IDIgKiBNYXRoLlBJO1xuXG5cdHZhciBpbnZlcnNlUG9pbnRMZW5ndGggPSAxLjAgLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XG5cdHZhciBpbnZlcnNlU2VnbWVudHMgPSAxLjAgLyBzZWdtZW50cztcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPD0gaWw7IGkgKysgKSB7XG5cblx0XHR2YXIgcGhpID0gcGhpU3RhcnQgKyBpICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggcGhpICksXG5cdFx0XHRzID0gTWF0aC5zaW4oIHBoaSApO1xuXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHBvaW50cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0dmFyIHB0ID0gcG9pbnRzWyBqIF07XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR2ZXJ0ZXgueCA9IGMgKiBwdC54IC0gcyAqIHB0Lnk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHMgKiBwdC54ICsgYyAqIHB0Lnk7XG5cdFx0XHR2ZXJ0ZXgueiA9IHB0Lno7XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHZhciBucCA9IHBvaW50cy5sZW5ndGg7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNlZ21lbnRzOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aCAtIDE7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0dmFyIGJhc2UgPSBqICsgbnAgKiBpO1xuXHRcdFx0dmFyIGEgPSBiYXNlO1xuXHRcdFx0dmFyIGIgPSBiYXNlICsgbnA7XG5cdFx0XHR2YXIgYyA9IGJhc2UgKyAxICsgbnA7XG5cdFx0XHR2YXIgZCA9IGJhc2UgKyAxO1xuXG5cdFx0XHR2YXIgdTAgPSBpICogaW52ZXJzZVNlZ21lbnRzO1xuXHRcdFx0dmFyIHYwID0gaiAqIGludmVyc2VQb2ludExlbmd0aDtcblx0XHRcdHZhciB1MSA9IHUwICsgaW52ZXJzZVNlZ21lbnRzO1xuXHRcdFx0dmFyIHYxID0gdjAgKyBpbnZlcnNlUG9pbnRMZW5ndGg7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcblxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjAgKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYxIClcblxuXHRcdFx0XSApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG5cblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcblxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjEgKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MSApXG5cblx0XHRcdF0gKTtcblxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QbGFuZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xuICovXG5cblRIUkVFLlBsYW5lR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG5cdGNvbnNvbGUuaW5mbyggJ1RIUkVFLlBsYW5lR2VvbWV0cnk6IENvbnNpZGVyIHVzaW5nIFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkgZm9yIGxvd2VyIG1lbW9yeSBmb290cHJpbnQuJyApO1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUGxhbmVHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHdpZHRoOiB3aWR0aCxcblx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuXHR9O1xuXG5cdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSApO1xuXG59O1xuXG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9QbGFuZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9QbGFuZS5hc1xuICovXG5cblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHdpZHRoOiB3aWR0aCxcblx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xuXHR9O1xuXG5cdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuXHR2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuXG5cdHZhciBncmlkWCA9IHdpZHRoU2VnbWVudHMgfHwgMTtcblx0dmFyIGdyaWRZID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcblxuXHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xuXHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG5cdHZhciBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcblx0dmFyIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cblx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xuXHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcblx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDIgKTtcblxuXHR2YXIgb2Zmc2V0ID0gMDtcblx0dmFyIG9mZnNldDIgPSAwO1xuXG5cdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcblxuXHRcdHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG5cdFx0Zm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHR2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XG5cblx0XHRcdHZlcnRpY2VzWyBvZmZzZXQgICAgIF0gPSB4O1xuXHRcdFx0dmVydGljZXNbIG9mZnNldCArIDEgXSA9IC0geTtcblxuXHRcdFx0bm9ybWFsc1sgb2Zmc2V0ICsgMiBdID0gMTtcblxuXHRcdFx0dXZzWyBvZmZzZXQyICAgICBdID0gaXggLyBncmlkWDtcblx0XHRcdHV2c1sgb2Zmc2V0MiArIDEgXSA9IDEgLSAoIGl5IC8gZ3JpZFkgKTtcblxuXHRcdFx0b2Zmc2V0ICs9IDM7XG5cdFx0XHRvZmZzZXQyICs9IDI7XG5cblx0XHR9XG5cblx0fVxuXG5cdG9mZnNldCA9IDA7XG5cblx0dmFyIGluZGljZXMgPSBuZXcgKCAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBncmlkWCAqIGdyaWRZICogNiApO1xuXG5cdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG5cdFx0Zm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XG5cblx0XHRcdHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcblx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0dmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgICAgIF0gPSBhO1xuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgMSBdID0gYjtcblx0XHRcdGluZGljZXNbIG9mZnNldCArIDIgXSA9IGQ7XG5cblx0XHRcdGluZGljZXNbIG9mZnNldCArIDMgXSA9IGI7XG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyA0IF0gPSBjO1xuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgNSBdID0gZDtcblxuXHRcdFx0b2Zmc2V0ICs9IDY7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAnaW5kZXgnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbn07XG5cblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1JpbmdHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgS2FsZWIgTXVycGh5XG4gKi9cblxuVEhSRUUuUmluZ0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHRoZXRhU2VnbWVudHMsIHBoaVNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcblx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0dGhldGFTZWdtZW50czogdGhldGFTZWdtZW50cyxcblx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0fTtcblxuXHRpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IDA7XG5cdG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgfHwgNTA7XG5cblx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG5cdHRoZXRhU2VnbWVudHMgPSB0aGV0YVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgdGhldGFTZWdtZW50cyApIDogODtcblx0cGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiA4O1xuXG5cdHZhciBpLCBvLCB1dnMgPSBbXSwgcmFkaXVzID0gaW5uZXJSYWRpdXMsIHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcblxuXHRmb3IgKCBpID0gMDsgaSA8IHBoaVNlZ21lbnRzICsgMTsgaSArKyApIHsgLy8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXG5cblx0XHRmb3IgKCBvID0gMDsgbyA8IHRoZXRhU2VnbWVudHMgKyAxOyBvICsrICkgeyAvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxuXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIG8gLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cdFx0XHR1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDIsICggdmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEgKSAvIDIgKSApO1xuXHRcdH1cblxuXHRcdHJhZGl1cyArPSByYWRpdXNTdGVwO1xuXG5cdH1cblxuXHR2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cblx0Zm9yICggaSA9IDA7IGkgPCBwaGlTZWdtZW50czsgaSArKyApIHsgLy8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXG5cblx0XHR2YXIgdGhldGFTZWdtZW50ID0gaSAqICh0aGV0YVNlZ21lbnRzICsgMSk7XG5cblx0XHRmb3IgKCBvID0gMDsgbyA8IHRoZXRhU2VnbWVudHMgOyBvICsrICkgeyAvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxuXG5cdFx0XHR2YXIgc2VnbWVudCA9IG8gKyB0aGV0YVNlZ21lbnQ7XG5cblx0XHRcdHZhciB2MSA9IHNlZ21lbnQ7XG5cdFx0XHR2YXIgdjIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDE7XG5cdFx0XHR2YXIgdjMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSk7XG5cblx0XHRcdHYxID0gc2VnbWVudDtcblx0XHRcdHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xuXHRcdFx0djMgPSBzZWdtZW50ICsgMTtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdKTtcblxuXHRcdH1cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU3BoZXJlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlNwaGVyZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoIFxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcblxuXHR3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCA4ICk7XG5cdGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgNiApO1xuXG5cdHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcblx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBwaGlMZW5ndGggOiBNYXRoLlBJICogMjtcblxuXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG5cdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSTtcblxuXHR2YXIgeCwgeSwgdmVydGljZXMgPSBbXSwgdXZzID0gW107XG5cblx0Zm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cblx0XHR2YXIgdmVydGljZXNSb3cgPSBbXTtcblx0XHR2YXIgdXZzUm93ID0gW107XG5cblx0XHRmb3IgKCB4ID0gMDsgeCA8PSB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHR2YXIgdSA9IHggLyB3aWR0aFNlZ21lbnRzO1xuXHRcdFx0dmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmVydGV4LnggPSAtIHJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHRcdHZlcnRpY2VzUm93LnB1c2goIHRoaXMudmVydGljZXMubGVuZ3RoIC0gMSApO1xuXHRcdFx0dXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XG5cblx0XHR9XG5cblx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXHRcdHV2cy5wdXNoKCB1dnNSb3cgKTtcblxuXHR9XG5cblx0Zm9yICggeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdGZvciAoIHggPSAwOyB4IDwgd2lkdGhTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcblx0XHRcdHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XG5cdFx0XHR2YXIgdjQgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcblxuXHRcdFx0dmFyIG4xID0gdGhpcy52ZXJ0aWNlc1sgdjEgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dmFyIG4yID0gdGhpcy52ZXJ0aWNlc1sgdjIgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dmFyIG4zID0gdGhpcy52ZXJ0aWNlc1sgdjMgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dmFyIG40ID0gdGhpcy52ZXJ0aWNlc1sgdjQgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djIgPSB1dnNbIHkgXVsgeCBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdXYzID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djQgPSB1dnNbIHkgKyAxIF1bIHggKyAxIF0uY2xvbmUoKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggdGhpcy52ZXJ0aWNlc1sgdjEgXS55ICkgPT09IHJhZGl1cyApIHtcblxuXHRcdFx0XHR1djEueCA9ICggdXYxLnggKyB1djIueCApIC8gMjtcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MywgdjQsIFsgbjEsIG4zLCBuNCBdICkgKTtcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MywgdXY0IF0gKTtcblxuXHRcdFx0fSBlbHNlIGlmICggTWF0aC5hYnMoIHRoaXMudmVydGljZXNbIHYzIF0ueSApID09PSByYWRpdXMgKSB7XG5cblx0XHRcdFx0dXYzLnggPSAoIHV2My54ICsgdXY0LnggKSAvIDI7XG5cdFx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjQsIFsgbjEsIG4yLCBuNCBdICkgKTtcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXY0IF0gKTtcblxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjIsIHYzLCB2NCwgWyBuMi5jbG9uZSgpLCBuMywgbjQuY2xvbmUoKSBdICkgKTtcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UZXh0R2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEZvciBjcmVhdGluZyAzRCB0ZXh0IGdlb21ldHJ5IGluIHRocmVlLmpzXG4gKlxuICogVGV4dCA9IDNEIFRleHRcbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIHNpemU6IFx0XHRcdDxmbG9hdD4sIFx0Ly8gc2l6ZSBvZiB0aGUgdGV4dFxuICogIGhlaWdodDogXHRcdDxmbG9hdD4sIFx0Ly8gdGhpY2tuZXNzIHRvIGV4dHJ1ZGUgdGV4dFxuICogIGN1cnZlU2VnbWVudHM6IFx0PGludD4sXHRcdC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICpcbiAqICBmb250OiBcdFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCBuYW1lXG4gKiAgd2VpZ2h0OiBcdFx0PHN0cmluZz4sXHRcdC8vIGZvbnQgd2VpZ2h0IChub3JtYWwsIGJvbGQpXG4gKiAgc3R5bGU6IFx0XHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IHN0eWxlICAobm9ybWFsLCBpdGFsaWNzKVxuICpcbiAqICBiZXZlbEVuYWJsZWQ6XHQ8Ym9vbD4sXHRcdFx0Ly8gdHVybiBvbiBiZXZlbFxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCBcdFx0Ly8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6XHRcdDxmbG9hdD4sIFx0XHQvLyBob3cgZmFyIGZyb20gdGV4dCBvdXRsaW5lIGlzIGJldmVsXG4gKiAgfVxuICpcbiAqL1xuXG4vKlx0VXNhZ2UgRXhhbXBsZXNcblxuXHQvLyBUZXh0R2VvbWV0cnkgd3JhcHBlclxuXG5cdHZhciB0ZXh0M2QgPSBuZXcgVGV4dEdlb21ldHJ5KCB0ZXh0LCBvcHRpb25zICk7XG5cblx0Ly8gQ29tcGxldGUgbWFubmVyXG5cblx0dmFyIHRleHRTaGFwZXMgPSBUSFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIG9wdGlvbnMgKTtcblx0dmFyIHRleHQzZCA9IG5ldyBFeHRydWRlR2VvbWV0cnkoIHRleHRTaGFwZXMsIG9wdGlvbnMgKTtcblxuKi9cblxuXG5USFJFRS5UZXh0R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHRleHQsIHBhcmFtZXRlcnMgKSB7XG5cblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cblx0dmFyIHRleHRTaGFwZXMgPSBUSFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIHBhcmFtZXRlcnMgKTtcblxuXHQvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXG5cblx0cGFyYW1ldGVycy5hbW91bnQgPSBwYXJhbWV0ZXJzLmhlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5oZWlnaHQgOiA1MDtcblxuXHQvLyBkZWZhdWx0c1xuXG5cdGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xuXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxTaXplID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9IDg7XG5cdGlmICggcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID0gZmFsc2U7XG5cblx0VEhSRUUuRXh0cnVkZUdlb21ldHJ5LmNhbGwoIHRoaXMsIHRleHRTaGFwZXMsIHBhcmFtZXRlcnMgKTtcblxuXHR0aGlzLnR5cGUgPSAnVGV4dEdlb21ldHJ5JztcblxufTtcblxuVEhSRUUuVGV4dEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxuICovXG5cblRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdHR1YmU6IHR1YmUsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdGFyYzogYXJjXG5cdH07XG5cblx0cmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcblx0dHViZSA9IHR1YmUgfHwgNDA7XG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0dHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY7XG5cdGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcblxuXHR2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdXZzID0gW10sIG5vcm1hbHMgPSBbXTtcblxuXHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG5cdFx0XHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG5cdFx0XHRjZW50ZXIueCA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICk7XG5cdFx0XHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0dmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuXHRcdFx0dmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuXHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdHVidWxhclNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKSApO1xuXHRcdFx0bm9ybWFscy5wdXNoKCB2ZXJ0ZXguY2xvbmUoKS5zdWIoIGNlbnRlciApLm5vcm1hbGl6ZSgpICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZvciAoIHZhciBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdHZhciBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XG5cdFx0XHR2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XG5cdFx0XHR2YXIgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblx0XHRcdHZhciBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblxuXHRcdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQsIFsgbm9ybWFsc1sgYSBdLmNsb25lKCksIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cblx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQsIFsgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGMgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBjIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RvcnVzS25vdEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRC9zcmMvYXdheTNkL3ByaW1pdGl2ZXMvVG9ydXNLbm90LmFzP3NwZWM9c3ZuMjQ3MyZyPTI0NzNcbiAqL1xuXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0dHViZTogdHViZSxcblx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG5cdFx0cDogcCxcblx0XHRxOiBxLFxuXHRcdGhlaWdodFNjYWxlOiBoZWlnaHRTY2FsZVxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XG5cdHR1YmUgPSB0dWJlIHx8IDQwO1xuXHRyYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDY0O1xuXHR0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgODtcblx0cCA9IHAgfHwgMjtcblx0cSA9IHEgfHwgMztcblx0aGVpZ2h0U2NhbGUgPSBoZWlnaHRTY2FsZSB8fCAxO1xuXHRcblx0dmFyIGdyaWQgPSBuZXcgQXJyYXkoIHJhZGlhbFNlZ21lbnRzICk7XG5cdHZhciB0YW5nID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgYml0YW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHJhZGlhbFNlZ21lbnRzOyArKyBpICkge1xuXG5cdFx0Z3JpZFsgaSBdID0gbmV3IEFycmF5KCB0dWJ1bGFyU2VnbWVudHMgKTtcblx0XHR2YXIgdSA9IGkgLyByYWRpYWxTZWdtZW50cyAqIDIgKiBwICogTWF0aC5QSTtcblx0XHR2YXIgcDEgPSBnZXRQb3MoIHUsIHEsIHAsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKTtcblx0XHR2YXIgcDIgPSBnZXRQb3MoIHUgKyAwLjAxLCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XG5cdFx0dGFuZy5zdWJWZWN0b3JzKCBwMiwgcDEgKTtcblx0XHRuLmFkZFZlY3RvcnMoIHAyLCBwMSApO1xuXG5cdFx0Yml0YW4uY3Jvc3NWZWN0b3JzKCB0YW5nLCBuICk7XG5cdFx0bi5jcm9zc1ZlY3RvcnMoIGJpdGFuLCB0YW5nICk7XG5cdFx0Yml0YW4ubm9ybWFsaXplKCk7XG5cdFx0bi5ub3JtYWxpemUoKTtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcblxuXHRcdFx0dmFyIHYgPSBqIC8gdHVidWxhclNlZ21lbnRzICogMiAqIE1hdGguUEk7XG5cdFx0XHR2YXIgY3ggPSAtIHR1YmUgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxuXHRcdFx0dmFyIGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cblx0XHRcdHZhciBwb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0cG9zLnggPSBwMS54ICsgY3ggKiBuLnggKyBjeSAqIGJpdGFuLng7XG5cdFx0XHRwb3MueSA9IHAxLnkgKyBjeCAqIG4ueSArIGN5ICogYml0YW4ueTtcblx0XHRcdHBvcy56ID0gcDEueiArIGN4ICogbi56ICsgY3kgKiBiaXRhbi56O1xuXG5cdFx0XHRncmlkWyBpIF1bIGogXSA9IHRoaXMudmVydGljZXMucHVzaCggcG9zICkgLSAxO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCByYWRpYWxTZWdtZW50czsgKysgaSApIHtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHR1YnVsYXJTZWdtZW50czsgKysgaiApIHtcblxuXHRcdFx0dmFyIGlwID0gKCBpICsgMSApICUgcmFkaWFsU2VnbWVudHM7XG5cdFx0XHR2YXIganAgPSAoIGogKyAxICkgJSB0dWJ1bGFyU2VnbWVudHM7XG5cblx0XHRcdHZhciBhID0gZ3JpZFsgaSBdWyBqIF07XG5cdFx0XHR2YXIgYiA9IGdyaWRbIGlwIF1bIGogXTtcblx0XHRcdHZhciBjID0gZ3JpZFsgaXAgXVsganAgXTtcblx0XHRcdHZhciBkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG5cdFx0XHR2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdFx0dmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgaiAvIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdFx0dmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHR2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyByYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdHVidWxhclNlZ21lbnRzICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG5cdFx0fVxuXHR9XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdGZ1bmN0aW9uIGdldFBvcyggdSwgaW5fcSwgaW5fcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApIHtcblxuXHRcdHZhciBjdSA9IE1hdGguY29zKCB1ICk7XG5cdFx0dmFyIHN1ID0gTWF0aC5zaW4oIHUgKTtcblx0XHR2YXIgcXVPdmVyUCA9IGluX3EgLyBpbl9wICogdTtcblx0XHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG5cdFx0dmFyIHR4ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xuXHRcdHZhciB0eSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcblx0XHR2YXIgdHogPSBoZWlnaHRTY2FsZSAqIHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UdWJlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBtaW5pbmdvbGQgLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW5nb2xkXG4gKlxuICogTW9kaWZpZWQgZnJvbSB0aGUgVG9ydXNLbm90R2VvbWV0cnkgYnkgQG9vc21veGllY29kZVxuICpcbiAqIENyZWF0ZXMgYSB0dWJlIHdoaWNoIGV4dHJ1ZGVzIGFsb25nIGEgM2Qgc3BsaW5lXG4gKlxuICogVXNlcyBwYXJhbGxlbCB0cmFuc3BvcnQgZnJhbWVzIGFzIGRlc2NyaWJlZCBpblxuICogaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXG4gKi9cblxuVEhSRUUuVHViZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBwYXRoLCBzZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cGF0aDogcGF0aCxcblx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdGNsb3NlZDogY2xvc2VkXG5cdH07XG5cblx0c2VnbWVudHMgPSBzZWdtZW50cyB8fCA2NDtcblx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0Y2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xuXG5cdHZhciBncmlkID0gW107XG5cblx0dmFyIHNjb3BlID0gdGhpcyxcblxuXHRcdHRhbmdlbnQsXG5cdFx0bm9ybWFsLFxuXHRcdGJpbm9ybWFsLFxuXG5cdFx0bnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxuXG5cdFx0eCwgeSwgeixcblx0XHR0eCwgdHksIHR6LFxuXHRcdHUsIHYsXG5cblx0XHRjeCwgY3ksXG5cdFx0cG9zLCBwb3MyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRpLCBqLFxuXHRcdGlwLCBqcCxcblx0XHRhLCBiLCBjLCBkLFxuXHRcdHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuXHR2YXIgZnJhbWVzID0gbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSxcblx0XHR0YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cyxcblx0XHRub3JtYWxzID0gZnJhbWVzLm5vcm1hbHMsXG5cdFx0Ymlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcblxuXHQvLyBwcm94eSBpbnRlcm5hbHNcblx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xuXHR0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuXHR0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuXHRmdW5jdGlvbiB2ZXJ0KCB4LCB5LCB6ICkge1xuXG5cdFx0cmV0dXJuIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKSAtIDE7XG5cblx0fVxuXG5cdC8vIGNvbnNydWN0IHRoZSBncmlkXG5cblx0Zm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cblx0XHRncmlkWyBpIF0gPSBbXTtcblxuXHRcdHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cblx0XHRwb3MgPSBwYXRoLmdldFBvaW50QXQoIHUgKTtcblxuXHRcdHRhbmdlbnQgPSB0YW5nZW50c1sgaSBdO1xuXHRcdG5vcm1hbCA9IG5vcm1hbHNbIGkgXTtcblx0XHRiaW5vcm1hbCA9IGJpbm9ybWFsc1sgaSBdO1xuXG5cdFx0Zm9yICggaiA9IDA7IGogPCByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0diA9IGogLyByYWRpYWxTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xuXG5cdFx0XHRjeCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cblx0XHRcdGN5ID0gcmFkaXVzICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0cG9zMi5jb3B5KCBwb3MgKTtcblx0XHRcdHBvczIueCArPSBjeCAqIG5vcm1hbC54ICsgY3kgKiBiaW5vcm1hbC54O1xuXHRcdFx0cG9zMi55ICs9IGN4ICogbm9ybWFsLnkgKyBjeSAqIGJpbm9ybWFsLnk7XG5cdFx0XHRwb3MyLnogKz0gY3ggKiBub3JtYWwueiArIGN5ICogYmlub3JtYWwuejtcblxuXHRcdFx0Z3JpZFsgaSBdWyBqIF0gPSB2ZXJ0KCBwb3MyLngsIHBvczIueSwgcG9zMi56ICk7XG5cblx0XHR9XG5cdH1cblxuXG5cdC8vIGNvbnN0cnVjdCB0aGUgbWVzaFxuXG5cdGZvciAoIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRpcCA9ICggY2xvc2VkICkgPyAoaSArIDEpICUgc2VnbWVudHMgOiBpICsgMTtcblx0XHRcdGpwID0gKGogKyAxKSAlIHJhZGlhbFNlZ21lbnRzO1xuXG5cdFx0XHRhID0gZ3JpZFsgaSBdWyBqIF07XHRcdC8vICoqKiBOT1QgTkVDRVNTQVJJTFkgUExBTkFSICEgKioqXG5cdFx0XHRiID0gZ3JpZFsgaXAgXVsgaiBdO1xuXHRcdFx0YyA9IGdyaWRbIGlwIF1bIGpwIF07XG5cdFx0XHRkID0gZ3JpZFsgaSBdWyBqcCBdO1xuXG5cdFx0XHR1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcblx0XHRcdHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0XHR1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuXHRcdH1cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG5cbi8vIEZvciBjb21wdXRpbmcgb2YgRnJlbmV0IGZyYW1lcywgZXhwb3NpbmcgdGhlIHRhbmdlbnRzLCBub3JtYWxzIGFuZCBiaW5vcm1hbHMgdGhlIHNwbGluZVxuVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyA9IGZ1bmN0aW9uICggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApIHtcblxuXHR2YXJcdHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0Ymlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG5cdFx0dGFuZ2VudHMgPSBbXSxcblx0XHRub3JtYWxzID0gW10sXG5cdFx0Ymlub3JtYWxzID0gW10sXG5cblx0XHR2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdG1hdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cblx0XHRudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXG5cdFx0dGhldGEsXG5cdFx0ZXBzaWxvbiA9IDAuMDAwMSxcblx0XHRzbWFsbGVzdCxcblxuXHRcdHR4LCB0eSwgdHosXG5cdFx0aSwgdSwgdjtcblxuXG5cdC8vIGV4cG9zZSBpbnRlcm5hbHNcblx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xuXHR0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuXHR0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuXHQvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG5cdGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG5cdFx0dSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcblxuXHRcdHRhbmdlbnRzWyBpIF0gPSBwYXRoLmdldFRhbmdlbnRBdCggdSApO1xuXHRcdHRhbmdlbnRzWyBpIF0ubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGluaXRpYWxOb3JtYWwzKCk7XG5cblx0Lypcblx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDEobGFzdEJpbm9ybWFsKSB7XG5cdFx0Ly8gZml4ZWQgc3RhcnQgYmlub3JtYWwuIEhhcyBkYW5nZXJzIG9mIDAgdmVjdG9yc1xuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGlmIChsYXN0Qmlub3JtYWw9PT11bmRlZmluZWQpIGxhc3RCaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggbGFzdEJpbm9ybWFsLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwyKCkge1xuXG5cdFx0Ly8gVGhpcyB1c2VzIHRoZSBGcmVuZXQtU2VycmV0IGZvcm11bGEgZm9yIGRlcml2aW5nIGJpbm9ybWFsXG5cdFx0dmFyIHQyID0gcGF0aC5nZXRUYW5nZW50QXQoIGVwc2lsb24gKTtcblxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc3ViVmVjdG9ycyggdDIsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcblxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGJpbm9ybWFsc1sgMCBdLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7IC8vIGxhc3QgYmlub3JtYWwgeCB0YW5nZW50XG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cdCovXG5cblx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDMoKSB7XG5cdFx0Ly8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5pY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxuXHRcdC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzbWFsbGVzdCB0YW5nZW50IHh5eiBjb21wb25lbnRcblxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHNtYWxsZXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHR0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcblx0XHR0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcblx0XHR0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcblxuXHRcdGlmICggdHggPD0gc21hbGxlc3QgKSB7XG5cdFx0XHRzbWFsbGVzdCA9IHR4O1xuXHRcdFx0bm9ybWFsLnNldCggMSwgMCwgMCApO1xuXHRcdH1cblxuXHRcdGlmICggdHkgPD0gc21hbGxlc3QgKSB7XG5cdFx0XHRzbWFsbGVzdCA9IHR5O1xuXHRcdFx0bm9ybWFsLnNldCggMCwgMSwgMCApO1xuXHRcdH1cblxuXHRcdGlmICggdHogPD0gc21hbGxlc3QgKSB7XG5cdFx0XHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XG5cdFx0fVxuXG5cdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XG5cblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xuXHR9XG5cblxuXHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG5cdGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG5cdFx0bm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaS0xIF0uY2xvbmUoKTtcblxuXHRcdGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpLTEgXS5jbG9uZSgpO1xuXG5cdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGktMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cblx0XHRpZiAoIHZlYy5sZW5ndGgoKSA+IGVwc2lsb24gKSB7XG5cblx0XHRcdHZlYy5ub3JtYWxpemUoKTtcblxuXHRcdFx0dGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRhbmdlbnRzWyBpLTEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLSAxLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xuXG5cdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XG5cblx0XHR9XG5cblx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG5cdH1cblxuXG5cdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcblxuXHRpZiAoIGNsb3NlZCApIHtcblxuXHRcdHRoZXRhID0gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBudW1wb2ludHMtMSBdICksIC0gMSwgMSApICk7XG5cdFx0dGhldGEgLz0gKCBudW1wb2ludHMgLSAxICk7XG5cblx0XHRpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIG51bXBvaW50cy0xIF0gKSApID4gMCApIHtcblxuXHRcdFx0dGhldGEgPSAtIHRoZXRhO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cblx0XHRcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXG5cdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcblx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cblx0XHR9XG5cblx0fVxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUG9seWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0aW5kaWNlczogaW5kaWNlcyxcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXHRkZXRhaWwgPSBkZXRhaWwgfHwgMDtcblxuXHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0cHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XG5cblx0fVxuXG5cdHZhciBtaWRwb2ludHMgPSBbXSwgcCA9IHRoaXMudmVydGljZXM7XG5cblx0dmFyIGZhY2VzID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzLCBqICsrICkge1xuXG5cdFx0dmFyIHYxID0gcFsgaW5kaWNlc1sgaSAgICAgXSBdO1xuXHRcdHZhciB2MiA9IHBbIGluZGljZXNbIGkgKyAxIF0gXTtcblx0XHR2YXIgdjMgPSBwWyBpbmRpY2VzWyBpICsgMiBdIF07XG5cblx0XHRmYWNlc1sgaiBdID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSApO1xuXG5cdH1cblxuXHR2YXIgY2VudHJvaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRzdWJkaXZpZGUoIGZhY2VzWyBpIF0sIGRldGFpbCApO1xuXG5cdH1cblxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gZmFjZSBzdHJhZGRsZXMgdGhlIHNlYW1cblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XG5cblx0XHR2YXIgeDAgPSB1dnNbIDAgXS54O1xuXHRcdHZhciB4MSA9IHV2c1sgMSBdLng7XG5cdFx0dmFyIHgyID0gdXZzWyAyIF0ueDtcblxuXHRcdHZhciBtYXggPSBNYXRoLm1heCggeDAsIE1hdGgubWF4KCB4MSwgeDIgKSApO1xuXHRcdHZhciBtaW4gPSBNYXRoLm1pbiggeDAsIE1hdGgubWluKCB4MSwgeDIgKSApO1xuXG5cdFx0aWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkgeyAvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XG5cblx0XHRcdGlmICggeDAgPCAwLjIgKSB1dnNbIDAgXS54ICs9IDE7XG5cdFx0XHRpZiAoIHgxIDwgMC4yICkgdXZzWyAxIF0ueCArPSAxO1xuXHRcdFx0aWYgKCB4MiA8IDAuMiApIHV2c1sgMiBdLnggKz0gMTtcblxuXHRcdH1cblxuXHR9XG5cblxuXHQvLyBBcHBseSByYWRpdXNcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHR0aGlzLnZlcnRpY2VzWyBpIF0ubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xuXG5cdH1cblxuXG5cdC8vIE1lcmdlIHZlcnRpY2VzXG5cblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cblxuXHQvLyBQcm9qZWN0IHZlY3RvciBvbnRvIHNwaGVyZSdzIHN1cmZhY2VcblxuXHRmdW5jdGlvbiBwcmVwYXJlKCB2ZWN0b3IgKSB7XG5cblx0XHR2YXIgdmVydGV4ID0gdmVjdG9yLm5vcm1hbGl6ZSgpLmNsb25lKCk7XG5cdFx0dmVydGV4LmluZGV4ID0gdGhhdC52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKSAtIDE7XG5cblx0XHQvLyBUZXh0dXJlIGNvb3JkcyBhcmUgZXF1aXZhbGVudCB0byBtYXAgY29vcmRzLCBjYWxjdWxhdGUgYW5nbGUgYW5kIGNvbnZlcnQgdG8gZnJhY3Rpb24gb2YgYSBjaXJjbGUuXG5cblx0XHR2YXIgdSA9IGF6aW11dGgoIHZlY3RvciApIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cdFx0dmFyIHYgPSBpbmNsaW5hdGlvbiggdmVjdG9yICkgLyBNYXRoLlBJICsgMC41O1xuXHRcdHZlcnRleC51diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApO1xuXG5cdFx0cmV0dXJuIHZlcnRleDtcblxuXHR9XG5cblxuXHQvLyBBcHByb3hpbWF0ZSBhIGN1cnZlZCBmYWNlIHdpdGggcmVjdXJzaXZlbHkgc3ViLWRpdmlkZWQgdHJpYW5nbGVzLlxuXG5cdGZ1bmN0aW9uIG1ha2UoIHYxLCB2MiwgdjMgKSB7XG5cblx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0gKTtcblx0XHR0aGF0LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuXHRcdGNlbnRyb2lkLmNvcHkoIHYxICkuYWRkKCB2MiApLmFkZCggdjMgKS5kaXZpZGVTY2FsYXIoIDMgKTtcblxuXHRcdHZhciBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xuXG5cdFx0dGhhdC5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXHRcdFx0Y29ycmVjdFVWKCB2MS51diwgdjEsIGF6aSApLFxuXHRcdFx0Y29ycmVjdFVWKCB2Mi51diwgdjIsIGF6aSApLFxuXHRcdFx0Y29ycmVjdFVWKCB2My51diwgdjMsIGF6aSApXG5cdFx0XSApO1xuXG5cdH1cblxuXG5cdC8vIEFuYWx5dGljYWxseSBzdWJkaXZpZGUgYSBmYWNlIHRvIHRoZSByZXF1aXJlZCBkZXRhaWwgbGV2ZWwuXG5cblx0ZnVuY3Rpb24gc3ViZGl2aWRlKCBmYWNlLCBkZXRhaWwgKSB7XG5cblx0XHR2YXIgY29scyA9IE1hdGgucG93KDIsIGRldGFpbCk7XG5cdFx0dmFyIGNlbGxzID0gTWF0aC5wb3coNCwgZGV0YWlsKTtcblx0XHR2YXIgYSA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYSBdICk7XG5cdFx0dmFyIGIgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmIgXSApO1xuXHRcdHZhciBjID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblx0XHR2YXIgdiA9IFtdO1xuXG5cdFx0Ly8gQ29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb24uXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAgOyBpIDw9IGNvbHM7IGkgKysgKSB7XG5cblx0XHRcdHZbIGkgXSA9IFtdO1xuXG5cdFx0XHR2YXIgYWogPSBwcmVwYXJlKCBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xuXHRcdFx0dmFyIGJqID0gcHJlcGFyZSggYi5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcblx0XHRcdHZhciByb3dzID0gY29scyAtIGk7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8PSByb3dzOyBqICsrKSB7XG5cblx0XHRcdFx0aWYgKCBqID09IDAgJiYgaSA9PSBjb2xzICkge1xuXG5cdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBhajtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBwcmVwYXJlKCBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlcy5cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNvbHMgOyBpICsrICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyICogKGNvbHMgLSBpKSAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xuXG5cdFx0XHRcdGlmICggaiAlIDIgPT0gMCApIHtcblxuXHRcdFx0XHRcdG1ha2UoXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGsgKyAxXSxcblx0XHRcdFx0XHRcdHZbIGkgKyAxIF1bIGsgXSxcblx0XHRcdFx0XHRcdHZbIGkgXVsgayBdXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bWFrZShcblx0XHRcdFx0XHRcdHZbIGkgXVsgayArIDEgXSxcblx0XHRcdFx0XHRcdHZbIGkgKyAxXVsgayArIDFdLFxuXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayBdXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblxuXHQvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXG5cblx0ZnVuY3Rpb24gYXppbXV0aCggdmVjdG9yICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XG5cblx0fVxuXG5cblx0Ly8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxuXG5cdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcblxuXHR9XG5cblxuXHQvLyBUZXh0dXJlIGZpeGluZyBoZWxwZXIuIFNwaGVyZXMgaGF2ZSBzb21lIG9kZCBiZWhhdmlvdXJzLlxuXG5cdGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHZlY3RvciwgYXppbXV0aCApIHtcblxuXHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcblx0XHRpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjUsIHV2LnkgKTtcblx0XHRyZXR1cm4gdXYuY2xvbmUoKTtcblxuXHR9XG5cblxufTtcblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Eb2RlY2FoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgQWJlIFBhem9zIC8gaHR0cHM6Ly9oYW1vaWQuY29tXG4gKi9cblxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG5cdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cdHZhciByID0gMSAvIHQ7XG5cblx0dmFyIHZlcnRpY2VzID0gW1xuXG5cdFx0Ly8gKMKxMSwgwrExLCDCsTEpXG5cdFx0LTEsIC0xLCAtMSwgICAgLTEsIC0xLCAgMSxcblx0XHQtMSwgIDEsIC0xLCAgICAtMSwgIDEsICAxLFxuXHRcdCAxLCAtMSwgLTEsICAgICAxLCAtMSwgIDEsXG5cdFx0IDEsICAxLCAtMSwgICAgIDEsICAxLCAgMSxcblxuXHRcdC8vICgwLCDCsTEvz4YsIMKxz4YpXG5cdFx0IDAsIC1yLCAtdCwgICAgIDAsIC1yLCAgdCxcblx0XHQgMCwgIHIsIC10LCAgICAgMCwgIHIsICB0LFxuXG5cdFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcblx0XHQtciwgLXQsICAwLCAgICAtciwgIHQsICAwLFxuXHRcdCByLCAtdCwgIDAsICAgICByLCAgdCwgIDAsXG5cblx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxuXHRcdC10LCAgMCwgLXIsICAgICB0LCAgMCwgLXIsXG5cdFx0LXQsICAwLCAgciwgICAgIHQsICAwLCAgclxuXHRdO1xuXG5cdHZhciBpbmRpY2VzID0gW1xuXHRcdCAzLCAxMSwgIDcsICAgICAgMywgIDcsIDE1LCAgICAgIDMsIDE1LCAxMyxcblx0XHQgNywgMTksIDE3LCAgICAgIDcsIDE3LCAgNiwgICAgICA3LCAgNiwgMTUsXG5cdFx0MTcsICA0LCAgOCwgICAgIDE3LCAgOCwgMTAsICAgICAxNywgMTAsICA2LFxuXHRcdCA4LCAgMCwgMTYsICAgICAgOCwgMTYsICAyLCAgICAgIDgsICAyLCAxMCxcblx0XHQgMCwgMTIsICAxLCAgICAgIDAsICAxLCAxOCwgICAgICAwLCAxOCwgMTYsXG5cdFx0IDYsIDEwLCAgMiwgICAgICA2LCAgMiwgMTMsICAgICAgNiwgMTMsIDE1LFxuXHRcdCAyLCAxNiwgMTgsICAgICAgMiwgMTgsICAzLCAgICAgIDIsICAzLCAxMyxcblx0XHQxOCwgIDEsICA5LCAgICAgMTgsICA5LCAxMSwgICAgIDE4LCAxMSwgIDMsXG5cdFx0IDQsIDE0LCAxMiwgICAgICA0LCAxMiwgIDAsICAgICAgNCwgIDAsICA4LFxuXHRcdDExLCAgOSwgIDUsICAgICAxMSwgIDUsIDE5LCAgICAgMTEsIDE5LCAgNyxcblx0XHQxOSwgIDUsIDE0LCAgICAgMTksIDE0LCAgNCwgICAgIDE5LCAgNCwgMTcsXG5cdFx0IDEsIDEyLCAxNCwgICAgICAxLCAxNCwgIDUsICAgICAgMSwgIDUsICA5XG5cdF07XG5cblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG59O1xuXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvSWNvc2FoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuXHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXG5cdHZhciB2ZXJ0aWNlcyA9IFtcblx0XHQtIDEsICB0LCAgMCwgICAgMSwgIHQsICAwLCAgIC0gMSwgLSB0LCAgMCwgICAgMSwgLSB0LCAgMCxcblx0XHQgMCwgLSAxLCAgdCwgICAgMCwgIDEsICB0LCAgICAwLCAtIDEsIC0gdCwgICAgMCwgIDEsIC0gdCxcblx0XHQgdCwgIDAsIC0gMSwgICAgdCwgIDAsICAxLCAgIC0gdCwgIDAsIC0gMSwgICAtIHQsICAwLCAgMVxuXHRdO1xuXG5cdHZhciBpbmRpY2VzID0gW1xuXHRcdCAwLCAxMSwgIDUsICAgIDAsICA1LCAgMSwgICAgMCwgIDEsICA3LCAgICAwLCAgNywgMTAsICAgIDAsIDEwLCAxMSxcblx0XHQgMSwgIDUsICA5LCAgICA1LCAxMSwgIDQsICAgMTEsIDEwLCAgMiwgICAxMCwgIDcsICA2LCAgICA3LCAgMSwgIDgsXG5cdFx0IDMsICA5LCAgNCwgICAgMywgIDQsICAyLCAgICAzLCAgMiwgIDYsICAgIDMsICA2LCAgOCwgICAgMywgIDgsICA5LFxuXHRcdCA0LCAgOSwgIDUsICAgIDIsICA0LCAxMSwgICAgNiwgIDIsIDEwLCAgICA4LCAgNiwgIDcsICAgIDksICA4LCAgMVxuXHRdO1xuXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHR0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdGRldGFpbDogZGV0YWlsXG5cdH07XG59O1xuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9PY3RhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0ZGV0YWlsOiBkZXRhaWxcblx0fTtcblxuXHR2YXIgdmVydGljZXMgPSBbXG5cdFx0MSwgMCwgMCwgICAtIDEsIDAsIDAsICAgIDAsIDEsIDAsICAgIDAsLSAxLCAwLCAgICAwLCAwLCAxLCAgICAwLCAwLC0gMVxuXHRdO1xuXG5cdHZhciBpbmRpY2VzID0gW1xuXHRcdDAsIDIsIDQsICAgIDAsIDQsIDMsICAgIDAsIDMsIDUsICAgIDAsIDUsIDIsICAgIDEsIDIsIDUsICAgIDEsIDUsIDMsICAgIDEsIDMsIDQsICAgIDEsIDQsIDJcblx0XTtcblxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0dGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdGRldGFpbDogZGV0YWlsXG5cdH07XG59O1xuXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RldHJhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0dmFyIHZlcnRpY2VzID0gW1xuXHRcdCAxLCAgMSwgIDEsICAgLSAxLCAtIDEsICAxLCAgIC0gMSwgIDEsIC0gMSwgICAgMSwgLSAxLCAtIDFcblx0XTtcblxuXHR2YXIgaW5kaWNlcyA9IFtcblx0XHQgMiwgIDEsICAwLCAgICAwLCAgMywgIDIsICAgIDEsICAzLCAgMCwgICAgMiwgIDMsICAxXG5cdF07XG5cblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0ZGV0YWlsOiBkZXRhaWxcblx0fTtcblxufTtcblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGFyYW1ldHJpY0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcbiAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XG4gKlxuICogbmV3IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSggcGFyYW1ldHJpY0Z1bmN0aW9uLCB1U2VnbWVudHMsIHlTZWdlbWVudHMgKTtcbiAqXG4gKi9cblxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1BhcmFtZXRyaWNHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdGZ1bmM6IGZ1bmMsXG5cdFx0c2xpY2VzOiBzbGljZXMsXG5cdFx0c3RhY2tzOiBzdGFja3Ncblx0fTtcblxuXHR2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuXHR2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuXHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XG5cblx0dmFyIGksIGlsLCBqLCBwO1xuXHR2YXIgdSwgdjtcblxuXHR2YXIgc3RhY2tDb3VudCA9IHN0YWNrcyArIDE7XG5cdHZhciBzbGljZUNvdW50ID0gc2xpY2VzICsgMTtcblxuXHRmb3IgKCBpID0gMDsgaSA8PSBzdGFja3M7IGkgKysgKSB7XG5cblx0XHR2ID0gaSAvIHN0YWNrcztcblxuXHRcdGZvciAoIGogPSAwOyBqIDw9IHNsaWNlczsgaiArKyApIHtcblxuXHRcdFx0dSA9IGogLyBzbGljZXM7XG5cblx0XHRcdHAgPSBmdW5jKCB1LCB2ICk7XG5cdFx0XHR2ZXJ0cy5wdXNoKCBwICk7XG5cblx0XHR9XG5cdH1cblxuXHR2YXIgYSwgYiwgYywgZDtcblx0dmFyIHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuXHRmb3IgKCBpID0gMDsgaSA8IHN0YWNrczsgaSArKyApIHtcblxuXHRcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xuXG5cdFx0XHRhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xuXHRcdFx0YiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XG5cdFx0XHRjID0gKGkgKyAxKSAqIHNsaWNlQ291bnQgKyBqICsgMTtcblx0XHRcdGQgPSAoaSArIDEpICogc2xpY2VDb3VudCArIGo7XG5cblx0XHRcdHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XG5cdFx0XHR1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XG5cdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcblx0XHRcdHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcblxuXHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcblx0XHRcdHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG5cdFx0XHRmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuXHRcdFx0dXZzLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBjb25zb2xlLmxvZyh0aGlzKTtcblxuXHQvLyBtYWdpYyBidWxsZXRcblx0Ly8gdmFyIGRpZmYgPSB0aGlzLm1lcmdlVmVydGljZXMoKTtcblx0Ly8gY29uc29sZS5sb2coJ3JlbW92ZWQgJywgZGlmZiwgJyB2ZXJ0aWNlcyBieSBtZXJnaW5nJyk7XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0F4aXNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF4aXNIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0c2l6ZSA9IHNpemUgfHwgMTtcblxuXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0MCwgMCwgMCwgIHNpemUsIDAsIDAsXG5cdFx0MCwgMCwgMCwgIDAsIHNpemUsIDAsXG5cdFx0MCwgMCwgMCwgIDAsIDAsIHNpemVcblx0XSApO1xuXG5cdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0MSwgMCwgMCwgIDEsIDAuNiwgMCxcblx0XHQwLCAxLCAwLCAgMC42LCAxLCAwLFxuXHRcdDAsIDAsIDEsICAwLCAwLjYsIDFcblx0XSApO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XG5cblx0VEhSRUUuTGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIFRIUkVFLkxpbmVQaWVjZXMgKTtcblxufTtcblxuVEhSRUUuQXhpc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9BcnJvd0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJvdyBmb3IgdmlzdWFsaXppbmcgZGlyZWN0aW9uc1xuICpcbiAqIFBhcmFtZXRlcnM6XG4gKiAgZGlyIC0gVmVjdG9yM1xuICogIG9yaWdpbiAtIFZlY3RvcjNcbiAqICBsZW5ndGggLSBOdW1iZXJcbiAqICBjb2xvciAtIGNvbG9yIGluIGhleCB2YWx1ZVxuICogIGhlYWRMZW5ndGggLSBOdW1iZXJcbiAqICBoZWFkV2lkdGggLSBOdW1iZXJcbiAqL1xuXG5USFJFRS5BcnJvd0hlbHBlciA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0bGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcblxuXHR2YXIgY29uZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDAuNSwgMSwgNSwgMSApO1xuXHRjb25lR2VvbWV0cnkuYXBwbHlNYXRyaXgoIG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKCAwLCAtIDAuNSwgMCApICk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggZGlyLCBvcmlnaW4sIGxlbmd0aCwgY29sb3IsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuXHRcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XG5cdFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IDE7XG5cdFx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xuXHRcdGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBvcmlnaW4gKTtcblxuXHRcdHRoaXMubGluZSA9IG5ldyBUSFJFRS5MaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cdFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmFkZCggdGhpcy5saW5lICk7XG5cblx0XHR0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuXHRcdHRoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG5cdFx0dGhpcy5zZXREaXJlY3Rpb24oIGRpciApO1xuXHRcdHRoaXMuc2V0TGVuZ3RoKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xuXG5cdH1cblxufSgpICk7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgcmFkaWFucztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBkaXIgKSB7XG5cblx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xuXG5cdFx0fSBlbHNlIGlmICggZGlyLnkgPCAtIDAuOTk5OTkgKSB7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGF4aXMuc2V0KCBkaXIueiwgMCwgLSBkaXIueCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRyYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgcmFkaWFucyApO1xuXG5cdFx0fVxuXG5cdH07XG5cbn0oKSApO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuXHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG5cdGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG5cdHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIGxlbmd0aCwgMSApO1xuXHR0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XG5cblx0dGhpcy5jb25lLnNjYWxlLnNldCggaGVhZFdpZHRoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcblx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XG5cdHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcblxufTtcblxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3hIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkJveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIDcyICksIDMgKSApO1xuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApLCBUSFJFRS5MaW5lUGllY2VzICk7XG5cblx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHRoaXMudXBkYXRlKCBvYmplY3QgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xuXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0fVxuXG5cdHZhciBtaW4gPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5taW47XG5cdHZhciBtYXggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5tYXg7XG5cblx0Lypcblx0ICA1X19fXzRcblx0MS9fX18wL3xcblx0fCA2X198Xzdcblx0Mi9fX18zL1xuXG5cdDA6IG1heC54LCBtYXgueSwgbWF4Lnpcblx0MTogbWluLngsIG1heC55LCBtYXguelxuXHQyOiBtaW4ueCwgbWluLnksIG1heC56XG5cdDM6IG1heC54LCBtaW4ueSwgbWF4Lnpcblx0NDogbWF4LngsIG1heC55LCBtaW4uelxuXHQ1OiBtaW4ueCwgbWF4LnksIG1pbi56XG5cdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcblx0NzogbWF4LngsIG1pbi55LCBtaW4uelxuXHQqL1xuXG5cdHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHR2ZXJ0aWNlc1sgIDAgXSA9IG1heC54OyB2ZXJ0aWNlc1sgIDEgXSA9IG1heC55OyB2ZXJ0aWNlc1sgIDIgXSA9IG1heC56O1xuXHR2ZXJ0aWNlc1sgIDMgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgIDQgXSA9IG1heC55OyB2ZXJ0aWNlc1sgIDUgXSA9IG1heC56O1xuXG5cdHZlcnRpY2VzWyAgNiBdID0gbWluLng7IHZlcnRpY2VzWyAgNyBdID0gbWF4Lnk7IHZlcnRpY2VzWyAgOCBdID0gbWF4Lno7XG5cdHZlcnRpY2VzWyAgOSBdID0gbWluLng7IHZlcnRpY2VzWyAxMCBdID0gbWluLnk7IHZlcnRpY2VzWyAxMSBdID0gbWF4Lno7XG5cblx0dmVydGljZXNbIDEyIF0gPSBtaW4ueDsgdmVydGljZXNbIDEzIF0gPSBtaW4ueTsgdmVydGljZXNbIDE0IF0gPSBtYXguejtcblx0dmVydGljZXNbIDE1IF0gPSBtYXgueDsgdmVydGljZXNbIDE2IF0gPSBtaW4ueTsgdmVydGljZXNbIDE3IF0gPSBtYXguejtcblxuXHR2ZXJ0aWNlc1sgMTggXSA9IG1heC54OyB2ZXJ0aWNlc1sgMTkgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMjAgXSA9IG1heC56O1xuXHR2ZXJ0aWNlc1sgMjEgXSA9IG1heC54OyB2ZXJ0aWNlc1sgMjIgXSA9IG1heC55OyB2ZXJ0aWNlc1sgMjMgXSA9IG1heC56O1xuXG5cdC8vXG5cblx0dmVydGljZXNbIDI0IF0gPSBtYXgueDsgdmVydGljZXNbIDI1IF0gPSBtYXgueTsgdmVydGljZXNbIDI2IF0gPSBtaW4uejtcblx0dmVydGljZXNbIDI3IF0gPSBtaW4ueDsgdmVydGljZXNbIDI4IF0gPSBtYXgueTsgdmVydGljZXNbIDI5IF0gPSBtaW4uejtcblxuXHR2ZXJ0aWNlc1sgMzAgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMzEgXSA9IG1heC55OyB2ZXJ0aWNlc1sgMzIgXSA9IG1pbi56O1xuXHR2ZXJ0aWNlc1sgMzMgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMzQgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMzUgXSA9IG1pbi56O1xuXG5cdHZlcnRpY2VzWyAzNiBdID0gbWluLng7IHZlcnRpY2VzWyAzNyBdID0gbWluLnk7IHZlcnRpY2VzWyAzOCBdID0gbWluLno7XG5cdHZlcnRpY2VzWyAzOSBdID0gbWF4Lng7IHZlcnRpY2VzWyA0MCBdID0gbWluLnk7IHZlcnRpY2VzWyA0MSBdID0gbWluLno7XG5cblx0dmVydGljZXNbIDQyIF0gPSBtYXgueDsgdmVydGljZXNbIDQzIF0gPSBtaW4ueTsgdmVydGljZXNbIDQ0IF0gPSBtaW4uejtcblx0dmVydGljZXNbIDQ1IF0gPSBtYXgueDsgdmVydGljZXNbIDQ2IF0gPSBtYXgueTsgdmVydGljZXNbIDQ3IF0gPSBtaW4uejtcblxuXHQvL1xuXG5cdHZlcnRpY2VzWyA0OCBdID0gbWF4Lng7IHZlcnRpY2VzWyA0OSBdID0gbWF4Lnk7IHZlcnRpY2VzWyA1MCBdID0gbWF4Lno7XG5cdHZlcnRpY2VzWyA1MSBdID0gbWF4Lng7IHZlcnRpY2VzWyA1MiBdID0gbWF4Lnk7IHZlcnRpY2VzWyA1MyBdID0gbWluLno7XG5cblx0dmVydGljZXNbIDU0IF0gPSBtaW4ueDsgdmVydGljZXNbIDU1IF0gPSBtYXgueTsgdmVydGljZXNbIDU2IF0gPSBtYXguejtcblx0dmVydGljZXNbIDU3IF0gPSBtaW4ueDsgdmVydGljZXNbIDU4IF0gPSBtYXgueTsgdmVydGljZXNbIDU5IF0gPSBtaW4uejtcblxuXHR2ZXJ0aWNlc1sgNjAgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgNjEgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgNjIgXSA9IG1heC56O1xuXHR2ZXJ0aWNlc1sgNjMgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgNjQgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgNjUgXSA9IG1pbi56O1xuXG5cdHZlcnRpY2VzWyA2NiBdID0gbWF4Lng7IHZlcnRpY2VzWyA2NyBdID0gbWluLnk7IHZlcnRpY2VzWyA2OCBdID0gbWF4Lno7XG5cdHZlcnRpY2VzWyA2OSBdID0gbWF4Lng7IHZlcnRpY2VzWyA3MCBdID0gbWluLnk7IHZlcnRpY2VzWyA3MSBdID0gbWluLno7XG5cblx0dGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm91bmRpbmdCb3hIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG4vLyBhIGhlbHBlciB0byBzaG93IHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhbiBvYmplY3RcblxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xuXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ODg4ODg4O1xuXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdHRoaXMuYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApLCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB3aXJlZnJhbWU6IHRydWUgfSApICk7XG5cbn07XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5ib3guc2V0RnJvbU9iamVjdCggdGhpcy5vYmplY3QgKTtcblxuXHR0aGlzLmJveC5zaXplKCB0aGlzLnNjYWxlICk7XG5cblx0dGhpcy5ib3guY2VudGVyKCB0aGlzLnBvc2l0aW9uICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0NhbWVyYUhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICpcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxuICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xuICogXHQtIGJhc2VkIG9uIGZydXN0dW0gdmlzdWFsaXphdGlvbiBpbiBsaWdodGdsLmpzIHNoYWRvd21hcCBleGFtcGxlXG4gKlx0XHRodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9saWdodGdsLmpzL3Rlc3RzL3NoYWRvd21hcC5odG1sXG4gKi9cblxuVEhSRUUuQ2FtZXJhSGVscGVyID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycyB9ICk7XG5cblx0dmFyIHBvaW50TWFwID0ge307XG5cblx0Ly8gY29sb3JzXG5cblx0dmFyIGhleEZydXN0dW0gPSAweGZmYWEwMDtcblx0dmFyIGhleENvbmUgPSAweGZmMDAwMDtcblx0dmFyIGhleFVwID0gMHgwMGFhZmY7XG5cdHZhciBoZXhUYXJnZXQgPSAweGZmZmZmZjtcblx0dmFyIGhleENyb3NzID0gMHgzMzMzMzM7XG5cblx0Ly8gbmVhclxuXG5cdGFkZExpbmUoIFwibjFcIiwgXCJuMlwiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjJcIiwgXCJuNFwiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjRcIiwgXCJuM1wiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjNcIiwgXCJuMVwiLCBoZXhGcnVzdHVtICk7XG5cblx0Ly8gZmFyXG5cblx0YWRkTGluZSggXCJmMVwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJmMlwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJmNFwiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJmM1wiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcblxuXHQvLyBzaWRlc1xuXG5cdGFkZExpbmUoIFwibjFcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjJcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjNcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XG5cdGFkZExpbmUoIFwibjRcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XG5cblx0Ly8gY29uZVxuXG5cdGFkZExpbmUoIFwicFwiLCBcIm4xXCIsIGhleENvbmUgKTtcblx0YWRkTGluZSggXCJwXCIsIFwibjJcIiwgaGV4Q29uZSApO1xuXHRhZGRMaW5lKCBcInBcIiwgXCJuM1wiLCBoZXhDb25lICk7XG5cdGFkZExpbmUoIFwicFwiLCBcIm40XCIsIGhleENvbmUgKTtcblxuXHQvLyB1cFxuXG5cdGFkZExpbmUoIFwidTFcIiwgXCJ1MlwiLCBoZXhVcCApO1xuXHRhZGRMaW5lKCBcInUyXCIsIFwidTNcIiwgaGV4VXAgKTtcblx0YWRkTGluZSggXCJ1M1wiLCBcInUxXCIsIGhleFVwICk7XG5cblx0Ly8gdGFyZ2V0XG5cblx0YWRkTGluZSggXCJjXCIsIFwidFwiLCBoZXhUYXJnZXQgKTtcblx0YWRkTGluZSggXCJwXCIsIFwiY1wiLCBoZXhDcm9zcyApO1xuXG5cdC8vIGNyb3NzXG5cblx0YWRkTGluZSggXCJjbjFcIiwgXCJjbjJcIiwgaGV4Q3Jvc3MgKTtcblx0YWRkTGluZSggXCJjbjNcIiwgXCJjbjRcIiwgaGV4Q3Jvc3MgKTtcblxuXHRhZGRMaW5lKCBcImNmMVwiLCBcImNmMlwiLCBoZXhDcm9zcyApO1xuXHRhZGRMaW5lKCBcImNmM1wiLCBcImNmNFwiLCBoZXhDcm9zcyApO1xuXG5cdGZ1bmN0aW9uIGFkZExpbmUoIGEsIGIsIGhleCApIHtcblxuXHRcdGFkZFBvaW50KCBhLCBoZXggKTtcblx0XHRhZGRQb2ludCggYiwgaGV4ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFBvaW50KCBpZCwgaGV4ICkge1xuXG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XG5cblx0XHRpZiAoIHBvaW50TWFwWyBpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XG5cblx0XHR9XG5cblx0XHRwb2ludE1hcFsgaWQgXS5wdXNoKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XG5cblx0fVxuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsLCBUSFJFRS5MaW5lUGllY2VzICk7XG5cblx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cdHRoaXMubWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHR0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XG5cblx0dGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XG5cblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XG5cdFxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcblxuXHR2YXIgc2V0UG9pbnQgPSBmdW5jdGlvbiAoIHBvaW50LCB4LCB5LCB6ICkge1xuXG5cdFx0dmVjdG9yLnNldCggeCwgeSwgeiApLnVucHJvamVjdCggY2FtZXJhICk7XG5cblx0XHR2YXIgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XG5cblx0XHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzWyBwb2ludHNbIGkgXSBdLmNvcHkoIHZlY3RvciApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0Z2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcblxuXHRcdHZhciB3ID0gMSwgaCA9IDE7XG5cblx0XHQvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4XG5cdFx0Ly8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcblxuXHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdC8vIGNlbnRlciAvIHRhcmdldFxuXG5cdFx0c2V0UG9pbnQoIFwiY1wiLCAwLCAwLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJ0XCIsIDAsIDAsICAxICk7XG5cblx0XHQvLyBuZWFyXG5cblx0XHRzZXRQb2ludCggXCJuMVwiLCAtIHcsIC0gaCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwibjJcIiwgICB3LCAtIGgsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcIm4zXCIsIC0gdywgICBoLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJuNFwiLCAgIHcsICAgaCwgLSAxICk7XG5cblx0XHQvLyBmYXJcblxuXHRcdHNldFBvaW50KCBcImYxXCIsIC0gdywgLSBoLCAxICk7XG5cdFx0c2V0UG9pbnQoIFwiZjJcIiwgICB3LCAtIGgsIDEgKTtcblx0XHRzZXRQb2ludCggXCJmM1wiLCAtIHcsICAgaCwgMSApO1xuXHRcdHNldFBvaW50KCBcImY0XCIsICAgdywgICBoLCAxICk7XG5cblx0XHQvLyB1cFxuXG5cdFx0c2V0UG9pbnQoIFwidTFcIiwgICB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJ1MlwiLCAtIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcInUzXCIsICAgICAgICAgMCwgaCAqIDIsICAgLSAxICk7XG5cblx0XHQvLyBjcm9zc1xuXG5cdFx0c2V0UG9pbnQoIFwiY2YxXCIsIC0gdywgICAwLCAxICk7XG5cdFx0c2V0UG9pbnQoIFwiY2YyXCIsICAgdywgICAwLCAxICk7XG5cdFx0c2V0UG9pbnQoIFwiY2YzXCIsICAgMCwgLSBoLCAxICk7XG5cdFx0c2V0UG9pbnQoIFwiY2Y0XCIsICAgMCwgICBoLCAxICk7XG5cblx0XHRzZXRQb2ludCggXCJjbjFcIiwgLSB3LCAgIDAsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcImNuMlwiLCAgIHcsICAgMCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwiY24zXCIsICAgMCwgLSBoLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJjbjRcIiwgICAwLCAgIGgsIC0gMSApO1xuXG5cdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHR9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0RpcmVjdGlvbmFsTGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzaXplICkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRzaXplID0gc2l6ZSB8fCAxO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsICAgc2l6ZSwgMCApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAgIHNpemUsICAgc2l6ZSwgMCApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAgIHNpemUsIC0gc2l6ZSwgMCApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsIC0gc2l6ZSwgMCApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsICAgc2l6ZSwgMCApXG5cdCk7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0dGhpcy5saWdodFBsYW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHR0aGlzLmFkZCggdGhpcy5saWdodFBsYW5lICk7XG5cblx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcblx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKClcblx0KTtcblxuXHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0dGhpcy5hZGQoIHRoaXMudGFyZ2V0TGluZSApO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblx0XHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0djMuc3ViVmVjdG9ycyggdjIsIHYxICk7XG5cblx0XHR0aGlzLmxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xuXHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbIDEgXS5jb3B5KCB2MyApO1xuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IgKTtcblxuXHR9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0VkZ2VzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuRWRnZXNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xuXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZmZmO1xuXG5cdHZhciBlZGdlID0gWyAwLCAwIF0sIGhhc2ggPSB7fTtcblx0dmFyIHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uICggYSwgYiApIHsgcmV0dXJuIGEgLSBiIH07XG5cblx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0dmFyIGdlb21ldHJ5MiA9IG9iamVjdC5nZW9tZXRyeS5jbG9uZSgpO1xuXG5cdGdlb21ldHJ5Mi5tZXJnZVZlcnRpY2VzKCk7XG5cdGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XG5cdHZhciBmYWNlcyA9IGdlb21ldHJ5Mi5mYWNlcztcblx0dmFyIG51bUVkZ2VzID0gMDtcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0ZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG5cdFx0XHRlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcblx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cblx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cblx0XHRcdGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRoYXNoWyBrZXkgXSA9IHsgdmVydDE6IGVkZ2VbIDAgXSwgdmVydDI6IGVkZ2VbIDEgXSwgZmFjZTE6IGksIGZhY2UyOiB1bmRlZmluZWQgfTtcblx0XHRcdFx0bnVtRWRnZXMgKys7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aGFzaFsga2V5IF0uZmFjZTIgPSBpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cblx0dmFyIGluZGV4ID0gMDtcblxuXHRmb3IgKCB2YXIga2V5IGluIGhhc2ggKSB7XG5cblx0XHR2YXIgaCA9IGhhc2hbIGtleSBdO1xuXG5cdFx0aWYgKCBoLmZhY2UyID09PSB1bmRlZmluZWQgfHwgZmFjZXNbIGguZmFjZTEgXS5ub3JtYWwuZG90KCBmYWNlc1sgaC5mYWNlMiBdLm5vcm1hbCApIDwgMC45OTk5ICkgeyAvLyBoYXJkd2lyZWQgY29uc3QgT0tcblxuXHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQxIF07XG5cdFx0XHRjb29yZHNbIGluZGV4ICsrIF0gPSB2ZXJ0ZXgueDtcblx0XHRcdGNvb3Jkc1sgaW5kZXggKysgXSA9IHZlcnRleC55O1xuXHRcdFx0Y29vcmRzWyBpbmRleCArKyBdID0gdmVydGV4Lno7XG5cblx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQyIF07XG5cdFx0XHRjb29yZHNbIGluZGV4ICsrIF0gPSB2ZXJ0ZXgueDtcblx0XHRcdGNvb3Jkc1sgaW5kZXggKysgXSA9IHZlcnRleC55O1xuXHRcdFx0Y29vcmRzWyBpbmRleCArKyBdID0gdmVydGV4Lno7XG5cblx0XHR9XG5cblx0fVxuXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSwgVEhSRUUuTGluZVBpZWNlcyApO1xuXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuRWRnZXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRmFjZU5vcm1hbHNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XG5cblx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuXHR2YXIgZmFjZXMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5mYWNlcztcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXG5cdH1cblxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSwgVEhSRUUuTGluZVBpZWNlcyApO1xuXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHRoaXMubm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuXHR0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0dmFyIG9iamVjdCA9IHRoaXMub2JqZWN0O1xuXHR2YXIgb2JqZWN0VmVydGljZXMgPSBvYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cdHZhciBvYmplY3RGYWNlcyA9IG9iamVjdC5nZW9tZXRyeS5mYWNlcztcblx0dmFyIG9iamVjdFdvcmxkTWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG5cdG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdHRoaXMubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0V29ybGRNYXRyaXggKTtcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGkyID0gMCwgbCA9IG9iamVjdEZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKyssIGkyICs9IDIgKSB7XG5cblx0XHR2YXIgZmFjZSA9IG9iamVjdEZhY2VzWyBpIF07XG5cblx0XHR2ZXJ0aWNlc1sgaTIgXS5jb3B5KCBvYmplY3RWZXJ0aWNlc1sgZmFjZS5hIF0gKVxuXHRcdFx0LmFkZCggb2JqZWN0VmVydGljZXNbIGZhY2UuYiBdIClcblx0XHRcdC5hZGQoIG9iamVjdFZlcnRpY2VzWyBmYWNlLmMgXSApXG5cdFx0XHQuZGl2aWRlU2NhbGFyKCAzIClcblx0XHRcdC5hcHBseU1hdHJpeDQoIG9iamVjdFdvcmxkTWF0cml4ICk7XG5cblx0XHR2ZXJ0aWNlc1sgaTIgKyAxIF0uY29weSggZmFjZS5ub3JtYWwgKVxuXHRcdFx0LmFwcGx5TWF0cml4MyggdGhpcy5ub3JtYWxNYXRyaXggKVxuXHRcdFx0Lm5vcm1hbGl6ZSgpXG5cdFx0XHQubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApXG5cdFx0XHQuYWRkKCB2ZXJ0aWNlc1sgaTIgXSApO1xuXG5cdH1cblxuXHR0aGlzLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvR3JpZEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuR3JpZEhlbHBlciA9IGZ1bmN0aW9uICggc2l6ZSwgc3RlcCApIHtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzIH0gKTtcblxuXHR0aGlzLmNvbG9yMSA9IG5ldyBUSFJFRS5Db2xvciggMHg0NDQ0NDQgKTtcblx0dGhpcy5jb2xvcjIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ODg4ODg4ICk7XG5cblx0Zm9yICggdmFyIGkgPSAtIHNpemU7IGkgPD0gc2l6ZTsgaSArPSBzdGVwICkge1xuXG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIHNpemUsIDAsIGkgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIHNpemUsIDAsIGkgKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCAtIHNpemUgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIGksIDAsIHNpemUgKVxuXHRcdCk7XG5cblx0XHR2YXIgY29sb3IgPSBpID09PSAwID8gdGhpcy5jb2xvcjEgOiB0aGlzLmNvbG9yMjtcblxuXHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yLCBjb2xvciApO1xuXG5cdH1cblxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCwgVEhSRUUuTGluZVBpZWNlcyApO1xuXG59O1xuXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XG5cblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uKCBjb2xvckNlbnRlckxpbmUsIGNvbG9yR3JpZCApIHtcblxuXHR0aGlzLmNvbG9yMS5zZXQoIGNvbG9yQ2VudGVyTGluZSApO1xuXHR0aGlzLmNvbG9yMi5zZXQoIGNvbG9yR3JpZCApO1xuXG5cdHRoaXMuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbn1cblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvSGVtaXNwaGVyZUxpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSwgYXJyb3dMZW5ndGgsIGRvbWVTaXplICkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHR0aGlzLmNvbG9ycyA9IFsgbmV3IFRIUkVFLkNvbG9yKCksIG5ldyBUSFJFRS5Db2xvcigpIF07XG5cblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG5cdGdlb21ldHJ5LmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvblgoIC0gTWF0aC5QSSAvIDIgKSApO1xuXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSA4OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRnZW9tZXRyeS5mYWNlc1sgaSBdLmNvbG9yID0gdGhpcy5jb2xvcnNbIGkgPCA0ID8gMCA6IDEgXTtcblxuXHR9XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycywgd2lyZWZyYW1lOiB0cnVlIH0gKTtcblxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHR0aGlzLmFkZCggdGhpcy5saWdodFNwaGVyZSApO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmxpZ2h0U3BoZXJlLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0dGhpcy5saWdodFNwaGVyZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jb2xvcnNbIDAgXS5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cdFx0dGhpcy5jb2xvcnNbIDEgXS5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0XHR0aGlzLmxpZ2h0U3BoZXJlLmxvb2tBdCggdmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApLm5lZ2F0ZSgpICk7XG5cdFx0dGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cbn0oKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvUG9pbnRMaWdodEhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xuXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy5tYXRyaXggPSB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHQvKlxuXHR2YXIgZGlzdGFuY2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KCAxLCAyICk7XG5cdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XG5cdHRoaXMubGlnaHREaXN0YW5jZSA9IG5ldyBUSFJFRS5NZXNoKCBkaXN0YW5jZUdlb21ldHJ5LCBkaXN0YW5jZU1hdGVyaWFsICk7XG5cblx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblxuXHR9XG5cblx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xuXHQqL1xuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xufTtcblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdC8qXG5cdHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcblxuXHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cblx0fVxuXHQqL1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Ta2VsZXRvbkhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgU2VhbiBHcmlmZmluIC8gaHR0cDovL3R3aXR0ZXIuY29tL3NncmlmXG4gKiBAYXV0aG9yIE1pY2hhZWwgR3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICovXG5cblRIUkVFLlNrZWxldG9uSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0dGhpcy5ib25lcyA9IHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdCApO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cblx0XHRpZiAoIGJvbmUucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdFx0Z2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMCwgMSApICk7XG5cdFx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCAwLCAxLCAwICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsLCBUSFJFRS5MaW5lUGllY2VzICk7XG5cblx0dGhpcy5yb290ID0gb2JqZWN0O1xuXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHR0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5nZXRCb25lTGlzdCA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cblx0dmFyIGJvbmVMaXN0ID0gW107XG5cblx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG5cdFx0Ym9uZUxpc3QucHVzaCggb2JqZWN0ICk7XG5cblx0fVxuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRib25lTGlzdC5wdXNoLmFwcGx5KCBib25lTGlzdCwgdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xuXG5cdH1cblxuXHRyZXR1cm4gYm9uZUxpc3Q7XG5cbn07XG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHR2YXIgbWF0cml4V29ybGRJbnYgPSBuZXcgVEhSRUUuTWF0cml4NCgpLmdldEludmVyc2UoIHRoaXMucm9vdC5tYXRyaXhXb3JsZCApO1xuXG5cdHZhciBib25lTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHR2YXIgaiA9IDA7XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHR2YXIgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuXHRcdGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG5cdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1sgaiBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xuXG5cdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNbIGogKyAxIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cblx0XHRcdGogKz0gMjtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvU3BvdExpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cblRIUkVFLlNwb3RMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAxLCAxLCA4LCAxLCB0cnVlICk7XG5cblx0Z2VvbWV0cnkuYXBwbHlNYXRyaXgoIG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKCAwLCAtIDAuNSwgMCApICk7XG5cdGdlb21ldHJ5LmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvblgoIC0gTWF0aC5QSSAvIDIgKSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xuXG5cdHRoaXMuY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHR0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xufTtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2ZWN0b3IyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDAwO1xuXHRcdHZhciBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4oIHRoaXMubGlnaHQuYW5nbGUgKTtcblxuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XG5cblx0XHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0dmVjdG9yMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR0aGlzLmNvbmUubG9va0F0KCB2ZWN0b3IyLnN1YiggdmVjdG9yICkgKTtcblxuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0fTtcblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhOb3JtYWxzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZjAwMDA7XG5cblx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuXHR2YXIgdmVydGljZXMgPSBvYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0dmFyIGZhY2VzID0gb2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApLCBUSFJFRS5MaW5lUGllY2VzICk7XG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy5ub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG5cdFx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuXG5cdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdHRoaXMubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHR2YXIgdmVydHMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdHZhciBmYWNlcyA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuXG5cdFx0dmFyIHdvcmxkTWF0cml4ID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cblx0XHR2YXIgaWR4ID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4SWQgPSBmYWNlWyBrZXlzWyBqIF0gXTtcblx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRzWyB2ZXJ0ZXhJZCBdO1xuXG5cdFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgaWR4IF0uY29weSggdmVydGV4ICkuYXBwbHlNYXRyaXg0KCB3b3JsZE1hdHJpeCApO1xuXG5cdFx0XHRcdHYxLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4MyggdGhpcy5ub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICk7XG5cblx0XHRcdFx0djEuYWRkKCB2ZXJ0aWNlc1sgaWR4IF0gKTtcblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgaWR4IF0uY29weSggdjEgKTtcblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59KCkpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhUYW5nZW50c0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cblRIUkVFLlZlcnRleFRhbmdlbnRzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcblxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweDAwMDBmZjtcblxuXHR2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdHZhciB2ZXJ0aWNlcyA9IG9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHR2YXIgZmFjZXMgPSBvYmplY3QuZ2VvbWV0cnkuZmFjZXM7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleFRhbmdlbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApLCBUSFJFRS5MaW5lUGllY2VzICk7XG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuXHRcdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnLCAnZCcgXTtcblxuXHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0dmFyIHZlcnRzID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHR2YXIgZmFjZXMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5mYWNlcztcblxuXHRcdHZhciB3b3JsZE1hdHJpeCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG5cdFx0dmFyIGlkeCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleFRhbmdlbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXhJZCA9IGZhY2VbIGtleXNbIGogXSBdO1xuXHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydHNbIHZlcnRleElkIF07XG5cblx0XHRcdFx0dmFyIHRhbmdlbnQgPSBmYWNlLnZlcnRleFRhbmdlbnRzWyBqIF07XG5cblx0XHRcdFx0dmVydGljZXNbIGlkeCBdLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggd29ybGRNYXRyaXggKTtcblxuXHRcdFx0XHR2MS5jb3B5KCB0YW5nZW50ICkudHJhbnNmb3JtRGlyZWN0aW9uKCB3b3JsZE1hdHJpeCApLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKTtcblxuXHRcdFx0XHR2MS5hZGQoIHZlcnRpY2VzWyBpZHggXSApO1xuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdHZlcnRpY2VzWyBpZHggXS5jb3B5KCB2MSApO1xuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn0oKSk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1dpcmVmcmFtZUhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2lyZWZyYW1lSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCApIHtcblxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcblxuXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XG5cdHZhciBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbiAoIGEsIGIgKSB7IHJldHVybiBhIC0gYiB9O1xuXG5cdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG5cdGlmICggb2JqZWN0Lmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgdmVydGljZXMgPSBvYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cdFx0dmFyIGZhY2VzID0gb2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuXHRcdHZhciBudW1FZGdlcyA9IDA7XG5cblx0XHQvLyBhbGxvY2F0ZSBtYXhpbWFsIHNpemVcblx0XHR2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDYgKiBmYWNlcy5sZW5ndGggKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcblx0XHRcdFx0ZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XG5cdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cblx0XHRcdFx0dmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuXHRcdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG5cdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcblx0XHRcdFx0XHRoYXNoWyBrZXkgXSA9IHRydWU7XG5cdFx0XHRcdFx0bnVtRWRnZXMgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZWRnZXMgWyAyICogaSArIGpdIF07XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRleC54O1xuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGV4Lnk7XG5cdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0ZXguejtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG5cdH0gZWxzZSBpZiAoIG9iamVjdC5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0aWYgKCBvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkICkgeyAvLyBJbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IG9iamVjdC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXHRcdFx0dmFyIGluZGljZXMgPSBvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleC5hcnJheTtcblx0XHRcdHZhciBkcmF3Y2FsbHMgPSBvYmplY3QuZ2VvbWV0cnkuZHJhd2NhbGxzO1xuXHRcdFx0dmFyIG51bUVkZ2VzID0gMDtcblxuXHRcdFx0aWYgKCBkcmF3Y2FsbHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdGRyYXdjYWxscyA9IFsgeyBjb3VudCA6IGluZGljZXMubGVuZ3RoLCBpbmRleCA6IDAsIHN0YXJ0IDogMCB9IF07XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG5cdFx0XHR2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBpbmRpY2VzLmxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgbyA9IDAsIG9sID0gZHJhd2NhbGxzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xuXG5cdFx0XHRcdHZhciBzdGFydCA9IGRyYXdjYWxsc1sgbyBdLnN0YXJ0O1xuXHRcdFx0XHR2YXIgY291bnQgPSBkcmF3Y2FsbHNbIG8gXS5jb3VudDtcblx0XHRcdFx0dmFyIGluZGV4ID0gZHJhd2NhbGxzWyBvIF0uaW5kZXg7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGVkZ2VbIDAgXSA9IGluZGV4ICsgaW5kaWNlc1sgaSArIGogXTtcblx0XHRcdFx0XHRcdGVkZ2VbIDEgXSA9IGluZGV4ICsgaW5kaWNlc1sgaSArICggaiArIDEgKSAlIDMgXTtcblx0XHRcdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cblx0XHRcdFx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cblx0XHRcdFx0XHRcdGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG5cdFx0XHRcdFx0XHRcdGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGhhc2hbIGtleSBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0bnVtRWRnZXMgKys7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuXHRcdFx0XHRcdHZhciBpbmRleDIgPSAzICogZWRnZXNbIDIgKiBpICsgal07XG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzWyBpbmRleDIgXTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MiArIDEgXTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXNbIGluZGV4MiArIDIgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG5cdFx0fSBlbHNlIHsgLy8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuXHRcdFx0dmFyIHZlcnRpY2VzID0gb2JqZWN0Lmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cdFx0XHR2YXIgbnVtRWRnZXMgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xuXHRcdFx0dmFyIG51bVRyaXMgPSBudW1FZGdlcyAvIDM7XG5cblx0XHRcdHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bVRyaXM7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSAxOCAqIGkgKyA2ICogajtcblxuXHRcdFx0XHRcdHZhciBpbmRleDEgPSA5ICogaSArIDMgKiBqO1xuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlc1sgaW5kZXgxIF07XG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRpY2VzWyBpbmRleDEgKyAxIF07XG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRpY2VzWyBpbmRleDEgKyAyIF07XG5cblx0XHRcdFx0XHR2YXIgaW5kZXgyID0gOSAqIGkgKyAzICogKCAoIGogKyAxICkgJSAzICk7XG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDMgXSA9IHZlcnRpY2VzWyBpbmRleDIgXTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgNCBdID0gdmVydGljZXNbIGluZGV4MiArIDEgXTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgNSBdID0gdmVydGljZXNbIGluZGV4MiArIDIgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSwgVEhSRUUuTGluZVBpZWNlcyApO1xuXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL0ltbWVkaWF0ZVJlbmRlck9iamVjdC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyQ2FsbGJhY2sgKSB7fTtcblxufTtcblxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvb2JqZWN0cy9Nb3JwaEJsZW5kTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTW9ycGhCbGVuZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy5hbmltYXRpb25zTWFwID0ge307XG5cdHRoaXMuYW5pbWF0aW9uc0xpc3QgPSBbXTtcblxuXHQvLyBwcmVwYXJlIGRlZmF1bHQgYW5pbWF0aW9uXG5cdC8vIChhbGwgZnJhbWVzIHBsYXllZCB0b2dldGhlciBpbiAxIHNlY29uZClcblxuXHR2YXIgbnVtRnJhbWVzID0gdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoO1xuXG5cdHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcblxuXHR2YXIgc3RhcnRGcmFtZSA9IDA7XG5cdHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XG5cblx0dmFyIGZwcyA9IG51bUZyYW1lcyAvIDE7XG5cblx0dGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBmcHMgKTtcblx0dGhpcy5zZXRBbmltYXRpb25XZWlnaHQoIG5hbWUsIDEgKTtcblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNyZWF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSwgc3RhcnQsIGVuZCwgZnBzICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB7XG5cblx0XHRzdGFydEZyYW1lOiBzdGFydCxcblx0XHRlbmRGcmFtZTogZW5kLFxuXG5cdFx0bGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXG5cblx0XHRmcHM6IGZwcyxcblx0XHRkdXJhdGlvbjogKCBlbmQgLSBzdGFydCApIC8gZnBzLFxuXG5cdFx0bGFzdEZyYW1lOiAwLFxuXHRcdGN1cnJlbnRGcmFtZTogMCxcblxuXHRcdGFjdGl2ZTogZmFsc2UsXG5cblx0XHR0aW1lOiAwLFxuXHRcdGRpcmVjdGlvbjogMSxcblx0XHR3ZWlnaHQ6IDEsXG5cblx0XHRkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxuXHRcdG1pcnJvcmVkTG9vcDogZmFsc2VcblxuXHR9O1xuXG5cdHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdID0gYW5pbWF0aW9uO1xuXHR0aGlzLmFuaW1hdGlvbnNMaXN0LnB1c2goIGFuaW1hdGlvbiApO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcblxuXHR2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcblxuXHR2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XG5cblx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XG5cdFx0dmFyIGNodW5rcyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcblxuXHRcdGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHR2YXIgbmFtZSA9IGNodW5rc1sgMSBdO1xuXHRcdFx0dmFyIG51bSA9IGNodW5rc1sgMiBdO1xuXG5cdFx0XHRpZiAoICEgZnJhbWVSYW5nZXNbIG5hbWUgXSApIGZyYW1lUmFuZ2VzWyBuYW1lIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtIEluZmluaXR5IH07XG5cblx0XHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XG5cblx0XHRcdGlmICggaSA8IHJhbmdlLnN0YXJ0ICkgcmFuZ2Uuc3RhcnQgPSBpO1xuXHRcdFx0aWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcblxuXHRcdFx0aWYgKCAhIGZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBuYW1lO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmb3IgKCB2YXIgbmFtZSBpbiBmcmFtZVJhbmdlcyApIHtcblxuXHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XG5cdFx0dGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGZwcyApO1xuXG5cdH1cblxuXHR0aGlzLmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAxO1xuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25CYWNrd2FyZCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cblx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHRhbmltYXRpb24uZGlyZWN0aW9uID0gLSAxO1xuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG5cdH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGFuaW1hdGlvbi5mcHMgPSBmcHM7XG5cdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZnBzO1xuXG5cdH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBkdXJhdGlvbiApIHtcblxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cblx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHRhbmltYXRpb24uZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0XHRhbmltYXRpb24uZnBzID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZHVyYXRpb247XG5cblx0fVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uV2VpZ2h0ID0gZnVuY3Rpb24gKCBuYW1lLCB3ZWlnaHQgKSB7XG5cblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG5cdGlmICggYW5pbWF0aW9uICkge1xuXG5cdFx0YW5pbWF0aW9uLndlaWdodCA9IHdlaWdodDtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGFuaW1hdGlvbi50aW1lID0gdGltZTtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdHZhciB0aW1lID0gMDtcblxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cblx0aWYgKCBhbmltYXRpb24gKSB7XG5cblx0XHR0aW1lID0gYW5pbWF0aW9uLnRpbWU7XG5cblx0fVxuXG5cdHJldHVybiB0aW1lO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0dmFyIGR1cmF0aW9uID0gLSAxO1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG5cdH1cblxuXHRyZXR1cm4gZHVyYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGFuaW1hdGlvbi50aW1lID0gMDtcblx0XHRhbmltYXRpb24uYWN0aXZlID0gdHJ1ZTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc29sZS53YXJuKCBcImFuaW1hdGlvbltcIiArIG5hbWUgKyBcIl0gdW5kZWZpbmVkXCIgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuXHRpZiAoIGFuaW1hdGlvbiApIHtcblxuXHRcdGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcblxuXHR9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmFuaW1hdGlvbnNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc0xpc3RbIGkgXTtcblxuXHRcdGlmICggISBhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XG5cblx0XHR2YXIgZnJhbWVUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uIC8gYW5pbWF0aW9uLmxlbmd0aDtcblxuXHRcdGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kaXJlY3Rpb24gKiBkZWx0YTtcblxuXHRcdGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcblxuXHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiB8fCBhbmltYXRpb24udGltZSA8IDAgKSB7XG5cblx0XHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiAqPSAtIDE7XG5cblx0XHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcblxuXHRcdFx0XHRcdGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIHtcblxuXHRcdFx0XHRcdGFuaW1hdGlvbi50aW1lID0gMDtcblx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG5cdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kdXJhdGlvbjtcblxuXHRcdH1cblxuXHRcdHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydEZyYW1lICsgVEhSRUUuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggYW5pbWF0aW9uLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgYW5pbWF0aW9uLmxlbmd0aCAtIDEgKTtcblx0XHR2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcblxuXHRcdGlmICgga2V5ZnJhbWUgIT09IGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgKSB7XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAwO1xuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IDEgKiB3ZWlnaHQ7XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBrZXlmcmFtZSBdID0gMDtcblxuXHRcdFx0YW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XG5cdFx0XHRhbmltYXRpb24uY3VycmVudEZyYW1lID0ga2V5ZnJhbWU7XG5cblx0XHR9XG5cblx0XHR2YXIgbWl4ID0gKCBhbmltYXRpb24udGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG5cdFx0aWYgKCBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzICkgbWl4ID0gMSAtIG1peDtcblxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XG5cdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9ICggMSAtIG1peCApICogd2VpZ2h0O1xuXG5cdH1cblxufTtcblxuXG4vLyBFeHBvcnQgdGhlIFRIUkVFIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbi8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbi8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcbi8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlLlxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcbiAgfVxuICBleHBvcnRzLlRIUkVFID0gVEhSRUU7XG59IGVsc2Uge1xuICB0aGlzWydUSFJFRSddID0gVEhSRUU7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiSXJYVXN1XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvbm9kZV9tb2R1bGVzL3RocmVlL3RocmVlLmpzXCIsXCIvbm9kZV9tb2R1bGVzL3RocmVlXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuIWZ1bmN0aW9uKCkge1xuICB2YXIgdG9wb2pzb24gPSB7XG4gICAgdmVyc2lvbjogXCIxLjYuMThcIixcbiAgICBtZXNoOiBmdW5jdGlvbih0b3BvbG9neSkgeyByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXNoQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsgfSxcbiAgICBtZXNoQXJjczogbWVzaEFyY3MsXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKHRvcG9sb2d5KSB7IHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lcmdlQXJjcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTsgfSxcbiAgICBtZXJnZUFyY3M6IG1lcmdlQXJjcyxcbiAgICBmZWF0dXJlOiBmZWF0dXJlT3JDb2xsZWN0aW9uLFxuICAgIG5laWdoYm9yczogbmVpZ2hib3JzLFxuICAgIHByZXNpbXBsaWZ5OiBwcmVzaW1wbGlmeVxuICB9O1xuXG4gIGZ1bmN0aW9uIHN0aXRjaEFyY3ModG9wb2xvZ3ksIGFyY3MpIHtcbiAgICB2YXIgc3RpdGNoZWRBcmNzID0ge30sXG4gICAgICAgIGZyYWdtZW50QnlTdGFydCA9IHt9LFxuICAgICAgICBmcmFnbWVudEJ5RW5kID0ge30sXG4gICAgICAgIGZyYWdtZW50cyA9IFtdLFxuICAgICAgICBlbXB0eUluZGV4ID0gLTE7XG5cbiAgICAvLyBTdGl0Y2ggZW1wdHkgYXJjcyBmaXJzdCwgc2luY2UgdGhleSBtYXkgYmUgc3Vic3VtZWQgYnkgb3RoZXIgYXJjcy5cbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSwgaikge1xuICAgICAgdmFyIGFyYyA9IHRvcG9sb2d5LmFyY3NbaSA8IDAgPyB+aSA6IGldLCB0O1xuICAgICAgaWYgKGFyYy5sZW5ndGggPCAzICYmICFhcmNbMV1bMF0gJiYgIWFyY1sxXVsxXSkge1xuICAgICAgICB0ID0gYXJjc1srK2VtcHR5SW5kZXhdLCBhcmNzW2VtcHR5SW5kZXhdID0gaSwgYXJjc1tqXSA9IHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIGUgPSBlbmRzKGkpLFxuICAgICAgICAgIHN0YXJ0ID0gZVswXSxcbiAgICAgICAgICBlbmQgPSBlWzFdLFxuICAgICAgICAgIGYsIGc7XG5cbiAgICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgICBmLnB1c2goaSk7XG4gICAgICAgIGYuZW5kID0gZW5kO1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XTtcbiAgICAgICAgICB2YXIgZmcgPSBnID09PSBmID8gZiA6IGYuY29uY2F0KGcpO1xuICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtmZy5zdGFydCA9IGYuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmZy5lbmQgPSBnLmVuZF0gPSBmZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZiA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICAgIGYudW5zaGlmdChpKTtcbiAgICAgICAgZi5zdGFydCA9IHN0YXJ0O1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuICAgICAgICAgIHZhciBnZiA9IGcgPT09IGYgPyBmIDogZy5jb25jYXQoZik7XG4gICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2dmLnN0YXJ0ID0gZy5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2dmLmVuZCA9IGYuZW5kXSA9IGdmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZiA9IFtpXTtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnQgPSBzdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kID0gZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBlbmRzKGkpIHtcbiAgICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgcDAgPSBhcmNbMF0sIHAxO1xuICAgICAgaWYgKHRvcG9sb2d5LnRyYW5zZm9ybSkgcDEgPSBbMCwgMF0sIGFyYy5mb3JFYWNoKGZ1bmN0aW9uKGRwKSB7IHAxWzBdICs9IGRwWzBdLCBwMVsxXSArPSBkcFsxXTsgfSk7XG4gICAgICBlbHNlIHAxID0gYXJjW2FyYy5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiBpIDwgMCA/IFtwMSwgcDBdIDogW3AwLCBwMV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KSB7XG4gICAgICBmb3IgKHZhciBrIGluIGZyYWdtZW50QnlFbmQpIHtcbiAgICAgICAgdmFyIGYgPSBmcmFnbWVudEJ5RW5kW2tdO1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgICBkZWxldGUgZi5zdGFydDtcbiAgICAgICAgZGVsZXRlIGYuZW5kO1xuICAgICAgICBmLmZvckVhY2goZnVuY3Rpb24oaSkgeyBzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldID0gMTsgfSk7XG4gICAgICAgIGZyYWdtZW50cy5wdXNoKGYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCk7XG4gICAgZmx1c2goZnJhZ21lbnRCeVN0YXJ0LCBmcmFnbWVudEJ5RW5kKTtcbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkgeyBpZiAoIXN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0pIGZyYWdtZW50cy5wdXNoKFtpXSk7IH0pO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lc2hBcmNzKHRvcG9sb2d5LCBvLCBmaWx0ZXIpIHtcbiAgICB2YXIgYXJjcyA9IFtdO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgZ2VvbXNCeUFyYyA9IFtdLFxuICAgICAgICAgIGdlb207XG5cbiAgICAgIGZ1bmN0aW9uIGFyYyhpKSB7XG4gICAgICAgIHZhciBqID0gaSA8IDAgPyB+aSA6IGk7XG4gICAgICAgIChnZW9tc0J5QXJjW2pdIHx8IChnZW9tc0J5QXJjW2pdID0gW10pKS5wdXNoKHtpOiBpLCBnOiBnZW9tfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgICAgICBhcmNzLmZvckVhY2goYXJjKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcG9seWdvbihhcmNzKSB7XG4gICAgICAgIGFyY3MuZm9yRWFjaChsaW5lKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2VvbWV0cnkobykge1xuICAgICAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7XG4gICAgICAgIGVsc2UgaWYgKG8udHlwZSBpbiBnZW9tZXRyeVR5cGUpIGdlb20gPSBvLCBnZW9tZXRyeVR5cGVbby50eXBlXShvLmFyY3MpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgICAgICBMaW5lU3RyaW5nOiBsaW5lLFxuICAgICAgICBNdWx0aUxpbmVTdHJpbmc6IHBvbHlnb24sXG4gICAgICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24oYXJjcykgeyBhcmNzLmZvckVhY2gocG9seWdvbik7IH1cbiAgICAgIH07XG5cbiAgICAgIGdlb21ldHJ5KG8pO1xuXG4gICAgICBnZW9tc0J5QXJjLmZvckVhY2goYXJndW1lbnRzLmxlbmd0aCA8IDNcbiAgICAgICAgICA/IGZ1bmN0aW9uKGdlb21zKSB7IGFyY3MucHVzaChnZW9tc1swXS5pKTsgfVxuICAgICAgICAgIDogZnVuY3Rpb24oZ2VvbXMpIHsgaWYgKGZpbHRlcihnZW9tc1swXS5nLCBnZW9tc1tnZW9tcy5sZW5ndGggLSAxXS5nKSkgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3BvbG9neS5hcmNzLmxlbmd0aDsgaSA8IG47ICsraSkgYXJjcy5wdXNoKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgYXJjczogc3RpdGNoQXJjcyh0b3BvbG9neSwgYXJjcyl9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VBcmNzKHRvcG9sb2d5LCBvYmplY3RzKSB7XG4gICAgdmFyIHBvbHlnb25zQnlBcmMgPSB7fSxcbiAgICAgICAgcG9seWdvbnMgPSBbXSxcbiAgICAgICAgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmIChvLnR5cGUgPT09IFwiUG9seWdvblwiKSByZWdpc3RlcihvLmFyY3MpO1xuICAgICAgZWxzZSBpZiAoby50eXBlID09PSBcIk11bHRpUG9seWdvblwiKSBvLmFyY3MuZm9yRWFjaChyZWdpc3Rlcik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWdpc3Rlcihwb2x5Z29uKSB7XG4gICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgKHBvbHlnb25zQnlBcmNbYXJjID0gYXJjIDwgMCA/IH5hcmMgOiBhcmNdIHx8IChwb2x5Z29uc0J5QXJjW2FyY10gPSBbXSkpLnB1c2gocG9seWdvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVyaW9yKHJpbmcpIHtcbiAgICAgIHJldHVybiBjYXJ0ZXNpYW5SaW5nQXJlYShvYmplY3QodG9wb2xvZ3ksIHt0eXBlOiBcIlBvbHlnb25cIiwgYXJjczogW3JpbmddfSkuY29vcmRpbmF0ZXNbMF0pID4gMDsgLy8gVE9ETyBhbGxvdyBzcGhlcmljYWw/XG4gICAgfVxuXG4gICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gW10sXG4gICAgICAgICAgICBuZWlnaGJvcnMgPSBbcG9seWdvbl07XG4gICAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICB3aGlsZSAocG9seWdvbiA9IG5laWdoYm9ycy5wb3AoKSkge1xuICAgICAgICAgIGNvbXBvbmVudC5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgICAgIHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICAgICAgICAgIGlmICghcG9seWdvbi5fKSB7XG4gICAgICAgICAgICAgICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgIGRlbGV0ZSBwb2x5Z29uLl87XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICAgIGFyY3M6IGNvbXBvbmVudHMubWFwKGZ1bmN0aW9uKHBvbHlnb25zKSB7XG4gICAgICAgIHZhciBhcmNzID0gW107XG5cbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgZXh0ZXJpb3IgKHVuaXF1ZSkgYXJjcy5cbiAgICAgICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgICAgaWYgKHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBhcmNzLnB1c2goYXJjKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN0aXRjaCB0aGUgYXJjcyBpbnRvIG9uZSBvciBtb3JlIHJpbmdzLlxuICAgICAgICBhcmNzID0gc3RpdGNoQXJjcyh0b3BvbG9neSwgYXJjcyk7XG5cbiAgICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSByaW5nIGlzIHJldHVybmVkLFxuICAgICAgICAvLyBhdCBtb3N0IG9uZSBvZiB0aGVzZSByaW5ncyBjYW4gYmUgdGhlIGV4dGVyaW9yO1xuICAgICAgICAvLyB0aGlzIGV4dGVyaW9yIHJpbmcgaGFzIHRoZSBzYW1lIHdpbmRpbmcgb3JkZXJcbiAgICAgICAgLy8gYXMgYW55IGV4dGVyaW9yIHJpbmcgaW4gdGhlIG9yaWdpbmFsIHBvbHlnb25zLlxuICAgICAgICBpZiAoKG4gPSBhcmNzLmxlbmd0aCkgPiAxKSB7XG4gICAgICAgICAgdmFyIHNnbiA9IGV4dGVyaW9yKHBvbHlnb25zWzBdWzBdKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgaWYgKHNnbiA9PT0gZXh0ZXJpb3IoYXJjc1tpXSkpIHtcbiAgICAgICAgICAgICAgdCA9IGFyY3NbMF0sIGFyY3NbMF0gPSBhcmNzW2ldLCBhcmNzW2ldID0gdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyY3M7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmZWF0dXJlT3JDb2xsZWN0aW9uKHRvcG9sb2d5LCBvKSB7XG4gICAgcmV0dXJuIG8udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA/IHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgIGZlYXR1cmVzOiBvLmdlb21ldHJpZXMubWFwKGZ1bmN0aW9uKG8pIHsgcmV0dXJuIGZlYXR1cmUodG9wb2xvZ3ksIG8pOyB9KVxuICAgIH0gOiBmZWF0dXJlKHRvcG9sb2d5LCBvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZlYXR1cmUodG9wb2xvZ3ksIG8pIHtcbiAgICB2YXIgZiA9IHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgaWQ6IG8uaWQsXG4gICAgICBwcm9wZXJ0aWVzOiBvLnByb3BlcnRpZXMgfHwge30sXG4gICAgICBnZW9tZXRyeTogb2JqZWN0KHRvcG9sb2d5LCBvKVxuICAgIH07XG4gICAgaWYgKG8uaWQgPT0gbnVsbCkgZGVsZXRlIGYuaWQ7XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3QodG9wb2xvZ3ksIG8pIHtcbiAgICB2YXIgYWJzb2x1dGUgPSB0cmFuc2Zvcm1BYnNvbHV0ZSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgICBhcmNzID0gdG9wb2xvZ3kuYXJjcztcblxuICAgIGZ1bmN0aW9uIGFyYyhpLCBwb2ludHMpIHtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoKSBwb2ludHMucG9wKCk7XG4gICAgICBmb3IgKHZhciBhID0gYXJjc1tpIDwgMCA/IH5pIDogaV0sIGsgPSAwLCBuID0gYS5sZW5ndGgsIHA7IGsgPCBuOyArK2spIHtcbiAgICAgICAgcG9pbnRzLnB1c2gocCA9IGFba10uc2xpY2UoKSk7XG4gICAgICAgIGFic29sdXRlKHAsIGspO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCAwKSByZXZlcnNlKHBvaW50cywgbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnQocCkge1xuICAgICAgcCA9IHAuc2xpY2UoKTtcbiAgICAgIGFic29sdXRlKHAsIDApO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZShhcmNzKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmMoYXJjc1tpXSwgcG9pbnRzKTtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikgcG9pbnRzLnB1c2gocG9pbnRzWzBdLnNsaWNlKCkpO1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nKGFyY3MpIHtcbiAgICAgIHZhciBwb2ludHMgPSBsaW5lKGFyY3MpO1xuICAgICAgd2hpbGUgKHBvaW50cy5sZW5ndGggPCA0KSBwb2ludHMucHVzaChwb2ludHNbMF0uc2xpY2UoKSk7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgICAgcmV0dXJuIGFyY3MubWFwKHJpbmcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICAgIHZhciB0ID0gby50eXBlO1xuICAgICAgcmV0dXJuIHQgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIgPyB7dHlwZTogdCwgZ2VvbWV0cmllczogby5nZW9tZXRyaWVzLm1hcChnZW9tZXRyeSl9XG4gICAgICAgICAgOiB0IGluIGdlb21ldHJ5VHlwZSA/IHt0eXBlOiB0LCBjb29yZGluYXRlczogZ2VvbWV0cnlUeXBlW3RdKG8pfVxuICAgICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgICAgUG9pbnQ6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIHBvaW50KG8uY29vcmRpbmF0ZXMpOyB9LFxuICAgICAgTXVsdGlQb2ludDogZnVuY3Rpb24obykgeyByZXR1cm4gby5jb29yZGluYXRlcy5tYXAocG9pbnQpOyB9LFxuICAgICAgTGluZVN0cmluZzogZnVuY3Rpb24obykgeyByZXR1cm4gbGluZShvLmFyY3MpOyB9LFxuICAgICAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFyY3MubWFwKGxpbmUpOyB9LFxuICAgICAgUG9seWdvbjogZnVuY3Rpb24obykgeyByZXR1cm4gcG9seWdvbihvLmFyY3MpOyB9LFxuICAgICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFyY3MubWFwKHBvbHlnb24pOyB9XG4gICAgfTtcblxuICAgIHJldHVybiBnZW9tZXRyeShvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXksIG4pIHtcbiAgICB2YXIgdCwgaiA9IGFycmF5Lmxlbmd0aCwgaSA9IGogLSBuOyB3aGlsZSAoaSA8IC0taikgdCA9IGFycmF5W2ldLCBhcnJheVtpKytdID0gYXJyYXlbal0sIGFycmF5W2pdID0gdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpc2VjdChhLCB4KSB7XG4gICAgdmFyIGxvID0gMCwgaGkgPSBhLmxlbmd0aDtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICBpZiAoYVttaWRdIDwgeCkgbG8gPSBtaWQgKyAxO1xuICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gbmVpZ2hib3JzKG9iamVjdHMpIHtcbiAgICB2YXIgaW5kZXhlc0J5QXJjID0ge30sIC8vIGFyYyBpbmRleCAtPiBhcnJheSBvZiBvYmplY3QgaW5kZXhlc1xuICAgICAgICBuZWlnaGJvcnMgPSBvYmplY3RzLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcblxuICAgIGZ1bmN0aW9uIGxpbmUoYXJjcywgaSkge1xuICAgICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgaWYgKGEgPCAwKSBhID0gfmE7XG4gICAgICAgIHZhciBvID0gaW5kZXhlc0J5QXJjW2FdO1xuICAgICAgICBpZiAobykgby5wdXNoKGkpO1xuICAgICAgICBlbHNlIGluZGV4ZXNCeUFyY1thXSA9IFtpXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb24oYXJjcywgaSkge1xuICAgICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBsaW5lKGFyYywgaSk7IH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlb21ldHJ5KG8sIGkpIHtcbiAgICAgIGlmIChvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIG8uZ2VvbWV0cmllcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHsgZ2VvbWV0cnkobywgaSk7IH0pO1xuICAgICAgZWxzZSBpZiAoby50eXBlIGluIGdlb21ldHJ5VHlwZSkgZ2VvbWV0cnlUeXBlW28udHlwZV0oby5hcmNzLCBpKTtcbiAgICB9XG5cbiAgICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgICAgTGluZVN0cmluZzogbGluZSxcbiAgICAgIE11bHRpTGluZVN0cmluZzogcG9seWdvbixcbiAgICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKGFyY3MsIGkpIHsgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBwb2x5Z29uKGFyYywgaSk7IH0pOyB9XG4gICAgfTtcblxuICAgIG9iamVjdHMuZm9yRWFjaChnZW9tZXRyeSk7XG5cbiAgICBmb3IgKHZhciBpIGluIGluZGV4ZXNCeUFyYykge1xuICAgICAgZm9yICh2YXIgaW5kZXhlcyA9IGluZGV4ZXNCeUFyY1tpXSwgbSA9IGluZGV4ZXMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBtOyArK2spIHtcbiAgICAgICAgICB2YXIgaWogPSBpbmRleGVzW2pdLCBpayA9IGluZGV4ZXNba10sIG47XG4gICAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lqXSlbaSA9IGJpc2VjdChuLCBpayldICE9PSBpaykgbi5zcGxpY2UoaSwgMCwgaWspO1xuICAgICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpa10pW2kgPSBiaXNlY3QobiwgaWopXSAhPT0gaWopIG4uc3BsaWNlKGksIDAsIGlqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWlnaGJvcnM7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVzaW1wbGlmeSh0b3BvbG9neSwgdHJpYW5nbGVBcmVhKSB7XG4gICAgdmFyIGFic29sdXRlID0gdHJhbnNmb3JtQWJzb2x1dGUodG9wb2xvZ3kudHJhbnNmb3JtKSxcbiAgICAgICAgcmVsYXRpdmUgPSB0cmFuc2Zvcm1SZWxhdGl2ZSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgICBoZWFwID0gbWluQXJlYUhlYXAoKTtcblxuICAgIGlmICghdHJpYW5nbGVBcmVhKSB0cmlhbmdsZUFyZWEgPSBjYXJ0ZXNpYW5UcmlhbmdsZUFyZWE7XG5cbiAgICB0b3BvbG9neS5hcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICB2YXIgdHJpYW5nbGVzID0gW10sXG4gICAgICAgICAgbWF4QXJlYSA9IDAsXG4gICAgICAgICAgdHJpYW5nbGU7XG5cbiAgICAgIC8vIFRvIHN0b3JlIGVhY2ggcG9pbnTigJlzIGVmZmVjdGl2ZSBhcmVhLCB3ZSBjcmVhdGUgYSBuZXcgYXJyYXkgcmF0aGVyIHRoYW5cbiAgICAgIC8vIGV4dGVuZGluZyB0aGUgcGFzc2VkLWluIHBvaW50IHRvIHdvcmthcm91bmQgYSBDaHJvbWUvVjggYnVnIChnZXR0aW5nXG4gICAgICAvLyBzdHVjayBpbiBzbWkgbW9kZSkuIEZvciBtaWRwb2ludHMsIHRoZSBpbml0aWFsIGVmZmVjdGl2ZSBhcmVhIG9mXG4gICAgICAvLyBJbmZpbml0eSB3aWxsIGJlIGNvbXB1dGVkIGluIHRoZSBuZXh0IHN0ZXAuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyYy5sZW5ndGgsIHA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgcCA9IGFyY1tpXTtcbiAgICAgICAgYWJzb2x1dGUoYXJjW2ldID0gW3BbMF0sIHBbMV0sIEluZmluaXR5XSwgaSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBuID0gYXJjLmxlbmd0aCAtIDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdHJpYW5nbGUgPSBhcmMuc2xpY2UoaSAtIDEsIGkgKyAyKTtcbiAgICAgICAgdHJpYW5nbGVbMV1bMl0gPSB0cmlhbmdsZUFyZWEodHJpYW5nbGUpO1xuICAgICAgICB0cmlhbmdsZXMucHVzaCh0cmlhbmdsZSk7XG4gICAgICAgIGhlYXAucHVzaCh0cmlhbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICB0cmlhbmdsZSA9IHRyaWFuZ2xlc1tpXTtcbiAgICAgICAgdHJpYW5nbGUucHJldmlvdXMgPSB0cmlhbmdsZXNbaSAtIDFdO1xuICAgICAgICB0cmlhbmdsZS5uZXh0ID0gdHJpYW5nbGVzW2kgKyAxXTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRyaWFuZ2xlID0gaGVhcC5wb3AoKSkge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSB0cmlhbmdsZS5wcmV2aW91cyxcbiAgICAgICAgICAgIG5leHQgPSB0cmlhbmdsZS5uZXh0O1xuXG4gICAgICAgIC8vIElmIHRoZSBhcmVhIG9mIHRoZSBjdXJyZW50IHBvaW50IGlzIGxlc3MgdGhhbiB0aGF0IG9mIHRoZSBwcmV2aW91cyBwb2ludFxuICAgICAgICAvLyB0byBiZSBlbGltaW5hdGVkLCB1c2UgdGhlIGxhdHRlcidzIGFyZWEgaW5zdGVhZC4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgcG9pbnQgY2Fubm90IGJlIGVsaW1pbmF0ZWQgd2l0aG91dCBlbGltaW5hdGluZyBwcmV2aW91c2x5LVxuICAgICAgICAvLyBlbGltaW5hdGVkIHBvaW50cy5cbiAgICAgICAgaWYgKHRyaWFuZ2xlWzFdWzJdIDwgbWF4QXJlYSkgdHJpYW5nbGVbMV1bMl0gPSBtYXhBcmVhO1xuICAgICAgICBlbHNlIG1heEFyZWEgPSB0cmlhbmdsZVsxXVsyXTtcblxuICAgICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICBwcmV2aW91c1syXSA9IHRyaWFuZ2xlWzJdO1xuICAgICAgICAgIHVwZGF0ZShwcmV2aW91cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICBuZXh0WzBdID0gdHJpYW5nbGVbMF07XG4gICAgICAgICAgdXBkYXRlKG5leHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFyYy5mb3JFYWNoKHJlbGF0aXZlKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0cmlhbmdsZSkge1xuICAgICAgaGVhcC5yZW1vdmUodHJpYW5nbGUpO1xuICAgICAgdHJpYW5nbGVbMV1bMl0gPSB0cmlhbmdsZUFyZWEodHJpYW5nbGUpO1xuICAgICAgaGVhcC5wdXNoKHRyaWFuZ2xlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9wb2xvZ3k7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FydGVzaWFuUmluZ0FyZWEocmluZykge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSByaW5nLmxlbmd0aCxcbiAgICAgICAgYSxcbiAgICAgICAgYiA9IHJpbmdbbiAtIDFdLFxuICAgICAgICBhcmVhID0gMDtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSByaW5nW2ldO1xuICAgICAgYXJlYSArPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBhcmVhICogLjU7XG4gIH1cblxuICBmdW5jdGlvbiBjYXJ0ZXNpYW5UcmlhbmdsZUFyZWEodHJpYW5nbGUpIHtcbiAgICB2YXIgYSA9IHRyaWFuZ2xlWzBdLCBiID0gdHJpYW5nbGVbMV0sIGMgPSB0cmlhbmdsZVsyXTtcbiAgICByZXR1cm4gTWF0aC5hYnMoKGFbMF0gLSBjWzBdKSAqIChiWzFdIC0gYVsxXSkgLSAoYVswXSAtIGJbMF0pICogKGNbMV0gLSBhWzFdKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIGFbMV1bMl0gLSBiWzFdWzJdO1xuICB9XG5cbiAgZnVuY3Rpb24gbWluQXJlYUhlYXAoKSB7XG4gICAgdmFyIGhlYXAgPSB7fSxcbiAgICAgICAgYXJyYXkgPSBbXSxcbiAgICAgICAgc2l6ZSA9IDA7XG5cbiAgICBoZWFwLnB1c2ggPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHVwKGFycmF5W29iamVjdC5fID0gc2l6ZV0gPSBvYmplY3QsIHNpemUrKyk7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9O1xuXG4gICAgaGVhcC5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzaXplIDw9IDApIHJldHVybjtcbiAgICAgIHZhciByZW1vdmVkID0gYXJyYXlbMF0sIG9iamVjdDtcbiAgICAgIGlmICgtLXNpemUgPiAwKSBvYmplY3QgPSBhcnJheVtzaXplXSwgZG93bihhcnJheVtvYmplY3QuXyA9IDBdID0gb2JqZWN0LCAwKTtcbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG5cbiAgICBoZWFwLnJlbW92ZSA9IGZ1bmN0aW9uKHJlbW92ZWQpIHtcbiAgICAgIHZhciBpID0gcmVtb3ZlZC5fLCBvYmplY3Q7XG4gICAgICBpZiAoYXJyYXlbaV0gIT09IHJlbW92ZWQpIHJldHVybjsgLy8gaW52YWxpZCByZXF1ZXN0XG4gICAgICBpZiAoaSAhPT0gLS1zaXplKSBvYmplY3QgPSBhcnJheVtzaXplXSwgKGNvbXBhcmVBcmVhKG9iamVjdCwgcmVtb3ZlZCkgPCAwID8gdXAgOiBkb3duKShhcnJheVtvYmplY3QuXyA9IGldID0gb2JqZWN0LCBpKTtcbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB1cChvYmplY3QsIGkpIHtcbiAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICB2YXIgaiA9ICgoaSArIDEpID4+IDEpIC0gMSxcbiAgICAgICAgICAgIHBhcmVudCA9IGFycmF5W2pdO1xuICAgICAgICBpZiAoY29tcGFyZUFyZWEob2JqZWN0LCBwYXJlbnQpID49IDApIGJyZWFrO1xuICAgICAgICBhcnJheVtwYXJlbnQuXyA9IGldID0gcGFyZW50O1xuICAgICAgICBhcnJheVtvYmplY3QuXyA9IGkgPSBqXSA9IG9iamVjdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb3duKG9iamVjdCwgaSkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHIgPSAoaSArIDEpIDw8IDEsXG4gICAgICAgICAgICBsID0gciAtIDEsXG4gICAgICAgICAgICBqID0gaSxcbiAgICAgICAgICAgIGNoaWxkID0gYXJyYXlbal07XG4gICAgICAgIGlmIChsIDwgc2l6ZSAmJiBjb21wYXJlQXJlYShhcnJheVtsXSwgY2hpbGQpIDwgMCkgY2hpbGQgPSBhcnJheVtqID0gbF07XG4gICAgICAgIGlmIChyIDwgc2l6ZSAmJiBjb21wYXJlQXJlYShhcnJheVtyXSwgY2hpbGQpIDwgMCkgY2hpbGQgPSBhcnJheVtqID0gcl07XG4gICAgICAgIGlmIChqID09PSBpKSBicmVhaztcbiAgICAgICAgYXJyYXlbY2hpbGQuXyA9IGldID0gY2hpbGQ7XG4gICAgICAgIGFycmF5W29iamVjdC5fID0gaSA9IGpdID0gb2JqZWN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoZWFwO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtQWJzb2x1dGUodHJhbnNmb3JtKSB7XG4gICAgaWYgKCF0cmFuc2Zvcm0pIHJldHVybiBub29wO1xuICAgIHZhciB4MCxcbiAgICAgICAgeTAsXG4gICAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgICAgZHggPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzBdLFxuICAgICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBvaW50LCBpKSB7XG4gICAgICBpZiAoIWkpIHgwID0geTAgPSAwO1xuICAgICAgcG9pbnRbMF0gPSAoeDAgKz0gcG9pbnRbMF0pICoga3ggKyBkeDtcbiAgICAgIHBvaW50WzFdID0gKHkwICs9IHBvaW50WzFdKSAqIGt5ICsgZHk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVJlbGF0aXZlKHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSByZXR1cm4gbm9vcDtcbiAgICB2YXIgeDAsXG4gICAgICAgIHkwLFxuICAgICAgICBreCA9IHRyYW5zZm9ybS5zY2FsZVswXSxcbiAgICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgICAgZHkgPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzFdO1xuICAgIHJldHVybiBmdW5jdGlvbihwb2ludCwgaSkge1xuICAgICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICAgIHZhciB4MSA9IChwb2ludFswXSAtIGR4KSAvIGt4IHwgMCxcbiAgICAgICAgICB5MSA9IChwb2ludFsxXSAtIGR5KSAvIGt5IHwgMDtcbiAgICAgIHBvaW50WzBdID0geDEgLSB4MDtcbiAgICAgIHBvaW50WzFdID0geTEgLSB5MDtcbiAgICAgIHgwID0geDE7XG4gICAgICB5MCA9IHkxO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIGRlZmluZSh0b3BvanNvbik7XG4gIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gdG9wb2pzb247XG4gIGVsc2UgdGhpcy50b3BvanNvbiA9IHRvcG9qc29uO1xufSgpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIklyWFVzdVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL25vZGVfbW9kdWxlcy90b3BvanNvbi90b3BvanNvbi5qc1wiLFwiL25vZGVfbW9kdWxlcy90b3BvanNvblwiKSJdfQ==
